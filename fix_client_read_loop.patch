# HG changeset patch
# Parent  320cb216628b79690a6b4851d8d8182f333bd0cf
Make the pipe/socket read loops fully resilient against incomplete json

In other words you can send your request character by character with as
much as white space as you want (and as allowed by JSON) and lightsd and
it will still sort it out.

Among some rework in the socket read loop one big fix was to call
jsmn_init before each call to jsmn_parse. So not sure if jsmn is really
working as explained in its documentation.

This changeset also moves -DJSMN_STRICT=1 to the top-level
CMakeLists.txt so that the tests and lightsd use the same code.

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -54,6 +54,8 @@
 
     "-DLGTD_HAVE_LIBBSD=${HAVE_LIBBSD}"
     "-DLGTD_HAVE_PROCTITLE=${HAVE_PROCTITLE}"
+
+    "-DJSMN_STRICT=1"
 )
 
 IF (CMAKE_BUILD_TYPE MATCHES "DEBUG")
diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -10,8 +10,6 @@
 
 CONFIGURE_FILE(version.h.in ${CMAKE_CURRENT_BINARY_DIR}/version.h)
 
-ADD_DEFINITIONS("-DJSMN_STRICT=1")
-
 ADD_EXECUTABLE(
     lightsd
     client.c
diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -70,59 +70,64 @@
     struct lgtd_client *client = ctx;
 
     struct evbuffer *input = bufferevent_get_input(bev);
-    size_t bufsz = evbuffer_get_contiguous_space(input);
+    size_t nbytes = evbuffer_get_contiguous_space(input);
     // Get the actual pointer to the beginning of the evbuf:
-    const char *buf = (char *)evbuffer_pullup(input, bufsz);
-    jsmnerr_t rv;
+    const char *buf = (char *)evbuffer_pullup(input, nbytes);
 
-retry_after_pullup:
-    rv = jsmn_parse(
-        &client->jsmn_ctx,
-        buf,
-        bufsz,
-        client->jsmn_tokens,
-        LGTD_ARRAY_SIZE(client->jsmn_tokens)
-    );
-    switch (rv) {
-    case JSMN_ERROR_NOMEM:
-        lgtd_warnx(
-            "dropping client [%s]:%hu: request too big, not "
-            "enough parser tokens", client->ip_addr, client->port
+    do {
+        jsmn_init(&client->jsmn_ctx);
+        jsmnerr_t rv = jsmn_parse(
+            &client->jsmn_ctx,
+            buf,
+            nbytes,
+            client->jsmn_tokens,
+            LGTD_ARRAY_SIZE(client->jsmn_tokens)
         );
-        lgtd_client_close(client);
-        break;
-    case JSMN_ERROR_INVAL:
-        lgtd_warnx(
-            "dropping client [%s]:%hu: invalid json",
-            client->ip_addr, client->port
-        );
-        // TODO: consume remaining data and send a proper error instead of
-        // closing the connection:
-        lgtd_client_close(client);
-        break;
-    case JSMN_ERROR_PART:
-        if (evbuffer_get_length(input) > LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) {
+        switch (rv) {
+        case JSMN_ERROR_NOMEM:
+        case JSMN_ERROR_INVAL:
             lgtd_warnx(
-                "dropping client [%s]:%hu: request too big",
+                "client [%s]:%hu: request too big or invalid",
                 client->ip_addr, client->port
             );
-            lgtd_client_close(client);
+            evbuffer_drain(input, nbytes);
             break;
-        } else if (bufsz >= evbuffer_get_length(input)) {
-            break; // We pulled up everything already, wait for more data
+        case JSMN_ERROR_PART:
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wswitch"
+        case 0:
+#pragma GCC diagnostic pop
+            (void)0;
+            size_t buflen = evbuffer_get_length(input);
+            if (buflen > LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) {
+                lgtd_warnx(
+                    "client [%s]:%hu: request too big or invalid",
+                    client->ip_addr, client->port
+                );
+                evbuffer_drain(input, buflen);
+            } else if (nbytes == buflen) {
+                return; // We pulled up everything already, wait for more data
+            }
+            break;
+        default:
+            client->json = buf;
+            lgtd_jsonrpc_dispatch_request(client, rv);
+            client->json = NULL;
+            size_t request_size = client->jsmn_tokens[0].end;
+            evbuffer_drain(input, request_size);
+            if (request_size < nbytes) {
+                buf += request_size;
+                nbytes -= request_size;
+                // FIXME: instead of calling jsmn_parse again, return the number
+                // of tokens consumed from jsonrpc and make this case a loop.
+                continue;
+            }
+            break;
         }
         // pullup and resume parsing:
         buf = (char *)evbuffer_pullup(input, -1);
-        bufsz = evbuffer_get_length(input);
-        goto retry_after_pullup;
-    default:
-        client->json = buf;
-        lgtd_jsonrpc_dispatch_request(client, rv);
-        client->json = NULL;
-        evbuffer_drain(input, bufsz);
-        jsmn_init(&client->jsmn_ctx);
-        break;
-    }
+        nbytes = evbuffer_get_contiguous_space(input);
+    } while (nbytes);
 }
 
 static void
@@ -216,7 +221,6 @@
     );
     lgtd_sockaddrtoa(peer_addr, client->ip_addr, sizeof(client->ip_addr));
     client->port = lgtd_sockaddrport(peer_addr);
-    jsmn_init(&client->jsmn_ctx);
     bufferevent_enable(client->io, EV_READ|EV_WRITE|EV_TIMEOUT);
 
     LIST_INSERT_HEAD(&lgtd_clients, client, link);
@@ -232,6 +236,4 @@
     assert(pipe_client);
 
     memset(pipe_client, 0, sizeof(*pipe_client));
-
-    jsmn_init(&pipe_client->jsmn_ctx);
 }
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -617,11 +617,16 @@
     assert(targets);
     assert(client);
     assert(target);
-    assert(target_ntokens >= 1);
+
+    if (target_ntokens < 1) {
+        return false;
+    }
 
     if (lgtd_jsonrpc_type_array(target, client->json)) {
         target_ntokens -= 1;
         target++;
+    } else if (target_ntokens != 1) {
+        return false;
     }
 
     for (int ti = target_ntokens; ti--;) {
@@ -1136,6 +1141,7 @@
     }
 
     assert(request.method);
+    assert(request.request_ntokens);
 
     for (int i = 0; i != LGTD_ARRAY_SIZE(methods); i++) {
         int parsed_method_namelen = LGTD_JSONRPC_TOKEN_LEN(request.method);
diff --git a/core/pipe.c b/core/pipe.c
--- a/core/pipe.c
+++ b/core/pipe.c
@@ -94,7 +94,7 @@
 
         if (!drain) {
         next_request:
-            (void)0;
+            jsmn_init(&pipe->client.jsmn_ctx);
             const char *buf = (char *)evbuffer_pullup(pipe->read_buf, -1);
             ssize_t bufsz = evbuffer_get_length(pipe->read_buf);
             jsmnerr_t rv = jsmn_parse(
@@ -127,7 +127,6 @@
                 lgtd_jsonrpc_dispatch_request(&pipe->client, ntokens);
 
                 pipe->client.json = NULL;
-                jsmn_init(&pipe->client.jsmn_ctx);
                 int request_size = pipe->client.jsmn_tokens[0].end;
                 evbuffer_drain(pipe->read_buf, request_size);
                 if (request_size < bufsz) {
@@ -141,7 +140,6 @@
             ssize_t bufsz = evbuffer_get_length(pipe->read_buf);
             evbuffer_drain(pipe->read_buf, bufsz);
             drain = false;
-            jsmn_init(&pipe->client.jsmn_ctx);
         }
     }
 
diff --git a/tests/core/client/CMakeLists.txt b/tests/core/client/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/core/client/CMakeLists.txt
@@ -0,0 +1,24 @@
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+ADD_LIBRARY(
+    test_core_client STATIC
+    ${LIGHTSD_SOURCE_DIR}/core/jsmn.c
+    ${LIGHTSD_SOURCE_DIR}/core/log.c
+    ${LIGHTSD_SOURCE_DIR}/core/stats.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
+)
+
+TARGET_LINK_LIBRARIES(test_core_client ${TIME_MONOTONIC_LIBRARY})
+
+FUNCTION(ADD_CLIENT_TEST TEST_SOURCE)
+    ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE} test_core_client)
+ENDFUNCTION()
+
+FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
+FOREACH(TEST ${TESTS})
+    ADD_CLIENT_TEST(${TEST})
+ENDFOREACH()
diff --git a/tests/core/client/test_client_read_callback.c b/tests/core/client/test_client_read_callback.c
new file mode 100644
--- /dev/null
+++ b/tests/core/client/test_client_read_callback.c
@@ -0,0 +1,165 @@
+#include "client.c"
+
+#include "lifx/wire_proto.h"
+
+#include "mock_daemon.h"
+#define MOCKED_EVBUFFER_PULLUP
+#define MOCKED_EVBUFFER_DRAIN
+#define MOCKED_EVBUFFER_GET_CONTIGUOUS_SPACE
+#define MOCKED_BUFFEREVENT_GET_INPUT
+#include "mock_event2.h"
+#include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
+#include "mock_router.h"
+#include "mock_timer.h"
+
+#include "tests_utils.h"
+#include "tests_client_utils.h"
+
+static unsigned char request[] = ("{"
+    "\"jsonrpc\": \"2.0\","
+    "\"method\": \"get_light_state\","
+    "\"params\": [\"*\"],"
+    "\"id\": 42"
+"}");
+
+static int
+get_nbytes_read(int call_count)
+{
+    switch (call_count) {
+    case 0:
+        return sizeof(request) - 1; // we don't return the '\0'
+    default:
+        return 0;
+    }
+}
+
+struct evbuffer *
+bufferevent_get_input(struct bufferevent *bufev)
+{
+    (void)bufev;
+
+    return FAKE_BUFFEREVENT_INPUT_BUF;
+}
+
+static int evbuffer_get_contiguous_space_call_count = 0;
+
+size_t
+evbuffer_get_contiguous_space(const struct evbuffer *buf)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(
+            1, "evbuffer_get_contiguous_space got buf %p (expected %p)",
+            buf, FAKE_BUFFEREVENT_INPUT_BUF
+        );
+    }
+
+    return get_nbytes_read(evbuffer_get_contiguous_space_call_count++);
+}
+
+static int jsonrpc_dispatch_request_call_count = 0;
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+
+    if (!parsed) {
+        errx(1, "number of parsed json tokens not passed in");
+    }
+
+    if (memcmp(client->json, request, sizeof(request))) {
+        errx(1, "got unexpected json");
+    }
+
+    if (jsonrpc_dispatch_request_call_count++) {
+        errx(1, "jsonrpc_dispatch_request should have been called once");
+    }
+}
+
+static int evbuffer_drain_call_count = 0;
+
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    switch (evbuffer_drain_call_count++) {
+    case 0:
+        if (len != sizeof(request) - 1) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)sizeof(request) - 1
+            );
+        }
+        break;
+    default:
+        errx(1, "evbuffer_drain should have been called once");
+        break;
+    }
+
+    return 0;
+}
+
+static int evbuffer_pullup_call_count = 0;
+
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    int offset;
+    switch (evbuffer_pullup_call_count++) {
+    case 0:
+        if (size != sizeof(request) - 1) {
+            errx(
+                1, "got unexpected size %jd in pullup (expected %ju)",
+                (intmax_t)size, (uintmax_t)sizeof(request) - 1
+            );
+        }
+        offset = 0;
+        break;
+    case 1:
+        if (size != -1) {
+            errx(
+                1, "got unexpected size %jd in pullup (expected -1)",
+                (intmax_t)size
+            );
+        }
+        offset = sizeof(request) - 1;
+        break;
+    default:
+        errx(1, "evbuffer_pullup should have been called twice");
+    }
+
+    return &request[offset];
+}
+
+int
+main(void)
+{
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+
+    lgtd_client_read_callback(FAKE_BUFFEREVENT, &client);
+
+    if (!evbuffer_get_contiguous_space_call_count) {
+        errx(1, "evbuffer_get_contiguous_space not called");
+    }
+    if (!jsonrpc_dispatch_request_call_count) {
+        errx(1, "jsonrpc_dispatch_request not called");
+    }
+    if (!evbuffer_drain_call_count) {
+        errx(1, "evbuffer_drain not called");
+    }
+    if (!evbuffer_pullup_call_count) {
+        errx(1, "evbuffer_pullup not called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/client/test_client_read_callback_extra_data.c b/tests/core/client/test_client_read_callback_extra_data.c
new file mode 100644
--- /dev/null
+++ b/tests/core/client/test_client_read_callback_extra_data.c
@@ -0,0 +1,225 @@
+#include "client.c"
+
+#include "lifx/wire_proto.h"
+
+#include "mock_daemon.h"
+#define MOCKED_EVBUFFER_PULLUP
+#define MOCKED_EVBUFFER_DRAIN
+#define MOCKED_EVBUFFER_GET_CONTIGUOUS_SPACE
+#define MOCKED_BUFFEREVENT_GET_INPUT
+#include "mock_event2.h"
+#include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
+#include "mock_router.h"
+#include "mock_timer.h"
+
+#include "tests_utils.h"
+#include "tests_client_utils.h"
+
+static unsigned char request[] = (
+    "lollllllllll       \n\n\n"
+    "{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"get_light_state\","
+        "\"params\": [\"*\"],"
+        "\"id\": 42"
+    "}HALP HALP \\_o< O)))"
+);
+
+enum { GARBAGE_BEFORE_REQUEST_LEN = sizeof("lollllllllll       \n\n\n") - 1 };
+enum {
+    REQUEST_LEN = sizeof("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"get_light_state\","
+        "\"params\": [\"*\"],"
+        "\"id\": 42"
+    "}") - 1
+};
+enum { GARBAGE_AFTER_REQUEST_LEN = sizeof("HALP HALP \\_o< O)))") - 1 };
+
+static int
+get_nbytes_read(int call_count)
+{
+    switch (call_count) {
+    case 0:
+        return GARBAGE_BEFORE_REQUEST_LEN;
+    case 1:
+        return REQUEST_LEN;
+    case 2:
+        return GARBAGE_AFTER_REQUEST_LEN;
+    default:
+        return 0;
+    }
+}
+
+struct evbuffer *
+bufferevent_get_input(struct bufferevent *bufev)
+{
+    (void)bufev;
+
+    return FAKE_BUFFEREVENT_INPUT_BUF;
+}
+
+static int evbuffer_get_contiguous_space_call_count = 0;
+
+size_t
+evbuffer_get_contiguous_space(const struct evbuffer *buf)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(
+            1, "evbuffer_get_contiguous_space got buf %p (expected %p)",
+            buf, FAKE_BUFFEREVENT_INPUT_BUF
+        );
+    }
+
+    return get_nbytes_read(evbuffer_get_contiguous_space_call_count++);
+}
+
+static int jsonrpc_dispatch_request_call_count = 0;
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+
+    if (!parsed) {
+        errx(1, "number of parsed json tokens not passed in");
+    }
+
+    bool diff = memcmp(
+        client->json, &request[GARBAGE_BEFORE_REQUEST_LEN], REQUEST_LEN
+    );
+    if (diff) {
+        errx(1, "got unexpected json");
+    }
+
+    if (jsonrpc_dispatch_request_call_count++) {
+        errx(1, "jsonrpc_dispatch_request should have been called once");
+    }
+}
+
+static int evbuffer_drain_call_count = 0;
+
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    switch (evbuffer_drain_call_count++) {
+    case 0:
+        if (len != GARBAGE_BEFORE_REQUEST_LEN) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)GARBAGE_BEFORE_REQUEST_LEN
+            );
+        }
+        break;
+    case 1:
+        if (len != REQUEST_LEN) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)REQUEST_LEN
+            );
+        }
+        break;
+    case 2:
+        if (len != GARBAGE_AFTER_REQUEST_LEN) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)REQUEST_LEN
+            );
+        }
+        break;
+    default:
+        errx(
+            1, "evbuffer_drain shouldn't have been called %d times",
+            evbuffer_drain_call_count
+        );
+    }
+
+    return 0;
+}
+
+static int evbuffer_pullup_call_count = 0;
+
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    int offset;
+    switch (evbuffer_pullup_call_count++) {
+    case 0:
+        if (size != GARBAGE_BEFORE_REQUEST_LEN) {
+            errx(
+                1, "trying to pullup %ju bytes (expected %ju)",
+                (intmax_t)size, (uintmax_t)GARBAGE_BEFORE_REQUEST_LEN
+            );
+        }
+        offset = 0;
+        break;
+    case 1:
+        if (size != -1) {
+            errx(
+                1, "got unexpected size %jd in pullup (expected -1)",
+                (intmax_t)size
+            );
+        }
+        offset = GARBAGE_BEFORE_REQUEST_LEN;
+        break;
+    case 2:
+        if (size != -1) {
+            errx(
+                1, "got unexpected size %jd in pullup (expected -1)",
+                (intmax_t)size
+            );
+        }
+        offset = GARBAGE_BEFORE_REQUEST_LEN + REQUEST_LEN;
+        break;
+    case 3:
+        if (size != -1) {
+            errx(
+                1, "got unexpected size %jd in pullup (expected -1)",
+                (intmax_t)size
+            );
+        }
+        offset = sizeof(request) - 1;
+        break;
+    default:
+        errx(
+            1, "evbuffer_pullup shouldn't have been called %d times",
+            evbuffer_pullup_call_count
+        );
+    }
+
+    return &request[offset];
+}
+
+int
+main(void)
+{
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+
+    lgtd_client_read_callback(FAKE_BUFFEREVENT, &client);
+
+    if (!evbuffer_get_contiguous_space_call_count) {
+        errx(1, "evbuffer_get_contiguous_space not called");
+    }
+    if (!jsonrpc_dispatch_request_call_count) {
+        errx(1, "jsonrpc_dispatch_request not called");
+    }
+    if (!evbuffer_drain_call_count) {
+        errx(1, "evbuffer_drain not called");
+    }
+    if (!evbuffer_pullup_call_count) {
+        errx(1, "evbuffer_pullup not called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/client/test_client_read_callback_multiple_requests.c b/tests/core/client/test_client_read_callback_multiple_requests.c
new file mode 100644
--- /dev/null
+++ b/tests/core/client/test_client_read_callback_multiple_requests.c
@@ -0,0 +1,210 @@
+#include "client.c"
+
+#include "lifx/wire_proto.h"
+
+#include "mock_daemon.h"
+#define MOCKED_EVBUFFER_PULLUP
+#define MOCKED_EVBUFFER_DRAIN
+#define MOCKED_EVBUFFER_GET_CONTIGUOUS_SPACE
+#define MOCKED_BUFFEREVENT_GET_INPUT
+#include "mock_event2.h"
+#include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
+#include "mock_router.h"
+#include "mock_timer.h"
+
+#include "tests_utils.h"
+#include "tests_client_utils.h"
+
+#define REQUEST_1 "{"                   \
+    "\"jsonrpc\": \"2.0\","             \
+    "\"method\": \"get_light_state\","  \
+    "\"params\": [\"*\"],"              \
+    "\"id\": 42"                        \
+"}"
+#define REQUEST_1_LEN (sizeof(REQUEST_1) - 1)
+
+#define REQUEST_2 "{"           \
+    "\"jsonrpc\": \"2.0\","     \
+    "\"method\": \"power_on\"," \
+    "\"params\": [\"*\"],"      \
+    "\"id\": 43"                \
+"}"
+#define REQUEST_2_LEN (sizeof(REQUEST_2) - 1)
+
+static unsigned char request[] = (
+    REQUEST_1
+    REQUEST_2
+);
+
+#define REQUEST_LEN (REQUEST_1_LEN + REQUEST_2_LEN)
+
+static int
+get_nbytes_read(int call_count)
+{
+    switch (call_count) {
+    case 0:
+        return REQUEST_LEN;
+    default:
+        return 0;
+    }
+}
+
+struct evbuffer *
+bufferevent_get_input(struct bufferevent *bufev)
+{
+    (void)bufev;
+
+    return FAKE_BUFFEREVENT_INPUT_BUF;
+}
+
+static int evbuffer_get_contiguous_space_call_count = 0;
+
+size_t
+evbuffer_get_contiguous_space(const struct evbuffer *buf)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(
+            1, "evbuffer_get_contiguous_space got buf %p (expected %p)",
+            buf, FAKE_BUFFEREVENT_INPUT_BUF
+        );
+    }
+
+    return get_nbytes_read(evbuffer_get_contiguous_space_call_count++);
+}
+
+static int jsonrpc_dispatch_request_call_count = 0;
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+
+    if (!parsed) {
+        errx(1, "number of parsed json tokens not passed in");
+    }
+
+    bool diff;
+    switch (jsonrpc_dispatch_request_call_count++) {
+    case 0:
+        diff = memcmp(client->json, REQUEST_1, REQUEST_1_LEN);
+        if (diff) {
+            errx(
+                1, "got unexpected json %s (expected) %s",
+                client->json, REQUEST_1
+            );
+        }
+        break;
+    case 1:
+        diff = memcmp(client->json, REQUEST_2, REQUEST_2_LEN);
+        if (diff) {
+            errx(
+                1, "got unexpected json %s (expected) %s",
+                client->json, REQUEST_2
+            );
+        }
+        break;
+    default:
+        errx(1, "jsonrpc_dispatch_request should have been called twice");
+    }
+}
+
+static int evbuffer_drain_call_count = 0;
+
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    switch (evbuffer_drain_call_count++) {
+    case 0:
+        if (len != REQUEST_1_LEN) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)REQUEST_1_LEN
+            );
+        }
+        break;
+    case 1:
+        if (len != REQUEST_2_LEN) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)REQUEST_2_LEN
+            );
+        }
+        break;
+    default:
+        errx(
+            1, "evbuffer_drain shouldn't have been called %d times",
+            evbuffer_drain_call_count
+        );
+    }
+
+    return 0;
+}
+
+static int evbuffer_pullup_call_count = 0;
+
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    int offset;
+    switch (evbuffer_pullup_call_count++) {
+    case 0:
+        if (size != REQUEST_LEN) {
+            errx(
+                1, "trying to pullup %ju bytes (expected %ju)",
+                (intmax_t)size, (uintmax_t)REQUEST_LEN
+            );
+        }
+        offset = 0;
+        break;
+    case 1:
+        if (size != -1) {
+            errx(
+                1, "got unexpected size %jd in pullup (expected -1)",
+                (intmax_t)size
+            );
+        }
+        offset = REQUEST_LEN;
+        break;
+    default:
+        errx(
+            1, "evbuffer_pullup shouldn't have been called %d times",
+            evbuffer_pullup_call_count
+        );
+    }
+
+    return &request[offset];
+}
+
+int
+main(void)
+{
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+
+    lgtd_client_read_callback(FAKE_BUFFEREVENT, &client);
+
+    if (!evbuffer_get_contiguous_space_call_count) {
+        errx(1, "evbuffer_get_contiguous_space not called");
+    }
+    if (!jsonrpc_dispatch_request_call_count) {
+        errx(1, "jsonrpc_dispatch_request not called");
+    }
+    if (!evbuffer_drain_call_count) {
+        errx(1, "evbuffer_drain not called");
+    }
+    if (!evbuffer_pullup_call_count) {
+        errx(1, "evbuffer_pullup not called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/client/test_client_read_callback_part_too_large.c b/tests/core/client/test_client_read_callback_part_too_large.c
new file mode 100644
--- /dev/null
+++ b/tests/core/client/test_client_read_callback_part_too_large.c
@@ -0,0 +1,205 @@
+#include "client.c"
+
+#include "lifx/wire_proto.h"
+
+#include "mock_daemon.h"
+#define MOCKED_EVBUFFER_PULLUP
+#define MOCKED_EVBUFFER_DRAIN
+#define MOCKED_EVBUFFER_GET_CONTIGUOUS_SPACE
+#define MOCKED_EVBUFFER_GET_LENGTH
+#define MOCKED_BUFFEREVENT_GET_INPUT
+#include "mock_event2.h"
+#include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
+#include "mock_router.h"
+#include "mock_timer.h"
+
+#include "tests_utils.h"
+#include "tests_client_utils.h"
+
+static unsigned char request[] = ("{"
+    "\"id\": \"verylongidyooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\","
+    "\"jsonrpc\": \"2.0\","
+    "\"method\": \"get_light_state\","
+    "\"params\": [\"*\"]"
+"}");
+
+#define REQUEST_LEN (sizeof(request) - 1)
+#define PART_1_LEN ((LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) + 1)
+#define PART_2_LEN ((REQUEST_LEN) - (PART_1_LEN))
+
+static int
+get_nbytes_read(int call_count)
+{
+    switch (call_count) {
+    case 0:
+        return PART_1_LEN;
+    case 1:
+        return PART_2_LEN;
+    default:
+        return 0;
+    }
+}
+
+static int evbuffer_get_length_call_count = 0;
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(
+            1, "evbuffer_get_length got buf %p (expected %p)",
+            buf, FAKE_BUFFEREVENT_INPUT_BUF
+        );
+    }
+
+    if (evbuffer_get_length_call_count) {
+        errx(1, "evbuffer_get_length should have been called once");
+    }
+
+    return get_nbytes_read(evbuffer_get_length_call_count++);
+}
+
+struct evbuffer *
+bufferevent_get_input(struct bufferevent *bufev)
+{
+    (void)bufev;
+
+    return FAKE_BUFFEREVENT_INPUT_BUF;
+}
+
+static int evbuffer_get_contiguous_space_call_count = 0;
+
+size_t
+evbuffer_get_contiguous_space(const struct evbuffer *buf)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(
+            1, "evbuffer_get_contiguous_space got buf %p (expected %p)",
+            buf, FAKE_BUFFEREVENT_INPUT_BUF
+        );
+    }
+
+    return get_nbytes_read(evbuffer_get_contiguous_space_call_count++);
+}
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+
+    errx(1, "No request should have been dispatched");
+}
+
+static int evbuffer_drain_call_count = 0;
+
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    switch (evbuffer_drain_call_count++) {
+    case 0:
+        if (len != PART_1_LEN) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)PART_1_LEN
+            );
+        }
+        break;
+    case 1:
+        if (len != PART_2_LEN) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)PART_2_LEN
+            );
+        }
+        break;
+    default:
+        errx(
+            1, "evbuffer_drain shouldn't have been called %d times",
+            evbuffer_drain_call_count
+        );
+    }
+
+    return 0;
+}
+
+static int evbuffer_pullup_call_count = 0;
+
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    int offset;
+    switch (evbuffer_pullup_call_count++) {
+    case 0:
+        if (size != PART_1_LEN) {
+            errx(
+                1, "trying to pullup %ju bytes (expected %ju)",
+                (intmax_t)size, (uintmax_t)PART_1_LEN
+            );
+        }
+        offset = 0;
+        break;
+    case 1:
+        if (size != -1) {
+            errx(
+                1, "trying to pullup %ju bytes (expected %ju)",
+                (intmax_t)size, (uintmax_t)-1
+            );
+        }
+        offset = PART_1_LEN;
+        break;
+    case 2:
+        if (size != -1) {
+            errx(1, "trying to pullup %ju bytes (expected -1)", (intmax_t)size);
+        }
+        offset = REQUEST_LEN;
+        break;
+    default:
+        errx(
+            1, "evbuffer_pullup shouldn't have been called %d times",
+            evbuffer_pullup_call_count
+        );
+    }
+
+    return &request[offset];
+}
+
+int
+main(void)
+{
+    if (LGTD_CLIENT_MAX_REQUEST_BUF_SIZE >= REQUEST_LEN) {
+        errx(
+            1, "Please adjust this test to copy with the new value of "
+            "LGTD_CLIENT_MAX_REQUEST_BUF_SIZE"
+        );
+    }
+
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+
+    lgtd_client_read_callback(FAKE_BUFFEREVENT, &client);
+
+    if (!evbuffer_get_contiguous_space_call_count) {
+        errx(1, "evbuffer_get_contiguous_space not called");
+    }
+    if (!evbuffer_drain_call_count) {
+        errx(1, "evbuffer_drain not called");
+    }
+    if (!evbuffer_pullup_call_count) {
+        errx(1, "evbuffer_pullup not called");
+    }
+    if (!evbuffer_get_length_call_count) {
+        errx(1, "evbuffer_get_length not called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/client/test_client_read_callback_yield_on_eagain.c b/tests/core/client/test_client_read_callback_yield_on_eagain.c
new file mode 100644
--- /dev/null
+++ b/tests/core/client/test_client_read_callback_yield_on_eagain.c
@@ -0,0 +1,210 @@
+#include "client.c"
+
+#include "lifx/wire_proto.h"
+
+#include "mock_daemon.h"
+#define MOCKED_EVBUFFER_PULLUP
+#define MOCKED_EVBUFFER_DRAIN
+#define MOCKED_EVBUFFER_GET_CONTIGUOUS_SPACE
+#define MOCKED_EVBUFFER_GET_LENGTH
+#define MOCKED_BUFFEREVENT_GET_INPUT
+#include "mock_event2.h"
+#include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
+#include "mock_router.h"
+#include "mock_timer.h"
+
+#include "tests_utils.h"
+#include "tests_client_utils.h"
+
+static unsigned char request[] = ("{"
+    "\"jsonrpc\": \"2.0\","
+    "\"method\": \"get_light_state\","
+    "\"params\": [\"*\"],"
+    "\"id\": 42"
+"}");
+
+#define REQUEST_LEN (sizeof(request) - 1)
+#define PART_1_LEN 16
+#define PART_2_LEN (REQUEST_LEN - PART_1_LEN)
+
+static int
+get_nbytes_read(int call_count)
+{
+    switch (call_count) {
+    case 0:
+        return PART_1_LEN;
+    case 1:
+        return REQUEST_LEN;
+    default:
+        return 0;
+    }
+}
+
+static int evbuffer_get_length_call_count = 0;
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(
+            1, "evbuffer_get_length got buf %p (expected %p)",
+            buf, FAKE_BUFFEREVENT_INPUT_BUF
+        );
+    }
+
+    if (evbuffer_get_length_call_count++ == 2) {
+        errx(1, "evbuffer_get_length should have been called twice");
+    }
+
+    return PART_1_LEN;
+}
+
+struct evbuffer *
+bufferevent_get_input(struct bufferevent *bufev)
+{
+    (void)bufev;
+
+    return FAKE_BUFFEREVENT_INPUT_BUF;
+}
+
+static int evbuffer_get_contiguous_space_call_count = 0;
+
+size_t
+evbuffer_get_contiguous_space(const struct evbuffer *buf)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(
+            1, "evbuffer_get_contiguous_space got buf %p (expected %p)",
+            buf, FAKE_BUFFEREVENT_INPUT_BUF
+        );
+    }
+
+    return get_nbytes_read(evbuffer_get_contiguous_space_call_count++);
+}
+
+static int jsonrpc_dispatch_request_call_count = 0;
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+
+    if (!parsed) {
+        errx(1, "number of parsed json tokens not passed in");
+    }
+
+    switch (jsonrpc_dispatch_request_call_count++) {
+    case 0:
+        if (memcmp(client->json, request, REQUEST_LEN)) {
+            errx(
+                1, "got unexpected json %s (expected) %s", client->json, request
+            );
+        }
+        break;
+    default:
+        errx(1, "jsonrpc_dispatch_request should have been called once");
+    }
+}
+
+static int evbuffer_drain_call_count = 0;
+
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    switch (evbuffer_drain_call_count++) {
+    case 0:
+        if (len != REQUEST_LEN) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)REQUEST_LEN
+            );
+        }
+        break;
+    default:
+        errx(
+            1, "evbuffer_drain shouldn't have been called %d times",
+            evbuffer_drain_call_count
+        );
+    }
+
+    return 0;
+}
+
+static int evbuffer_pullup_call_count = 0;
+
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    if (buf != FAKE_BUFFEREVENT_INPUT_BUF) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    int offset;
+    switch (evbuffer_pullup_call_count++) {
+    case 0:
+        if (size != PART_1_LEN) {
+            errx(
+                1, "trying to pullup %ju bytes (expected %ju)",
+                (intmax_t)size, (uintmax_t)PART_1_LEN
+            );
+        }
+        offset = 0;
+        break;
+    case 1:
+        if (size != REQUEST_LEN) {
+            errx(
+                1, "trying to pullup %ju bytes (expected %ju)",
+                (intmax_t)size, (uintmax_t)REQUEST_LEN
+            );
+        }
+        offset = 0;
+        break;
+    case 2:
+        if (size != -1) {
+            errx(1, "trying to pullup %ju bytes (expected -1)", (intmax_t)size);
+        }
+        offset = REQUEST_LEN;
+        break;
+    default:
+        errx(
+            1, "evbuffer_pullup shouldn't have been called %d times",
+            evbuffer_pullup_call_count
+        );
+    }
+
+    return &request[offset];
+}
+
+int
+main(void)
+{
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+
+    lgtd_client_read_callback(FAKE_BUFFEREVENT, &client);
+    lgtd_client_read_callback(FAKE_BUFFEREVENT, &client);
+
+    if (!evbuffer_get_contiguous_space_call_count) {
+        errx(1, "evbuffer_get_contiguous_space not called");
+    }
+    if (!jsonrpc_dispatch_request_call_count) {
+        errx(1, "jsonrpc_dispatch_request not called");
+    }
+    if (!evbuffer_drain_call_count) {
+        errx(1, "evbuffer_drain not called");
+    }
+    if (!evbuffer_pullup_call_count) {
+        errx(1, "evbuffer_pullup not called");
+    }
+    if (!evbuffer_get_length_call_count) {
+        errx(1, "evbuffer_get_length not called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/client/tests_client_utils.h b/tests/core/client/tests_client_utils.h
new file mode 100644
--- /dev/null
+++ b/tests/core/client/tests_client_utils.h
@@ -0,0 +1,4 @@
+#pragma once
+
+#define FAKE_BUFFEREVENT (void *)0xfeed
+#define FAKE_BUFFEREVENT_INPUT_BUF (void *)3412
diff --git a/tests/core/jsonrpc/test_jsonrpc_build_target_list.c b/tests/core/jsonrpc/test_jsonrpc_build_target_list.c
--- a/tests/core/jsonrpc/test_jsonrpc_build_target_list.c
+++ b/tests/core/jsonrpc/test_jsonrpc_build_target_list.c
@@ -53,14 +53,18 @@
     test_params("[\"on\", 12345, \"6789\"]", expected_1);
 
     const char *expected_2[] = {"#tower", NULL};
-    test_params("#tower", expected_2);
+    test_params("\"#tower\"", expected_2);
 
     test_params("{\"key\": 42}", NULL);
 
-    test_params("null", NULL);
-
     const char *expected_3[] = {NULL};
     test_params("[]", expected_3);
 
+    test_params("[\"on\", {\"lol\": \"wut\"}, \"6789\"]", NULL);
+
+    // and make sure nothing blows up on plain invalid json/parameters
+    // (jsmn_parse will return a negative value):
+    test_params("null", NULL);
+
     return 0;
 }
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_invalid.c b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_invalid.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_invalid.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_invalid.c
@@ -9,7 +9,7 @@
 {
     jsmntok_t tokens[8];
     parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
-    if (lgtd_jsonrpc_type_float_between_0_and_1(tokens, json)) {
+    if (lgtd_jsonrpc_type_float_between_0_and_1(&tokens[1], json)) {
         errx(1, "%s was considered as a valid float >= 0 and <= 1", json);
     }
 }
@@ -17,12 +17,12 @@
 int
 main(void)
 {
-    test_float("1.1234");
-    test_float("-0.1234");
-    test_float("1.00000001");
-    test_float("2.0000");
-    test_float("10");
-    test_float("0.0.1");
+    test_float("[1.1234]");
+    test_float("[-0.1234]");
+    test_float("[1.00000001]");
+    test_float("[2.0000]");
+    test_float("[10]");
+    test_float("[0.0.1]");
 
     return 0;
 }
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_valid.c b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_valid.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_valid.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_valid.c
@@ -9,7 +9,7 @@
 {
     jsmntok_t tokens[8];
     parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
-    if (!lgtd_jsonrpc_type_float_between_0_and_1(tokens, json)) {
+    if (!lgtd_jsonrpc_type_float_between_0_and_1(&tokens[1], json)) {
         errx(1, "%s wasn't considered as a valid float >= 0 and <= 1", json);
     }
 }
@@ -17,11 +17,11 @@
 int
 main(void)
 {
-    test_float("0.1234");
-    test_float("1.0000000");
-    test_float("0.9999");
-    test_float("0.01");
-    test_float("000.01");
+    test_float("[0.1234]");
+    test_float("[1.0000000]");
+    test_float("[0.9999]");
+    test_float("[0.01]");
+    test_float("[000.01]");
 
     return 0;
 }
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_invalid.c b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_invalid.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_invalid.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_invalid.c
@@ -9,7 +9,7 @@
 {
     jsmntok_t tokens[8];
     parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
-    if (lgtd_jsonrpc_type_float_between_0_and_360(tokens, json)) {
+    if (lgtd_jsonrpc_type_float_between_0_and_360(&tokens[1], json)) {
         errx(1, "%s was considered as a valid float >= 0 and <= 360", json);
     }
 }
@@ -17,12 +17,12 @@
 int
 main(void)
 {
-    test_float("-1.1234");
-    test_float("-0.1234");
-    test_float("0.1.234");
-    test_float("0.1a234");
-    test_float("360a");
-    test_float("360.1");
+    test_float("[-1.1234]");
+    test_float("[-0.1234]");
+    test_float("[0.1.234]");
+    test_float("[0.1a234]");
+    test_float("[360a]");
+    test_float("[360.1]");
 
     return 0;
 }
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_valid.c b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_valid.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_valid.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_valid.c
@@ -9,7 +9,7 @@
 {
     jsmntok_t tokens[8];
     parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
-    if (!lgtd_jsonrpc_type_float_between_0_and_360(tokens, json)) {
+    if (!lgtd_jsonrpc_type_float_between_0_and_360(&tokens[1], json)) {
         errx(1, "%s wasn't considered as a valid float >= 0 and <= 360", json);
     }
 }
@@ -17,15 +17,15 @@
 int
 main(void)
 {
-    test_float("1.1234");
-    test_float("1.00000001");
-    test_float("2.0000");
-    test_float("10");
-    test_float("0.1");
-    test_float("0");
-    test_float("231.");
-    test_float("359.1");
-    test_float("360");
+    test_float("[1.1234]");
+    test_float("[1.00000001]");
+    test_float("[2.0000]");
+    test_float("[10]");
+    test_float("[0.1]");
+    test_float("[0]");
+    test_float("[231.]");
+    test_float("[359.1]");
+    test_float("[360]");
 
     return 0;
 }
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_integer.c b/tests/core/jsonrpc/test_jsonrpc_type_integer.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_integer.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_integer.c
@@ -7,12 +7,14 @@
 int
 main(void)
 {
-    const char *json = "1234";
+    const char json[] = "[1234]";
     jsmntok_t tokens[8];
 
-    parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json));
+    int rv = parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json));
 
-    bool ok = lgtd_jsonrpc_type_integer(tokens, json);
+    printf("rv = %d\n", rv);
+
+    bool ok = lgtd_jsonrpc_type_integer(&tokens[1], json);
 
     if (!ok) {
         errx(1, "%s wasn't considered as a valid integer", json);
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_integer_invalid_characters.c b/tests/core/jsonrpc/test_jsonrpc_type_integer_invalid_characters.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_integer_invalid_characters.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_integer_invalid_characters.c
@@ -7,12 +7,12 @@
 int
 main(void)
 {
-    const char *json = "-1a";
+    const char json[] = "[-1a]";
     jsmntok_t tokens[8];
 
     parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json));
 
-    bool ok = lgtd_jsonrpc_type_integer(tokens, json);
+    bool ok = lgtd_jsonrpc_type_integer(&tokens[1], json);
 
     if (ok) {
         errx(1, "%s wasn't considered invalid", json);
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_integer_too_big.c b/tests/core/jsonrpc/test_jsonrpc_type_integer_too_big.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_integer_too_big.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_integer_too_big.c
@@ -7,12 +7,12 @@
 int
 main(void)
 {
-    const char *json = "9999999999";
+    const char json[] = "[99999999999999999999999]";
     jsmntok_t tokens[8];
 
     parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json));
 
-    bool ok = lgtd_jsonrpc_type_integer(tokens, json);
+    bool ok = lgtd_jsonrpc_type_integer(&tokens[1], json);
 
     if (ok) {
         errx(1, "%s wasn't considered invalid", json);
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_integer_too_small.c b/tests/core/jsonrpc/test_jsonrpc_type_integer_too_small.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_integer_too_small.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_integer_too_small.c
@@ -7,12 +7,12 @@
 int
 main(void)
 {
-    const char *json = "-9999999999";
+    const char json[] = "[-999999999999999999999]";
     jsmntok_t tokens[8];
 
     parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json));
 
-    bool ok = lgtd_jsonrpc_type_integer(tokens, json);
+    bool ok = lgtd_jsonrpc_type_integer(&tokens[1], json);
 
     if (ok) {
         errx(1, "%s wasn't considered invalid", json);
diff --git a/tests/core/mock_client_buf.h b/tests/core/mock_client_buf.h
--- a/tests/core/mock_client_buf.h
+++ b/tests/core/mock_client_buf.h
@@ -1,5 +1,7 @@
 #pragma once
 
+#define MOCKED_BUFFEREVENT_WRITE
+
 static char client_write_buf[4096] = { 0 };
 static int client_write_buf_idx = 0;
 
diff --git a/tests/core/mock_event2.h b/tests/core/mock_event2.h
--- a/tests/core/mock_event2.h
+++ b/tests/core/mock_event2.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <event2/buffer.h>
+#include <event2/bufferevent.h>
 #include <event2/event.h>
 
 #define MOCK_EVENT_NEW_EVENT_PTR ((void *)0xdadadada)
@@ -60,6 +61,15 @@
 }
 #endif
 
+#ifndef MOCKED_EVBUFFER_GET_CONTIGUOUS_SPACE
+size_t
+evbuffer_get_contiguous_space(const struct evbuffer *buf)
+{
+    (void)buf;
+    return 0;
+}
+#endif
+
 #ifndef MOCKED_EVENT_ADD
 int
 event_add(struct event *ev, const struct timeval *timeout)
@@ -133,3 +143,70 @@
     return 0;
 }
 #endif
+
+#ifndef MOCKED_BUFFEREVENT_GET_INPUT
+struct evbuffer *
+bufferevent_get_input(struct bufferevent *bufev)
+{
+    (void)bufev;
+    return NULL;
+}
+#endif
+
+#ifndef MOCKED_BUFFEREVENT_ENABLE
+int
+bufferevent_enable(struct bufferevent *bufev, short event)
+{
+    (void)bufev;
+    (void)event;
+    return 0;
+}
+#endif
+
+#ifndef MOCKED_BUFFEREVENT_FREE
+void
+bufferevent_free(struct bufferevent *bufev)
+{
+    (void)bufev;
+}
+#endif
+
+#ifndef MOCKED_BUFFEREVENT_SETCB
+void
+bufferevent_setcb(struct bufferevent *bufev,
+                  bufferevent_data_cb readcb,
+                  bufferevent_data_cb writecb,
+                  bufferevent_event_cb eventcb,
+                  void *cbarg)
+{
+    (void)bufev;
+    (void)readcb;
+    (void)writecb;
+    (void)eventcb;
+    (void)cbarg;
+}
+#endif
+
+#ifndef MOCKED_BUFFEREVENT_SOCKET_NEW
+struct bufferevent *
+bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options)
+{
+    (void)base;
+    (void)fd;
+    (void)options;
+    return NULL;
+}
+#endif
+
+#ifndef MOCKED_BUFFEREVENT_WRITE
+int
+bufferevent_write(struct bufferevent *bufev,
+                  const void *data,
+                  size_t size)
+{
+    (void)bufev;
+    (void)data;
+    (void)size;
+    return 0;
+}
+#endif
diff --git a/tests/core/mock_jsonrpc.h b/tests/core/mock_jsonrpc.h
new file mode 100644
--- /dev/null
+++ b/tests/core/mock_jsonrpc.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#ifndef MOCKED_JSONRPC_DISPATCH_REQUEST
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+}
+#endif
+
+#ifndef MOCKED_JSONRPC_SEND_ERROR
+void
+lgtd_jsonrpc_send_error(struct lgtd_client *client,
+                        enum lgtd_jsonrpc_error_code code,
+                        const char *msg)
+{
+    (void)client;
+    (void)code;
+    (void)msg;
+}
+#endif
+
+#ifndef MOCKED_JSONRPC_SEND_RESPONSE
+void
+lgtd_jsonrpc_send_response(struct lgtd_client *client, const char *msg)
+{
+    (void)client;
+    (void)msg;
+}
+#endif
+
+#ifndef MOCKED_JSONRPC_START_SEND_RESPONSE
+void
+lgtd_jsonrpc_start_send_response(struct lgtd_client *client)
+{
+    (void)client;
+}
+#endif
+
+#ifndef MOCKED_JSONRPC_END_SEND_RESPONSE
+void
+lgtd_jsonrpc_end_send_response(struct lgtd_client *client)
+{
+    (void)client;
+}
+#endif
diff --git a/tests/core/pipe/test_pipe_close.c b/tests/core/pipe/test_pipe_close.c
--- a/tests/core/pipe/test_pipe_close.c
+++ b/tests/core/pipe/test_pipe_close.c
@@ -13,6 +13,7 @@
 #define MOCKED_EVENT_FREE
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
diff --git a/tests/core/pipe/test_pipe_open.c b/tests/core/pipe/test_pipe_open.c
--- a/tests/core/pipe/test_pipe_open.c
+++ b/tests/core/pipe/test_pipe_open.c
@@ -12,6 +12,7 @@
 #define MOCKED_EVENT_ADD
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
diff --git a/tests/core/pipe/test_pipe_open_fifo_already_exists.c b/tests/core/pipe/test_pipe_open_fifo_already_exists.c
--- a/tests/core/pipe/test_pipe_open_fifo_already_exists.c
+++ b/tests/core/pipe/test_pipe_open_fifo_already_exists.c
@@ -12,6 +12,7 @@
 #define MOCKED_EVENT_ADD
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
diff --git a/tests/core/pipe/test_pipe_read_callback.c b/tests/core/pipe/test_pipe_read_callback.c
--- a/tests/core/pipe/test_pipe_read_callback.c
+++ b/tests/core/pipe/test_pipe_read_callback.c
@@ -15,11 +15,12 @@
 #define MOCKED_EVBUFFER_DRAIN
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#define MOCKED_JSONRPC_DISPATCH_REQUEST
 #include "tests_pipe_utils.h"
 
 static unsigned char request[] = ("{"
@@ -108,14 +109,6 @@
         errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
     }
 
-    jsmn_parser jsmn_ctx;
-    jsmn_init(&jsmn_ctx);
-    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
-    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
-        errx(1, "the client json parser context wasn't re-initialized");
-    }
-
-
     switch (evbuffer_drain_call_count) {
     case 0:
         if (len != sizeof(request) - 1) {
@@ -148,6 +141,13 @@
         );
     }
 
+    jsmn_parser jsmn_ctx;
+    jsmn_init(&jsmn_ctx);
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
+        errx(1, "the client json parser context wasn't re-initialized");
+    }
+
     return &request[evbuffer_pullup_call_count++ ? sizeof(request) - 1 : 0];
 }
 
diff --git a/tests/core/pipe/test_pipe_read_callback_extra_data.c b/tests/core/pipe/test_pipe_read_callback_extra_data.c
--- a/tests/core/pipe/test_pipe_read_callback_extra_data.c
+++ b/tests/core/pipe/test_pipe_read_callback_extra_data.c
@@ -14,11 +14,12 @@
 #define MOCKED_EVBUFFER_DRAIN
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#define MOCKED_JSONRPC_DISPATCH_REQUEST
 #include "tests_pipe_utils.h"
 
 #define REQUEST_1 "{"                   \
@@ -103,15 +104,16 @@
         errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
     }
 
-    jsmn_parser jsmn_ctx;
-    jsmn_init(&jsmn_ctx);
-    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
-    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
-        errx(1, "the client json parser context wasn't re-initialized");
-    }
-
     switch (evbuffer_drain_call_count) {
     case 0:
+        if (len != sizeof(request) - sizeof(REQUEST_1)) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)(sizeof(request) - sizeof(REQUEST_1))
+            );
+        }
+        break;
+    case 1:
         if (len != sizeof(REQUEST_1) - 1) {
             errx(
                 1, "trying to drain %ju bytes (expected %ju)",
@@ -119,14 +121,6 @@
             );
         }
         break;
-    case 1:
-        if (len != sizeof(request) - sizeof(REQUEST_1)) {
-            errx(
-                1, "trying to drain %ju bytes (expected %ju)",
-                (uintmax_t)len, (uintmax_t)(sizeof(request) - sizeof(REQUEST_1))
-            );
-        }
-        break;
     default:
         break;
     }
@@ -150,6 +144,13 @@
         );
     }
 
+    jsmn_parser jsmn_ctx;
+    jsmn_init(&jsmn_ctx);
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
+        errx(1, "the client json parser context wasn't re-initialized");
+    }
+
     return &request[evbuffer_pullup_call_count++ ? sizeof(request) - 1 : 0];
 }
 
diff --git a/tests/core/pipe/test_pipe_read_callback_multiple_requests.c b/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
--- a/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
+++ b/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
@@ -14,11 +14,12 @@
 #define MOCKED_EVBUFFER_DRAIN
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#define MOCKED_JSONRPC_DISPATCH_REQUEST
 #include "tests_pipe_utils.h"
 
 #define REQUEST_1 "{"                   \
@@ -119,13 +120,6 @@
         errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
     }
 
-    jsmn_parser jsmn_ctx;
-    jsmn_init(&jsmn_ctx);
-    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
-    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
-        errx(1, "the client json parser context wasn't re-initialized");
-    }
-
     switch (evbuffer_drain_call_count) {
     case 0:
         if (len != sizeof(REQUEST_1) - 1) {
@@ -167,6 +161,13 @@
         );
     }
 
+    jsmn_parser jsmn_ctx;
+    jsmn_init(&jsmn_ctx);
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
+        errx(1, "the client json parser context wasn't re-initialized");
+    }
+
     int offset;
     switch (evbuffer_pullup_call_count) {
     case 0:
diff --git a/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c b/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c
--- a/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c
+++ b/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c
@@ -14,11 +14,12 @@
 #define MOCKED_EVBUFFER_DRAIN
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#define MOCKED_JSONRPC_DISPATCH_REQUEST
 #include "tests_pipe_utils.h"
 
 #define REQUEST_1 "{"                   \
@@ -119,13 +120,6 @@
         errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
     }
 
-    jsmn_parser jsmn_ctx;
-    jsmn_init(&jsmn_ctx);
-    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
-    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
-        errx(1, "the client json parser context wasn't re-initialized");
-    }
-
     switch (evbuffer_drain_call_count) {
     case 0:
         if (len != sizeof(REQUEST_1) - 1) {
@@ -167,6 +161,13 @@
         );
     }
 
+    jsmn_parser jsmn_ctx;
+    jsmn_init(&jsmn_ctx);
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
+        errx(1, "the client json parser context wasn't re-initialized");
+    }
+
     int offset;
     switch (evbuffer_pullup_call_count) {
     case 0:
diff --git a/tests/core/pipe/tests_pipe_utils.h b/tests/core/pipe/tests_pipe_utils.h
--- a/tests/core/pipe/tests_pipe_utils.h
+++ b/tests/core/pipe/tests_pipe_utils.h
@@ -10,12 +10,3 @@
     jsmn_init(&pipe_client->jsmn_ctx);
 }
 #endif
-
-#ifndef MOCKED_JSONRPC_DISPATCH_REQUEST
-void
-lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
-{
-    (void)client;
-    (void)parsed;
-}
-#endif
diff --git a/tests/core/tests_shims.c b/tests/core/tests_shims.c
--- a/tests/core/tests_shims.c
+++ b/tests/core/tests_shims.c
@@ -1,6 +1,7 @@
 #include <sys/queue.h>
 #include <sys/tree.h>
 #include <sys/socket.h>
+#include <assert.h>
 #include <endian.h>
 #include <netinet/in.h>
 #include <stdbool.h>
@@ -32,3 +33,17 @@
 lgtd_cleanup(void)
 {
 }
+
+short
+lgtd_sockaddrport(const struct sockaddr_storage *peer)
+{
+    assert(peer);
+
+    if (peer->ss_family == AF_INET) {
+        const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
+        return ntohs(in_peer->sin_port);
+    } else {
+        const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
+        return ntohs(in6_peer->sin6_port);
+    }
+}
