# HG changeset patch
# Parent  6d4f1494c6d4bcfab5e6cf6c47631e95118d2b22

diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -70,59 +70,62 @@
     struct lgtd_client *client = ctx;
 
     struct evbuffer *input = bufferevent_get_input(bev);
-    size_t bufsz = evbuffer_get_contiguous_space(input);
+    size_t nbytes = evbuffer_get_contiguous_space(input);
     // Get the actual pointer to the beginning of the evbuf:
-    const char *buf = (char *)evbuffer_pullup(input, bufsz);
-    jsmnerr_t rv;
+    const char *buf = (char *)evbuffer_pullup(input, nbytes);
 
-retry_after_pullup:
-    rv = jsmn_parse(
-        &client->jsmn_ctx,
-        buf,
-        bufsz,
-        client->jsmn_tokens,
-        LGTD_ARRAY_SIZE(client->jsmn_tokens)
-    );
-    switch (rv) {
-    case JSMN_ERROR_NOMEM:
-        lgtd_warnx(
-            "dropping client [%s]:%hu: request too big, not "
-            "enough parser tokens", client->ip_addr, client->port
+    lgtd_info("START nbytes %ju", (uintmax_t)nbytes);
+    do {
+        jsmnerr_t rv = jsmn_parse(
+            &client->jsmn_ctx,
+            buf,
+            nbytes,
+            client->jsmn_tokens,
+            LGTD_ARRAY_SIZE(client->jsmn_tokens)
         );
-        lgtd_client_close(client);
-        break;
-    case JSMN_ERROR_INVAL:
-        lgtd_warnx(
-            "dropping client [%s]:%hu: invalid json",
-            client->ip_addr, client->port
-        );
-        // TODO: consume remaining data and send a proper error instead of
-        // closing the connection:
-        lgtd_client_close(client);
-        break;
-    case JSMN_ERROR_PART:
-        if (evbuffer_get_length(input) > LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) {
+        switch (rv) {
+        case JSMN_ERROR_NOMEM:
+        case JSMN_ERROR_INVAL:
+            lgtd_info("NOMEM/INVAL, draining nbytes %ju", (uintmax_t)nbytes);
             lgtd_warnx(
-                "dropping client [%s]:%hu: request too big",
+                "client [%s]:%hu: request too big or invalid",
                 client->ip_addr, client->port
             );
-            lgtd_client_close(client);
+            evbuffer_drain(input, nbytes);
+            jsmn_init(&client->jsmn_ctx);
             break;
-        } else if (bufsz >= evbuffer_get_length(input)) {
-            break; // We pulled up everything already, wait for more data
+        case JSMN_ERROR_PART:
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wswitch"
+        case 0:
+#pragma GCC diagnostic pop
+            lgtd_info("PART/0");
+            if (evbuffer_get_length(input) > LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) {
+                lgtd_warnx(
+                    "dropping client [%s]:%hu: request too big",
+                    client->ip_addr, client->port
+                );
+                lgtd_client_close(client);
+                break;
+            } else if (nbytes == evbuffer_get_length(input)) {
+                lgtd_info("PART/0 RETURN");
+                return; // We pulled up everything already, wait for more data
+            }
+            break;
+        default:
+            lgtd_info("DEFAULT");
+            client->json = buf;
+            lgtd_jsonrpc_dispatch_request(client, rv);
+            client->json = NULL;
+            evbuffer_drain(input, nbytes);
+            jsmn_init(&client->jsmn_ctx);
+            break;
         }
         // pullup and resume parsing:
         buf = (char *)evbuffer_pullup(input, -1);
-        bufsz = evbuffer_get_length(input);
-        goto retry_after_pullup;
-    default:
-        client->json = buf;
-        lgtd_jsonrpc_dispatch_request(client, rv);
-        client->json = NULL;
-        evbuffer_drain(input, bufsz);
-        jsmn_init(&client->jsmn_ctx);
-        break;
-    }
+        nbytes = evbuffer_get_contiguous_space(input);
+        lgtd_info("PULLUP, nbytes = %ju", (uintmax_t)nbytes);
+    } while (nbytes);
 }
 
 static void
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -1136,6 +1136,7 @@
     }
 
     assert(request.method);
+    assert(request.request_ntokens);
 
     for (int i = 0; i != LGTD_ARRAY_SIZE(methods); i++) {
         int parsed_method_namelen = LGTD_JSONRPC_TOKEN_LEN(request.method);
