# HG changeset patch
# Parent  51336c56c6a8d78e341c3aef261c9014d41823eb
Add support for a write-only command pipe for easy scripting

You can just dump simple JSON-RPC calls in it, it will pair nicely with
the toggle command that I'm gonna implement.

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -42,6 +42,8 @@
     "-D_POSIX_C_SOURCE=200809L"
     "-D_BSD_SOURCE=1"
     "-D_DEFAULT_SOURCE=1"
+
+    "-D_DARWIN_C_SOURCE=1"
 )
 
 IF (CMAKE_BUILD_TYPE MATCHES "DEBUG")
diff --git a/README.rst b/README.rst
--- a/README.rst
+++ b/README.rst
@@ -33,8 +33,8 @@
   tests);
 - toggle (power on if off and vice-versa, coming up).
 
-The JSON-RPC interface works on top on IPv4/v6, over a command (named) pipe
-(coming up) and Unix sockets (coming up).
+The JSON-RPC interface works on top of TCP/IPv4/v6, Unix sockets (coming up) or
+over a command pipe (named pipe, see mkfifo(1)).
 
 lightsd can target single or multiple bulbs at once:
 
diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -20,6 +20,7 @@
     listen.c
     lightsd.c
     log.c
+    pipe.c
     proto.c
     router.c
 )
diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -23,6 +23,7 @@
 #include <stdbool.h>
 #include <stdlib.h>
 #include <stdint.h>
+#include <string.h>
 
 #include <event2/buffer.h>
 #include <event2/bufferevent.h>
@@ -138,6 +139,29 @@
 }
 
 void
+lgtd_client_write_string(struct lgtd_client *client, const char *msg)
+{
+    assert(client);
+    assert(msg);
+
+    if (client->io) {
+        bufferevent_write(client->io, msg, strlen(msg));
+    }
+}
+
+void
+lgtd_client_write_buf(struct lgtd_client *client, const char *buf, int bufsz)
+{
+    assert(client);
+    assert(buf);
+    assert(bufsz >= 0);
+
+    if (bufsz > 0 && client->io) {
+        bufferevent_write(client->io, buf, bufsz);
+    }
+}
+
+void
 lgtd_client_send_response(struct lgtd_client *client, const char *msg)
 {
     lgtd_jsonrpc_send_response(client, msg);
@@ -195,3 +219,13 @@
 
     return client;
 }
+
+void
+lgtd_client_open_from_pipe(struct lgtd_client *pipe_client)
+{
+    assert(pipe_client);
+
+    memset(pipe_client, 0, sizeof(*pipe_client));
+
+    jsmn_init(&pipe_client->jsmn_ctx);
+}
diff --git a/core/client.h b/core/client.h
--- a/core/client.h
+++ b/core/client.h
@@ -42,13 +42,12 @@
 };
 LIST_HEAD(lgtd_client_list, lgtd_client);
 
-#define LGTD_CLIENT_WRITE_STRING(client, s) do {        \
-    bufferevent_write((client)->io, s, strlen((s)));    \
-} while(0)
-
 struct lgtd_client *lgtd_client_open(evutil_socket_t, const struct sockaddr_storage *);
+void lgtd_client_open_from_pipe(struct lgtd_client *);
 void lgtd_client_close_all(void);
 
+void lgtd_client_write_string(struct lgtd_client *, const char *);
+void lgtd_client_write_buf(struct lgtd_client *, const char *, int);
 void lgtd_client_send_response(struct lgtd_client *, const char *);
 void lgtd_client_start_send_response(struct lgtd_client *);
 void lgtd_client_end_send_response(struct lgtd_client *);
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -480,7 +480,7 @@
 lgtd_jsonrpc_write_id(struct lgtd_client *client)
 {
     if (!client->current_request->id) {
-        LGTD_CLIENT_WRITE_STRING(client, "null");
+        lgtd_client_write_string(client, "null");
         return;
     }
 
@@ -492,7 +492,7 @@
         start = client->current_request->id->start;
         stop = client->current_request->id->end;
     }
-    bufferevent_write(client->io, &client->json[start], stop - start);
+    lgtd_client_write_buf(client, &client->json[start], stop - start);
 }
 
 void
@@ -503,15 +503,15 @@
     assert(client);
     assert(message);
 
-    LGTD_CLIENT_WRITE_STRING(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
+    lgtd_client_write_string(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
     lgtd_jsonrpc_write_id(client);
-    LGTD_CLIENT_WRITE_STRING(client, ", \"error\": {\"code\": ");
+    lgtd_client_write_string(client, ", \"error\": {\"code\": ");
     char str_code[8] = { 0 };
     snprintf(str_code, sizeof(str_code), "%d", code);
-    LGTD_CLIENT_WRITE_STRING(client, str_code);
-    LGTD_CLIENT_WRITE_STRING(client, ", \"message\": \"");
-    LGTD_CLIENT_WRITE_STRING(client, message);
-    LGTD_CLIENT_WRITE_STRING(client, "\"}}");
+    lgtd_client_write_string(client, str_code);
+    lgtd_client_write_string(client, ", \"message\": \"");
+    lgtd_client_write_string(client, message);
+    lgtd_client_write_string(client, "\"}}");
 }
 
 void
@@ -521,11 +521,11 @@
     assert(client);
     assert(result);
 
-    LGTD_CLIENT_WRITE_STRING(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
+    lgtd_client_write_string(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
     lgtd_jsonrpc_write_id(client);
-    LGTD_CLIENT_WRITE_STRING(client, ", \"result\": ");
-    LGTD_CLIENT_WRITE_STRING(client, result);
-    LGTD_CLIENT_WRITE_STRING(client, "}");
+    lgtd_client_write_string(client, ", \"result\": ");
+    lgtd_client_write_string(client, result);
+    lgtd_client_write_string(client, "}");
 }
 
 void
@@ -533,15 +533,15 @@
 {
     assert(client);
 
-    LGTD_CLIENT_WRITE_STRING(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
+    lgtd_client_write_string(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
     lgtd_jsonrpc_write_id(client);
-    LGTD_CLIENT_WRITE_STRING(client, ", \"result\": ");
+    lgtd_client_write_string(client, ", \"result\": ");
 }
 
 void
 lgtd_jsonrpc_end_send_response(struct lgtd_client *client)
 {
-    LGTD_CLIENT_WRITE_STRING(client, "}");
+    lgtd_client_write_string(client, "}");
 }
 
 static bool
diff --git a/core/lightsd.c b/core/lightsd.c
--- a/core/lightsd.c
+++ b/core/lightsd.c
@@ -45,6 +45,7 @@
 #include "jsmn.h"
 #include "jsonrpc.h"
 #include "client.h"
+#include "pipe.h"
 #include "listen.h"
 #include "lightsd.h"
 
@@ -60,6 +61,7 @@
 lgtd_cleanup(void)
 {
     lgtd_listen_close_all();
+    lgtd_command_pipe_close_all();
     lgtd_client_close_all();
     lgtd_lifx_timer_close();
     lgtd_lifx_broadcast_close();
@@ -126,8 +128,14 @@
 lgtd_usage(const char *progname)
 {
     printf(
-        "Usage: %s -l addr:port [-l ...] [-f] [-t] [-h] [-V] "
-        "[-v debug|info|warning|error]\n",
+        "Usage: %s ...\n\n"
+        "  [-l,--listen addr:port [+]]\n"
+        "  [-c,--comand-pipe /command/fifo [+]]\n"
+        "  [-f,--foreground]\n"
+        "  [-t,--no-timestamps]\n"
+        "  [-h,--help]\n"
+        "  [-V,--version]\n"
+        "  [-v,--verbosity debug|info|warning|error]\n",
         progname
     );
     exit(0);
@@ -141,6 +149,7 @@
 
     static const struct option long_opts[] = {
         {"listen",          required_argument, NULL, 'l'},
+        {"command-pipe",    required_argument, NULL, 'c'},
         {"foreground",      no_argument,       NULL, 'f'},
         {"no-timestamps",   no_argument,       NULL, 't'},
         {"help",            no_argument,       NULL, 'h'},
@@ -148,7 +157,7 @@
         {"version",         no_argument,       NULL, 'V'},
         {NULL,              0,                 NULL, 0}
     };
-    const char short_opts[] = "l:fthv:V";
+    const char short_opts[] = "l:c:fthv:V";
 
     for (int rv = getopt_long(argc, argv, short_opts, long_opts, NULL);
          rv != -1;
@@ -164,6 +173,12 @@
             if (!lgtd_listen_open(optarg, sep + 1)) {
                 exit(1);
             }
+            break;
+        case 'c':
+            if (!lgtd_command_pipe_open(optarg)) {
+                exit(1);
+            }
+            break;
         case 'f':
             lgtd_opts.foreground = true;
             break;
diff --git a/core/pipe.c b/core/pipe.c
new file mode 100644
--- /dev/null
+++ b/core/pipe.c
@@ -0,0 +1,248 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <sys/queue.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <assert.h>
+#include <err.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <event2/buffer.h>
+#include <event2/event.h>
+
+#include "jsmn.h"
+#include "jsonrpc.h"
+#include "client.h"
+#include "pipe.h"
+#include "lightsd.h"
+
+struct lgtd_command_pipe_list lgtd_command_pipes =
+    SLIST_HEAD_INITIALIZER(&lgtd_command_pipes);
+
+static void
+lgtd_command_pipe_close(struct lgtd_command_pipe *pipe)
+{
+    assert(pipe);
+
+    event_del(pipe->read_ev);
+    if (pipe->fd != -1) {
+        close(pipe->fd);
+    }
+    unlink(pipe->path);
+    SLIST_REMOVE(&lgtd_command_pipes, pipe, lgtd_command_pipe, link);
+    evbuffer_free(pipe->read_buf);
+    event_free(pipe->read_ev);
+
+    lgtd_info("closed command pipe %s", pipe->path);
+    free(pipe);
+}
+
+static void
+lgtd_command_pipe_read_callback(evutil_socket_t socket, short events, void *ctx)
+{
+    assert(ctx);
+    assert(socket != -1);
+
+    (void)socket;
+    (void)events;
+
+    struct lgtd_command_pipe *pipe = ctx;
+
+    bool drain = false;
+    int read = 0;
+    for (int nbytes = evbuffer_read(pipe->read_buf, pipe->fd, -1);
+         nbytes;
+         nbytes = evbuffer_read(pipe->read_buf, pipe->fd, -1)) {
+        if (nbytes == -1) {
+            if (errno == EINTR) {
+                continue;
+            }
+            if (errno != EAGAIN) {
+                lgtd_warn("read error on command pipe %s", pipe->path);
+                const char *path = pipe->path;
+                lgtd_command_pipe_close(pipe);
+                lgtd_command_pipe_open(path);
+                return;
+            }
+            continue;
+        }
+
+        if (!drain) {
+            read += nbytes;
+        next_request:
+            (void)0;
+            const char *buf = (char *)evbuffer_pullup(pipe->read_buf, -1);
+            ssize_t bufsz = evbuffer_get_length(pipe->read_buf);
+            jsmnerr_t rv = jsmn_parse(
+                &pipe->client.jsmn_ctx,
+                buf,
+                bufsz,
+                pipe->client.jsmn_tokens,
+                LGTD_ARRAY_SIZE(pipe->client.jsmn_tokens)
+            );
+            switch (rv) {
+            case JSMN_ERROR_NOMEM:
+            case JSMN_ERROR_INVAL:
+                lgtd_warnx("pipe %s: request too big or invalid", pipe->path);
+                // ignore what's left
+                drain = true;
+                break;
+            case JSMN_ERROR_PART:
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wswitch"
+            case 0:
+#pragma GCC diagnostic pop
+                if (bufsz >= LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) {
+                    lgtd_warnx("pipe %s: request too big", pipe->path);
+                    drain = true;
+                }
+                break;
+            default:
+                pipe->client.json = buf;
+                int ntokens = rv;
+                lgtd_jsonrpc_dispatch_request(&pipe->client, ntokens);
+
+                pipe->client.json = NULL;
+                jsmn_init(&pipe->client.jsmn_ctx);
+                int request_size = pipe->client.jsmn_tokens[0].end;
+                evbuffer_drain(pipe->read_buf, request_size);
+                read -= request_size;
+                if (read) {
+                    goto next_request;
+                }
+                break;
+            }
+        } else {
+            evbuffer_drain(pipe->read_buf, read + nbytes);
+            read = 0;
+        }
+    }
+
+    if (read) {
+        lgtd_debug(
+            "pipe %s: discarding %d bytes of unusable data", pipe->path, read
+        );
+        evbuffer_drain(pipe->read_buf, read);
+    }
+    jsmn_init(&pipe->client.jsmn_ctx);
+}
+
+static mode_t
+lgtd_command_pipe_get_umask(void)
+{
+    mode_t mask = umask(0);
+    umask(mask);
+    return mask;
+}
+
+bool
+lgtd_command_pipe_open(const char *path)
+{
+    assert(path);
+
+    struct lgtd_command_pipe *pipe;
+    SLIST_FOREACH(pipe, &lgtd_command_pipes, link) {
+        if (!strcmp(pipe->path, path)) {
+            return true;
+        }
+    }
+
+    pipe = calloc(1, sizeof(*pipe));
+    if (!pipe) {
+        lgtd_warn("can't open command pipe %s", path);
+        return false;
+    }
+
+    lgtd_client_open_from_pipe(&pipe->client);
+    pipe->path = path;
+    pipe->fd = -1;
+
+    mode_t mode = S_IWUSR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IWGRP;
+    if (mkfifo(path, mode)) {
+        if (errno != EEXIST) {
+            goto error;
+        }
+        mode &= ~lgtd_command_pipe_get_umask();
+        if (chmod(path, mode)) {
+            goto error;
+        }
+    }
+
+    pipe->fd = open(path, O_RDONLY|O_NONBLOCK);
+    if (pipe->fd == -1) {
+        goto error;
+    }
+
+    if (evutil_make_socket_nonblocking(pipe->fd) == -1) {
+        goto error;
+    }
+
+    pipe->read_ev = event_new(
+        lgtd_ev_base,
+        pipe->fd,
+        EV_READ|EV_PERSIST,
+        lgtd_command_pipe_read_callback,
+        pipe
+    );
+    if (!pipe->read_ev) {
+        goto error;
+    }
+
+    pipe->read_buf = evbuffer_new();
+    if (!pipe->read_buf) {
+        goto error;
+    }
+
+    if (event_add(pipe->read_ev, NULL)) {
+        goto error;
+    }
+
+    lgtd_info("command pipe ready at %s", pipe->path);
+
+    SLIST_INSERT_HEAD(&lgtd_command_pipes, pipe, link);
+
+    return true;
+
+error:
+    lgtd_warn("can't open command pipe %s", path);
+    if (pipe->read_buf) {
+        evbuffer_free(pipe->read_buf);
+    }
+    if (pipe->read_ev) {
+        event_free(pipe->read_ev);
+    }
+    if (pipe->fd != -1) {
+        close(pipe->fd);
+    }
+    free(pipe);
+    return false;
+}
+
+void
+lgtd_command_pipe_close_all(void)
+{
+    while (!SLIST_EMPTY(&lgtd_command_pipes)) {
+        lgtd_command_pipe_close(SLIST_FIRST(&lgtd_command_pipes));
+    }
+}
diff --git a/core/pipe.h b/core/pipe.h
new file mode 100644
--- /dev/null
+++ b/core/pipe.h
@@ -0,0 +1,33 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#pragma once
+
+struct lgtd_command_pipe {
+    SLIST_ENTRY(lgtd_command_pipe)  link;
+    const char                      *path;
+    int                             fd;
+    struct event                    *read_ev;
+    struct evbuffer                 *read_buf;
+    struct lgtd_client              client;
+};
+SLIST_HEAD(lgtd_command_pipe_list, lgtd_command_pipe);
+
+extern struct lgtd_command_pipe_list lgtd_command_pipes;
+
+bool lgtd_command_pipe_open(const char *);
+void lgtd_command_pipe_close_all(void);
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -178,7 +178,7 @@
     )
 
     lgtd_client_start_send_response(client);
-    LGTD_CLIENT_WRITE_STRING(client, "[");
+    lgtd_client_write_string(client, "[");
     struct lgtd_router_device *device;
     SLIST_FOREACH(device, devices, link) {
         struct lgtd_lifx_bulb *bulb = device->device;
@@ -204,22 +204,22 @@
             );
             continue;
         }
-        LGTD_CLIENT_WRITE_STRING(client, buf);
+        lgtd_client_write_string(client, buf);
 
         bool comma = false;
         int tag_id;
         LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, bulb->state.tags) {
-            LGTD_CLIENT_WRITE_STRING(client, comma ? ",\"" : "\"");
-            LGTD_CLIENT_WRITE_STRING(client, bulb->gw->tags[tag_id]->label);
-            LGTD_CLIENT_WRITE_STRING(client, "\"");
+            lgtd_client_write_string(client, comma ? ",\"" : "\"");
+            lgtd_client_write_string(client, bulb->gw->tags[tag_id]->label);
+            lgtd_client_write_string(client, "\"");
             comma = true;
         }
 
-        LGTD_CLIENT_WRITE_STRING(
+        lgtd_client_write_string(
             client, SLIST_NEXT(device, link) ?  "]}," : "]}"
         );
     }
-    LGTD_CLIENT_WRITE_STRING(client, "]");
+    lgtd_client_write_string(client, "]");
     lgtd_client_end_send_response(client);
 
     lgtd_router_device_list_free(devices);
diff --git a/tests/lightsc b/examples/lightsc.py
rename from tests/lightsc
rename to examples/lightsc.py
diff --git a/examples/lightsc.sh b/examples/lightsc.sh
new file mode 100644
--- /dev/null
+++ b/examples/lightsc.sh
@@ -0,0 +1,72 @@
+#!/bin/sh
+
+# Here is an example script that dims bulbs to a warm orange:
+
+# #!/bin/sh
+#
+# # Optional (default value: /run/lightsd.cmd):
+# COMMAND_PIPE=/foo/bar/lightsd.cmd
+#
+# . /usr/lib/lightsd/lightsc.sh
+#
+# lightsc set_light_from_hsbk ${*:-'"*"'} 37.469443 1.0 0.05 3500 600
+
+# Here is how you could use it:
+#
+# - dim all the bulbs: orange
+# - dim the bulb named kitchen: orange '"kitchen"'
+# - dim the bulb named kitchen and the bulbs tagged bedroom:
+#   orange '["kitchen", "#bedroom"]'
+#
+# You can also load this file directly in your shell rc configuration file.
+#
+# NOTE: Keep in mind that arguments must be JSON, you will have to enclose
+#       tags and labels into double quotes '"likethis"'. Also keep in mind
+#       that the pipe is write-only you cannot read any result back.
+
+_b64e() {
+    if type base64 >/dev/null 2>&1 ; then
+        base64
+    elif type b64encode >/dev/null 2>&1 ; then
+        b64encode
+    else
+        cat >/dev/null
+        echo null
+    fi
+}
+
+_gen_request_id() {
+    if type dd >/dev/null 2>&1 ; then
+        printf '"%s"' `dd if=/dev/urandom bs=8 count=1 2>&- | _b64e`
+    else
+        echo null
+    fi
+}
+
+lightsc() {
+    if [ $# -lt 2 ] ; then
+        echo >&2 "Usage: $0 METHOD PARAMS ..."
+        return 1
+    fi
+
+    local pipe=${COMMAND_PIPE:-/run/lightsd.cmd}
+    if [ ! -p $pipe ] ; then
+        echo >&2 "$pipe cannot be found, is lightsd running?"
+        return 1
+    fi
+
+    local method=$1 ; shift
+    local params=$1 ; shift
+    for target in $* ; do
+        params=$params,$target
+    done
+
+    tee $pipe <<EOF
+{
+  "jsonrpc": "2.0",
+  "method": "$method",
+  "params": [$params],
+  "id": `_gen_request_id`
+}
+EOF
+}
diff --git a/tests/core/CMakeLists.txt b/tests/core/CMakeLists.txt
--- a/tests/core/CMakeLists.txt
+++ b/tests/core/CMakeLists.txt
@@ -2,9 +2,11 @@
     ${LIGHTSD_SOURCE_DIR}
     ${LIGHTSD_SOURCE_DIR}/core/
     ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_SOURCE_DIR}/../lifx
     ${LIGHTSD_BINARY_DIR}
     ${LIGHTSD_BINARY_DIR}/core/
     ${CMAKE_CURRENT_BINARY_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}/../lifx
 )
 
 ADD_ALL_SUBDIRECTORIES()
diff --git a/tests/core/jsonrpc/test_jsonrpc_utils.h b/tests/core/jsonrpc/test_jsonrpc_utils.h
--- a/tests/core/jsonrpc/test_jsonrpc_utils.h
+++ b/tests/core/jsonrpc/test_jsonrpc_utils.h
@@ -1,5 +1,7 @@
 #pragma once
 
+#include "mock_gateway.h"
+
 #define TEST_REQUEST_INITIALIZER { NULL, NULL, 0, NULL }
 
 static inline int
diff --git a/tests/core/mock_client_buf.h b/tests/core/mock_client_buf.h
--- a/tests/core/mock_client_buf.h
+++ b/tests/core/mock_client_buf.h
@@ -21,3 +21,15 @@
     client_write_buf_idx += to_write;
     return 0;
 }
+
+void
+lgtd_client_write_string(struct lgtd_client *client, const char *msg)
+{
+    bufferevent_write(client->io, msg, strlen(msg));
+}
+
+void
+lgtd_client_write_buf(struct lgtd_client *client, const char *buf, int bufsz)
+{
+    bufferevent_write(client->io, buf, bufsz);
+}
diff --git a/tests/core/mock_event2.h b/tests/core/mock_event2.h
new file mode 100644
--- /dev/null
+++ b/tests/core/mock_event2.h
@@ -0,0 +1,109 @@
+#pragma once
+
+#ifndef MOCKED_EVBUFFER_DRAIN
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    (void)buf;
+    (void)len;
+    return 0;
+}
+#endif
+
+#ifndef MOCKED_EVBUFFER_NEW
+struct evbuffer *
+evbuffer_new(void)
+{
+    return NULL;
+}
+#endif
+
+#ifndef MOCKED_EVENT_FREE
+void
+evbuffer_free(struct evbuffer *buf)
+{
+    (void)buf;
+}
+#endif
+
+#ifndef MOCKED_EVBUFFER_GET_LENGTH
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    (void)buf;
+    return 0;
+}
+#endif
+
+#ifndef MOCKED_EVBUFFER_PULLUP
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    (void)buf;
+    (void)size;
+    return NULL;
+}
+#endif
+
+#ifndef MOCKED_EVBUFFER_READ
+int
+evbuffer_read(struct evbuffer *buffer, evutil_socket_t fd, int howmuch)
+{
+    (void)buffer;
+    (void)fd;
+    return howmuch;
+}
+#endif
+
+#ifndef MOCKED_EVENT_ADD
+int
+event_add(struct event *ev, const struct timeval *timeout)
+{
+    (void)ev;
+    (void)timeout;
+    return 0;
+}
+#endif
+
+#ifndef MOCKED_EVENT_DEL
+int
+event_del(struct event *ev)
+{
+    (void)ev;
+    return 0;
+}
+#endif
+
+#ifndef MOCKED_EVENT_FREE
+void
+event_free(struct event *ev)
+{
+    (void)ev;
+}
+#endif
+
+#ifndef MOCKED_EVENT_NEW
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    (void)base;
+    (void)fd;
+    (void)events;
+    (void)cb;
+    (void)ctx;
+    return NULL;
+}
+#endif
+
+#ifndef MOCKED_EVUTIL_MAKE_SOCKET_NONBLOCKING
+int
+evutil_make_socket_nonblocking(evutil_socket_t fd)
+{
+    (void)fd;
+    return 0;
+}
+#endif
diff --git a/tests/core/pipe/CMakeLists.txt b/tests/core/pipe/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/core/pipe/CMakeLists.txt
@@ -0,0 +1,26 @@
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+ADD_LIBRARY(
+    test_core_pipe STATIC
+    ${LIGHTSD_SOURCE_DIR}/core/jsmn.c
+    ${LIGHTSD_SOURCE_DIR}/core/log.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/tagging.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_utils.c
+)
+
+TARGET_LINK_LIBRARIES(test_core_pipe ${TIME_MONOTONIC_LIBRARY})
+
+FUNCTION(ADD_PIPE_TEST TEST_SOURCE)
+    ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE} test_core_pipe)
+ENDFUNCTION()
+
+FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
+FOREACH(TEST ${TESTS})
+    ADD_PIPE_TEST(${TEST})
+ENDFOREACH()
diff --git a/tests/core/pipe/test_pipe_close.c b/tests/core/pipe/test_pipe_close.c
new file mode 100644
--- /dev/null
+++ b/tests/core/pipe/test_pipe_close.c
@@ -0,0 +1,116 @@
+#include "pipe.c"
+
+#include <sys/tree.h>
+#include <endian.h>
+#include <limits.h>
+
+#include "lifx/wire_proto.h"
+
+#define MOCKED_EVENT_NEW
+#define MOCKED_EVBUFFER_NEW
+#define MOCKED_EVENT_DEL
+#define MOCKED_EVBUFFER_FREE
+#define MOCKED_EVENT_FREE
+#include "mock_event2.h"
+#include "mock_gateway.h"
+
+#include "tests_utils.h"
+#include "tests_pipe_utils.h"
+
+char *tmpdir = NULL;
+
+void
+cleanup_tmpdir(void)
+{
+    lgtd_tests_remove_temp_dir(tmpdir);
+}
+
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    (void)base;
+    (void)fd;
+    (void)events;
+    (void)cb;
+    (void)ctx;
+
+    return (void *)1;
+}
+
+struct evbuffer *
+evbuffer_new(void)
+{
+    return (void *)2;
+}
+
+static int event_del_call_count = 0;
+
+int
+event_del(struct event *ev)
+{
+    (void)ev;
+
+    event_del_call_count++;
+
+    return 0;
+}
+
+static int evbuffer_free_call_count = 0;
+
+void
+evbuffer_free(struct evbuffer *buf)
+{
+    (void)buf;
+
+    evbuffer_free_call_count++;
+}
+
+static int event_free_call_count = 0;
+
+void
+event_free(struct event *ev)
+{
+    (void)ev;
+
+    event_free_call_count++;
+}
+
+int
+main(void)
+{
+    tmpdir = lgtd_tests_make_temp_dir();
+    atexit(cleanup_tmpdir);
+
+    char path[PATH_MAX] = { 0 };
+    snprintf(path, sizeof(path), "%s/lightsd.pipe", tmpdir);
+    if (!lgtd_command_pipe_open(path)) {
+        errx(1, "couldn't open pipe");
+    }
+
+    int pipe_fd = SLIST_FIRST(&lgtd_command_pipes)->fd;
+
+    lgtd_command_pipe_close_all();
+
+    if (event_del_call_count != 1) {
+        errx(1, "event_del_call_count = %d", event_del_call_count);
+    }
+    if (evbuffer_free_call_count != 1) {
+        errx(1, "evbuffer_free_call_count = %d", evbuffer_free_call_count);
+    }
+    if (event_free_call_count != 1) {
+        errx(1, "event_free_call_count = %d", event_free_call_count);
+    }
+    struct stat sb;
+    if (fstat(pipe_fd, &sb) != -1 && errno != EBADF) {
+        errx(1, "the pipe file descriptor wasn't closed correctly");
+    }
+    if (stat(path, &sb) != -1 && errno != ENOENT) {
+        errx(1, "the pipe wasn't removed correctly");
+    }
+
+    return 0;
+}
diff --git a/tests/core/pipe/test_pipe_open.c b/tests/core/pipe/test_pipe_open.c
new file mode 100644
--- /dev/null
+++ b/tests/core/pipe/test_pipe_open.c
@@ -0,0 +1,170 @@
+#include "pipe.c"
+
+#include <sys/tree.h>
+#include <endian.h>
+#include <limits.h>
+
+#include "lifx/wire_proto.h"
+
+#define MOCKED_EVUTIL_MAKE_SOCKET_NONBLOCKING
+#define MOCKED_EVENT_NEW
+#define MOCKED_EVBUFFER_NEW
+#define MOCKED_EVENT_ADD
+#include "mock_event2.h"
+#include "mock_gateway.h"
+
+#include "tests_utils.h"
+#define MOCKED_CLIENT_OPEN_FROM_PIPE
+#include "tests_pipe_utils.h"
+
+char *tmpdir = NULL;
+
+void
+cleanup_tmpdir(void)
+{
+    lgtd_tests_remove_temp_dir(tmpdir);
+}
+
+static bool make_socket_nonblocking_call_count = 0;
+
+int 
+evutil_make_socket_nonblocking(evutil_socket_t fd)
+{
+    if (fd <= 0) {
+        errx(1, "got invalid fd %d in make_socket_nonblocking", fd);
+    }
+
+    make_socket_nonblocking_call_count++;
+
+    return 0;
+}
+
+static int event_new_call_count = 0;
+
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    if (base != lgtd_ev_base) {
+        errx(
+            1, "unexpected lgtd_ev_base = %p (expected %p)",
+            base, lgtd_ev_base
+        );
+    }
+    if (fd <= 0) {
+        errx(1, "got invalid fd %d in event_new", fd);
+    }
+    if (events != (EV_READ|EV_PERSIST)) {
+        errx(1, "got events %#x (expected %#x)", events, EV_READ|EV_PERSIST);
+    }
+    if (cb != lgtd_command_pipe_read_callback) {
+        errx(1, "the read callback wasn't set correctly");
+    }
+    if (!ctx) {
+        errx(1, "the callback context wasn't set correctly");
+    }
+
+    event_new_call_count++;
+
+    return (void *)1;
+}
+
+static int evbuffer_new_call_count = 0;
+
+struct evbuffer *
+evbuffer_new(void)
+{
+    evbuffer_new_call_count++;
+
+    return (void *)2;
+}
+
+static int event_add_call_count = 0;
+
+int
+event_add(struct event *ev, const struct timeval *timeout)
+{
+    if (ev != (void *)1) {
+        errx(1, "got unexpected event %p (expected %p)", ev, (void*)1);
+    }
+
+    if (timeout) {
+        errx(1, "a timeout shouldn't have been passed");
+    }
+
+    event_add_call_count++;
+
+    return 0;
+}
+
+static int client_open_from_pipe_call_count = 0;
+
+void
+lgtd_client_open_from_pipe(struct lgtd_client *pipe_client)
+{
+    if (!pipe_client) {
+        errx(1, "missing pipe_client");
+    }
+
+    client_open_from_pipe_call_count++;
+}
+
+int
+main(void)
+{
+    tmpdir = lgtd_tests_make_temp_dir();
+    atexit(cleanup_tmpdir);
+
+    char path[PATH_MAX] = { 0 };
+    snprintf(path, sizeof(path), "%s/lightsd.pipe", tmpdir);
+    if (!lgtd_command_pipe_open(path)) {
+        errx(1, "couldn't open pipe");
+    }
+
+    if (make_socket_nonblocking_call_count != 1) {
+        errx(
+            1, "make_socket_nonblocking_call_count = %d",
+            make_socket_nonblocking_call_count
+        );
+    }
+    if (event_new_call_count != 1) {
+        errx(1, "event_new_call_count = %d", event_new_call_count);
+    }
+    if (evbuffer_new_call_count != 1) {
+        errx(1, "evbuffer_new_call_count = %d", evbuffer_new_call_count);
+    }
+    if (event_add_call_count != 1) {
+        errx(1, "event_add_call_count = %d", event_add_call_count);
+    }
+    if (SLIST_EMPTY(&lgtd_command_pipes)) {
+        errx(1, "the list of command pipes shouldn't be empty");
+    }
+
+    struct stat sb;
+    if (stat(path, &sb)) {
+        errx(1, "can't stat pipe %s", path);
+    }
+
+    mode_t expected_mode;
+    expected_mode = S_IFIFO|S_IWUSR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IWGRP;
+    expected_mode &= ~lgtd_command_pipe_get_umask();
+    if (sb.st_mode != expected_mode) {
+        errx(
+            1, "unexpected mode %o (expected %o)",
+            sb.st_mode, expected_mode
+        );
+    }
+
+    // make sure it's idempotent:
+    if (!lgtd_command_pipe_open(path)) {
+        errx(1, "couldn't open pipe");
+    }
+    if (event_new_call_count != 1) {
+        errx(1, "event_new_call_count = %d", event_new_call_count);
+    }
+
+    return 0;
+}
diff --git a/tests/core/pipe/test_pipe_open_fifo_already_exists.c b/tests/core/pipe/test_pipe_open_fifo_already_exists.c
new file mode 100644
--- /dev/null
+++ b/tests/core/pipe/test_pipe_open_fifo_already_exists.c
@@ -0,0 +1,175 @@
+#include "pipe.c"
+
+#include <sys/tree.h>
+#include <endian.h>
+#include <limits.h>
+
+#include "lifx/wire_proto.h"
+
+#define MOCKED_EVUTIL_MAKE_SOCKET_NONBLOCKING
+#define MOCKED_EVENT_NEW
+#define MOCKED_EVBUFFER_NEW
+#define MOCKED_EVENT_ADD
+#include "mock_event2.h"
+#include "mock_gateway.h"
+
+#include "tests_utils.h"
+#define MOCKED_CLIENT_OPEN_FROM_PIPE
+#include "tests_pipe_utils.h"
+
+char *tmpdir = NULL;
+
+void
+cleanup_tmpdir(void)
+{
+    lgtd_tests_remove_temp_dir(tmpdir);
+}
+
+static bool make_socket_nonblocking_call_count = 0;
+
+int 
+evutil_make_socket_nonblocking(evutil_socket_t fd)
+{
+    if (fd <= 0) {
+        errx(1, "got invalid fd %d in make_socket_nonblocking", fd);
+    }
+
+    make_socket_nonblocking_call_count++;
+
+    return 0;
+}
+
+static int event_new_call_count = 0;
+
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    if (base != lgtd_ev_base) {
+        errx(
+            1, "unexpected lgtd_ev_base = %p (expected %p)",
+            base, lgtd_ev_base
+        );
+    }
+    if (fd <= 0) {
+        errx(1, "got invalid fd %d in event_new", fd);
+    }
+    if (events != (EV_READ|EV_PERSIST)) {
+        errx(1, "got events %#x (expected %#x)", events, EV_READ|EV_PERSIST);
+    }
+    if (cb != lgtd_command_pipe_read_callback) {
+        errx(1, "the read callback wasn't set correctly");
+    }
+    if (!ctx) {
+        errx(1, "the callback context wasn't set correctly");
+    }
+
+    event_new_call_count++;
+
+    return (void *)1;
+}
+
+static int evbuffer_new_call_count = 0;
+
+struct evbuffer *
+evbuffer_new(void)
+{
+    evbuffer_new_call_count++;
+
+    return (void *)2;
+}
+
+static int event_add_call_count = 0;
+
+int
+event_add(struct event *ev, const struct timeval *timeout)
+{
+    if (ev != (void *)1) {
+        errx(1, "got unexpected event %p (expected %p)", ev, (void*)1);
+    }
+
+    if (timeout) {
+        errx(1, "a timeout shouldn't have been passed");
+    }
+
+    event_add_call_count++;
+
+    return 0;
+}
+
+static int client_open_from_pipe_call_count = 0;
+
+void
+lgtd_client_open_from_pipe(struct lgtd_client *pipe_client)
+{
+    if (!pipe_client) {
+        errx(1, "missing pipe_client");
+    }
+
+    client_open_from_pipe_call_count++;
+}
+
+int
+main(void)
+{
+    tmpdir = lgtd_tests_make_temp_dir();
+    atexit(cleanup_tmpdir);
+
+    char path[PATH_MAX] = { 0 };
+    snprintf(path, sizeof(path), "%s/lightsd.pipe", tmpdir);
+
+    if (mkfifo(path, 0)) {
+        errx(1, "can't open fifo");
+    }
+
+    if (!lgtd_command_pipe_open(path)) {
+        errx(1, "couldn't open pipe");
+    }
+
+    if (make_socket_nonblocking_call_count != 1) {
+        errx(
+            1, "make_socket_nonblocking_call_count = %d",
+            make_socket_nonblocking_call_count
+        );
+    }
+    if (event_new_call_count != 1) {
+        errx(1, "event_new_call_count = %d", event_new_call_count);
+    }
+    if (evbuffer_new_call_count != 1) {
+        errx(1, "evbuffer_new_call_count = %d", evbuffer_new_call_count);
+    }
+    if (event_add_call_count != 1) {
+        errx(1, "event_add_call_count = %d", event_add_call_count);
+    }
+    if (SLIST_EMPTY(&lgtd_command_pipes)) {
+        errx(1, "the list of command pipes shouldn't be empty");
+    }
+
+    struct stat sb;
+    if (stat(path, &sb)) {
+        errx(1, "can't stat pipe %s", path);
+    }
+
+    mode_t expected_mode;
+    expected_mode = S_IFIFO|S_IWUSR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IWGRP;
+    expected_mode &= ~lgtd_command_pipe_get_umask();
+    if (sb.st_mode != expected_mode) {
+        errx(
+            1, "unexpected mode %o (expected %o)",
+            sb.st_mode, expected_mode
+        );
+    }
+
+    // make sure it's idempotent:
+    if (!lgtd_command_pipe_open(path)) {
+        errx(1, "couldn't open pipe");
+    }
+    if (event_new_call_count != 1) {
+        errx(1, "event_new_call_count = %d", event_new_call_count);
+    }
+
+    return 0;
+}
diff --git a/tests/core/pipe/test_pipe_read_callback.c b/tests/core/pipe/test_pipe_read_callback.c
new file mode 100644
--- /dev/null
+++ b/tests/core/pipe/test_pipe_read_callback.c
@@ -0,0 +1,191 @@
+#include "pipe.c"
+
+#include <sys/tree.h>
+#include <endian.h>
+#include <limits.h>
+
+#include "lifx/wire_proto.h"
+
+#define MOCKED_EVENT_NEW
+#define MOCKED_EVBUFFER_NEW
+#define MOCKED_EVBUFFER_READ
+#define MOCKED_EVBUFFER_PULLUP
+#define MOCKED_EVBUFFER_GET_LENGTH
+#define MOCKED_EVBUFFER_DRAIN
+#include "mock_event2.h"
+#include "mock_gateway.h"
+
+#include "tests_utils.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "tests_pipe_utils.h"
+
+static unsigned char request[] = ("{"
+    "\"jsonrpc\": \"2.0\","
+    "\"method\": \"get_light_state\","
+    "\"params\": [\"*\"],"
+    "\"id\": 42"
+"}");
+
+static char *tmpdir = NULL;
+
+void
+cleanup_tmpdir(void)
+{
+    lgtd_tests_remove_temp_dir(tmpdir);
+}
+
+static int jsonrpc_dispatch_request_call_count = 0;
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+
+    if (!parsed) {
+        errx(1, "number of parsed json tokens not passed in");
+    }
+
+    if (memcmp(client->json, request, sizeof(request))) {
+        errx(1, "got unexpected json");
+    }
+
+    jsonrpc_dispatch_request_call_count++;
+}
+
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    (void)base;
+    (void)fd;
+    (void)events;
+    (void)cb;
+    (void)ctx;
+
+    return (void *)1;
+}
+
+static int
+get_nbytes_read(int call_count)
+{
+    switch (call_count) {
+    case 0:
+        return sizeof(request) - 1; // we don't return the '\0'
+    default:
+        return 0;
+    }
+}
+
+struct evbuffer *
+evbuffer_new(void)
+{
+    return (void *)2;
+}
+
+static int evbuffer_drain_call_count = 0;
+
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    jsmn_parser jsmn_ctx;
+    jsmn_init(&jsmn_ctx);
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
+        errx(1, "the client json parser context wasn't re-initialized");
+    }
+
+
+    switch (evbuffer_drain_call_count) {
+    case 0:
+        if (len != sizeof(request) - 1) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)sizeof(request) - 1
+            );
+        }
+        break;
+    default:
+        break;
+    }
+    evbuffer_drain_call_count++;
+
+    return 0;
+}
+
+static int evbuffer_pullup_call_count = 0;
+
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    if (size != -1) {
+        errx(1, "got unexpected size %ld in pullup (expected -1)", size);
+    }
+
+    return &request[evbuffer_pullup_call_count++ ? sizeof(request) - 1 : 0];
+}
+
+static int evbuffer_get_length_call_count = 0;
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    return get_nbytes_read(evbuffer_get_length_call_count++);
+}
+
+static int evbuffer_read_call_count = 0;
+
+int
+evbuffer_read(struct evbuffer *buf, evutil_socket_t fd, int howmuch)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (fd != pipe->fd) {
+        errx(1, "got unexpected fd %d (expected %d)", fd, pipe->fd);
+    }
+
+    if (howmuch != -1) {
+        errx(
+            1, "got unexpected howmuch bytes to read %d (expected -1)", howmuch
+        );
+    }
+
+    return get_nbytes_read(evbuffer_read_call_count++);
+}
+
+int
+main(void)
+{
+    tmpdir = lgtd_tests_make_temp_dir();
+    atexit(cleanup_tmpdir);
+
+    char path[PATH_MAX] = { 0 };
+    snprintf(path, sizeof(path), "%s/lightsd.pipe", tmpdir);
+    if (!lgtd_command_pipe_open(path)) {
+        errx(1, "couldn't open pipe");
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+
+    lgtd_command_pipe_read_callback(pipe->fd, EV_READ, pipe);
+
+    return 0;
+}
diff --git a/tests/core/pipe/test_pipe_read_callback_extra_data.c b/tests/core/pipe/test_pipe_read_callback_extra_data.c
new file mode 100644
--- /dev/null
+++ b/tests/core/pipe/test_pipe_read_callback_extra_data.c
@@ -0,0 +1,218 @@
+#include "pipe.c"
+
+#include <sys/tree.h>
+#include <endian.h>
+#include <limits.h>
+
+#include "lifx/wire_proto.h"
+
+#define MOCKED_EVENT_NEW
+#define MOCKED_EVBUFFER_NEW
+#define MOCKED_EVBUFFER_READ
+#define MOCKED_EVBUFFER_PULLUP
+#define MOCKED_EVBUFFER_GET_LENGTH
+#define MOCKED_EVBUFFER_DRAIN
+#include "mock_event2.h"
+#include "mock_gateway.h"
+
+#include "tests_utils.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "tests_pipe_utils.h"
+
+#define REQUEST_1 "{"                   \
+    "\"jsonrpc\": \"2.0\","             \
+    "\"method\": \"get_light_state\","  \
+    "\"params\": [\"*\"],"              \
+    "\"id\": 42"                        \
+"}"
+#define EXTRA_DATA "BLUBLBULBUBUHIFESHFUSsoundsaboutright" 
+
+static unsigned char request[] = (
+    REQUEST_1
+    EXTRA_DATA
+);
+
+static char *tmpdir = NULL;
+
+void
+cleanup_tmpdir(void)
+{
+    lgtd_tests_remove_temp_dir(tmpdir);
+}
+
+static int jsonrpc_dispatch_request_call_count = 0;
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+
+    if (!parsed) {
+        errx(1, "number of parsed json tokens not passed in");
+    }
+
+    if (memcmp(client->json, request, sizeof(request))) {
+        errx(1, "got unexpected json");
+    }
+
+    jsonrpc_dispatch_request_call_count++;
+}
+
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    (void)base;
+    (void)fd;
+    (void)events;
+    (void)cb;
+    (void)ctx;
+
+    return (void *)1;
+}
+
+static int
+get_nbytes_read(int call_count)
+{
+    switch (call_count) {
+    case 0:
+        return sizeof(request) - 1; // we don't return the '\0'
+    default:
+        return 0;
+    }
+}
+
+struct evbuffer *
+evbuffer_new(void)
+{
+    return (void *)2;
+}
+
+static int evbuffer_drain_call_count = 0;
+
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    jsmn_parser jsmn_ctx;
+    jsmn_init(&jsmn_ctx);
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
+        errx(1, "the client json parser context wasn't re-initialized");
+    }
+
+    switch (evbuffer_drain_call_count) {
+    case 0:
+        if (len != sizeof(REQUEST_1) - 1) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)sizeof(request) - 1
+            );
+        }
+        break;
+    case 1:
+        if (len != sizeof(request) - sizeof(REQUEST_1)) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, sizeof(request) - sizeof(REQUEST_1)
+            );
+        }
+        break;
+    default:
+        break;
+    }
+    evbuffer_drain_call_count++;
+
+    return 0;
+}
+
+static int evbuffer_pullup_call_count = 0;
+
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    if (size != -1) {
+        errx(1, "got unexpected size %ld in pullup (expected -1)", size);
+    }
+
+    return &request[evbuffer_pullup_call_count++ ? sizeof(request) - 1 : 0];
+}
+
+static int evbuffer_get_length_call_count = 0;
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    size_t len;
+    switch (evbuffer_get_length_call_count) {
+    case 0:
+        len = sizeof(request) - 1;
+        break;
+    case 1:
+        len = sizeof(request) - sizeof(REQUEST_1);
+        break;
+    default:
+        len = 0;
+        break;
+    }
+    evbuffer_get_length_call_count++;
+
+    return len;
+}
+
+static int evbuffer_read_call_count = 0;
+
+int
+evbuffer_read(struct evbuffer *buf, evutil_socket_t fd, int howmuch)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (fd != pipe->fd) {
+        errx(1, "got unexpected fd %d (expected %d)", fd, pipe->fd);
+    }
+
+    if (howmuch != -1) {
+        errx(
+            1, "got unexpected howmuch bytes to read %d (expected -1)", howmuch
+        );
+    }
+
+    return get_nbytes_read(evbuffer_read_call_count++);
+}
+
+int
+main(void)
+{
+    tmpdir = lgtd_tests_make_temp_dir();
+    atexit(cleanup_tmpdir);
+
+    char path[PATH_MAX] = { 0 };
+    snprintf(path, sizeof(path), "%s/lightsd.pipe", tmpdir);
+    if (!lgtd_command_pipe_open(path)) {
+        errx(1, "couldn't open pipe");
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+
+    lgtd_command_pipe_read_callback(pipe->fd, EV_READ, pipe);
+
+    return 0;
+}
diff --git a/tests/core/pipe/test_pipe_read_callback_multiple_requests.c b/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
new file mode 100644
--- /dev/null
+++ b/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
@@ -0,0 +1,258 @@
+#include "pipe.c"
+
+#include <sys/tree.h>
+#include <endian.h>
+#include <limits.h>
+
+#include "lifx/wire_proto.h"
+
+#define MOCKED_EVENT_NEW
+#define MOCKED_EVBUFFER_NEW
+#define MOCKED_EVBUFFER_READ
+#define MOCKED_EVBUFFER_PULLUP
+#define MOCKED_EVBUFFER_GET_LENGTH
+#define MOCKED_EVBUFFER_DRAIN
+#include "mock_event2.h"
+#include "mock_gateway.h"
+
+#include "tests_utils.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "tests_pipe_utils.h"
+
+#define REQUEST_1 "{"                   \
+    "\"jsonrpc\": \"2.0\","             \
+    "\"method\": \"get_light_state\","  \
+    "\"params\": [\"*\"],"              \
+    "\"id\": 42"                        \
+"}"
+
+#define REQUEST_2 "{"           \
+    "\"jsonrpc\": \"2.0\","     \
+    "\"method\": \"power_on\"," \
+    "\"params\": [\"*\"],"      \
+    "\"id\": 43"                \
+"}"
+
+static unsigned char request[] = (
+    REQUEST_1
+    REQUEST_2
+);
+
+static char *tmpdir = NULL;
+
+void
+cleanup_tmpdir(void)
+{
+    lgtd_tests_remove_temp_dir(tmpdir);
+}
+
+static int jsonrpc_dispatch_request_call_count = 0;
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+
+    if (!parsed) {
+        errx(1, "number of parsed json tokens not passed in");
+    }
+
+    switch (jsonrpc_dispatch_request_call_count) {
+    case 0:
+        if (memcmp(client->json, request, sizeof(request) - 1)) {
+            errx(
+                1, "got unexpected json %s (expected %s)",
+                client->json, request
+            );
+        }
+        break;
+    case 1:
+        if (memcmp(client->json, REQUEST_2, sizeof(REQUEST_2) - 1)) {
+            errx(
+                1, "got unexpected json %s (expected %s)",
+                client->json, REQUEST_2
+            );
+        }
+        break;
+    default:
+        errx(
+            1, "jsonrpc_dispatch_request_call_count = %d",
+            jsonrpc_dispatch_request_call_count
+        );
+        break;
+    }
+
+    jsonrpc_dispatch_request_call_count++;
+}
+
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    (void)base;
+    (void)fd;
+    (void)events;
+    (void)cb;
+    (void)ctx;
+
+    return (void *)1;
+}
+
+struct evbuffer *
+evbuffer_new(void)
+{
+    return (void *)2;
+}
+
+static int evbuffer_drain_call_count = 0;
+
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    jsmn_parser jsmn_ctx;
+    jsmn_init(&jsmn_ctx);
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
+        errx(1, "the client json parser context wasn't re-initialized");
+    }
+
+    switch (evbuffer_drain_call_count) {
+    case 0:
+        if (len != sizeof(REQUEST_1) - 1) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)sizeof(REQUEST_1) - 1
+            );
+        }
+        break;
+    case 1:
+        if (len != sizeof(REQUEST_2) - 1) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)sizeof(REQUEST_2) - 1
+            );
+        }
+        break;
+    default:
+        errx(1, "evbuffer_drain_call_count = %d", evbuffer_drain_call_count);
+        break;
+    }
+    evbuffer_drain_call_count++;
+
+    return 0;
+}
+
+static int evbuffer_pullup_call_count = 0;
+
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    if (size != -1) {
+        errx(1, "got unexpected size %ld in pullup (expected -1)", size);
+    }
+
+    int offset;
+    switch (evbuffer_pullup_call_count) {
+    case 0:
+        offset = 0;
+        break;
+    case 1:
+        offset = sizeof(REQUEST_1) - 1;
+        break;
+    default:
+        offset = sizeof(request);
+        break;
+    }
+    evbuffer_pullup_call_count++;
+
+    return &request[offset];
+}
+
+static int evbuffer_get_length_call_count = 0;
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    size_t len;
+    switch (evbuffer_get_length_call_count) {
+    case 0:
+        len = sizeof(request) - 1;
+        break;
+    case 1:
+        len = sizeof(request) - sizeof(REQUEST_1);
+        break;
+    default:
+        len = 0;
+        break;
+    }
+    evbuffer_get_length_call_count++;
+
+    return len;
+}
+
+static int evbuffer_read_call_count = 0;
+
+int
+evbuffer_read(struct evbuffer *buf, evutil_socket_t fd, int howmuch)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (fd != pipe->fd) {
+        errx(1, "got unexpected fd %d (expected %d)", fd, pipe->fd);
+    }
+
+    if (howmuch != -1) {
+        errx(
+            1, "got unexpected howmuch bytes to read %d (expected -1)", howmuch
+        );
+    }
+
+    int rv = 0;
+    switch (evbuffer_read_call_count) {
+    case 0:
+        rv = sizeof(request) - 1;
+    default:
+        break;
+    }
+    evbuffer_read_call_count++;
+
+    return rv;
+}
+
+int
+main(void)
+{
+    tmpdir = lgtd_tests_make_temp_dir();
+    atexit(cleanup_tmpdir);
+
+    char path[PATH_MAX] = { 0 };
+    snprintf(path, sizeof(path), "%s/lightsd.pipe", tmpdir);
+    if (!lgtd_command_pipe_open(path)) {
+        errx(1, "couldn't open pipe");
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+
+    lgtd_command_pipe_read_callback(pipe->fd, EV_READ, pipe);
+
+    return 0;
+}
diff --git a/tests/core/pipe/tests_pipe_utils.h b/tests/core/pipe/tests_pipe_utils.h
new file mode 100644
--- /dev/null
+++ b/tests/core/pipe/tests_pipe_utils.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#ifndef MOCKED_CLIENT_OPEN_FROM_PIPE
+void
+lgtd_client_open_from_pipe(struct lgtd_client *pipe_client)
+{
+    memset(pipe_client, 0, sizeof(*pipe_client));
+    jsmn_init(&pipe_client->jsmn_ctx);
+}
+#endif
+
+#ifndef MOCKED_JSONRPC_DISPATCH_REQUEST
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+}
+#endif
diff --git a/tests/core/proto/CMakeLists.txt b/tests/core/proto/CMakeLists.txt
--- a/tests/core/proto/CMakeLists.txt
+++ b/tests/core/proto/CMakeLists.txt
@@ -8,6 +8,7 @@
     ${LIGHTSD_SOURCE_DIR}/core/log.c
     ${LIGHTSD_SOURCE_DIR}/core/jsonrpc.c
     ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/tagging.c
     ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
     ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
@@ -15,11 +16,11 @@
 )
 TARGET_LINK_LIBRARIES(test_core_proto ${TIME_MONOTONIC_LIBRARY})
 
-FUNCTION(ADD_ROUTER_TEST TEST_SOURCE)
+FUNCTION(ADD_PROTO_TEST TEST_SOURCE)
     ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE} test_core_proto)
 ENDFUNCTION()
 
 FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
 FOREACH(TEST ${TESTS})
-    ADD_ROUTER_TEST(${TEST})
+    ADD_PROTO_TEST(${TEST})
 ENDFOREACH()
diff --git a/tests/core/proto/test_proto_get_light_state.c b/tests/core/proto/test_proto_get_light_state.c
--- a/tests/core/proto/test_proto_get_light_state.c
+++ b/tests/core/proto/test_proto_get_light_state.c
@@ -29,6 +29,9 @@
     static struct lgtd_router_device_list devices =
         SLIST_HEAD_INITIALIZER(&devices);
 
+    static struct lgtd_lifx_gateway gw_bulb_1 = {
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_1.bulbs)
+    };
     static struct lgtd_lifx_bulb bulb_1 = {
         .addr = { 1, 2, 3, 4, 5 },
         .state = {
@@ -39,7 +42,8 @@
             .label = "wave",
             .power = LGTD_LIFX_POWER_ON,
             .tags = 0
-        }
+        },
+        .gw = &gw_bulb_1
     };
     static struct lgtd_router_device device_1 = { .device = &bulb_1 };
     SLIST_INSERT_HEAD(&devices, &device_1, link);
@@ -76,7 +80,7 @@
 int
 main(void)
 {
-    struct lgtd_client client;
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
     struct lgtd_proto_target_list *targets = (void *)0x2a;
 
     lgtd_proto_get_light_state(&client, targets);
@@ -103,7 +107,7 @@
             1,
             "%d bytes written, expected %lu "
             "(got %.*s instead of %s)",
-            client_write_buf_idx, sizeof(expected) - 1,
+            client_write_buf_idx, sizeof(expected) - 1UL,
             client_write_buf_idx, client_write_buf, expected
         );
     }
diff --git a/tests/core/proto/test_proto_get_light_state_empty_device_list.c b/tests/core/proto/test_proto_get_light_state_empty_device_list.c
--- a/tests/core/proto/test_proto_get_light_state_empty_device_list.c
+++ b/tests/core/proto/test_proto_get_light_state_empty_device_list.c
@@ -35,7 +35,7 @@
 int
 main(void)
 {
-    struct lgtd_client client;
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
     struct lgtd_proto_target_list *targets = (void *)0x2a;
 
     lgtd_proto_get_light_state(&client, targets);
@@ -45,7 +45,7 @@
     if (client_write_buf_idx != sizeof(expected) - 1) {
         lgtd_errx(
             1, "%d bytes written, expected %lu",
-            client_write_buf_idx, sizeof(expected) - 1
+            client_write_buf_idx, sizeof(expected) - 1UL
         );
     }
 
diff --git a/tests/core/proto/test_proto_get_light_state_null_device_list.c b/tests/core/proto/test_proto_get_light_state_null_device_list.c
--- a/tests/core/proto/test_proto_get_light_state_null_device_list.c
+++ b/tests/core/proto/test_proto_get_light_state_null_device_list.c
@@ -45,7 +45,7 @@
 int
 main(void)
 {
-    struct lgtd_client client;
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
     struct lgtd_proto_target_list *targets = (void *)0x2a;
 
     lgtd_proto_get_light_state(&client, targets);
diff --git a/tests/core/proto/test_proto_power_off.c b/tests/core/proto/test_proto_power_off.c
--- a/tests/core/proto/test_proto_power_off.c
+++ b/tests/core/proto/test_proto_power_off.c
@@ -52,7 +52,7 @@
     struct lgtd_proto_target_list *targets;
     targets = lgtd_tests_build_target_list("*", NULL);
 
-    struct lgtd_client client;
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
 
     lgtd_proto_power_off(&client, targets);
 
diff --git a/tests/core/proto/test_proto_power_off_routing_error.c b/tests/core/proto/test_proto_power_off_routing_error.c
--- a/tests/core/proto/test_proto_power_off_routing_error.c
+++ b/tests/core/proto/test_proto_power_off_routing_error.c
@@ -52,7 +52,7 @@
     struct lgtd_proto_target_list *targets;
     targets = lgtd_tests_build_target_list("*", NULL);
 
-    struct lgtd_client client;
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
 
     lgtd_proto_power_off(&client, targets);
 
diff --git a/tests/core/proto/test_proto_power_on.c b/tests/core/proto/test_proto_power_on.c
--- a/tests/core/proto/test_proto_power_on.c
+++ b/tests/core/proto/test_proto_power_on.c
@@ -52,7 +52,7 @@
     struct lgtd_proto_target_list *targets;
     targets = lgtd_tests_build_target_list("*", NULL);
 
-    struct lgtd_client client;
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
 
     lgtd_proto_power_on(&client, targets);
 
diff --git a/tests/core/proto/test_proto_power_on_routing_error.c b/tests/core/proto/test_proto_power_on_routing_error.c
--- a/tests/core/proto/test_proto_power_on_routing_error.c
+++ b/tests/core/proto/test_proto_power_on_routing_error.c
@@ -52,7 +52,7 @@
     struct lgtd_proto_target_list *targets;
     targets = lgtd_tests_build_target_list("*", NULL);
 
-    struct lgtd_client client;
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
 
     lgtd_proto_power_on(&client, targets);
 
diff --git a/tests/core/proto/tests_proto_utils.h b/tests/core/proto/tests_proto_utils.h
--- a/tests/core/proto/tests_proto_utils.h
+++ b/tests/core/proto/tests_proto_utils.h
@@ -1,5 +1,9 @@
 #pragma once
 
+#include "mock_gateway.h"
+
+#define FAKE_BUFFEREVENT (void *)0xfeed
+
 void
 lgtd_client_start_send_response(struct lgtd_client *client)
 {
@@ -16,7 +20,7 @@
 void
 lgtd_client_send_response(struct lgtd_client *client, const char *msg)
 {
-    LGTD_CLIENT_WRITE_STRING(client, msg);
+    lgtd_client_write_string(client, msg);
 }
 #endif
 
diff --git a/tests/core/router/CMakeLists.txt b/tests/core/router/CMakeLists.txt
--- a/tests/core/router/CMakeLists.txt
+++ b/tests/core/router/CMakeLists.txt
@@ -8,6 +8,7 @@
     ${LIGHTSD_SOURCE_DIR}/core/log.c
     ${LIGHTSD_SOURCE_DIR}/core/proto.c
     ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/tagging.c
     ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
     ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
diff --git a/tests/core/router/tests_router_utils.h b/tests/core/router/tests_router_utils.h
--- a/tests/core/router/tests_router_utils.h
+++ b/tests/core/router/tests_router_utils.h
@@ -1,5 +1,7 @@
 #pragma once
 
+#include "mock_gateway.h"
+
 int lgtd_tests_gw_pkt_queue_size = 0;
 struct {
     struct lgtd_lifx_gateway        *gw;
diff --git a/tests/core/tests_shims.c b/tests/core/tests_shims.c
--- a/tests/core/tests_shims.c
+++ b/tests/core/tests_shims.c
@@ -30,52 +30,3 @@
 lgtd_cleanup(void)
 {
 }
-
-
-void lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *gw,
-                                          const struct lgtd_lifx_packet_header *hdr,
-                                          const struct lgtd_lifx_packet_pan_gateway *pkt)
-{
-    (void)gw;
-    (void)hdr;
-    (void)pkt;
-}
-
-void lgtd_lifx_gateway_handle_light_status(struct lgtd_lifx_gateway *gw,
-                                           const struct lgtd_lifx_packet_header *hdr,
-                                           const struct lgtd_lifx_packet_light_status *pkt)
-{
-    (void)gw;
-    (void)hdr;
-    (void)pkt;
-}
-
-void lgtd_lifx_gateway_handle_power_state(struct lgtd_lifx_gateway *gw,
-                                          const struct lgtd_lifx_packet_header *hdr,
-                                          const struct lgtd_lifx_packet_power_state *pkt)
-{
-    (void)gw;
-    (void)hdr;
-    (void)pkt;
-}
-
-void lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *gw,
-                                         const struct lgtd_lifx_packet_header *hdr,
-                                         const struct lgtd_lifx_packet_tag_labels *pkt)
-{
-    (void)gw;
-    (void)hdr;
-    (void)pkt;
-}
-
-struct lgtd_lifx_tag *
-lgtd_lifx_tagging_find_tag(const char *tag_label)
-{
-    struct lgtd_lifx_tag *tag = NULL;
-    LIST_FOREACH(tag, &lgtd_lifx_tags, link) {
-        if (!strcmp(tag->label, tag_label)) {
-            break;
-        }
-    }
-    return tag;
-}
diff --git a/tests/core/tests_utils.c b/tests/core/tests_utils.c
--- a/tests/core/tests_utils.c
+++ b/tests/core/tests_utils.c
@@ -2,13 +2,18 @@
 #include <sys/tree.h>
 #include <sys/socket.h>
 #include <assert.h>
+#include <dirent.h>
 #include <endian.h>
+#include <err.h>
+#include <limits.h>
 #include <netinet/in.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stdlib.h>
 #include <stdint.h>
+#include <stdio.h>
 #include <string.h>
+#include <unistd.h>
 
 #include <event2/util.h>
 
@@ -26,9 +31,6 @@
 struct lgtd_lifx_gateway_list lgtd_lifx_gateways =
     LIST_HEAD_INITIALIZER(&lgtd_lifx_gateways);
 
-struct lgtd_lifx_tag_list lgtd_lifx_tags =
-    LIST_HEAD_INITIALIZER(&lgtd_lifx_tags);
-
 struct lgtd_lifx_gateway *
 lgtd_tests_insert_mock_gateway(int id)
 {
@@ -112,3 +114,42 @@
     LIST_INSERT_HEAD(&tag->sites, site, link);
     return site;
 }
+
+char *
+lgtd_tests_make_temp_dir(void)
+{
+    char buf[PATH_MAX] = { 0 };
+    int n = snprintf(buf, sizeof(buf), "%s/lightsd.test.XXXXXXXX", P_tmpdir);
+    if (n >= (int)sizeof(buf)) {
+        errx(1, "cannot allocate temporary directory");
+    }
+    return strdup(mkdtemp(buf));
+}
+
+void
+lgtd_tests_remove_temp_dir(char *path)
+{
+    DIR *tmpdir = opendir(path);
+    if (!tmpdir) {
+        return;
+    }
+
+    struct dirent db;
+    struct dirent *entry = &db;
+    while (!readdir_r(tmpdir, entry, &entry) && entry) {
+        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, "..")) {
+            continue;
+        }
+        char buf[PATH_MAX] = { 0 };
+        snprintf(buf, sizeof(buf), "%s/%s", path, entry->d_name);
+        unlink(buf);
+    }
+
+    closedir(tmpdir);
+
+    if (rmdir(path)) {
+        warn("couldn't remove tempdir %s", path);
+    }
+
+    free(path);
+}
diff --git a/tests/core/tests_utils.h b/tests/core/tests_utils.h
--- a/tests/core/tests_utils.h
+++ b/tests/core/tests_utils.h
@@ -30,6 +30,9 @@
     return true;
 }
 
+char *lgtd_tests_make_temp_dir(void);
+void lgtd_tests_remove_temp_dir(char *);
+
 struct lgtd_lifx_gateway *lgtd_tests_insert_mock_gateway(int);
 struct lgtd_lifx_bulb *lgtd_tests_insert_mock_bulb(struct lgtd_lifx_gateway *, uint64_t);
 struct lgtd_proto_target_list *lgtd_tests_build_target_list(const char *, ...);
diff --git a/tests/lifx/mock_gateway.h b/tests/lifx/mock_gateway.h
new file mode 100644
--- /dev/null
+++ b/tests/lifx/mock_gateway.h
@@ -0,0 +1,119 @@
+#pragma once
+
+#include "core/time_monotonic.h"
+#include "lifx/bulb.h"
+#include "lifx/gateway.h"
+
+struct lgtd_lifx_tag;
+struct lgtd_lifx_gateway;
+
+#ifndef MOCKED_LIFX_GATEWAY_SEND_TO_SITE
+bool
+lgtd_lifx_gateway_send_to_site(struct lgtd_lifx_gateway *gw,
+                               enum lgtd_lifx_packet_type pkt_type,
+                               const void *pkt)
+{
+    (void)gw;
+    (void)pkt_type;
+    (void)pkt;
+    return false;
+}
+#endif
+
+#ifndef MOCKED_LIFX_GATEWAY_ALLOCATE_TAG_ID
+int
+lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *gw,
+                                  int tag_id,
+                                  const char *tag_label)
+{
+    (void)gw;
+    (void)tag_id;
+    (void)tag_label;
+    return -1;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_HANDLE_PAN_GATEWAY
+void
+lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *gw,
+                                     const struct lgtd_lifx_packet_header *hdr,
+                                     const struct lgtd_lifx_packet_pan_gateway *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_HANDLE_LIGHT_STATUS
+void
+lgtd_lifx_gateway_handle_light_status(struct lgtd_lifx_gateway *gw,
+                                      const struct lgtd_lifx_packet_header *hdr,
+                                      const struct lgtd_lifx_packet_light_status *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_HANDLE_POWER_STATE
+void
+lgtd_lifx_gateway_handle_power_state(struct lgtd_lifx_gateway *gw,
+                                     const struct lgtd_lifx_packet_header *hdr,
+                                     const struct lgtd_lifx_packet_power_state *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_HANDLE_TAG_LABELS
+void
+lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *gw,
+                                    const struct lgtd_lifx_packet_header *hdr,
+                                    const struct lgtd_lifx_packet_tag_labels *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_DEALLOCATE_TAG_ID
+void
+lgtd_lifx_gateway_deallocate_tag_id(struct lgtd_lifx_gateway *gw, int tag_id)
+{
+    (void)gw;
+    (void)tag_id;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_GET_TAG_ID
+int
+lgtd_lifx_gateway_get_tag_id(const struct lgtd_lifx_gateway *gw,
+                             const struct lgtd_lifx_tag *tag)
+{
+    int tag_id;
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, gw->tag_ids) {
+        if (gw->tags[tag_id] == tag) {
+            return tag_id;
+        }
+    }
+
+    return -1;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_UPDATE_TAG_REFCOUNTS
+void
+lgtd_lifx_gateway_update_tag_refcounts(struct lgtd_lifx_gateway *gw,
+                                       uint64_t bulb_tags,
+                                       uint64_t pkt_tags)
+{
+    (void)gw;
+    (void)bulb_tags;
+    (void)pkt_tags;
+}
+#endif
