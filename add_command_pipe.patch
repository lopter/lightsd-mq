# HG changeset patch
# Parent  0ded0e4a2bc8e4eb6d24e3f7f86ee6adf8b4c7e1
Add a command pipe to easily do actions from a shell

NOTE: the command pipe is write only, responses aren't returned.

diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -20,6 +20,7 @@
     listen.c
     lightsd.c
     log.c
+    pipe.c
     proto.c
     router.c
     stats.c
diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -23,6 +23,7 @@
 #include <stdbool.h>
 #include <stdlib.h>
 #include <stdint.h>
+#include <string.h>
 
 #include <event2/buffer.h>
 #include <event2/bufferevent.h>
@@ -138,6 +139,29 @@
 }
 
 void
+lgtd_client_write_string(struct lgtd_client *client, const char *msg)
+{
+    assert(client);
+    assert(msg);
+
+    if (client->io) {
+        bufferevent_write(client->io, msg, strlen(msg));
+    }
+}
+
+void
+lgtd_client_write_buf(struct lgtd_client *client, const char *buf, int bufsz)
+{
+    assert(client);
+    assert(buf);
+    assert(bufsz >= 0);
+
+    if (bufsz > 0 && client->io) {
+        bufferevent_write(client->io, buf, bufsz);
+    }
+}
+
+void
 lgtd_client_send_response(struct lgtd_client *client, const char *msg)
 {
     lgtd_jsonrpc_send_response(client, msg);
@@ -195,3 +219,13 @@
 
     return client;
 }
+
+void
+lgtd_client_open_from_pipe(struct lgtd_client *pipe_client)
+{
+    assert(pipe_client);
+
+    memset(pipe_client, 0, sizeof(*pipe_client));
+
+    jsmn_init(&pipe_client->jsmn_ctx);
+}
diff --git a/core/client.h b/core/client.h
--- a/core/client.h
+++ b/core/client.h
@@ -42,13 +42,12 @@
 };
 LIST_HEAD(lgtd_client_list, lgtd_client);
 
-#define LGTD_CLIENT_WRITE_STRING(client, s) do {        \
-    bufferevent_write((client)->io, s, strlen((s)));    \
-} while(0)
-
 struct lgtd_client *lgtd_client_open(evutil_socket_t, const struct sockaddr_storage *);
+void lgtd_client_open_from_pipe(struct lgtd_client *);
 void lgtd_client_close_all(void);
 
+void lgtd_client_write_string(struct lgtd_client *, const char *);
+void lgtd_client_write_buf(struct lgtd_client *, const char *, int);
 void lgtd_client_send_response(struct lgtd_client *, const char *);
 void lgtd_client_start_send_response(struct lgtd_client *);
 void lgtd_client_end_send_response(struct lgtd_client *);
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -129,7 +129,7 @@
     return c == '-' || (c >= '0' && c <= '9');
 }
 
-static bool __attribute__((unused))
+static bool
 lgtd_jsonrpc_type_bool(const jsmntok_t *t, const char *json)
 {
     if (t->type != JSMN_PRIMITIVE) {
@@ -480,7 +480,7 @@
 lgtd_jsonrpc_write_id(struct lgtd_client *client)
 {
     if (!client->current_request->id) {
-        LGTD_CLIENT_WRITE_STRING(client, "null");
+        lgtd_client_write_string(client, "null");
         return;
     }
 
@@ -492,7 +492,7 @@
         start = client->current_request->id->start;
         stop = client->current_request->id->end;
     }
-    bufferevent_write(client->io, &client->json[start], stop - start);
+    lgtd_client_write_buf(client, &client->json[start], stop - start);
 }
 
 void
@@ -503,15 +503,15 @@
     assert(client);
     assert(message);
 
-    LGTD_CLIENT_WRITE_STRING(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
+    lgtd_client_write_string(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
     lgtd_jsonrpc_write_id(client);
-    LGTD_CLIENT_WRITE_STRING(client, ", \"error\": {\"code\": ");
+    lgtd_client_write_string(client, ", \"error\": {\"code\": ");
     char str_code[8] = { 0 };
     snprintf(str_code, sizeof(str_code), "%d", code);
-    LGTD_CLIENT_WRITE_STRING(client, str_code);
-    LGTD_CLIENT_WRITE_STRING(client, ", \"message\": \"");
-    LGTD_CLIENT_WRITE_STRING(client, message);
-    LGTD_CLIENT_WRITE_STRING(client, "\"}}");
+    lgtd_client_write_string(client, str_code);
+    lgtd_client_write_string(client, ", \"message\": \"");
+    lgtd_client_write_string(client, message);
+    lgtd_client_write_string(client, "\"}}");
 }
 
 void
@@ -521,11 +521,11 @@
     assert(client);
     assert(result);
 
-    LGTD_CLIENT_WRITE_STRING(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
+    lgtd_client_write_string(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
     lgtd_jsonrpc_write_id(client);
-    LGTD_CLIENT_WRITE_STRING(client, ", \"result\": ");
-    LGTD_CLIENT_WRITE_STRING(client, result);
-    LGTD_CLIENT_WRITE_STRING(client, "}");
+    lgtd_client_write_string(client, ", \"result\": ");
+    lgtd_client_write_string(client, result);
+    lgtd_client_write_string(client, "}");
 }
 
 void
@@ -533,15 +533,15 @@
 {
     assert(client);
 
-    LGTD_CLIENT_WRITE_STRING(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
+    lgtd_client_write_string(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
     lgtd_jsonrpc_write_id(client);
-    LGTD_CLIENT_WRITE_STRING(client, ", \"result\": ");
+    lgtd_client_write_string(client, ", \"result\": ");
 }
 
 void
 lgtd_jsonrpc_end_send_response(struct lgtd_client *client)
 {
-    LGTD_CLIENT_WRITE_STRING(client, "}");
+    lgtd_client_write_string(client, "}");
 }
 
 static bool
diff --git a/core/lightsd.c b/core/lightsd.c
--- a/core/lightsd.c
+++ b/core/lightsd.c
@@ -52,6 +52,7 @@
 #include "jsmn.h"
 #include "jsonrpc.h"
 #include "client.h"
+#include "pipe.h"
 #include "listen.h"
 #include "lightsd.h"
 
@@ -69,6 +70,7 @@
 lgtd_cleanup(void)
 {
     lgtd_listen_close_all();
+    lgtd_command_pipe_close_all();
     lgtd_client_close_all();
     lgtd_lifx_timer_close();
     lgtd_lifx_broadcast_close();
@@ -135,10 +137,17 @@
 lgtd_usage(const char *progname)
 {
     printf(
-        "Usage: %s -l addr:port [-l ...] [-f] [-t] [-h] [-V] "
-        "[-v debug|info|warning|error]\n",
+        "Usage: %s ...\n\n"
+        "  [-l,--listen addr:port [-l ...]]\n"
+        "  [-c,--comand-pipe /command/fifo -[c ...]]\n"
+        "  [-f,--foreground]\n"
+        "  [-t,--no-timestamps]\n"
+        "  [-h,--help]\n"
+        "  [-V,--version]\n"
+        "  [-v,--verbosity debug|info|warning|error]\n",
         progname
     );
+    lgtd_cleanup();
     exit(0);
 }
 
@@ -198,6 +207,7 @@
 
     static const struct option long_opts[] = {
         {"listen",          required_argument, NULL, 'l'},
+        {"command-pipe",    required_argument, NULL, 'c'},
         {"foreground",      no_argument,       NULL, 'f'},
         {"no-timestamps",   no_argument,       NULL, 't'},
         {"help",            no_argument,       NULL, 'h'},
@@ -205,7 +215,7 @@
         {"version",         no_argument,       NULL, 'V'},
         {NULL,              0,                 NULL, 0}
     };
-    const char short_opts[] = "l:fthv:V";
+    const char short_opts[] = "l:c:fthv:V";
 
     for (int rv = getopt_long(argc, argv, short_opts, long_opts, NULL);
          rv != -1;
@@ -218,8 +228,7 @@
                 lgtd_usage(argv[0]);
             }
             strncat(binds, optarg, LGTD_MIN(
-                sizeof(binds) - strlen(binds) - 1,
-                strlen(optarg)
+                sizeof(binds) - strlen(binds) - 1, strlen(optarg)
             ));
             strncat(binds, ", ", LGTD_MIN(
                 sizeof(binds) - strlen(binds) - 1, 2
@@ -230,6 +239,11 @@
             }
             *sep = ':';
             break;
+        case 'c':
+            if (!lgtd_command_pipe_open(optarg)) {
+                exit(1);
+            }
+            break;
         case 'f':
             lgtd_opts.foreground = true;
             break;
diff --git a/core/pipe.c b/core/pipe.c
new file mode 100644
--- /dev/null
+++ b/core/pipe.c
@@ -0,0 +1,233 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <sys/queue.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <assert.h>
+#include <err.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <event2/buffer.h>
+#include <event2/event.h>
+
+#include "jsmn.h"
+#include "jsonrpc.h"
+#include "client.h"
+#include "pipe.h"
+#include "lightsd.h"
+
+static struct lgtd_command_pipe_list lgtd_command_pipes =
+    SLIST_HEAD_INITIALIZER(&lgtd_command_pipes);
+
+static void
+lgtd_command_pipe_close(struct lgtd_command_pipe *pipe)
+{
+    assert(pipe);
+
+    event_del(pipe->read_ev);
+    if (pipe->fd != -1) {
+        close(pipe->fd);
+    }
+    unlink(pipe->path);
+    SLIST_REMOVE(&lgtd_command_pipes, pipe, lgtd_command_pipe, link);
+    evbuffer_free(pipe->read_buf);
+    event_free(pipe->read_ev);
+
+    lgtd_info("closed command pipe %s", pipe->path);
+    free(pipe);
+}
+
+static void
+lgtd_command_pipe_read_callback(evutil_socket_t socket, short events, void *ctx)
+{
+    assert(ctx);
+    assert(socket != -1);
+
+    (void)socket;
+    (void)events;
+
+    struct lgtd_command_pipe *pipe = ctx;
+
+    bool drain = false;
+    int read = 0;
+    for (int nbytes = evbuffer_read(pipe->read_buf, pipe->fd, -1);
+         nbytes;
+         nbytes = evbuffer_read(pipe->read_buf, pipe->fd, -1)) {
+        if (nbytes == -1) {
+            if (errno == EINTR) {
+                continue;
+            }
+            if (errno != EAGAIN) {
+                lgtd_warn("read error on command pipe %s", pipe->path);
+                const char *path = pipe->path;
+                lgtd_command_pipe_close(pipe);
+                lgtd_command_pipe_open(path);
+                return;
+            }
+            continue;
+        }
+
+        if (!drain) {
+            read += nbytes;
+        next_request:
+            (void)0;
+            const char *buf = (char *)evbuffer_pullup(pipe->read_buf, -1);
+            ssize_t bufsz = evbuffer_get_length(pipe->read_buf);
+            jsmnerr_t rv = jsmn_parse(
+                &pipe->client.jsmn_ctx,
+                buf,
+                bufsz,
+                pipe->client.jsmn_tokens,
+                LGTD_ARRAY_SIZE(pipe->client.jsmn_tokens)
+            );
+            switch (rv) {
+            case JSMN_ERROR_NOMEM:
+            case JSMN_ERROR_INVAL:
+                lgtd_warnx("pipe %s: request too big or invalid", pipe->path);
+                // ignore what's left
+                drain = true;
+                break;
+            case JSMN_ERROR_PART:
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wswitch"
+            case 0:
+#pragma GCC diagnostic pop
+                if (bufsz >= LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) {
+                    lgtd_warnx("pipe %s: request too big", pipe->path);
+                    drain = true;
+                }
+                break;
+            default:
+                pipe->client.json = buf;
+                int ntokens = rv;
+                lgtd_jsonrpc_dispatch_request(&pipe->client, ntokens);
+
+                pipe->client.json = NULL;
+                jsmn_init(&pipe->client.jsmn_ctx);
+                int request_size = pipe->client.jsmn_tokens[0].end;
+                evbuffer_drain(pipe->read_buf, request_size);
+                read -= request_size;
+                if (read) {
+                    goto next_request;
+                }
+                break;
+            }
+        } else {
+            evbuffer_drain(pipe->read_buf, read + nbytes);
+            read = 0;
+        }
+    }
+
+    if (read) {
+        lgtd_debug(
+            "pipe %s: discarding %d bytes of unusable data", pipe->path, read
+        );
+        evbuffer_drain(pipe->read_buf, read);
+    }
+    jsmn_init(&pipe->client.jsmn_ctx);
+}
+
+bool
+lgtd_command_pipe_open(const char *path)
+{
+    assert(path);
+
+    struct lgtd_command_pipe *pipe;
+    SLIST_FOREACH(pipe, &lgtd_command_pipes, link) {
+        if (!strcmp(pipe->path, path)) {
+            return true;
+        }
+    }
+
+    pipe = calloc(1, sizeof(*pipe));
+    if (!pipe) {
+        lgtd_warn("can't open command pipe %s", path);
+        return false;
+    }
+
+    pipe->path = path;
+    pipe->fd = -1;
+
+    mode_t mode = S_IWUSR|S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IWGRP;
+    if (mkfifo(path, mode) && errno != EEXIST) {
+        goto error;
+    }
+
+    pipe->fd = open(path, O_RDONLY|O_NONBLOCK);
+    if (pipe->fd == -1) {
+        goto error;
+    }
+
+    if (evutil_make_socket_nonblocking(pipe->fd) == -1) {
+        goto error;
+    }
+
+    pipe->read_ev = event_new(
+        lgtd_ev_base,
+        pipe->fd,
+        EV_READ|EV_PERSIST,
+        lgtd_command_pipe_read_callback,
+        pipe
+    );
+    if (!pipe->read_ev) {
+        goto error;
+    }
+
+    pipe->read_buf = evbuffer_new();
+    if (!pipe->read_buf) {
+        goto error;
+    }
+
+    if (event_add(pipe->read_ev, NULL)) {
+        goto error;
+    }
+
+    lgtd_info("command pipe ready at %s", pipe->path);
+
+    SLIST_INSERT_HEAD(&lgtd_command_pipes, pipe, link);
+
+    return true;
+
+error:
+    lgtd_warn("can't open command pipe %s", path);
+    if (pipe->read_buf) {
+        evbuffer_free(pipe->read_buf);
+    }
+    if (pipe->read_ev) {
+        event_free(pipe->read_ev);
+    }
+    if (pipe->fd != -1) {
+        close(pipe->fd);
+    }
+    free(pipe);
+    return false;
+}
+
+void
+lgtd_command_pipe_close_all(void)
+{
+    while (!SLIST_EMPTY(&lgtd_command_pipes)) {
+        lgtd_command_pipe_close(SLIST_FIRST(&lgtd_command_pipes));
+    }
+}
diff --git a/core/pipe.h b/core/pipe.h
new file mode 100644
--- /dev/null
+++ b/core/pipe.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#pragma once
+
+struct lgtd_command_pipe {
+    SLIST_ENTRY(lgtd_command_pipe)  link;
+    const char                      *path;
+    int                             fd;
+    struct event                    *read_ev;
+    struct evbuffer                 *read_buf;
+    struct lgtd_client              client;
+};
+SLIST_HEAD(lgtd_command_pipe_list, lgtd_command_pipe);
+
+bool lgtd_command_pipe_open(const char *);
+void lgtd_command_pipe_close_all(void);
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -178,7 +178,7 @@
     )
 
     lgtd_client_start_send_response(client);
-    LGTD_CLIENT_WRITE_STRING(client, "[");
+    lgtd_client_write_string(client, "[");
     struct lgtd_router_device *device;
     SLIST_FOREACH(device, devices, link) {
         struct lgtd_lifx_bulb *bulb = device->device;
@@ -204,15 +204,15 @@
             );
             continue;
         }
-        LGTD_CLIENT_WRITE_STRING(client, buf);
+        lgtd_client_write_string(client, buf);
 
         bool comma = false;
         int tag_id;
         LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, bulb->state.tags) {
             if (LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id) & bulb->gw->tag_ids) {
-                LGTD_CLIENT_WRITE_STRING(client, comma ? ",\"" : "\"");
-                LGTD_CLIENT_WRITE_STRING(client, bulb->gw->tags[tag_id]->label);
-                LGTD_CLIENT_WRITE_STRING(client, "\"");
+                lgtd_client_write_string(client, comma ? ",\"" : "\"");
+                lgtd_client_write_string(client, bulb->gw->tags[tag_id]->label);
+                lgtd_client_write_string(client, "\"");
                 comma = true;
             } else {
                 lgtd_warnx(
@@ -225,11 +225,11 @@
             }
         }
 
-        LGTD_CLIENT_WRITE_STRING(
+        lgtd_client_write_string(
             client, SLIST_NEXT(device, link) ?  "]}," : "]}"
         );
     }
-    LGTD_CLIENT_WRITE_STRING(client, "]");
+    lgtd_client_write_string(client, "]");
     lgtd_client_end_send_response(client);
 
     lgtd_router_device_list_free(devices);
diff --git a/tests/core/mock_client_buf.h b/tests/core/mock_client_buf.h
--- a/tests/core/mock_client_buf.h
+++ b/tests/core/mock_client_buf.h
@@ -21,3 +21,15 @@
     client_write_buf_idx += to_write;
     return 0;
 }
+
+void
+lgtd_client_write_string(struct lgtd_client *client, const char *msg)
+{
+    bufferevent_write(client->io, msg, strlen(msg));
+}
+
+void
+lgtd_client_write_buf(struct lgtd_client *client, const char *buf, int bufsz)
+{
+    bufferevent_write(client->io, buf, bufsz);
+}
diff --git a/tests/core/proto/tests_proto_utils.h b/tests/core/proto/tests_proto_utils.h
--- a/tests/core/proto/tests_proto_utils.h
+++ b/tests/core/proto/tests_proto_utils.h
@@ -16,7 +16,7 @@
 void
 lgtd_client_send_response(struct lgtd_client *client, const char *msg)
 {
-    LGTD_CLIENT_WRITE_STRING(client, msg);
+    lgtd_client_write_string(client, msg);
 }
 #endif
 
