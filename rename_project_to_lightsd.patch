# HG changeset patch
# Parent 97fcada8bd1b73683330460f5804f4869e5029a4
Rename the project lightsd

And re-organize the sources accordingly.

There is no reason to make this LIFX specific.

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,20 +1,20 @@
 CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
 
-PROJECT(LIFXD C)
+PROJECT(LIGHTSD C)
 
 SET(CPACK_PACKAGE_VERSION_MAJOR "0")
 SET(CPACK_PACKAGE_VERSION_MINOR "0")
 SET(CPACK_PACKAGE_VERSION_PATCH "1")
-SET(LIFXD_VERSION "${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}")
+SET(LIGHTSD_VERSION "${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}")
 
 MESSAGE(STATUS "CMake version: ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}")
-MESSAGE(STATUS "lifxd version: ${LIFXD_VERSION}")
+MESSAGE(STATUS "lgtd version: ${LIGHTSD_VERSION}")
 MESSAGE(STATUS "Build type: ${CMAKE_BUILD_TYPE}")
 MESSAGE(STATUS "System: ${CMAKE_SYSTEM_NAME} ${CMAKE_SYSTEM_VERSION}")
 MESSAGE(STATUS "Install prefix: ${CMAKE_INSTALL_PREFIX}")
-MESSAGE(STATUS "Source directory: ${LIFXD_SOURCE_DIR}")
+MESSAGE(STATUS "Source directory: ${LIGHTSD_SOURCE_DIR}")
 
-SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${LIFXD_SOURCE_DIR}/CMakeScripts)
+SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${LIGHTSD_SOURCE_DIR}/CMakeScripts)
 
 ### Platform checks ############################################################
 
@@ -25,7 +25,7 @@
 
 INCLUDE(CheckTypeSize)
 CHECK_TYPE_SIZE(suseconds_t SUSECONDS_T_SIZE)
-ADD_DEFINITIONS("-DLIFXD_SUSECONDS_T_SIZE=${SUSECONDS_T_SIZE}")
+ADD_DEFINITIONS("-DLGTD_SUSECONDS_T_SIZE=${SUSECONDS_T_SIZE}")
 
 ### Global definitions #########################################################
 
@@ -45,6 +45,7 @@
     ENDIF ()
 ENDIF ()
 
-INCLUDE_DIRECTORIES(${LIFXD_SOURCE_DIR}/compat/generic ${LIFXD_BINARY_DIR}/compat)
+INCLUDE_DIRECTORIES(${LIGHTSD_SOURCE_DIR}/compat/generic ${LIGHTSD_BINARY_DIR}/compat)
 
 ADD_SUBDIRECTORY(core)
+ADD_SUBDIRECTORY(lifx)
diff --git a/CMakeScripts/CompatTimeMonotonic.cmake b/CMakeScripts/CompatTimeMonotonic.cmake
--- a/CMakeScripts/CompatTimeMonotonic.cmake
+++ b/CMakeScripts/CompatTimeMonotonic.cmake
@@ -1,10 +1,10 @@
 INCLUDE(CheckFunctionExists)
 
 IF (NOT TIME_MONOTONIC_IMPL)
-    SET(COMPAT_TIME_MONOTONIC_IMPL "${LIFXD_SOURCE_DIR}/compat/${CMAKE_SYSTEM_NAME}/time_monotonic.c")
-    SET(COMPAT_TIME_MONOTONIC_H "${LIFXD_SOURCE_DIR}/compat/${CMAKE_SYSTEM_NAME}/time_monotonic.h")
-    SET(GENERIC_TIME_MONOTONIC_IMPL "${LIFXD_SOURCE_DIR}/compat/generic/time_monotonic.c")
-    SET(GENERIC_TIME_MONOTONIC_H "${LIFXD_SOURCE_DIR}/compat/generic/time_monotonic.h")
+    SET(COMPAT_TIME_MONOTONIC_IMPL "${LIGHTSD_SOURCE_DIR}/compat/${CMAKE_SYSTEM_NAME}/time_monotonic.c")
+    SET(COMPAT_TIME_MONOTONIC_H "${LIGHTSD_SOURCE_DIR}/compat/${CMAKE_SYSTEM_NAME}/time_monotonic.h")
+    SET(GENERIC_TIME_MONOTONIC_IMPL "${LIGHTSD_SOURCE_DIR}/compat/generic/time_monotonic.c")
+    SET(GENERIC_TIME_MONOTONIC_H "${LIGHTSD_SOURCE_DIR}/compat/generic/time_monotonic.h")
 
     SET(CMAKE_REQUIRED_QUIET TRUE)
     MESSAGE(STATUS "Looking for clock_gettime")
@@ -13,17 +13,17 @@
 
     IF (HAVE_CLOCK_GETTIME)
         MESSAGE(STATUS "Looking for clock_gettime - found")
-        FILE(COPY "${GENERIC_TIME_MONOTONIC_H}" DESTINATION "${LIFXD_BINARY_DIR}/compat/")
+        FILE(COPY "${GENERIC_TIME_MONOTONIC_H}" DESTINATION "${LIGHTSD_BINARY_DIR}/core/")
         SET(
             TIME_MONOTONIC_IMPL "${GENERIC_TIME_MONOTONIC_IMPL}"
-            CACHE INTERNAL "lifxd_time_monotonic (POSIX generic implementation)"
+            CACHE INTERNAL "lgtd_time_monotonic (POSIX generic implementation)"
         )
     ELSEIF (EXISTS "${COMPAT_TIME_MONOTONIC_IMPL}")
         MESSAGE(STATUS "Looking for clock_gettime - not found, using built-in compatibilty file")
-        FILE(COPY "${COMPAT_TIME_MONOTONIC_H}" DESTINATION "${LIFXD_BINARY_DIR}/compat/")
+        FILE(COPY "${COMPAT_TIME_MONOTONIC_H}" DESTINATION "${LIGHTSD_BINARY_DIR}/core/")
         SET(
             TIME_MONOTONIC_IMPL "${COMPAT_TIME_MONOTONIC_IMPL}"
-            CACHE INTERNAL "lifxd_time_monotonic (${CMAKE_SYSTEM_NAME} specific implementation)"
+            CACHE INTERNAL "lgtd_time_monotonic (${CMAKE_SYSTEM_NAME} specific implementation)"
         )
     ELSE ()
         MESSAGE(SEND_ERROR "Looking for clock_gettime - not found")
diff --git a/CMakeScripts/FindEndian.cmake b/CMakeScripts/FindEndian.cmake
--- a/CMakeScripts/FindEndian.cmake
+++ b/CMakeScripts/FindEndian.cmake
@@ -1,8 +1,8 @@
 INCLUDE(CheckIncludeFile)
 
 IF (NOT ENDIAN_H_PATH)
-    SET(COMPAT_ENDIAN_H "${LIFXD_SOURCE_DIR}/compat/${CMAKE_SYSTEM_NAME}/endian.h")
-    SET(GENERIC_ENDIAN_H "${LIFXD_SOURCE_DIR}/compat/generic/endian.h")
+    SET(COMPAT_ENDIAN_H "${LIGHTSD_SOURCE_DIR}/compat/${CMAKE_SYSTEM_NAME}/endian.h")
+    SET(GENERIC_ENDIAN_H "${LIGHTSD_SOURCE_DIR}/compat/generic/endian.h")
 
     SET(CMAKE_REQUIRED_QUIET TRUE)
     MESSAGE(STATUS "Looking for endian.h")
@@ -14,7 +14,7 @@
         SET(ENDIAN_H_PATH "using native headers" CACHE INTERNAL "endian.h path")
     ELSEIF (EXISTS "${COMPAT_ENDIAN_H}")
         MESSAGE(STATUS "Looking for endian.h - not found, using built-in compatibility file")
-        FILE(COPY "${COMPAT_ENDIAN_H}" DESTINATION "${LIFXD_BINARY_DIR}/compat/")
+        FILE(COPY "${COMPAT_ENDIAN_H}" DESTINATION "${LIGHTSD_BINARY_DIR}/compat/")
         SET(ENDIAN_H_PATH "${COMPAT_ENDIAN_H}" CACHE INTERNAL "endian.h path")
     ELSE ()
         MESSAGE(STATUS "Looking for endian.h - not found")
diff --git a/README.rst b/README.rst
--- a/README.rst
+++ b/README.rst
@@ -1,18 +1,18 @@
-lifxd, a LIFX broker
-====================
+lightsd, a LIFX broker
+======================
 
-lifxd acts a central point of control for your LIFX_ WiFi bulbs. lifxd should be
-a small, simple and fast daemon exposing an easy to use protocol inspired by how
-musicpd_ works.
+lightsd acts a central point of control for your LIFX_ WiFi bulbs. lightsd
+should be a small, simple and fast daemon exposing an easy to use protocol
+inspired by how musicpd_ works.
 
-Having to run a daemon to control your LIFX bulbs may seem a little bit
-backward but has some advantages:
+Having to run a daemon to control your LIFX bulbs may seem a little bit backward
+but has some advantages:
 
 - no discovery delay ever, you get all the bulbs and their state right away;
-- lifxd is always in sync with the bulbs and always know their state;
-- lifxd act as an abstraction layer and can expose new discovery mechanism (e.g:
-  zeroconf) and totally new APIs;
-- For those of you with a high paranoia factor, lifxd let you place your bulbs
+- lightsd is always in sync with the bulbs and always know their state;
+- lightsd act as an abstraction layer and can expose new discovery mechanism and
+  totally new APIs;
+- For those of you with a high paranoia factor, lightsd let you place your bulbs
   in a totally separate and closed network.
 
 .. _LIFX: http://lifx.co/
@@ -21,24 +21,22 @@
 Current features
 ----------------
 
-lifxd doesn't do much yet, it just discovers your bulbs and stay in sync with
-them.
+lightsd doesn't do much yet, it just discovers your LIFX bulbs and stay in sync
+with them.
 
-Developers
-----------
+Developpers
+-----------
 
-The project is far from being usable right now, but I'll be happy to hear your
-feedback and share ideas.
-
-Be aware that some parts of the code aren't really clean yet: I'm more focused
-on getting things working and good abstractions. Testing is definitely missing.
+Feel free to reach out via email or irc (kalessin on freenode). As the project
+name implies, I'm fairly interested in other smart bulbs.
 
 Requirements
 ------------
 
-lifxd aims to be highly portable on any POSIX system (win32 support should be
-quite easy, but isn't really the goal) and on any kind of hardware including
-embedded devices. Hence why lifxd is written in C with reasonable dependencies:
+lightsd aims to be highly portable on any slightly POSIX system (win32 support
+should be quite easy, but isn't really the goal) and on any kind of hardware
+including embedded devices. Hence why lightsd is written in C with reasonable
+dependencies:
 
 - CMake ≥ 2.8;
 - libevent ≥ 2.0.19.
diff --git a/compat/Darwin/time_monotonic.c b/compat/Darwin/time_monotonic.c
--- a/compat/Darwin/time_monotonic.c
+++ b/compat/Darwin/time_monotonic.c
@@ -40,7 +40,7 @@
 enum { MSECS_IN_NSEC = 1000000 };
 
 time_t
-lifxd_time_monotonic_msecs(void)
+lgtd_time_monotonic_msecs(void)
 {
     static mach_timebase_info_data_t timebase = { 0, 0 };
     if (timebase.denom == 0) {
diff --git a/compat/Darwin/time_monotonic.h b/compat/Darwin/time_monotonic.h
--- a/compat/Darwin/time_monotonic.h
+++ b/compat/Darwin/time_monotonic.h
@@ -29,6 +29,6 @@
 
 #pragma once
 
-typedef time_t lifxd_time_mono_t;
+typedef time_t lgtd_time_mono_t;
 
-lifxd_time_mono_t lifxd_time_monotonic_msecs(void);
+lgtd_time_mono_t lgtd_time_monotonic_msecs(void);
diff --git a/compat/generic/time_monotonic.c b/compat/generic/time_monotonic.c
--- a/compat/generic/time_monotonic.c
+++ b/compat/generic/time_monotonic.c
@@ -32,7 +32,7 @@
 #include "time_monotonic.h"
 
 time_t
-lifxd_time_monotonic_msecs(void)
+lgtd_time_monotonic_msecs(void)
 {
     struct timespec tp;
     clock_gettime(CLOCK_MONOTONIC, &tp);
diff --git a/compat/generic/time_monotonic.h b/compat/generic/time_monotonic.h
--- a/compat/generic/time_monotonic.h
+++ b/compat/generic/time_monotonic.h
@@ -29,6 +29,6 @@
 
 #pragma once
 
-typedef time_t lifxd_time_mono_t;
+typedef time_t lgtd_time_mono_t;
 
-lifxd_time_mono_t lifxd_time_monotonic_msecs(void);
+lgtd_time_mono_t lgtd_time_monotonic_msecs(void);
diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -1,18 +1,20 @@
-INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR})
+# As you'll find out the code in this directory isn't really generic at all.
+# I only have lifx bulbs right now and I don't want to do any premature work.
+
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}/../
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}/../
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
 
 CONFIGURE_FILE(version.h.in ${CMAKE_CURRENT_BINARY_DIR}/version.h)
 
 ADD_EXECUTABLE(
-    lifxd
-    broadcast.c
-    bulb.c
-    client.c
-    gateway.c
-    lifxd.c
+    lightsd
+    lightsd.c
     log.c
     ${TIME_MONOTONIC_IMPL}
-    timer.c
-    wire_proto.c
 )
 
-TARGET_LINK_LIBRARIES(lifxd ${EVENT2_CORE_LIBRARY})
+TARGET_LINK_LIBRARIES(lightsd lifx ${EVENT2_CORE_LIBRARY})
diff --git a/core/client.c b/core/client.c
deleted file mode 100644
diff --git a/core/client.h b/core/client.h
deleted file mode 100644
--- a/core/client.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#pragma once
-
-struct lifxd_client {
-    LIST_ENTRY(lifxd_client)    link;
-};
-LIST_HEAD(lifxd_client_list, lifxd_client);
diff --git a/core/lifxd.c b/core/lightsd.c
rename from core/lifxd.c
rename to core/lightsd.c
--- a/core/lifxd.c
+++ b/core/lightsd.c
@@ -46,38 +46,37 @@
 #include <event2/event.h>
 #include <event2/event_struct.h>
 
-#include "wire_proto.h"
+#include "lifx/wire_proto.h"
 #include "time_monotonic.h"
-#include "bulb.h"
-#include "gateway.h"
-#include "broadcast.h"
+#include "lifx/bulb.h"
+#include "lifx/gateway.h"
+#include "lifx/broadcast.h"
 #include "version.h"
-#include "timer.h"
-#include "lifxd.h"
+#include "lifx/timer.h"
+#include "lightsd.h"
 
-struct lifxd_opts lifxd_opts = {
+struct lgtd_opts lgtd_opts = {
     .foreground = false,
     .log_timestamps = true,
-    .master_port = 56700,
-    .verbosity = LIFXD_DEBUG
+    .verbosity = LGTD_DEBUG
 }; 
 
-struct event_base *lifxd_ev_base = NULL;
+struct event_base *lgtd_ev_base = NULL;
 
 void
-lifxd_cleanup(void)
+lgtd_cleanup(void)
 {
-    lifxd_timer_close();
-    lifxd_broadcast_close();
-    lifxd_gateway_close_all();
-    event_base_free(lifxd_ev_base);
+    lgtd_lifx_timer_close();
+    lgtd_lifx_broadcast_close();
+    lgtd_lifx_gateway_close_all();
+    event_base_free(lgtd_ev_base);
 #if LIBEVENT_VERSION_NUMBER >= 0x02010100
     libevent_global_shutdown();
 #endif
 }
 
 short
-lifxd_sockaddrport(const struct sockaddr_storage *peer)
+lgtd_sockaddrport(const struct sockaddr_storage *peer)
 {
     assert(peer);
 
@@ -91,38 +90,37 @@
 }
 
 static void
-lifxd_signal_event_callback(int signum, short events, void *ctx)
+lgtd_signal_event_callback(int signum, short events, void *ctx)
 {
     assert(ctx);
 
-    lifxd_info(
+    lgtd_info(
         "received signal %d (%s), exiting...", signum, strsignal(signum)
     );
     event_del((struct event *)ctx);  // restore default behavior
-    event_base_loopbreak(lifxd_ev_base);
+    event_base_loopbreak(lgtd_ev_base);
     (void)events;
 }
 
 static void
-lifxd_configure_libevent(void)
+lgtd_configure_libevent(void)
 {
-    lifxd_gateway_close_all();
-    event_set_log_callback(lifxd_libevent_log);
-    lifxd_ev_base = event_base_new();
+    event_set_log_callback(lgtd_libevent_log);
+    lgtd_ev_base = event_base_new();
 }
 
 static void
-lifxd_configure_signal_handling(void)
+lgtd_configure_signal_handling(void)
 {
     const int signals[] = {SIGINT, SIGTERM, SIGQUIT};
-    static struct event sigevs[LIFXD_ARRAY_SIZE(signals)];
+    static struct event sigevs[LGTD_ARRAY_SIZE(signals)];
 
-    for (int i = 0; i != LIFXD_ARRAY_SIZE(signals); i++) {
+    for (int i = 0; i != LGTD_ARRAY_SIZE(signals); i++) {
         evsignal_assign(
             &sigevs[i],
-            lifxd_ev_base,
+            lgtd_ev_base,
             signals[i],
-            lifxd_signal_event_callback,
+            lgtd_signal_event_callback,
             &sigevs[i]
         );
         evsignal_add(&sigevs[i], NULL);
@@ -130,11 +128,10 @@
 }
 
 static void
-lifxd_usage(const char *progname)
+lgtd_usage(const char *progname)
 {
     printf(
-        "Usage: %s [-p master_bulb_port] "
-        "[-v debug|info|warning|error] [-f] [-t] [-h] [-V]\n",
+        "Usage: %s [-v debug|info|warning|error] [-f] [-t] [-h] [-V]\n",
         progname
     );
     exit(0);
@@ -147,73 +144,62 @@
         {"foreground",      no_argument,       NULL, 'f'},
         {"no-timestamps",   no_argument,       NULL, 't'},
         {"help",            no_argument,       NULL, 'h'},
-        {"master-port",     required_argument, NULL, 'p'},
         {"verbosity",       required_argument, NULL, 'v'},
         {"version",         no_argument,       NULL, 'V'},
         {NULL,              0,                 NULL, 0}
     };
-    const char short_opts[] = "fthp:v:V";
+    const char short_opts[] = "fthv:V";
 
     for (int rv = getopt_long(argc, argv, short_opts, long_opts, NULL);
          rv != -1;
          rv = getopt_long(argc, argv, short_opts, long_opts, NULL)) {
         switch (rv) {
         case 'f':
-            lifxd_opts.foreground = true;
+            lgtd_opts.foreground = true;
             break;
         case 't':
-            lifxd_opts.log_timestamps = false;
+            lgtd_opts.log_timestamps = false;
             break;
         case 'h':
-            lifxd_usage(argv[0]);
-        case 'p':
-            errno = 0;
-            long port = strtol(optarg, NULL, 10);
-            if (!errno && port <= UINT16_MAX && port > 0) {
-                lifxd_opts.master_port = port;
-                break;
-            }
-            lifxd_errx(
-                1, "The master port must be between 1 and %d", UINT16_MAX
-            );
+            lgtd_usage(argv[0]);
         case 'v':
             for (int i = 0;;) {
                 const char *verbose_levels[] = {
                     "debug", "info", "warning", "error"
                 };
                 if (!strcasecmp(optarg, verbose_levels[i])) {
-                    lifxd_opts.verbosity = i;
+                    lgtd_opts.verbosity = i;
                     break;
                 }
-                if (++i == LIFXD_ARRAY_SIZE(verbose_levels)) {
-                    lifxd_errx(1, "Unknown verbosity level: %s", optarg);
+                if (++i == LGTD_ARRAY_SIZE(verbose_levels)) {
+                    lgtd_errx(1, "Unknown verbosity level: %s", optarg);
                 }
             }
             break;
         case 'V':
-            printf("%s v%s\n", argv[0], LIFXD_VERSION);
+            printf("%s v%s\n", argv[0], LGTD_VERSION);
             return 0;
         default:
-            lifxd_usage(argv[0]);
+            lgtd_usage(argv[0]);
         }
     }
 
     argc -= optind;
     argv += optind;
 
-    lifxd_configure_libevent();
-    lifxd_configure_signal_handling();
+    lgtd_configure_libevent();
+    lgtd_configure_signal_handling();
 
-    lifxd_wire_load_packet_infos_map();
-    if (!lifxd_timer_setup() || !lifxd_broadcast_setup()) {
-        lifxd_err(1, "can't setup lifxd");
+    lgtd_lifx_wire_load_packet_infos_map();
+    if (!lgtd_lifx_timer_setup() || !lgtd_lifx_broadcast_setup()) {
+        lgtd_err(1, "can't setup lgtd_lifx");
     }
 
-    lifxd_timer_start_discovery();
+    lgtd_lifx_timer_start_discovery();
 
-    event_base_dispatch(lifxd_ev_base);
+    event_base_dispatch(lgtd_ev_base);
 
-    lifxd_cleanup();
+    lgtd_cleanup();
 
     return 0;
 }
diff --git a/core/lifxd.h b/core/lightsd.h
rename from core/lifxd.h
rename to core/lightsd.h
--- a/core/lifxd.h
+++ b/core/lightsd.h
@@ -33,46 +33,45 @@
 # define __atttribute__(e)
 #endif
 
-#define LIFXD_ABS(v) ((v) >= 0 ? (v) : (v) * -1)
-#define LIFXD_ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
-#define LIFXD_MSECS_TO_TIMEVAL(v) { \
+#define LGTD_ABS(v) ((v) >= 0 ? (v) : (v) * -1)
+#define LGTD_ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+#define LGTD_MSECS_TO_TIMEVAL(v) { \
     .tv_sec = (v) / 1000,           \
     .tv_usec = ((v) % 1000) * 1000  \
 }
 
-enum lifxd_verbosity {
-    LIFXD_DEBUG = 0,
-    LIFXD_INFO,
-    LIFXD_WARN,
-    LIFXD_ERR
+enum lgtd_verbosity {
+    LGTD_DEBUG = 0,
+    LGTD_INFO,
+    LGTD_WARN,
+    LGTD_ERR
 };
 
-enum { LIFXD_ERROR_MSG_BUFSIZE = 2048 };
+enum { LGTD_ERROR_MSG_BUFSIZE = 2048 };
 
-struct lifxd_opts {
+struct lgtd_opts {
     bool                    foreground;
     bool                    log_timestamps;
-    uint16_t                master_port;
-    enum lifxd_verbosity    verbosity;
+    enum lgtd_verbosity    verbosity;
 };
 
-extern struct lifxd_opts lifxd_opts;
-extern struct event_base *lifxd_ev_base;
+extern struct lgtd_opts lgtd_opts;
+extern struct event_base *lgtd_ev_base;
 
-const char *lifxd_addrtoa(const uint8_t *);
-void lifxd_sockaddrtoa(const struct sockaddr_storage *, char *buf, int buflen);
-short lifxd_sockaddrport(const struct sockaddr_storage *);
+const char *lgtd_addrtoa(const uint8_t *);
+void lgtd_sockaddrtoa(const struct sockaddr_storage *, char *buf, int buflen);
+short lgtd_sockaddrport(const struct sockaddr_storage *);
 
-void _lifxd_err(void (*)(int, const char *, ...), int, const char *, ...)
+void _lgtd_err(void (*)(int, const char *, ...), int, const char *, ...)
     __attribute__((format(printf, 3, 4)));
-#define lifxd_err(eval, fmt, ...) _lifxd_err(err, (eval), (fmt), ##__VA_ARGS__);
-#define lifxd_errx(eval, fmt, ...) _lifxd_err(errx, (eval), (fmt), ##__VA_ARGS__);
-void _lifxd_warn(void (*)(const char *, va_list), const char *, ...)
+#define lgtd_err(eval, fmt, ...) _lgtd_err(err, (eval), (fmt), ##__VA_ARGS__);
+#define lgtd_errx(eval, fmt, ...) _lgtd_err(errx, (eval), (fmt), ##__VA_ARGS__);
+void _lgtd_warn(void (*)(const char *, va_list), const char *, ...)
     __attribute__((format(printf, 2, 3)));
-#define lifxd_warn(fmt, ...) _lifxd_warn(vwarn, (fmt), ##__VA_ARGS__);
-#define lifxd_warnx(fmt, ...) _lifxd_warn(vwarnx, (fmt), ##__VA_ARGS__);
-void lifxd_info(const char *, ...) __attribute__((format(printf, 1, 2)));
-void lifxd_debug(const char *, ...) __attribute__((format(printf, 1, 2)));
-void lifxd_libevent_log(int, const char *);
+#define lgtd_warn(fmt, ...) _lgtd_warn(vwarn, (fmt), ##__VA_ARGS__);
+#define lgtd_warnx(fmt, ...) _lgtd_warn(vwarnx, (fmt), ##__VA_ARGS__);
+void lgtd_info(const char *, ...) __attribute__((format(printf, 1, 2)));
+void lgtd_debug(const char *, ...) __attribute__((format(printf, 1, 2)));
+void lgtd_libevent_log(int, const char *);
 
-void lifxd_cleanup(void);
+void lgtd_cleanup(void);
diff --git a/core/log.c b/core/log.c
--- a/core/log.c
+++ b/core/log.c
@@ -41,11 +41,11 @@
 
 #include <event2/event.h>
 
-#include "wire_proto.h"
-#include "lifxd.h"
+#include "lifx/wire_proto.h"
+#include "lightsd.h"
 
 static void
-lifxd_isotime_now(char *strbuf, int bufsz)
+lgtd_isotime_now(char *strbuf, int bufsz)
 {
     assert(strbuf);
     assert(bufsz > 0);
@@ -60,7 +60,7 @@
     }
     // '2015-01-02T10:13:16.132222+00:00'
     snprintf(
-#if LIFXD_SUSECONDS_T_SIZE == 4
+#if LGTD_SUSECONDS_T_SIZE == 4
         strbuf, bufsz, "%d-%02d-%02dT%02d:%02d:%02d.%d%c%02ld:%02ld",
 #else
         strbuf, bufsz, "%d-%02d-%02dT%02d:%02d:%02d.%ld%c%02ld:%02ld",
@@ -68,7 +68,7 @@
         1900 + tm_now.tm_year, 1 + tm_now.tm_mon, tm_now.tm_mday,
         tm_now.tm_hour, tm_now.tm_min, tm_now.tm_sec,
         now.tv_usec, tm_now.tm_gmtoff >= 0 ? '+' : '-', // %+02ld doesn't work
-        LIFXD_ABS(tm_now.tm_gmtoff / 60 / 60), tm_now.tm_gmtoff % (60 * 60)
+        LGTD_ABS(tm_now.tm_gmtoff / 60 / 60), tm_now.tm_gmtoff % (60 * 60)
     );
     return;
 error:
@@ -76,26 +76,26 @@
 }
 
 static void
-lifxd_log_header(const char *loglvl, bool showprogname)
+lgtd_log_header(const char *loglvl, bool showprogname)
 {
-    if (lifxd_opts.log_timestamps) {
+    if (lgtd_opts.log_timestamps) {
         char timestr[64];
-        lifxd_isotime_now(timestr, sizeof(timestr));
+        lgtd_isotime_now(timestr, sizeof(timestr));
         fprintf(
             stderr, "[%s] [%s] %s",
-            timestr, loglvl, showprogname ? "lifxd: " : ""
+            timestr, loglvl, showprogname ? "lightsd " : ""
         );
         return;
     }
-    fprintf(stderr, "[%s] %s", loglvl, showprogname ? "lifxd: " : "");
+    fprintf(stderr, "[%s] %s", loglvl, showprogname ? "lightsd " : "");
 }
 
 const char *
-lifxd_addrtoa(const uint8_t *addr)
+lgtd_addrtoa(const uint8_t *addr)
 {
     assert(addr);
 
-    static char str[LIFXD_ADDR_LENGTH * 2 + LIFXD_ADDR_LENGTH - 1 + 1];
+    static char str[LGTD_LIFX_ADDR_LENGTH * 2 + LGTD_LIFX_ADDR_LENGTH - 1 + 1];
     snprintf(
         str, sizeof(str), "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
         addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]
@@ -104,7 +104,7 @@
 }
 
 void
-lifxd_sockaddrtoa(const struct sockaddr_storage *peer, char *buf, int buflen)
+lgtd_sockaddrtoa(const struct sockaddr_storage *peer, char *buf, int buflen)
 {
     assert(peer);
     assert(buf);
@@ -120,7 +120,7 @@
 }
 
 void
-_lifxd_err(void (*errfn)(int, const char *, ...),
+_lgtd_err(void (*errfn)(int, const char *, ...),
            int eval,
            const char *fmt,
            ...)
@@ -128,36 +128,36 @@
     int errsave = errno;
     va_list ap;
     va_start(ap, fmt);
-    // lifxd_cleanup is probably going to free some of the arguments we got, so
+    // lgtd_cleanup is probably going to free some of the arguments we got, so
     // let's print to a buffer before we call err.
-    char errmsg[LIFXD_ERROR_MSG_BUFSIZE];
+    char errmsg[LGTD_ERROR_MSG_BUFSIZE];
     vsnprintf(errmsg, sizeof(errmsg), fmt, ap);
     va_end(ap);
-    lifxd_cleanup();
-    lifxd_log_header("ERR", false);
+    lgtd_cleanup();
+    lgtd_log_header("ERR", false);
     errno = errsave;
     errfn(eval, errmsg);
 }
 
 void
-_lifxd_warn(void (*warnfn)(const char *, va_list), const char *fmt, ...)
+_lgtd_warn(void (*warnfn)(const char *, va_list), const char *fmt, ...)
 {
-    if (lifxd_opts.verbosity <= LIFXD_WARN) {
+    if (lgtd_opts.verbosity <= LGTD_WARN) {
         va_list ap;
         va_start(ap, fmt);
-        lifxd_log_header("WARN", false);
+        lgtd_log_header("WARN", false);
         warnfn(fmt, ap);
         va_end(ap);
     }
 }
 
 void
-lifxd_info(const char *fmt, ...)
+lgtd_info(const char *fmt, ...)
 {
-    if (lifxd_opts.verbosity <= LIFXD_INFO) {
+    if (lgtd_opts.verbosity <= LGTD_INFO) {
         va_list ap;
         va_start(ap, fmt);
-        lifxd_log_header("INFO", true);
+        lgtd_log_header("INFO", true);
         vfprintf(stderr, fmt, ap);
         va_end(ap);
         fprintf(stderr, "\n");
@@ -165,12 +165,12 @@
 }
 
 void
-lifxd_debug(const char *fmt, ...)
+lgtd_debug(const char *fmt, ...)
 {
-    if (lifxd_opts.verbosity <= LIFXD_DEBUG) {
+    if (lgtd_opts.verbosity <= LGTD_DEBUG) {
         va_list ap;
         va_start(ap, fmt);
-        lifxd_log_header("DEBUG", true);
+        lgtd_log_header("DEBUG", true);
         vfprintf(stderr, fmt, ap);
         va_end(ap);
         fprintf(stderr, "\n");
@@ -178,13 +178,13 @@
 }
 
 void
-lifxd_libevent_log(int severity, const char *msg)
+lgtd_libevent_log(int severity, const char *msg)
 {
     switch (severity) {
-    case EVENT_LOG_DEBUG:   lifxd_debug("%s", msg); break;
-    case EVENT_LOG_MSG:     lifxd_info("%s", msg);  break;
-    case EVENT_LOG_WARN:    lifxd_warnx("%s", msg)  break;
-    case EVENT_LOG_ERR:     lifxd_warnx("%s", msg); break;
+    case EVENT_LOG_DEBUG:   lgtd_debug("%s", msg); break;
+    case EVENT_LOG_MSG:     lgtd_info("%s", msg);  break;
+    case EVENT_LOG_WARN:    lgtd_warnx("%s", msg)  break;
+    case EVENT_LOG_ERR:     lgtd_warnx("%s", msg); break;
     default:                                        break;
     }
 }
diff --git a/core/version.h.in b/core/version.h.in
--- a/core/version.h.in
+++ b/core/version.h.in
@@ -29,4 +29,4 @@
 
 #pragma once
 
-const char LIFXD_VERSION[] = "@LIFXD_VERSION@";
+const char LGTD_VERSION[] = "@LGTD_VERSION@";
diff --git a/lifx/CMakeLists.txt b/lifx/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/lifx/CMakeLists.txt
@@ -0,0 +1,15 @@
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}/../
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}/../
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+ADD_LIBRARY(
+    lifx
+    broadcast.c
+    bulb.c
+    gateway.c
+    timer.c
+    wire_proto.c
+)
diff --git a/core/broadcast.c b/lifx/broadcast.c
rename from core/broadcast.c
rename to lifx/broadcast.c
--- a/core/broadcast.c
+++ b/lifx/broadcast.c
@@ -45,40 +45,40 @@
 #include <event2/util.h>
 
 #include "wire_proto.h"
-#include "time_monotonic.h"
+#include "core/time_monotonic.h"
 #include "bulb.h"
 #include "gateway.h"
 #include "broadcast.h"
-#include "lifxd.h"
+#include "core/lightsd.h"
 
 static struct {
     evutil_socket_t socket;
     struct event    *read_ev;
     struct event    *write_ev;
-} lifxd_broadcast_endpoint = {
+} lgtd_lifx_broadcast_endpoint = {
     .socket = -1,
     .read_ev = NULL,
     .write_ev = NULL,
 };
 
 static bool
-lifxd_broadcast_handle_read(void)
+lgtd_lifx_broadcast_handle_read(void)
 {
-    assert(lifxd_broadcast_endpoint.socket != -1);
+    assert(lgtd_lifx_broadcast_endpoint.socket != -1);
 
     while (true) {
         struct sockaddr_storage peer;
         // if we get back from recvfrom with a sockaddr_in the end of the struct
         // will not be initialized and we will be comparing unintialized stuff
-        // in lifxd_gateway_get:
+        // in lgtd_lifx_gateway_get:
         memset(&peer, 0, sizeof(peer));
         ev_socklen_t addrlen = sizeof(peer);
         union {
-            char buf[LIFXD_MAX_PACKET_SIZE];
-            struct lifxd_packet_header hdr;
+            char buf[LGTD_LIFX_MAX_PACKET_SIZE];
+            struct lgtd_lifx_packet_header hdr;
         } read;
         int nbytes = recvfrom(
-            lifxd_broadcast_endpoint.socket,
+            lgtd_lifx_broadcast_endpoint.socket,
             read.buf,
             sizeof(read.buf),
             0,
@@ -93,70 +93,72 @@
             if (error == EAGAIN) {
                 return true;
             }
-            lifxd_warn("can't receive broadcast packet");
+            lgtd_warn("can't receive broadcast packet");
             return false;
         }
 
-        lifxd_time_mono_t received_at = lifxd_time_monotonic_msecs();
+        lgtd_time_mono_t received_at = lgtd_time_monotonic_msecs();
         char peer_addr[INET6_ADDRSTRLEN];
-        lifxd_sockaddrtoa(&peer, peer_addr, sizeof(peer_addr));
-        short peer_port = lifxd_sockaddrport(&peer);
+        lgtd_sockaddrtoa(&peer, peer_addr, sizeof(peer_addr));
+        short peer_port = lgtd_sockaddrport(&peer);
 
-        if (nbytes < LIFXD_PACKET_HEADER_SIZE) {
-            lifxd_warnx(
+        if (nbytes < LGTD_LIFX_PACKET_HEADER_SIZE) {
+            lgtd_warnx(
                 "broadcast packet too short from [%s]:%hu", peer_addr, peer_port
             );
             return false;
         }
 
-        lifxd_wire_decode_header(&read.hdr);
+        lgtd_lifx_wire_decode_header(&read.hdr);
         if (read.hdr.size != nbytes) {
-            lifxd_warnx(
+            lgtd_warnx(
                 "incomplete broadcast packet from [%s]:%hu",
                 peer_addr, peer_port
             );
             return false;
         }
-        if (read.hdr.protocol.version != LIFXD_LIFX_PROTOCOL_V1) {
-            lifxd_warnx(
+        if (read.hdr.protocol.version != LGTD_LIFX_PROTOCOL_V1) {
+            lgtd_warnx(
                 "unsupported protocol %d from [%s]:%hu",
                 read.hdr.protocol.version, peer_addr, peer_port
             );
         }
-        if (read.hdr.packet_type == LIFXD_GET_PAN_GATEWAY) {
+        if (read.hdr.packet_type == LGTD_LIFX_GET_PAN_GATEWAY) {
             continue;
         }
 
-        const struct lifxd_packet_infos *pkt_infos =
-            lifxd_wire_get_packet_infos(read.hdr.packet_type);
+        const struct lgtd_lifx_packet_infos *pkt_infos =
+            lgtd_lifx_wire_get_packet_infos(read.hdr.packet_type);
         if (!pkt_infos) {
-            lifxd_warnx(
+            lgtd_warnx(
                 "received unknown packet %#x from [%s]:%hu",
                 read.hdr.packet_type, peer_addr, peer_port
             )
             continue;
         }
         if (read.hdr.protocol.tagged || !read.hdr.protocol.addressable) {
-            lifxd_warnx(
+            lgtd_warnx(
                 "received non-addressable packet %s from [%s]:%hu",
                 pkt_infos->name, peer_addr, peer_port
             );
             continue;
         }
-        struct lifxd_gateway *gw = lifxd_gateway_get(&peer);
-        if (!gw && read.hdr.packet_type == LIFXD_PAN_GATEWAY) {
-            gw = lifxd_gateway_open(&peer, addrlen, read.hdr.site, received_at);
+        struct lgtd_lifx_gateway *gw = lgtd_lifx_gateway_get(&peer);
+        if (!gw && read.hdr.packet_type == LGTD_LIFX_PAN_GATEWAY) {
+            gw = lgtd_lifx_gateway_open(
+                &peer, addrlen, read.hdr.site, received_at
+            );
             if (!gw) {
-                lifxd_err(1, "can't allocate gateway");
+                lgtd_err(1, "can't allocate gateway");
             }
         }
         if (gw) {
-            void *pkt = &read.buf[LIFXD_PACKET_HEADER_SIZE];
+            void *pkt = &read.buf[LGTD_LIFX_PACKET_HEADER_SIZE];
             gw->last_pkt_at = received_at;
             pkt_infos->decode(pkt);
             pkt_infos->handle(gw, &read.hdr, pkt);
         } else {
-            lifxd_warnx(
+            lgtd_warnx(
                 "got packet from unknown gateway [%s]:%hu", peer_addr, peer_port
             );
         }
@@ -164,28 +166,28 @@
 }
 
 static bool
-lifxd_broadcast_handle_write(void)
+lgtd_lifx_broadcast_handle_write(void)
 {
-    assert(lifxd_broadcast_endpoint.socket != -1);
+    assert(lgtd_lifx_broadcast_endpoint.socket != -1);
 
     struct sockaddr_in lifx_addr = {
         .sin_family = AF_INET,
         .sin_addr = { INADDR_BROADCAST },
-        .sin_port = htons(lifxd_opts.master_port)
+        .sin_port = htons(LGTD_LIFX_PROTOCOL_PORT)
     };
-    struct lifxd_packet_header get_pan_gateway;
-    lifxd_wire_setup_header(
+    struct lgtd_lifx_packet_header get_pan_gateway;
+    lgtd_lifx_wire_setup_header(
         &get_pan_gateway,
-        LIFXD_TARGET_ALL_DEVICES,
-        LIFXD_UNSPEC_TARGET,
+        LGTD_LIFX_TARGET_ALL_DEVICES,
+        LGTD_LIFX_UNSPEC_TARGET,
         NULL,
-        LIFXD_GET_PAN_GATEWAY
+        LGTD_LIFX_GET_PAN_GATEWAY
     );
 
     int nbytes;
 retry:
     nbytes = sendto(
-        lifxd_broadcast_endpoint.socket,
+        lgtd_lifx_broadcast_endpoint.socket,
         (void *)&get_pan_gateway,
         sizeof(get_pan_gateway),
         0,
@@ -193,8 +195,8 @@
         sizeof(lifx_addr)
     );
     if (nbytes == sizeof(get_pan_gateway)) {
-        if (event_del(lifxd_broadcast_endpoint.write_ev)) {
-            lifxd_err(1, "can't setup events");
+        if (event_del(lgtd_lifx_broadcast_endpoint.write_ev)) {
+            lgtd_err(1, "can't setup events");
         }
         return true;
     }
@@ -202,31 +204,33 @@
         if (EVUTIL_SOCKET_ERROR() == EINTR) {
             goto retry;
         }
-        lifxd_warn("can't broadcast discovery packet");
+        lgtd_warn("can't broadcast discovery packet");
     } else {
-        lifxd_warnx("can't broadcast discovery packet");
+        lgtd_warnx("can't broadcast discovery packet");
     }
     return false;
 }
 
 static void
-lifxd_broadcast_event_callback(evutil_socket_t socket, short events, void *ctx)
+lgtd_lifx_broadcast_event_callback(evutil_socket_t socket,
+                                   short events,
+                                   void *ctx)
 {
     (void)socket;
     (void)ctx;
 
     if (events & EV_TIMEOUT) {
         // not sure how that could happen but eh.
-        lifxd_warnx("timeout on the udp broadcast socket");
+        lgtd_warnx("timeout on the udp broadcast socket");
         goto error_reset;
     }
     if (events & EV_READ) {
-        if (!lifxd_broadcast_handle_read()) {
+        if (!lgtd_lifx_broadcast_handle_read()) {
             goto error_reset;
         }
     }
     if (events & EV_WRITE) {
-        if (!lifxd_broadcast_handle_write()) {
+        if (!lgtd_lifx_broadcast_handle_write()) {
             goto error_reset;
         }
     }
@@ -234,45 +238,47 @@
     return;
 
 error_reset:
-    lifxd_broadcast_close();
-    lifxd_broadcast_setup();
-    lifxd_broadcast_discovery();
+    lgtd_lifx_broadcast_close();
+    lgtd_lifx_broadcast_setup();
+    lgtd_lifx_broadcast_discovery();
 }
 
 void
-lifxd_broadcast_close(void)
+lgtd_lifx_broadcast_close(void)
 {
-    if (lifxd_broadcast_endpoint.read_ev) {
-        event_del(lifxd_broadcast_endpoint.read_ev);
-        event_free(lifxd_broadcast_endpoint.read_ev);
-        lifxd_broadcast_endpoint.read_ev = NULL;
+    if (lgtd_lifx_broadcast_endpoint.read_ev) {
+        event_del(lgtd_lifx_broadcast_endpoint.read_ev);
+        event_free(lgtd_lifx_broadcast_endpoint.read_ev);
+        lgtd_lifx_broadcast_endpoint.read_ev = NULL;
     }
-    if (lifxd_broadcast_endpoint.write_ev) {
-        event_del(lifxd_broadcast_endpoint.write_ev);
-        event_free(lifxd_broadcast_endpoint.write_ev);
-        lifxd_broadcast_endpoint.write_ev = NULL;
+    if (lgtd_lifx_broadcast_endpoint.write_ev) {
+        event_del(lgtd_lifx_broadcast_endpoint.write_ev);
+        event_free(lgtd_lifx_broadcast_endpoint.write_ev);
+        lgtd_lifx_broadcast_endpoint.write_ev = NULL;
     }
-    if (lifxd_broadcast_endpoint.socket != -1) {
-        evutil_closesocket(lifxd_broadcast_endpoint.socket);
-        lifxd_broadcast_endpoint.socket = -1;
+    if (lgtd_lifx_broadcast_endpoint.socket != -1) {
+        evutil_closesocket(lgtd_lifx_broadcast_endpoint.socket);
+        lgtd_lifx_broadcast_endpoint.socket = -1;
     }
 }
 
 bool
-lifxd_broadcast_setup(void)
+lgtd_lifx_broadcast_setup(void)
 {
-    assert(lifxd_broadcast_endpoint.socket == -1);
-    assert(lifxd_broadcast_endpoint.read_ev == NULL);
-    assert(lifxd_broadcast_endpoint.write_ev == NULL);
+    assert(lgtd_lifx_broadcast_endpoint.socket == -1);
+    assert(lgtd_lifx_broadcast_endpoint.read_ev == NULL);
+    assert(lgtd_lifx_broadcast_endpoint.write_ev == NULL);
 
-    lifxd_broadcast_endpoint.socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
-    if (lifxd_broadcast_endpoint.socket == -1) {
+    lgtd_lifx_broadcast_endpoint.socket = socket(
+        AF_INET, SOCK_DGRAM, IPPROTO_UDP
+    );
+    if (lgtd_lifx_broadcast_endpoint.socket == -1) {
         return false;
     }
 
     int val = 1;
     int err = setsockopt(
-        lifxd_broadcast_endpoint.socket,
+        lgtd_lifx_broadcast_endpoint.socket,
         SOL_SOCKET,
         SO_BROADCAST,
         &val,
@@ -282,18 +288,19 @@
         goto error;
     }
 
-    if (evutil_make_socket_nonblocking(lifxd_broadcast_endpoint.socket) == -1) {
+    err = evutil_make_socket_nonblocking(lgtd_lifx_broadcast_endpoint.socket);
+    if (err == -1) {
         goto error;
     }
 
     struct sockaddr_in lifx_addr = {
         .sin_family = AF_INET,
         .sin_addr = { INADDR_ANY },
-        .sin_port = htons(lifxd_opts.master_port)
+        .sin_port = htons(LGTD_LIFX_PROTOCOL_PORT)
     };
 
     err = bind(
-        lifxd_broadcast_endpoint.socket,
+        lgtd_lifx_broadcast_endpoint.socket,
         (const struct sockaddr *)&lifx_addr,
         sizeof(lifx_addr)
     );
@@ -301,40 +308,40 @@
         goto error;
     }
 
-    lifxd_broadcast_endpoint.read_ev = event_new(
-        lifxd_ev_base,
-        lifxd_broadcast_endpoint.socket,
+    lgtd_lifx_broadcast_endpoint.read_ev = event_new(
+        lgtd_ev_base,
+        lgtd_lifx_broadcast_endpoint.socket,
         EV_READ|EV_PERSIST,
-        lifxd_broadcast_event_callback,
+        lgtd_lifx_broadcast_event_callback,
         NULL
     );
-    lifxd_broadcast_endpoint.write_ev = event_new(
-        lifxd_ev_base,
-        lifxd_broadcast_endpoint.socket,
+    lgtd_lifx_broadcast_endpoint.write_ev = event_new(
+        lgtd_ev_base,
+        lgtd_lifx_broadcast_endpoint.socket,
         EV_WRITE|EV_PERSIST,
-        lifxd_broadcast_event_callback,
+        lgtd_lifx_broadcast_event_callback,
         NULL
     );
-    if (!lifxd_broadcast_endpoint.read_ev
-        || !lifxd_broadcast_endpoint.write_ev) {
+    if (!lgtd_lifx_broadcast_endpoint.read_ev
+        || !lgtd_lifx_broadcast_endpoint.write_ev) {
         goto error;
     }
 
-    if (!event_add(lifxd_broadcast_endpoint.read_ev, NULL)) {
+    if (!event_add(lgtd_lifx_broadcast_endpoint.read_ev, NULL)) {
         return true;
     }
 
     int errsave;
 error:
     errsave = errno;
-    lifxd_broadcast_close();
+    lgtd_lifx_broadcast_close();
     errno = errsave;
     return false;
 }
 
 bool
-lifxd_broadcast_discovery(void)
+lgtd_lifx_broadcast_discovery(void)
 {
-    assert(lifxd_broadcast_endpoint.write_ev);
-    return event_add(lifxd_broadcast_endpoint.write_ev, NULL) == 0;
+    assert(lgtd_lifx_broadcast_endpoint.write_ev);
+    return event_add(lgtd_lifx_broadcast_endpoint.write_ev, NULL) == 0;
 }
diff --git a/core/broadcast.h b/lifx/broadcast.h
rename from core/broadcast.h
rename to lifx/broadcast.h
--- a/core/broadcast.h
+++ b/lifx/broadcast.h
@@ -29,6 +29,6 @@
 
 #pragma once
 
-bool lifxd_broadcast_setup(void);
-void lifxd_broadcast_close(void);
-bool lifxd_broadcast_discovery(void);
+bool lgtd_lifx_broadcast_setup(void);
+void lgtd_lifx_broadcast_close(void);
+bool lgtd_lifx_broadcast_discovery(void);
diff --git a/core/bulb.c b/lifx/bulb.c
rename from core/bulb.c
rename to lifx/bulb.c
--- a/core/bulb.c
+++ b/lifx/bulb.c
@@ -40,56 +40,57 @@
 #include <event2/util.h>
 
 #include "wire_proto.h"
-#include "time_monotonic.h"
+#include "core/time_monotonic.h"
 #include "bulb.h"
 #include "gateway.h"
-#include "lifxd.h"
+#include "core/lightsd.h"
 
-struct lifxd_bulb_map lifxd_bulbs_table = RB_INITIALIZER(&lifxd_bulbs_table);
+struct lgtd_lifx_bulb_map lgtd_lifx_bulbs_table =
+    RB_INITIALIZER(&lgtd_lifx_bulbs_table);
 
-struct lifxd_bulb *
-lifxd_bulb_get(struct lifxd_gateway *gw, const uint8_t *addr)
+struct lgtd_lifx_bulb *
+lgtd_lifx_bulb_get(struct lgtd_lifx_gateway *gw, const uint8_t *addr)
 {
     assert(gw);
     assert(addr);
 
-    struct lifxd_bulb bulb;
+    struct lgtd_lifx_bulb bulb;
     memcpy(bulb.addr, addr, sizeof(bulb.addr));
-    return RB_FIND(lifxd_bulb_map, &lifxd_bulbs_table, &bulb);
+    return RB_FIND(lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table, &bulb);
 }
 
-struct lifxd_bulb *
-lifxd_bulb_open(struct lifxd_gateway *gw, const uint8_t *addr)
+struct lgtd_lifx_bulb *
+lgtd_lifx_bulb_open(struct lgtd_lifx_gateway *gw, const uint8_t *addr)
 {
     assert(gw);
     assert(addr);
 
-    struct lifxd_bulb *bulb = calloc(1, sizeof(*bulb));
+    struct lgtd_lifx_bulb *bulb = calloc(1, sizeof(*bulb));
     if (!bulb) {
-        lifxd_warn("can't allocate a new bulb");
+        lgtd_warn("can't allocate a new bulb");
         return NULL;
     }
 
     bulb->gw = gw;
     memcpy(bulb->addr, addr, sizeof(bulb->addr));
-    RB_INSERT(lifxd_bulb_map, &lifxd_bulbs_table, bulb);
+    RB_INSERT(lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table, bulb);
 
-    bulb->last_light_state_at = lifxd_time_monotonic_msecs();
+    bulb->last_light_state_at = lgtd_time_monotonic_msecs();
 
     return bulb;
 }
 
 void
-lifxd_bulb_close(struct lifxd_bulb *bulb)
+lgtd_lifx_bulb_close(struct lgtd_lifx_bulb *bulb)
 {
     assert(bulb);
     assert(bulb->gw);
 
-    RB_REMOVE(lifxd_bulb_map, &lifxd_bulbs_table, bulb);
-    SLIST_REMOVE(&bulb->gw->bulbs, bulb, lifxd_bulb, link_by_gw);
-    lifxd_info(
+    RB_REMOVE(lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table, bulb);
+    SLIST_REMOVE(&bulb->gw->bulbs, bulb, lgtd_lifx_bulb, link_by_gw);
+    lgtd_info(
         "closed bulb \"%.*s\" on [%s]:%hu",
-        LIFXD_LABEL_SIZE,
+        LGTD_LIFX_LABEL_SIZE,
         bulb->state.label,
         bulb->gw->ip_addr,
         bulb->gw->port
@@ -98,9 +99,9 @@
 }
 
 void
-lifxd_bulb_set_light_state(struct lifxd_bulb *bulb,
-                           const struct lifxd_light_state *state,
-                           lifxd_time_mono_t received_at)
+lgtd_lifx_bulb_set_light_state(struct lgtd_lifx_bulb *bulb,
+                               const struct lgtd_lifx_light_state *state,
+                               lgtd_time_mono_t received_at)
 {
     assert(bulb);
     assert(state);
@@ -109,7 +110,7 @@
 }
 
 void
-lifxd_bulb_set_power_state(struct lifxd_bulb *bulb, uint16_t power)
+lgtd_lifx_bulb_set_power_state(struct lgtd_lifx_bulb *bulb, uint16_t power)
 {
     assert(bulb);
     bulb->state.power = power;
diff --git a/core/bulb.h b/lifx/bulb.h
rename from core/bulb.h
rename to lifx/bulb.h
--- a/core/bulb.h
+++ b/lifx/bulb.h
@@ -29,52 +29,52 @@
 
 #pragma once
 
-struct lifxd_gateway;
+struct lgtd_lifx_gateway;
 
 #pragma pack(push, 1)
-struct lifxd_light_state {
+struct lgtd_lifx_light_state {
     uint16_t    hue;
     uint16_t    saturation;
     uint16_t    brightness;
     uint16_t    kelvin;
     uint16_t    dim;
     uint16_t    power;
-    char        label[LIFXD_LABEL_SIZE];
+    char        label[LGTD_LIFX_LABEL_SIZE];
     uint64_t    tags;
 };
 #pragma pack(pop)
 
-struct lifxd_bulb {
-    RB_ENTRY(lifxd_bulb)        link;
-    SLIST_ENTRY(lifxd_bulb)     link_by_gw;
-    struct lifxd_gateway        *gw;
-    uint8_t                     addr[LIFXD_ADDR_LENGTH];
-    struct lifxd_light_state    state;
-    lifxd_time_mono_t           last_light_state_at;
+struct lgtd_lifx_bulb {
+    RB_ENTRY(lgtd_lifx_bulb)        link;
+    SLIST_ENTRY(lgtd_lifx_bulb)     link_by_gw;
+    struct lgtd_lifx_gateway        *gw;
+    uint8_t                         addr[LGTD_LIFX_ADDR_LENGTH];
+    struct lgtd_lifx_light_state    state;
+    lgtd_time_mono_t                last_light_state_at;
 };
-RB_HEAD(lifxd_bulb_map, lifxd_bulb);
-SLIST_HEAD(lifxd_bulb_list, lifxd_bulb);
+RB_HEAD(lgtd_lifx_bulb_map, lgtd_lifx_bulb);
+SLIST_HEAD(lgtd_lifx_bulb_list, lgtd_lifx_bulb);
 
-extern struct lifxd_bulb_map lifxd_bulbs_table;
+extern struct lgtd_lifx_bulb_map lgtd_lifx_bulbs_table;
 
 static inline int
-lifxd_bulb_cmp(const struct lifxd_bulb *a, const struct lifxd_bulb *b)
+lgtd_lifx_bulb_cmp(const struct lgtd_lifx_bulb *a, const struct lgtd_lifx_bulb *b)
 {
     return memcmp(a->addr, b->addr, sizeof(a->addr));
 }
 
 RB_GENERATE_STATIC(
-    lifxd_bulb_map,
-    lifxd_bulb,
+    lgtd_lifx_bulb_map,
+    lgtd_lifx_bulb,
     link,
-    lifxd_bulb_cmp
+    lgtd_lifx_bulb_cmp
 );
 
-struct lifxd_bulb *lifxd_bulb_get(struct lifxd_gateway *, const uint8_t *);
-struct lifxd_bulb *lifxd_bulb_open(struct lifxd_gateway *, const uint8_t *);
-void lifxd_bulb_close(struct lifxd_bulb *);
+struct lgtd_lifx_bulb *lgtd_lifx_bulb_get(struct lgtd_lifx_gateway *, const uint8_t *);
+struct lgtd_lifx_bulb *lgtd_lifx_bulb_open(struct lgtd_lifx_gateway *, const uint8_t *);
+void lgtd_lifx_bulb_close(struct lgtd_lifx_bulb *);
 
-void lifxd_bulb_set_light_state(struct lifxd_bulb *,
-                                const struct lifxd_light_state *,
-                                lifxd_time_mono_t);
-void lifxd_bulb_set_power_state(struct lifxd_bulb *, uint16_t);
+void lgtd_lifx_bulb_set_light_state(struct lgtd_lifx_bulb *,
+                                    const struct lgtd_lifx_light_state *,
+                                    lgtd_time_mono_t);
+void lgtd_lifx_bulb_set_power_state(struct lgtd_lifx_bulb *, uint16_t);
diff --git a/core/gateway.c b/lifx/gateway.c
rename from core/gateway.c
rename to lifx/gateway.c
--- a/core/gateway.c
+++ b/lifx/gateway.c
@@ -45,18 +45,18 @@
 #include <event2/util.h>
 
 #include "wire_proto.h"
-#include "time_monotonic.h"
+#include "core/time_monotonic.h"
 #include "bulb.h"
 #include "gateway.h"
 #include "broadcast.h"
 #include "timer.h"
-#include "lifxd.h"
+#include "core/lightsd.h"
 
-struct lifxd_gateway_list lifxd_gateways =
-    LIST_HEAD_INITIALIZER(&lifxd_gateways);
+struct lgtd_lifx_gateway_list lgtd_lifx_gateways =
+    LIST_HEAD_INITIALIZER(&lgtd_lifx_gateways);
 
 void
-lifxd_gateway_close(struct lifxd_gateway *gw)
+lgtd_lifx_gateway_close(struct lgtd_lifx_gateway *gw)
 {
     assert(gw);
 
@@ -69,41 +69,43 @@
     event_free(gw->refresh_ev);
     event_free(gw->write_ev);
     evbuffer_free(gw->write_buf);
-    struct lifxd_bulb *bulb, *next_bulb;
+    struct lgtd_lifx_bulb *bulb, *next_bulb;
     SLIST_FOREACH_SAFE(bulb, &gw->bulbs, link_by_gw, next_bulb) {
-        lifxd_bulb_close(bulb);
+        lgtd_lifx_bulb_close(bulb);
     }
 
-    lifxd_info(
+    lgtd_info(
         "connection with gateway bulb [%s]:%hu closed", gw->ip_addr, gw->port
     );
     free(gw);
 }
 
 static void
-lifxd_gateway_write_callback(evutil_socket_t socket, short events, void *ctx)
+lgtd_lifx_gateway_write_callback(evutil_socket_t socket,
+                                 short events, void *ctx)
 {
     (void)socket;
 
     assert(ctx);
 
-    struct lifxd_gateway *gw = (struct lifxd_gateway *)ctx;
+    struct lgtd_lifx_gateway *gw = (struct lgtd_lifx_gateway *)ctx;
     if (events & EV_TIMEOUT) {  // Not sure how that could happen in UDP but eh.
-        lifxd_warn(
+        lgtd_warn(
             "lost connection with gateway bulb [%s]:%hu", gw->ip_addr, gw->port
         );
-        lifxd_gateway_close(gw);
-        if (!lifxd_broadcast_discovery()) {
-            lifxd_err(1, "can't start auto discovery");
+        lgtd_lifx_gateway_close(gw);
+        if (!lgtd_lifx_broadcast_discovery()) {
+            lgtd_err(1, "can't start auto discovery");
         }
         return;
     }
     if (events & EV_WRITE) {
-        if (evbuffer_write(gw->write_buf, gw->socket) == -1 && errno != EAGAIN) {
-            lifxd_warn("can't write to [%s]:%hu", gw->ip_addr, gw->port);
-            lifxd_gateway_close(gw);
-            if (!lifxd_broadcast_discovery()) {
-                lifxd_err(1, "can't start auto discovery");
+        int nbytes = evbuffer_write(gw->write_buf, gw->socket);
+        if (nbytes == -1 && errno != EAGAIN) {
+            lgtd_warn("can't write to [%s]:%hu", gw->ip_addr, gw->port);
+            lgtd_lifx_gateway_close(gw);
+            if (!lgtd_lifx_broadcast_discovery()) {
+                lgtd_err(1, "can't start auto discovery");
             }
             return;
         }
@@ -112,7 +114,7 @@
         // latency with last_pkt_at < last_req_at, which isn't true since the
         // pkt will be for an answer the previous write:
         gw->last_req_at = gw->next_req_at;
-        gw->next_req_at = lifxd_time_monotonic_msecs();
+        gw->next_req_at = lgtd_time_monotonic_msecs();
         if (!evbuffer_get_length(gw->write_buf)) {
             event_del(gw->write_ev);
         }
@@ -120,109 +122,112 @@
 }
 
 static void
-lifxd_gateway_send_get_all_light_state(struct lifxd_gateway *gw)
+lgtd_lifx_gateway_send_get_all_light_state(struct lgtd_lifx_gateway *gw)
 {
     assert(gw);
 
-    struct lifxd_packet_header hdr;
-    union lifxd_target target = { .addr = gw->site };
-    lifxd_wire_setup_header(
-        &hdr, LIFXD_TARGET_SITE, target, gw->site, LIFXD_GET_LIGHT_STATE
+    struct lgtd_lifx_packet_header hdr;
+    union lgtd_lifx_target target = { .addr = gw->site };
+    lgtd_lifx_wire_setup_header(
+        &hdr, LGTD_LIFX_TARGET_SITE, target, gw->site, LGTD_LIFX_GET_LIGHT_STATE
     );
-    lifxd_debug("GET_LIGHT_STATE --> [%s]:%hu", gw->ip_addr, gw->port);
-    lifxd_gateway_send_packet(gw, &hdr, NULL, 0);
+    lgtd_debug("GET_LIGHT_STATE --> [%s]:%hu", gw->ip_addr, gw->port);
+    lgtd_lifx_gateway_send_packet(gw, &hdr, NULL, 0);
 }
 
 static void
-lifxd_gateway_refresh_callback(evutil_socket_t socket, short events, void *ctx)
+lgtd_lifx_gateway_refresh_callback(evutil_socket_t socket,
+                                   short events,
+                                   void *ctx)
 {
     (void)socket;
     (void)events;
-    lifxd_gateway_send_get_all_light_state((struct lifxd_gateway *)ctx);
+    lgtd_lifx_gateway_send_get_all_light_state((struct lgtd_lifx_gateway *)ctx);
 }
 
-static struct lifxd_bulb *
-lifxd_gateway_get_or_open_bulb(struct lifxd_gateway *gw, const uint8_t *bulb_addr)
+static struct lgtd_lifx_bulb *
+lgtd_lifx_gateway_get_or_open_bulb(struct lgtd_lifx_gateway *gw,
+                                   const uint8_t *bulb_addr)
 {
     assert(gw);
     assert(bulb_addr);
 
-    struct lifxd_bulb *bulb = lifxd_bulb_get(gw, bulb_addr);
+    struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_get(gw, bulb_addr);
     if (!bulb) {
-        bulb = lifxd_bulb_open(gw, bulb_addr);
+        bulb = lgtd_lifx_bulb_open(gw, bulb_addr);
         if (bulb) {
             SLIST_INSERT_HEAD(&gw->bulbs, bulb, link_by_gw);
-            lifxd_info(
+            lgtd_info(
                 "bulb %s on [%s]:%hu",
-                lifxd_addrtoa(bulb_addr), gw->ip_addr, gw->port
+                lgtd_addrtoa(bulb_addr), gw->ip_addr, gw->port
             );
         }
     }
     return bulb;
 }
 
-struct lifxd_gateway *
-lifxd_gateway_open(const struct sockaddr_storage *peer,
-                   ev_socklen_t addrlen,
-                   const uint8_t *site,
-                   lifxd_time_mono_t received_at)
+struct lgtd_lifx_gateway *
+lgtd_lifx_gateway_open(const struct sockaddr_storage *peer,
+                       ev_socklen_t addrlen,
+                       const uint8_t *site,
+                       lgtd_time_mono_t received_at)
 {
     assert(peer);
     assert(site);
 
-    struct lifxd_gateway *gw = calloc(1, sizeof(*gw));
+    struct lgtd_lifx_gateway *gw = calloc(1, sizeof(*gw));
     if (!gw) {
-        lifxd_warn("can't allocate a new gateway bulb");
+        lgtd_warn("can't allocate a new gateway bulb");
         return false;
     }
     gw->socket = socket(peer->ss_family, SOCK_DGRAM, IPPROTO_UDP);
     if (gw->socket == -1) {
-        lifxd_warn("can't open a new socket");
+        lgtd_warn("can't open a new socket");
         goto error_socket;
     }
     if (connect(gw->socket, (const struct sockaddr *)peer, addrlen) == -1
         || evutil_make_socket_nonblocking(gw->socket) == -1) {
-        lifxd_warn("can't open a new socket");
+        lgtd_warn("can't open a new socket");
         goto error_connect;
     }
     gw->write_ev = event_new(
-        lifxd_ev_base,
+        lgtd_ev_base,
         gw->socket,
         EV_WRITE|EV_PERSIST,
-        lifxd_gateway_write_callback,
+        lgtd_lifx_gateway_write_callback,
         gw
     );
     gw->write_buf = evbuffer_new();
     gw->refresh_ev = evtimer_new(
-        lifxd_ev_base, lifxd_gateway_refresh_callback, gw
+        lgtd_ev_base, lgtd_lifx_gateway_refresh_callback, gw
     );
     memcpy(&gw->peer, peer, sizeof(gw->peer));
-    lifxd_sockaddrtoa(peer, gw->ip_addr, sizeof(gw->ip_addr));
-    gw->port = lifxd_sockaddrport(peer);
+    lgtd_sockaddrtoa(peer, gw->ip_addr, sizeof(gw->ip_addr));
+    gw->port = lgtd_sockaddrport(peer);
     memcpy(gw->site, site, sizeof(gw->site));
     gw->last_req_at = received_at;
     gw->next_req_at = received_at;
     gw->last_pkt_at = received_at;
 
-    struct timeval refresh_interval = LIFXD_MSECS_TO_TIMEVAL(
-        LIFXD_GATEWAY_MIN_REFRESH_INTERVAL_MSECS
+    struct timeval refresh_interval = LGTD_MSECS_TO_TIMEVAL(
+        LGTD_LIFX_GATEWAY_MIN_REFRESH_INTERVAL_MSECS
     );
 
     if (!gw->write_ev || !gw->write_buf || !gw->refresh_ev
         || event_add(gw->refresh_ev, &refresh_interval) != 0) {
-        lifxd_warn("can't allocate a new gateway bulb");
+        lgtd_warn("can't allocate a new gateway bulb");
         goto error_allocate;
     }
 
-    lifxd_info(
+    lgtd_info(
         "gateway for site %s at [%s]:%hu",
-        lifxd_addrtoa(gw->site), gw->ip_addr, gw->port
+        lgtd_addrtoa(gw->site), gw->ip_addr, gw->port
     );
-    LIST_INSERT_HEAD(&lifxd_gateways, gw, link);
+    LIST_INSERT_HEAD(&lgtd_lifx_gateways, gw, link);
 
     // In case this is the first bulb (re-)discovered, start the watchdog, it
     // will stop by itself:
-    lifxd_timer_start_watchdog();
+    lgtd_lifx_timer_start_watchdog();
 
     return gw;
 
@@ -243,13 +248,13 @@
     return NULL;
 }
 
-struct lifxd_gateway *
-lifxd_gateway_get(const struct sockaddr_storage *peer)
+struct lgtd_lifx_gateway *
+lgtd_lifx_gateway_get(const struct sockaddr_storage *peer)
 {
     assert(peer);
 
-    struct lifxd_gateway *gw, *next_gw;
-    LIST_FOREACH_SAFE(gw, &lifxd_gateways, link, next_gw) {
+    struct lgtd_lifx_gateway *gw, *next_gw;
+    LIST_FOREACH_SAFE(gw, &lgtd_lifx_gateways, link, next_gw) {
         if (peer->ss_family == gw->peer.ss_family
             && !memcmp(&gw->peer, peer, sizeof(*peer))) {
             return gw;
@@ -260,24 +265,24 @@
 }
 
 void
-lifxd_gateway_close_all(void)
+lgtd_lifx_gateway_close_all(void)
 {
-    struct lifxd_gateway *gw, *next_gw;
-    LIST_FOREACH_SAFE(gw, &lifxd_gateways, link, next_gw) {
-        lifxd_gateway_close(gw);
+    struct lgtd_lifx_gateway *gw, *next_gw;
+    LIST_FOREACH_SAFE(gw, &lgtd_lifx_gateways, link, next_gw) {
+        lgtd_lifx_gateway_close(gw);
     }
 }
 
 void
-lifxd_gateway_send_packet(struct lifxd_gateway *gw,
-                          const struct lifxd_packet_header *hdr,
-                          const void *pkt,
-                          int pkt_size)
+lgtd_lifx_gateway_send_packet(struct lgtd_lifx_gateway *gw,
+                              const struct lgtd_lifx_packet_header *hdr,
+                              const void *pkt,
+                              int pkt_size)
 {
     assert(gw);
     assert(hdr);
-    assert(pkt_size >= 0 && pkt_size < LIFXD_MAX_PACKET_SIZE);
-    assert(!memcmp(hdr->site, gw->site, LIFXD_ADDR_LENGTH));
+    assert(pkt_size >= 0 && pkt_size < LGTD_LIFX_MAX_PACKET_SIZE);
+    assert(!memcmp(hdr->site, gw->site, LGTD_LIFX_ADDR_LENGTH));
 
     evbuffer_add(gw->write_buf, hdr, sizeof(*hdr));
     if (pkt) {
@@ -288,37 +293,37 @@
 }
 
 void
-lifxd_gateway_handle_pan_gateway(struct lifxd_gateway *gw,
-                                 const struct lifxd_packet_header *hdr,
-                                 const struct lifxd_packet_pan_gateway *pkt)
+lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *gw,
+                                     const struct lgtd_lifx_packet_header *hdr,
+                                     const struct lgtd_lifx_packet_pan_gateway *pkt)
 {
     assert(gw && hdr && pkt);
 
-    lifxd_debug(
+    lgtd_debug(
         "SET_PAN_GATEWAY <-- [%s]:%hu - %s site=%s",
         gw->ip_addr, gw->port,
-        lifxd_addrtoa(hdr->target.device_addr),
-        lifxd_addrtoa(hdr->site)
+        lgtd_addrtoa(hdr->target.device_addr),
+        lgtd_addrtoa(hdr->site)
     );
 }
 
 void
-lifxd_gateway_handle_light_status(struct lifxd_gateway *gw,
-                                  const struct lifxd_packet_header *hdr,
-                                  const struct lifxd_packet_light_status *pkt)
+lgtd_lifx_gateway_handle_light_status(struct lgtd_lifx_gateway *gw,
+                                      const struct lgtd_lifx_packet_header *hdr,
+                                      const struct lgtd_lifx_packet_light_status *pkt)
 {
     assert(gw && hdr && pkt);
 
-    lifxd_debug(
+    lgtd_debug(
         "SET_LIGHT_STATE <-- [%s]:%hu - %s "
         "hue=%#hx, saturation=%#hx, brightness=%#hx, "
         "kelvin=%d, dim=%#hx, power=%#hx, label=%.*s, tags=%#llx",
-        gw->ip_addr, gw->port, lifxd_addrtoa(hdr->target.device_addr),
+        gw->ip_addr, gw->port, lgtd_addrtoa(hdr->target.device_addr),
         pkt->hue, pkt->saturation, pkt->brightness, pkt->kelvin,
-        pkt->dim, pkt->power, LIFXD_LABEL_SIZE, pkt->label, pkt->tags
+        pkt->dim, pkt->power, LGTD_LIFX_LABEL_SIZE, pkt->label, pkt->tags
     );
 
-    struct lifxd_bulb *b = lifxd_gateway_get_or_open_bulb(
+    struct lgtd_lifx_bulb *b = lgtd_lifx_gateway_get_or_open_bulb(
         gw, hdr->target.device_addr
     );
     if (!b) {
@@ -326,47 +331,47 @@
     }
 
     assert(sizeof(*pkt) == sizeof(b->state));
-    lifxd_bulb_set_light_state(
-        b, (const struct lifxd_light_state *)pkt, gw->last_pkt_at
+    lgtd_lifx_bulb_set_light_state(
+        b, (const struct lgtd_lifx_light_state *)pkt, gw->last_pkt_at
     );
 
     int latency = gw->last_pkt_at - gw->last_req_at;
-    if (latency < LIFXD_GATEWAY_MIN_REFRESH_INTERVAL_MSECS) {
-        int timeout = LIFXD_GATEWAY_MIN_REFRESH_INTERVAL_MSECS - latency;
-        struct timeval tv = LIFXD_MSECS_TO_TIMEVAL(timeout);
+    if (latency < LGTD_LIFX_GATEWAY_MIN_REFRESH_INTERVAL_MSECS) {
+        int timeout = LGTD_LIFX_GATEWAY_MIN_REFRESH_INTERVAL_MSECS - latency;
+        struct timeval tv = LGTD_MSECS_TO_TIMEVAL(timeout);
         evtimer_add(gw->refresh_ev, &tv);
-        lifxd_debug(
+        lgtd_debug(
             "[%s]:%hu latency is %dms, scheduling next GET_LIGHT_STATE in %dms",
             gw->ip_addr, gw->port, latency, timeout
         );
         return;
     }
 
-    lifxd_debug(
+    lgtd_debug(
         "[%s]:%hu latency is %dms, sending GET_LIGHT_STATE now",
         gw->ip_addr, gw->port, latency
     );
-    lifxd_gateway_send_get_all_light_state(gw);
+    lgtd_lifx_gateway_send_get_all_light_state(gw);
 }
 
 void
-lifxd_gateway_handle_power_state(struct lifxd_gateway *gw,
-                                 const struct lifxd_packet_header *hdr,
-                                 const struct lifxd_packet_power_state *pkt)
+lgtd_lifx_gateway_handle_power_state(struct lgtd_lifx_gateway *gw,
+                                     const struct lgtd_lifx_packet_header *hdr,
+                                     const struct lgtd_lifx_packet_power_state *pkt)
 {
     assert(gw && hdr && pkt);
 
-    lifxd_debug(
+    lgtd_debug(
         "SET_POWER_STATE <-- [%s]:%hu - %s power=%#hx",
-        gw->ip_addr, gw->port, lifxd_addrtoa(hdr->target.device_addr), pkt->power
+        gw->ip_addr, gw->port, lgtd_addrtoa(hdr->target.device_addr), pkt->power
     );
 
-    struct lifxd_bulb *b = lifxd_gateway_get_or_open_bulb(
+    struct lgtd_lifx_bulb *b = lgtd_lifx_gateway_get_or_open_bulb(
         gw, hdr->target.device_addr
     );
     if (!b) {
         return;
     }
 
-    lifxd_bulb_set_power_state(b, pkt->power);
+    lgtd_lifx_bulb_set_power_state(b, pkt->power);
 }
diff --git a/core/gateway.h b/lifx/gateway.h
rename from core/gateway.h
rename to lifx/gateway.h
--- a/core/gateway.h
+++ b/lifx/gateway.h
@@ -33,56 +33,56 @@
 // according to my own tests, aggressively polling a bulb doesn't raise its
 // consumption at all (and it's interesting to note that a turned off bulb
 // still draw about 2W in ZigBee and about 3W in WiFi).
-enum { LIFXD_GATEWAY_MIN_REFRESH_INTERVAL_MSECS = 200 };
+enum { LGTD_LIFX_GATEWAY_MIN_REFRESH_INTERVAL_MSECS = 200 };
 
-struct lifxd_gateway {
-    LIST_ENTRY(lifxd_gateway)   link;
-    struct lifxd_bulb_list      bulbs;
+struct lgtd_lifx_gateway {
+    LIST_ENTRY(lgtd_lifx_gateway)   link;
+    struct lgtd_lifx_bulb_list      bulbs;
     // Multiple gateways can share the same site (that happens when bulbs are
     // far away enough that ZigBee can't be used). Moreover the SET_PAN_GATEWAY
     // packet doesn't include the device address in the header (i.e: site and
     // device_addr have the same value) so we have no choice but to use the
     // remote ip address to identify a gateway:
-    struct sockaddr_storage     peer;
-    char                        ip_addr[INET6_ADDRSTRLEN];
-    uint16_t                    port;
-    uint8_t                     site[LIFXD_ADDR_LENGTH];
-    evutil_socket_t             socket;
+    struct sockaddr_storage         peer;
+    char                            ip_addr[INET6_ADDRSTRLEN];
+    uint16_t                        port;
+    uint8_t                         site[LGTD_LIFX_ADDR_LENGTH];
+    evutil_socket_t                 socket;
     // Those three timers let us measure the latency of the gateway. If we
     // aren't the only client on the network then this won't be accurate since
     // we will get pushed packets we didn't ask for, but good enough for our
     // purpose of rate limiting our requests to the gateway:
-    lifxd_time_mono_t           last_req_at;
-    lifxd_time_mono_t           next_req_at;
-    lifxd_time_mono_t           last_pkt_at;
-    struct event                *write_ev;
-    struct evbuffer             *write_buf;
-    struct event                *refresh_ev;
+    lgtd_time_mono_t                last_req_at;
+    lgtd_time_mono_t                next_req_at;
+    lgtd_time_mono_t                last_pkt_at;
+    struct event                    *write_ev;
+    struct evbuffer                 *write_buf;
+    struct event                    *refresh_ev;
 };
-LIST_HEAD(lifxd_gateway_list, lifxd_gateway);
+LIST_HEAD(lgtd_lifx_gateway_list, lgtd_lifx_gateway);
 
-extern struct lifxd_gateway_list lifxd_gateways;
+extern struct lgtd_lifx_gateway_list lgtd_lifx_gateways;
 
-struct lifxd_gateway *lifxd_gateway_get(const struct sockaddr_storage *);
-struct lifxd_gateway *lifxd_gateway_open(const struct sockaddr_storage *,
-                                         ev_socklen_t,
-                                         const uint8_t *,
-                                         lifxd_time_mono_t);
+struct lgtd_lifx_gateway *lgtd_lifx_gateway_get(const struct sockaddr_storage *);
+struct lgtd_lifx_gateway *lgtd_lifx_gateway_open(const struct sockaddr_storage *,
+                                                 ev_socklen_t,
+                                                 const uint8_t *,
+                                                 lgtd_time_mono_t);
 
-void lifxd_gateway_close(struct lifxd_gateway *);
-void lifxd_gateway_close_all(void);
+void lgtd_lifx_gateway_close(struct lgtd_lifx_gateway *);
+void lgtd_lifx_gateway_close_all(void);
 
-void lifxd_gateway_send_packet(struct lifxd_gateway *,
-                               const struct lifxd_packet_header *,
-                               const void *,
-                               int);
+void lgtd_lifx_gateway_send_packet(struct lgtd_lifx_gateway *,
+                                   const struct lgtd_lifx_packet_header *,
+                                   const void *,
+                                   int);
 
-void lifxd_gateway_handle_pan_gateway(struct lifxd_gateway *,
-                                      const struct lifxd_packet_header *,
-                                      const struct lifxd_packet_pan_gateway *);
-void lifxd_gateway_handle_light_status(struct lifxd_gateway *,
-                                       const struct lifxd_packet_header *,
-                                       const struct lifxd_packet_light_status *);
-void lifxd_gateway_handle_power_state(struct lifxd_gateway *,
-                                      const struct lifxd_packet_header *,
-                                      const struct lifxd_packet_power_state *);
+void lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *,
+                                          const struct lgtd_lifx_packet_header *,
+                                          const struct lgtd_lifx_packet_pan_gateway *);
+void lgtd_lifx_gateway_handle_light_status(struct lgtd_lifx_gateway *,
+                                           const struct lgtd_lifx_packet_header *,
+                                           const struct lgtd_lifx_packet_light_status *);
+void lgtd_lifx_gateway_handle_power_state(struct lgtd_lifx_gateway *,
+                                          const struct lgtd_lifx_packet_header *,
+                                          const struct lgtd_lifx_packet_power_state *);
diff --git a/core/timer.c b/lifx/timer.c
rename from core/timer.c
rename to lifx/timer.c
--- a/core/timer.c
+++ b/lifx/timer.c
@@ -39,69 +39,74 @@
 #include <event2/util.h>
 
 #include "wire_proto.h"
-#include "time_monotonic.h"
+#include "core/time_monotonic.h"
 #include "broadcast.h"
 #include "bulb.h"
 #include "gateway.h"
 #include "timer.h"
-#include "lifxd.h"
+#include "core/lightsd.h"
 
 static struct {
     struct event *watchdog_interval_ev;
     struct event *discovery_timeout_ev;
-} lifxd_timer_context = {
+} lgtd_lifx_timer_context = {
     .watchdog_interval_ev = NULL,
     .discovery_timeout_ev = NULL
 };
 
 static void
-lifxd_timer_discovery_timeout_event_callback(evutil_socket_t socket,
-                                             short events,
-                                             void *ctx)
+lgtd_lifx_timer_discovery_timeout_event_callback(evutil_socket_t socket,
+                                                 short events,
+                                                 void *ctx)
 {
     (void)socket;
     (void)events;
     (void)ctx;
 
-    int timeout = LIFXD_TIMER_PASSIVE_DISCOVERY_INTERVAL_MSECS;
-    if (LIST_EMPTY(&lifxd_gateways)) {
-        lifxd_debug(
+    int timeout = LGTD_LIFX_TIMER_PASSIVE_DISCOVERY_INTERVAL_MSECS;
+    if (LIST_EMPTY(&lgtd_lifx_gateways)) {
+        lgtd_debug(
             "discovery didn't returned anything in %dms, restarting it",
-            LIFXD_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS
+            LGTD_LIFX_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS
         );
-        timeout = LIFXD_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS;
+        timeout = LGTD_LIFX_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS;
     } else {
-        lifxd_debug("sending periodic discovery packet");
+        lgtd_debug("sending periodic discovery packet");
     }
 
-    struct timeval tv = LIFXD_MSECS_TO_TIMEVAL(timeout);
-    if (event_add(lifxd_timer_context.discovery_timeout_ev, &tv)
-        || !lifxd_broadcast_discovery()) {
-        lifxd_err(1, "can't start discovery");
+    struct timeval tv = LGTD_MSECS_TO_TIMEVAL(timeout);
+    if (event_add(lgtd_lifx_timer_context.discovery_timeout_ev, &tv)
+        || !lgtd_lifx_broadcast_discovery()) {
+        lgtd_err(1, "can't start discovery");
     }
 }
 
 static void
-lifxd_timer_watchdog_timeout_event_callback(evutil_socket_t socket,
-                                            short events,
-                                            void *ctx)
+lgtd_lifx_timer_watchdog_timeout_event_callback(evutil_socket_t socket,
+                                                short events,
+                                                void *ctx)
 {
     (void)socket;
     (void)events;
     (void)ctx;
 
     bool start_discovery = false;
-    lifxd_time_mono_t now = lifxd_time_monotonic_msecs();
+    lgtd_time_mono_t now = lgtd_time_monotonic_msecs();
 
-    struct lifxd_bulb *bulb, *next_bulb;
-    RB_FOREACH_SAFE(bulb, lifxd_bulb_map, &lifxd_bulbs_table, next_bulb) {
+    struct lgtd_lifx_bulb *bulb, *next_bulb;
+    RB_FOREACH_SAFE(
+        bulb,
+        lgtd_lifx_bulb_map,
+        &lgtd_lifx_bulbs_table,
+        next_bulb
+    ) {
         int light_state_lag = now - bulb->last_light_state_at;
-        if (light_state_lag >= LIFXD_TIMER_DEVICE_TIMEOUT_MSECS) {
-            lifxd_info(
+        if (light_state_lag >= LGTD_LIFX_TIMER_DEVICE_TIMEOUT_MSECS) {
+            lgtd_info(
                 "closing bulb \"%.*s\" that hasn't been updated for %dms",
-                LIFXD_LABEL_SIZE, bulb->state.label, light_state_lag
+                LGTD_LIFX_LABEL_SIZE, bulb->state.label, light_state_lag
             );
-            lifxd_bulb_close(bulb);
+            lgtd_lifx_bulb_close(bulb);
             start_discovery = true;
         }
     }
@@ -109,17 +114,17 @@
     // Repeat for the gateways, we could also look if we are removing the last
     // bulb on the gateway but this will also support architectures where
     // gateways aren't bulbs themselves:
-    struct lifxd_gateway *gw, *next_gw;
-    LIST_FOREACH_SAFE(gw, &lifxd_gateways, link, next_gw) {
+    struct lgtd_lifx_gateway *gw, *next_gw;
+    LIST_FOREACH_SAFE(gw, &lgtd_lifx_gateways, link, next_gw) {
         int gw_lag = now - gw->last_pkt_at;
-        if (gw_lag >= LIFXD_TIMER_DEVICE_TIMEOUT_MSECS) {
-            lifxd_info(
+        if (gw_lag >= LGTD_LIFX_TIMER_DEVICE_TIMEOUT_MSECS) {
+            lgtd_info(
                 "closing bulb gateway [%s]:%hu that "
                 "hasn't received traffic for %dms",
                 gw->ip_addr, gw->port,
                 gw_lag
             );
-            lifxd_gateway_close(gw);
+            lgtd_lifx_gateway_close(gw);
             start_discovery = true;
         }
     }
@@ -127,83 +132,87 @@
     // If anything happens restart a discovery right away, maybe something just
     // moved on the network:
     if (start_discovery) {
-        lifxd_broadcast_discovery();
+        lgtd_lifx_broadcast_discovery();
     }
 }
 
 bool
-lifxd_timer_setup(void)
+lgtd_lifx_timer_setup(void)
 {
-    assert(!lifxd_timer_context.watchdog_interval_ev);
-    assert(!lifxd_timer_context.discovery_timeout_ev);
+    assert(!lgtd_lifx_timer_context.watchdog_interval_ev);
+    assert(!lgtd_lifx_timer_context.discovery_timeout_ev);
 
-    lifxd_timer_context.discovery_timeout_ev = event_new(
-        lifxd_ev_base,
+    lgtd_lifx_timer_context.discovery_timeout_ev = event_new(
+        lgtd_ev_base,
         -1,
         0,
-        lifxd_timer_discovery_timeout_event_callback,
+        lgtd_lifx_timer_discovery_timeout_event_callback,
         NULL
     );
-    lifxd_timer_context.watchdog_interval_ev = event_new(
-        lifxd_ev_base,
+    lgtd_lifx_timer_context.watchdog_interval_ev = event_new(
+        lgtd_ev_base,
         -1,
         EV_PERSIST,
-        lifxd_timer_watchdog_timeout_event_callback,
+        lgtd_lifx_timer_watchdog_timeout_event_callback,
         NULL
     );
 
-    if (lifxd_timer_context.discovery_timeout_ev
-        && lifxd_timer_context.watchdog_interval_ev) {
+    if (lgtd_lifx_timer_context.discovery_timeout_ev
+        && lgtd_lifx_timer_context.watchdog_interval_ev) {
         return true;
     }
 
     int errsave = errno;
-    lifxd_timer_close();
+    lgtd_lifx_timer_close();
     errno = errsave;
     return false;
 }
 
 void
-lifxd_timer_close(void)
+lgtd_lifx_timer_close(void)
 {
-    if (lifxd_timer_context.discovery_timeout_ev) {
-        event_del(lifxd_timer_context.discovery_timeout_ev);
-        event_free(lifxd_timer_context.discovery_timeout_ev);
-        lifxd_timer_context.discovery_timeout_ev = NULL;
+    if (lgtd_lifx_timer_context.discovery_timeout_ev) {
+        event_del(lgtd_lifx_timer_context.discovery_timeout_ev);
+        event_free(lgtd_lifx_timer_context.discovery_timeout_ev);
+        lgtd_lifx_timer_context.discovery_timeout_ev = NULL;
     }
-    if (lifxd_timer_context.watchdog_interval_ev) {
-        event_del(lifxd_timer_context.watchdog_interval_ev);
-        event_free(lifxd_timer_context.watchdog_interval_ev);
-        lifxd_timer_context.watchdog_interval_ev = NULL;
+    if (lgtd_lifx_timer_context.watchdog_interval_ev) {
+        event_del(lgtd_lifx_timer_context.watchdog_interval_ev);
+        event_free(lgtd_lifx_timer_context.watchdog_interval_ev);
+        lgtd_lifx_timer_context.watchdog_interval_ev = NULL;
     }
 }
 
 void
-lifxd_timer_start_watchdog(void)
+lgtd_lifx_timer_start_watchdog(void)
 {
-    assert(!RB_EMPTY(&lifxd_bulbs_table) || !LIST_EMPTY(&lifxd_gateways));
+    assert(
+        !RB_EMPTY(&lgtd_lifx_bulbs_table) || !LIST_EMPTY(&lgtd_lifx_gateways)
+    );
 
-    if (!evtimer_pending(lifxd_timer_context.watchdog_interval_ev, NULL)) {
-        struct timeval tv = LIFXD_MSECS_TO_TIMEVAL(
-            LIFXD_TIMER_WATCHDOG_INTERVAL_MSECS
+    if (!evtimer_pending(lgtd_lifx_timer_context.watchdog_interval_ev, NULL)) {
+        struct timeval tv = LGTD_MSECS_TO_TIMEVAL(
+            LGTD_LIFX_TIMER_WATCHDOG_INTERVAL_MSECS
         );
-        if (event_add(lifxd_timer_context.watchdog_interval_ev, &tv)) {
-            lifxd_err(1, "can't start watchdog");
+        if (event_add(lgtd_lifx_timer_context.watchdog_interval_ev, &tv)) {
+            lgtd_err(1, "can't start watchdog");
         }
-        lifxd_debug("starting watchdog timer");
+        lgtd_debug("starting watchdog timer");
     }
 }
 
 void
-lifxd_timer_start_discovery(void)
+lgtd_lifx_timer_start_discovery(void)
 {
-    assert(!evtimer_pending(lifxd_timer_context.discovery_timeout_ev, NULL));
+    assert(!evtimer_pending(
+        lgtd_lifx_timer_context.discovery_timeout_ev, NULL
+    ));
 
-    struct timeval tv = LIFXD_MSECS_TO_TIMEVAL(
-        LIFXD_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS
+    struct timeval tv = LGTD_MSECS_TO_TIMEVAL(
+        LGTD_LIFX_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS
     );
-    if (event_add(lifxd_timer_context.discovery_timeout_ev, &tv)) {
-        lifxd_err(1, "can't start discovery timer");
+    if (event_add(lgtd_lifx_timer_context.discovery_timeout_ev, &tv)) {
+        lgtd_err(1, "can't start discovery timer");
     }
-    lifxd_debug("starting discovery timer");
+    lgtd_debug("starting discovery timer");
 }
diff --git a/core/timer.h b/lifx/timer.h
rename from core/timer.h
rename to lifx/timer.h
--- a/core/timer.h
+++ b/lifx/timer.h
@@ -29,12 +29,12 @@
 
 #pragma once
 
-enum { LIFXD_TIMER_WATCHDOG_INTERVAL_MSECS = 200 };
-enum { LIFXD_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS = 2000 };
-enum { LIFXD_TIMER_PASSIVE_DISCOVERY_INTERVAL_MSECS = 10000 };
-enum { LIFXD_TIMER_DEVICE_TIMEOUT_MSECS = 2000 };
+enum { LGTD_LIFX_TIMER_WATCHDOG_INTERVAL_MSECS = 200 };
+enum { LGTD_LIFX_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS = 2000 };
+enum { LGTD_LIFX_TIMER_PASSIVE_DISCOVERY_INTERVAL_MSECS = 10000 };
+enum { LGTD_LIFX_TIMER_DEVICE_TIMEOUT_MSECS = 2000 };
 
-bool lifxd_timer_setup(void);
-void lifxd_timer_close(void);
-void lifxd_timer_start_watchdog(void);
-void lifxd_timer_start_discovery(void);
+bool lgtd_lifx_timer_setup(void);
+void lgtd_lifx_timer_close(void);
+void lgtd_lifx_timer_start_watchdog(void);
+void lgtd_lifx_timer_start_discovery(void);
diff --git a/core/wire_proto.c b/lifx/wire_proto.c
rename from core/wire_proto.c
rename to lifx/wire_proto.c
--- a/core/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -42,33 +42,33 @@
 #include <event2/util.h>
 
 #include "wire_proto.h"
-#include "time_monotonic.h"
+#include "core/time_monotonic.h"
 #include "bulb.h"
 #include "gateway.h"
-#include "lifxd.h"
+#include "core/lightsd.h"
 
-union lifxd_target LIFXD_UNSPEC_TARGET = { .tags = 0 };
+union lgtd_lifx_target LGTD_LIFX_UNSPEC_TARGET = { .tags = 0 };
 
-static struct lifxd_packet_infos_map lifxd_packet_infos =
-    RB_INITIALIZER(&lifxd_packets_infos);
+static struct lgtd_lifx_packet_infos_map lgtd_lifx_packet_infos =
+    RB_INITIALIZER(&lgtd_lifx_packets_infos);
 
 RB_GENERATE_STATIC(
-    lifxd_packet_infos_map,
-    lifxd_packet_infos,
+    lgtd_lifx_packet_infos_map,
+    lgtd_lifx_packet_infos,
     link,
-    lifxd_packet_infos_cmp
+    lgtd_lifx_packet_infos_cmp
 );
 
 static void
-lifxd_wire_null_packet_encoder_decoder(void *pkt)
+lgtd_lifx_wire_null_packet_encoder_decoder(void *pkt)
 {
     (void)pkt;
 }
 
 static void
-lifxd_wire_null_packet_handler(struct lifxd_gateway *gw,
-                               const struct lifxd_packet_header *hdr,
-                               const void *pkt)
+lgtd_lifx_wire_null_packet_handler(struct lgtd_lifx_gateway *gw,
+                                   const struct lgtd_lifx_packet_header *hdr,
+                                   const void *pkt)
 {
     (void)gw;
     (void)hdr;
@@ -76,74 +76,76 @@
 }
 
 void
-lifxd_wire_load_packet_infos_map(void)
+lgtd_lifx_wire_load_packet_infos_map(void)
 {
 #define DECODER(x)  ((void (*)(void *))(x))
 #define ENCODER(x)  ((void (*)(void *))(x))
 #define HANDLER(x)                                  \
-    ((void (*)(struct lifxd_gateway *,              \
-               const struct lifxd_packet_header *,  \
+    ((void (*)(struct lgtd_lifx_gateway *,              \
+               const struct lgtd_lifx_packet_header *,  \
                const void *))(x))
 #define REQUEST_ONLY                                    \
-    .decode = lifxd_wire_null_packet_encoder_decoder,   \
-    .encode = lifxd_wire_null_packet_encoder_decoder,   \
-    .handle = lifxd_wire_null_packet_handler
+    .decode = lgtd_lifx_wire_null_packet_encoder_decoder,   \
+    .encode = lgtd_lifx_wire_null_packet_encoder_decoder,   \
+    .handle = lgtd_lifx_wire_null_packet_handler
 
-    static struct lifxd_packet_infos packet_table[] = {
+    static struct lgtd_lifx_packet_infos packet_table[] = {
         {
             REQUEST_ONLY,
             .name = "GET_PAN_GATEWAY",
-            .type = LIFXD_GET_PAN_GATEWAY
+            .type = LGTD_LIFX_GET_PAN_GATEWAY
         },
         {
             .name = "PAN_GATEWAY",
-            .type = LIFXD_PAN_GATEWAY,
-            .size = sizeof(struct lifxd_packet_pan_gateway),
-            .decode = DECODER(lifxd_wire_decode_pan_gateway),
-            .encode = ENCODER(lifxd_wire_encode_pan_gateway),
-            .handle = HANDLER(lifxd_gateway_handle_pan_gateway)
+            .type = LGTD_LIFX_PAN_GATEWAY,
+            .size = sizeof(struct lgtd_lifx_packet_pan_gateway),
+            .decode = DECODER(lgtd_lifx_wire_decode_pan_gateway),
+            .encode = ENCODER(lgtd_lifx_wire_encode_pan_gateway),
+            .handle = HANDLER(lgtd_lifx_gateway_handle_pan_gateway)
         },
         {
             REQUEST_ONLY,
             .name = "GET_LIGHT_STATUS",
-            .type = LIFXD_GET_LIGHT_STATE
+            .type = LGTD_LIFX_GET_LIGHT_STATE
         },
         {
             .name = "LIGHT_STATUS",
-            .type = LIFXD_LIGHT_STATUS,
-            .size = sizeof(struct lifxd_packet_light_status),
-            .decode = DECODER(lifxd_wire_decode_light_status),
-            .encode = ENCODER(lifxd_wire_encode_light_status),
-            .handle = HANDLER(lifxd_gateway_handle_light_status)
+            .type = LGTD_LIFX_LIGHT_STATUS,
+            .size = sizeof(struct lgtd_lifx_packet_light_status),
+            .decode = DECODER(lgtd_lifx_wire_decode_light_status),
+            .encode = ENCODER(lgtd_lifx_wire_encode_light_status),
+            .handle = HANDLER(lgtd_lifx_gateway_handle_light_status)
         },
         {
             .name = "POWER_STATE",
-            .type = LIFXD_POWER_STATE,
-            .size = sizeof(struct lifxd_packet_power_state),
-            .decode = DECODER(lifxd_wire_decode_power_state),
-            .handle = HANDLER(lifxd_gateway_handle_power_state)
+            .type = LGTD_LIFX_POWER_STATE,
+            .size = sizeof(struct lgtd_lifx_packet_power_state),
+            .decode = DECODER(lgtd_lifx_wire_decode_power_state),
+            .handle = HANDLER(lgtd_lifx_gateway_handle_power_state)
         }
     };
 
-    for (int i = 0; i != LIFXD_ARRAY_SIZE(packet_table); ++i) {
+    for (int i = 0; i != LGTD_ARRAY_SIZE(packet_table); ++i) {
         RB_INSERT(
-            lifxd_packet_infos_map, &lifxd_packet_infos, &packet_table[i]
+            lgtd_lifx_packet_infos_map,
+            &lgtd_lifx_packet_infos,
+            &packet_table[i]
         );
     }
 }
 
-const struct lifxd_packet_infos *
-lifxd_wire_get_packet_infos(enum lifxd_packet_type packet_type)
+const struct lgtd_lifx_packet_infos *
+lgtd_lifx_wire_get_packet_infos(enum lgtd_lifx_packet_type packet_type)
 {
-    struct lifxd_packet_infos pkt_infos = { .type = packet_type };
-    return RB_FIND(lifxd_packet_infos_map, &lifxd_packet_infos, &pkt_infos);
+    struct lgtd_lifx_packet_infos pkt_infos = { .type = packet_type };
+    return RB_FIND(lgtd_lifx_packet_infos_map, &lgtd_lifx_packet_infos, &pkt_infos);
 }
 
 // Convert all the fields in the header to the host endianness.
 //
 // \return The payload size or -1 if the header is invalid.
 void
-lifxd_wire_decode_header(struct lifxd_packet_header *hdr)
+lgtd_lifx_wire_decode_header(struct lgtd_lifx_packet_header *hdr)
 {
     assert(hdr);
 
@@ -156,53 +158,52 @@
     hdr->packet_type = le16toh(hdr->packet_type);
 }
 
-const struct lifxd_packet_infos *
-lifxd_wire_setup_header(struct lifxd_packet_header *hdr,
-                        enum lifxd_target_type target_type,
-                        union lifxd_target target,
-                        const uint8_t *site,
-                        enum lifxd_packet_type packet_type)
+const struct lgtd_lifx_packet_infos *
+lgtd_lifx_wire_setup_header(struct lgtd_lifx_packet_header *hdr,
+                            enum lgtd_lifx_target_type target_type,
+                            union lgtd_lifx_target target,
+                            const uint8_t *site,
+                            enum lgtd_lifx_packet_type packet_type)
 {
     assert(hdr);
 
-    const struct lifxd_packet_infos *pkt_infos = lifxd_wire_get_packet_infos(
-        packet_type
-    );
+    const struct lgtd_lifx_packet_infos *pkt_infos =
+        lgtd_lifx_wire_get_packet_infos(packet_type);
 
     memset(hdr, 0, sizeof(*hdr));
     hdr->size = pkt_infos->size + sizeof(*hdr);
-    hdr->protocol.version = LIFXD_LIFX_PROTOCOL_V1;
+    hdr->protocol.version = LGTD_LIFX_PROTOCOL_V1;
     hdr->packet_type = packet_type;
     if (site) {
         memcpy(hdr->site, site, sizeof(hdr->site));
     } else {
-        assert(target_type == LIFXD_TARGET_ALL_DEVICES);
+        assert(target_type == LGTD_LIFX_TARGET_ALL_DEVICES);
     }
 
     switch (target_type) {
-    case LIFXD_TARGET_SITE:
+    case LGTD_LIFX_TARGET_SITE:
         hdr->protocol.tagged = true;
         break;
-    case LIFXD_TARGET_TAGS:
+    case LGTD_LIFX_TARGET_TAGS:
         hdr->protocol.tagged = true;
         hdr->target.tags = target.tags;
         break;
-    case LIFXD_TARGET_DEVICE:
+    case LGTD_LIFX_TARGET_DEVICE:
         hdr->protocol.addressable = false;
-        memcpy(hdr->target.device_addr, target.addr, LIFXD_ADDR_LENGTH);
+        memcpy(hdr->target.device_addr, target.addr, LGTD_LIFX_ADDR_LENGTH);
         break;
-    case LIFXD_TARGET_ALL_DEVICES:
+    case LGTD_LIFX_TARGET_ALL_DEVICES:
         hdr->protocol.tagged = true;
         break;
     }
 
-    lifxd_wire_encode_header(hdr);
+    lgtd_lifx_wire_encode_header(hdr);
 
     return pkt_infos;
 }
 
 void
-lifxd_wire_encode_header(struct lifxd_packet_header *hdr)
+lgtd_lifx_wire_encode_header(struct lgtd_lifx_packet_header *hdr)
 {
     assert(hdr);
 
@@ -216,7 +217,7 @@
 }
 
 void
-lifxd_wire_decode_pan_gateway(struct lifxd_packet_pan_gateway *pkt)
+lgtd_lifx_wire_decode_pan_gateway(struct lgtd_lifx_packet_pan_gateway *pkt)
 {
     assert(pkt);
 
@@ -224,7 +225,7 @@
 }
 
 void
-lifxd_wire_encode_pan_gateway(struct lifxd_packet_pan_gateway *pkt)
+lgtd_lifx_wire_encode_pan_gateway(struct lgtd_lifx_packet_pan_gateway *pkt)
 {
     assert(pkt);
 
@@ -232,7 +233,7 @@
 }
 
 void
-lifxd_wire_decode_light_status(struct lifxd_packet_light_status *pkt)
+lgtd_lifx_wire_decode_light_status(struct lgtd_lifx_packet_light_status *pkt)
 {
     assert(pkt);
 
@@ -246,7 +247,7 @@
 }
 
 void
-lifxd_wire_encode_light_status(struct lifxd_packet_light_status *pkt)
+lgtd_lifx_wire_encode_light_status(struct lgtd_lifx_packet_light_status *pkt)
 {
     assert(pkt);
 
@@ -260,7 +261,7 @@
 }
 
 void
-lifxd_wire_decode_power_state(struct lifxd_packet_power_state *pkt)
+lgtd_lifx_wire_decode_power_state(struct lgtd_lifx_packet_power_state *pkt)
 {
     assert(pkt);
 }
diff --git a/core/wire_proto.h b/lifx/wire_proto.h
rename from core/wire_proto.h
rename to lifx/wire_proto.h
--- a/core/wire_proto.h
+++ b/lifx/wire_proto.h
@@ -36,15 +36,17 @@
 typedef uint64_t uint64le_t;
 typedef uint64_t uint64be_t;
 
-enum { LIFXD_ADDR_LENGTH = 6 };
+enum { LGTD_LIFX_PROTOCOL_PORT = 56700 };
+
+enum { LGTD_LIFX_ADDR_LENGTH = 6 };
 
 #pragma pack(push, 1)
 
-struct lifxd_packet_header {
+struct lgtd_lifx_packet_header {
     //! Packet size including the headers (i.e: this structure).
     uint16le_t      size;
     struct {
-        //! Protocol version should be LIFXD_LIFX_PROTOCOL_V1.
+        //! Protocol version should be LGTD_LIFX_LIFX_PROTOCOL_V1.
         uint16le_t  version:12;
         //! True when the target field holds a device address.
         uint16le_t  addressable:1;
@@ -59,9 +61,9 @@
         //! All targeted tags ORed together.
         uint64le_t  tags;
         //! Address of the targeted device.
-        uint8_t     device_addr[LIFXD_ADDR_LENGTH];
+        uint8_t     device_addr[LGTD_LIFX_ADDR_LENGTH];
     }               target;
-    uint8_t         site[LIFXD_ADDR_LENGTH];
+    uint8_t         site[LGTD_LIFX_ADDR_LENGTH];
     struct {
         //! True when a response is required, called acknowledge in lifx-gem...
         uint8_t     response_required:1;
@@ -76,148 +78,148 @@
     uint8_t         reserved[2];
 };
 
-enum { LIFXD_PACKET_HEADER_SIZE = sizeof(struct lifxd_packet_header) };
+enum { LGTD_LIFX_PACKET_HEADER_SIZE = sizeof(struct lgtd_lifx_packet_header) };
 
-enum { LIFXD_LIFX_PROTOCOL_V1 = 1024 };
+enum { LGTD_LIFX_PROTOCOL_V1 = 1024 };
 
 // Let's define a maximum packet size just in case somebody sends us weird
 // headers:
-enum { LIFXD_MAX_PACKET_SIZE = 4096 };
+enum { LGTD_LIFX_MAX_PACKET_SIZE = 4096 };
 
-enum lifxd_packet_type {
-    LIFXD_GET_PAN_GATEWAY = 0x02,
-    LIFXD_PAN_GATEWAY = 0x03,
-    LIFXD_GET_TIME = 0x04,
-    LIFXD_SET_TIME = 0x05,
-    LIFXD_TIME_STATE = 0x06,
-    LIFXD_GET_RESET_SWITCH_STATE = 0x07,
-    LIFXD_RESET_SWITCH_STATE = 0x08,
-    LIFXD_GET_MESH_INFO = 0x0c,
-    LIFXD_MESH_INFO = 0x0d,
-    LIFXD_GET_MESH_FIRMWARE = 0x0e,
-    LIFXD_MESH_FIRMWARE = 0x0f,
-    LIFXD_GET_WIFI_INFO = 0x10,
-    LIFXD_WIFI_INFO = 0x11,
-    LIFXD_GET_WIFI_FIRMWARE_STATE = 0x12,
-    LIFXD_WIFI_FIRMWARE_STATE = 0x13,
-    LIFXD_GET_POWER_STATE = 0x14,
-    LIFXD_SET_POWER_STATE = 0x15,
-    LIFXD_POWER_STATE = 0x16,
-    LIFXD_GET_BULB_LABEL = 0x17,
-    LIFXD_SET_BULB_LABEL = 0x18,
-    LIFXD_BULB_LABEL = 0x19,
-    LIFXD_GET_TAGS = 0x1a,
-    LIFXD_SET_TAGS = 0x1b,
-    LIFXD_TAGS = 0x1c,
-    LIFXD_GET_TAG_LABELS = 0x1d,
-    LIFXD_SET_TAG_LABELS = 0x1e,
-    LIFXD_TAG_LABELS = 0x1f,
-    LIFXD_GET_VERSION = 0x20,
-    LIFXD_VERSION_STATE = 0x21,
-    LIFXD_GET_INFO = 0x22,
-    LIFXD_INFO_STATE = 0x23,
-    LIFXD_GET_MCU_RAIL_VOLTAGE = 0x24,
-    LIFXD_MCU_RAIL_VOLTAGE = 0x25,
-    LIFXD_REBOOT = 0x26,
-    LIFXD_SET_FACTORY_TEST_MODE = 0x27,
-    LIFXD_DISABLE_FACTORY_TEST_MODE = 0x28,
-    LIFXD_GET_LIGHT_STATE = 0x65,
-    LIFXD_SET_LIGHT_COLOUR = 0x66,
-    LIFXD_SET_WAVEFORM = 0x67,
-    LIFXD_SET_DIM_ABSOLUTE = 0x68,
-    LIFXD_SET_DIM_RELATIVE = 0x69,
-    LIFXD_LIGHT_STATUS = 0x6b,
-    LIFXD_GET_WIFI_STATE = 0x12d,
-    LIFXD_SET_WIFI_STATE = 0x12e,
-    LIFXD_WIFI_STATE = 0x12f,
-    LIFXD_GET_ACCESS_POINTS = 0x130,
-    LIFXD_SET_ACCESS_POINTS = 0x131,
-    LIFXD_ACCESS_POINT = 0x132,
+enum lgtd_lifx_packet_type {
+    LGTD_LIFX_GET_PAN_GATEWAY = 0x02,
+    LGTD_LIFX_PAN_GATEWAY = 0x03,
+    LGTD_LIFX_GET_TIME = 0x04,
+    LGTD_LIFX_SET_TIME = 0x05,
+    LGTD_LIFX_TIME_STATE = 0x06,
+    LGTD_LIFX_GET_RESET_SWITCH_STATE = 0x07,
+    LGTD_LIFX_RESET_SWITCH_STATE = 0x08,
+    LGTD_LIFX_GET_MESH_INFO = 0x0c,
+    LGTD_LIFX_MESH_INFO = 0x0d,
+    LGTD_LIFX_GET_MESH_FIRMWARE = 0x0e,
+    LGTD_LIFX_MESH_FIRMWARE = 0x0f,
+    LGTD_LIFX_GET_WIFI_INFO = 0x10,
+    LGTD_LIFX_WIFI_INFO = 0x11,
+    LGTD_LIFX_GET_WIFI_FIRMWARE_STATE = 0x12,
+    LGTD_LIFX_WIFI_FIRMWARE_STATE = 0x13,
+    LGTD_LIFX_GET_POWER_STATE = 0x14,
+    LGTD_LIFX_SET_POWER_STATE = 0x15,
+    LGTD_LIFX_POWER_STATE = 0x16,
+    LGTD_LIFX_GET_BULB_LABEL = 0x17,
+    LGTD_LIFX_SET_BULB_LABEL = 0x18,
+    LGTD_LIFX_BULB_LABEL = 0x19,
+    LGTD_LIFX_GET_TAGS = 0x1a,
+    LGTD_LIFX_SET_TAGS = 0x1b,
+    LGTD_LIFX_TAGS = 0x1c,
+    LGTD_LIFX_GET_TAG_LABELS = 0x1d,
+    LGTD_LIFX_SET_TAG_LABELS = 0x1e,
+    LGTD_LIFX_TAG_LABELS = 0x1f,
+    LGTD_LIFX_GET_VERSION = 0x20,
+    LGTD_LIFX_VERSION_STATE = 0x21,
+    LGTD_LIFX_GET_INFO = 0x22,
+    LGTD_LIFX_INFO_STATE = 0x23,
+    LGTD_LIFX_GET_MCU_RAIL_VOLTAGE = 0x24,
+    LGTD_LIFX_MCU_RAIL_VOLTAGE = 0x25,
+    LGTD_LIFX_REBOOT = 0x26,
+    LGTD_LIFX_SET_FACTORY_TEST_MODE = 0x27,
+    LGTD_LIFX_DISABLE_FACTORY_TEST_MODE = 0x28,
+    LGTD_LIFX_GET_LIGHT_STATE = 0x65,
+    LGTD_LIFX_SET_LIGHT_COLOUR = 0x66,
+    LGTD_LIFX_SET_WAVEFORM = 0x67,
+    LGTD_LIFX_SET_DIM_ABSOLUTE = 0x68,
+    LGTD_LIFX_SET_DIM_RELATIVE = 0x69,
+    LGTD_LIFX_LIGHT_STATUS = 0x6b,
+    LGTD_LIFX_GET_WIFI_STATE = 0x12d,
+    LGTD_LIFX_SET_WIFI_STATE = 0x12e,
+    LGTD_LIFX_WIFI_STATE = 0x12f,
+    LGTD_LIFX_GET_ACCESS_POINTS = 0x130,
+    LGTD_LIFX_SET_ACCESS_POINTS = 0x131,
+    LGTD_LIFX_ACCESS_POINT = 0x132,
 };
 
-enum { LIFXD_LABEL_SIZE = 32 };
+enum { LGTD_LIFX_LABEL_SIZE = 32 };
 
-struct lifxd_packet_light_status {
+struct lgtd_lifx_packet_light_status {
     uint16le_t  hue;
     uint16le_t  saturation;
     uint16le_t  brightness;
     uint16le_t  kelvin;
     uint16le_t  dim;
     uint16le_t  power;
-    uint8_t     label[LIFXD_LABEL_SIZE];
+    uint8_t     label[LGTD_LIFX_LABEL_SIZE];
     uint64be_t  tags;
 };
 
-enum lifxd_power_state {
-    LIFXD_POWER_OFF = 0,
-    LIFXD_POWER_ON = 0xffff
+enum lgtd_lifx_power_state {
+    LGTD_LIFX_POWER_OFF = 0,
+    LGTD_LIFX_POWER_ON = 0xffff
 };
 
-struct lifxd_packet_power_state {
-    uint16_t    power; // see enum lifxd_power_state
+struct lgtd_lifx_packet_power_state {
+    uint16_t    power; // see enum lgtd_lifx_power_state
 };
 
-enum lifxd_service_type {
-    LIFXD_SERVICE_TCP = 1,
-    LIFXD_SERVICE_UDP = 2
+enum lgtd_lifx_service_type {
+    LGTD_LIFX_SERVICE_TCP = 1,
+    LGTD_LIFX_SERVICE_UDP = 2
 };
 
-struct lifxd_packet_pan_gateway {
-    uint8_t     service_type; // see enum lifxd_service_type
+struct lgtd_lifx_packet_pan_gateway {
+    uint8_t     service_type; // see enum lgtd_lifx_service_type
     uint32le_t  port;
 };
 
-enum lifxd_target_type {
-    LIFXD_TARGET_SITE,
-    LIFXD_TARGET_TAGS,
-    LIFXD_TARGET_DEVICE,
-    LIFXD_TARGET_ALL_DEVICES
+enum lgtd_lifx_target_type {
+    LGTD_LIFX_TARGET_SITE,
+    LGTD_LIFX_TARGET_TAGS,
+    LGTD_LIFX_TARGET_DEVICE,
+    LGTD_LIFX_TARGET_ALL_DEVICES
 };
 
 #pragma pack(pop)
 
-struct lifxd_gateway;
+struct lgtd_lifx_gateway;
 
-struct lifxd_packet_infos {
-    RB_ENTRY(lifxd_packet_infos)    link;
-    const char                      *name;
-    enum lifxd_packet_type          type;
-    unsigned                        size;
-    void                            (*decode)(void *);
-    void                            (*encode)(void *);
-    void                            (*handle)(struct lifxd_gateway *,
-                                              const struct lifxd_packet_header *,
-                                              const void *);
+struct lgtd_lifx_packet_infos {
+    RB_ENTRY(lgtd_lifx_packet_infos)    link;
+    const char                          *name;
+    enum lgtd_lifx_packet_type          type;
+    unsigned                            size;
+    void                                (*decode)(void *);
+    void                                (*encode)(void *);
+    void                                (*handle)(struct lgtd_lifx_gateway *,
+                                                  const struct lgtd_lifx_packet_header *,
+                                                  const void *);
 };
-RB_HEAD(lifxd_packet_infos_map, lifxd_packet_infos);
+RB_HEAD(lgtd_lifx_packet_infos_map, lgtd_lifx_packet_infos);
 
 static inline int
-lifxd_packet_infos_cmp(struct lifxd_packet_infos *a,
-                       struct lifxd_packet_infos *b)
+lgtd_lifx_packet_infos_cmp(struct lgtd_lifx_packet_infos *a,
+                       struct lgtd_lifx_packet_infos *b)
 {
     return a->type - b->type;
 }
 
-union lifxd_target {
+union lgtd_lifx_target {
     uint64_t        tags;
     const uint8_t   *addr; //! site or device address
 };
 
-extern union lifxd_target LIFXD_UNSPEC_TARGET;
+extern union lgtd_lifx_target LGTD_LIFX_UNSPEC_TARGET;
 
-const struct lifxd_packet_infos *lifxd_wire_get_packet_infos(enum lifxd_packet_type);
-void lifxd_wire_load_packet_infos_map(void);
+const struct lgtd_lifx_packet_infos *lgtd_lifx_wire_get_packet_infos(enum lgtd_lifx_packet_type);
+void lgtd_lifx_wire_load_packet_infos_map(void);
 
-const struct lifxd_packet_infos *lifxd_wire_setup_header(struct lifxd_packet_header *,
-                                                         enum lifxd_target_type,
-                                                         union lifxd_target,
-                                                         const uint8_t *,
-                                                         enum lifxd_packet_type);
-void lifxd_wire_decode_header(struct lifxd_packet_header *);
-void lifxd_wire_encode_header(struct lifxd_packet_header *);
+const struct lgtd_lifx_packet_infos *lgtd_lifx_wire_setup_header(struct lgtd_lifx_packet_header *,
+                                                                 enum lgtd_lifx_target_type,
+                                                                 union lgtd_lifx_target,
+                                                                 const uint8_t *,
+                                                                 enum lgtd_lifx_packet_type);
+void lgtd_lifx_wire_decode_header(struct lgtd_lifx_packet_header *);
+void lgtd_lifx_wire_encode_header(struct lgtd_lifx_packet_header *);
 
-void lifxd_wire_decode_pan_gateway(struct lifxd_packet_pan_gateway *);
-void lifxd_wire_encode_pan_gateway(struct lifxd_packet_pan_gateway *);
-void lifxd_wire_decode_light_status(struct lifxd_packet_light_status *);
-void lifxd_wire_encode_light_status(struct lifxd_packet_light_status *);
-void lifxd_wire_decode_power_state(struct lifxd_packet_power_state *);
+void lgtd_lifx_wire_decode_pan_gateway(struct lgtd_lifx_packet_pan_gateway *);
+void lgtd_lifx_wire_encode_pan_gateway(struct lgtd_lifx_packet_pan_gateway *);
+void lgtd_lifx_wire_decode_light_status(struct lgtd_lifx_packet_light_status *);
+void lgtd_lifx_wire_encode_light_status(struct lgtd_lifx_packet_light_status *);
+void lgtd_lifx_wire_decode_power_state(struct lgtd_lifx_packet_power_state *);
