# HG changeset patch
# Parent  0d019f96f2501d38d43a3055494e3767f55bdc26
Do not stop at the first match when targeting a label

People should use tags, but that seems like the correct behavior to
have.

diff --git a/core/router.c b/core/router.c
--- a/core/router.c
+++ b/core/router.c
@@ -168,7 +168,7 @@
 
     struct lgtd_lifx_bulb *bulb;
     RB_FOREACH(bulb, lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table) {
-        if (!strcmp(bulb->state.label, label)) {
+        if (lgtd_lifx_bulb_has_label(bulb, label)) {
             struct lgtd_lifx_packet_header hdr;
             union lgtd_lifx_target target = { .addr = bulb->addr };
             pkt_info = lgtd_lifx_wire_setup_header(
@@ -341,20 +341,26 @@
             struct lgtd_lifx_bulb *bulb = NULL;
             if (isxdigit(target->target[0])) {
                 bulb = lgtd_router_device_addr_to_device(target->target);
+                if (bulb) {
+                    bool ok = lgtd_router_insert_device_if_not_in_list(
+                        devices, bulb
+                    );
+                    if (!ok) {
+                        goto device_alloc_error;
+                    }
+                    continue;
+                }
             }
-            if (!bulb) {
-                RB_FOREACH(bulb, lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table) {
-                    if (!strcmp(bulb->state.label, target->target)) {
-                        break;
+            RB_FOREACH(bulb, lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table) {
+                if (lgtd_lifx_bulb_has_label(bulb, target->target)) {
+                    bool ok = lgtd_router_insert_device_if_not_in_list(
+                        devices, bulb
+                    );
+                    if (!ok) {
+                        goto device_alloc_error;
                     }
                 }
             }
-            if (!bulb) {
-                continue;
-            }
-            if (!lgtd_router_insert_device_if_not_in_list(devices, bulb)) {
-                goto device_alloc_error;
-            }
         }
     }
 
diff --git a/lifx/bulb.c b/lifx/bulb.c
--- a/lifx/bulb.c
+++ b/lifx/bulb.c
@@ -207,6 +207,21 @@
     free(bulb);
 }
 
+bool
+lgtd_lifx_bulb_has_label(const struct lgtd_lifx_bulb *bulb,
+                         const char *label)
+{
+    assert(bulb);
+    assert(label);
+
+    const char *bulb_label = &bulb->state.label[0];
+    const char *endp = memchr(bulb_label, 0, LGTD_LIFX_LABEL_SIZE);
+    int bulb_label_len = endp ? endp - bulb_label : LGTD_LIFX_LABEL_SIZE;
+    int label_len = strlen(label);
+    // clipping the label at 32 chars seems like the desired default behavior:
+    return !memcmp(bulb_label, label, LGTD_MIN(bulb_label_len, label_len));
+}
+
 void
 lgtd_lifx_bulb_set_light_state(struct lgtd_lifx_bulb *bulb,
                                const struct lgtd_lifx_light_state *state,
diff --git a/lifx/bulb.h b/lifx/bulb.h
--- a/lifx/bulb.h
+++ b/lifx/bulb.h
@@ -119,6 +119,9 @@
 struct lgtd_lifx_bulb *lgtd_lifx_bulb_open(struct lgtd_lifx_gateway *, const uint8_t *);
 void lgtd_lifx_bulb_close(struct lgtd_lifx_bulb *);
 
+bool lgtd_lifx_bulb_has_label(const struct lgtd_lifx_bulb *,
+                              const char *);
+
 void lgtd_lifx_bulb_set_light_state(struct lgtd_lifx_bulb *,
                                     const struct lgtd_lifx_light_state *,
                                     lgtd_time_mono_t);
diff --git a/tests/core/router/test_router_send_to_label.c b/tests/core/router/test_router_send_to_label.c
--- a/tests/core/router/test_router_send_to_label.c
+++ b/tests/core/router/test_router_send_to_label.c
@@ -14,9 +14,11 @@
     struct lgtd_lifx_bulb *bulb_1 = lgtd_tests_insert_mock_bulb(gw_1, 1);
     struct lgtd_lifx_gateway *gw_2 = lgtd_tests_insert_mock_gateway(2);
     struct lgtd_lifx_bulb *bulb_2 = lgtd_tests_insert_mock_bulb(gw_2, 2);
+    struct lgtd_lifx_bulb *bulb_3 = lgtd_tests_insert_mock_bulb(gw_2, 3);
 
     const char *label = "feed";
     strcpy(bulb_1->state.label, label);
+    strcpy(bulb_3->state.label, label);
     strcpy(bulb_2->state.label, "trololo");
 
     struct lgtd_lifx_packet_power_state payload = {
diff --git a/tests/core/router/test_router_targets_to_devices.c b/tests/core/router/test_router_targets_to_devices.c
--- a/tests/core/router/test_router_targets_to_devices.c
+++ b/tests/core/router/test_router_targets_to_devices.c
@@ -169,5 +169,20 @@
         lgtd_errx(1, "expected 4 device but got %d", count);
     }
 
+    // targeting a label shouldn't break at the first match:
+    struct lgtd_lifx_bulb *bulb_3_gw_2 = lgtd_tests_insert_mock_bulb(gw_2, 7);
+    strcpy(bulb_3_gw_2->state.label, "desk");
+    targets = lgtd_tests_build_target_list("desk", NULL);
+    devices = lgtd_router_targets_to_devices(targets);
+    if ((count = count_device(devices, bulb_1_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_1_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = count_device(devices, bulb_3_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_3_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = len(devices)) != 2) {
+        lgtd_errx(1, "expected 2 device but got %d", count);
+    }
+
     return 0;
 }
