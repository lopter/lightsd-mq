# HG changeset patch
# Parent  1b107b000cf6f8b694a398d0ace05f9e79fa59e7
Do not stop at the first match when targeting a label

People should use tags, but that seems like the correct behavior to
have.

diff --git a/core/router.c b/core/router.c
--- a/core/router.c
+++ b/core/router.c
@@ -168,7 +168,7 @@
 
     struct lgtd_lifx_bulb *bulb;
     RB_FOREACH(bulb, lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table) {
-        if (!strcmp(bulb->state.label, label)) {
+        if (lgtd_lifx_bulb_has_label(bulb, label)) {
             struct lgtd_lifx_packet_header hdr;
             union lgtd_lifx_target target = { .addr = bulb->addr };
             pkt_info = lgtd_lifx_wire_setup_header(
@@ -341,20 +341,26 @@
             struct lgtd_lifx_bulb *bulb = NULL;
             if (isxdigit(target->target[0])) {
                 bulb = lgtd_router_device_addr_to_device(target->target);
+                if (bulb) {
+                    bool ok = lgtd_router_insert_device_if_not_in_list(
+                        devices, bulb
+                    );
+                    if (!ok) {
+                        goto device_alloc_error;
+                    }
+                    continue;
+                }
             }
-            if (!bulb) {
-                RB_FOREACH(bulb, lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table) {
-                    if (!strcmp(bulb->state.label, target->target)) {
-                        break;
+            RB_FOREACH(bulb, lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table) {
+                if (lgtd_lifx_bulb_has_label(bulb, target->target)) {
+                    bool ok = lgtd_router_insert_device_if_not_in_list(
+                        devices, bulb
+                    );
+                    if (!ok) {
+                        goto device_alloc_error;
                     }
                 }
             }
-            if (!bulb) {
-                continue;
-            }
-            if (!lgtd_router_insert_device_if_not_in_list(devices, bulb)) {
-                goto device_alloc_error;
-            }
         }
     }
 
diff --git a/lifx/bulb.c b/lifx/bulb.c
--- a/lifx/bulb.c
+++ b/lifx/bulb.c
@@ -207,6 +207,21 @@
     free(bulb);
 }
 
+bool
+lgtd_lifx_bulb_has_label(const struct lgtd_lifx_bulb *bulb,
+                         const char *label)
+{
+    assert(bulb);
+    assert(label);
+
+    const char *bulb_label = &bulb->state.label[0];
+    const char *endp = memchr(bulb_label, 0, LGTD_LIFX_LABEL_SIZE);
+    int bulb_label_len = endp ? endp - bulb_label : LGTD_LIFX_LABEL_SIZE;
+    // clipping the label at 32 chars seems like the desired default behavior:
+    int label_len = LGTD_MIN(strlen(label), LGTD_LIFX_LABEL_SIZE);
+    return label_len == bulb_label_len && !memcmp(bulb_label, label, label_len);
+}
+
 void
 lgtd_lifx_bulb_set_light_state(struct lgtd_lifx_bulb *bulb,
                                const struct lgtd_lifx_light_state *state,
diff --git a/lifx/bulb.h b/lifx/bulb.h
--- a/lifx/bulb.h
+++ b/lifx/bulb.h
@@ -119,6 +119,9 @@
 struct lgtd_lifx_bulb *lgtd_lifx_bulb_open(struct lgtd_lifx_gateway *, const uint8_t *);
 void lgtd_lifx_bulb_close(struct lgtd_lifx_bulb *);
 
+bool lgtd_lifx_bulb_has_label(const struct lgtd_lifx_bulb *,
+                              const char *);
+
 void lgtd_lifx_bulb_set_light_state(struct lgtd_lifx_bulb *,
                                     const struct lgtd_lifx_light_state *,
                                     lgtd_time_mono_t);
diff --git a/tests/core/router/test_router_send_to_label.c b/tests/core/router/test_router_send_to_label.c
--- a/tests/core/router/test_router_send_to_label.c
+++ b/tests/core/router/test_router_send_to_label.c
@@ -14,9 +14,11 @@
     struct lgtd_lifx_bulb *bulb_1 = lgtd_tests_insert_mock_bulb(gw_1, 1);
     struct lgtd_lifx_gateway *gw_2 = lgtd_tests_insert_mock_gateway(2);
     struct lgtd_lifx_bulb *bulb_2 = lgtd_tests_insert_mock_bulb(gw_2, 2);
+    struct lgtd_lifx_bulb *bulb_3 = lgtd_tests_insert_mock_bulb(gw_2, 3);
 
     const char *label = "feed";
     strcpy(bulb_1->state.label, label);
+    strcpy(bulb_3->state.label, label);
     strcpy(bulb_2->state.label, "trololo");
 
     struct lgtd_lifx_packet_power_state payload = {
@@ -26,40 +28,44 @@
     targets = lgtd_tests_build_target_list(label, NULL);
     lgtd_router_send(targets, LGTD_LIFX_SET_POWER_STATE, &payload);
 
-    if (lgtd_tests_gw_pkt_queue_size != 1) {
-        lgtd_errx(1, "1 packet should have been sent");
+    if (lgtd_tests_gw_pkt_queue_size != 2) {
+        lgtd_errx(1, "2 packet should have been sent");
     }
 
-    struct lgtd_lifx_gateway *recpt_gw = lgtd_tests_gw_pkt_queue[0].gw;
-    struct lgtd_lifx_packet_header *hdr_queued = lgtd_tests_gw_pkt_queue[0].hdr;
-    const void *pkt_queued = lgtd_tests_gw_pkt_queue[0].pkt;
-    int pkt_size = lgtd_tests_gw_pkt_queue[0].pkt_size;
+    for (int i = 0; i != lgtd_tests_gw_pkt_queue_size; i++) {
+        struct lgtd_lifx_gateway *recpt_gw = lgtd_tests_gw_pkt_queue[0].gw;
+        struct lgtd_lifx_packet_header *hdr_queued = lgtd_tests_gw_pkt_queue[0].hdr;
+        const void *pkt_queued = lgtd_tests_gw_pkt_queue[0].pkt;
+        int pkt_size = lgtd_tests_gw_pkt_queue[0].pkt_size;
 
-    if (recpt_gw != gw_1) {
-        lgtd_errx(1, "the packet has been sent to the wrong gateway");
-    }
+        if (!lgtd_tests_lifx_header_has_flags(hdr_queued, LGTD_LIFX_ADDRESSABLE)) {
+            lgtd_errx(1, "the packet header doesn't have the right protocol flags");
+        }
+        if (pkt_queued != &payload) {
+            lgtd_errx(1, "invalid payload");
+        }
+        if (pkt_size != sizeof(payload)) {
+            lgtd_errx(
+                1, "unexpected pkt size %d (expected %ju)",
+                pkt_size, (uintmax_t)sizeof(payload)
+            );
+        }
 
-    if (!lgtd_tests_lifx_header_has_flags(hdr_queued, LGTD_LIFX_ADDRESSABLE)) {
-        lgtd_errx(1, "the packet header doesn't have the right protocol flags");
-    }
-
-    if (memcmp(hdr_queued->target.device_addr, bulb_1->addr, sizeof(bulb_1->addr))) {
-        lgtd_errx(1, "the packet header doesn't have the right target address");
-    }
-
-    if (memcmp(gw_1->site.as_array, hdr_queued->site, sizeof(hdr_queued->site))) {
-        lgtd_errx(1, "incorrect site in the headers");
-    }
-
-    if (pkt_queued != &payload) {
-        lgtd_errx(1, "invalid payload");
-    }
-
-    if (pkt_size != sizeof(payload)) {
-        lgtd_errx(
-            1, "unexpected pkt size %d (expected %ju)",
-            pkt_size, (uintmax_t)sizeof(payload)
-        );
+        if (recpt_gw == gw_1) {
+            if (memcmp(hdr_queued->target.device_addr, bulb_1->addr, sizeof(bulb_1->addr))) {
+                lgtd_errx(1, "the packet header doesn't have the right target address");
+            }
+            if (memcmp(gw_1->site.as_array, hdr_queued->site, sizeof(hdr_queued->site))) {
+                lgtd_errx(1, "incorrect site in the headers");
+            }
+        } else if (recpt_gw == gw_2) {
+            if (memcmp(hdr_queued->target.device_addr, bulb_3->addr, sizeof(bulb_3->addr))) {
+                lgtd_errx(1, "the packet header doesn't have the right target address");
+            }
+            if (memcmp(gw_2->site.as_array, hdr_queued->site, sizeof(hdr_queued->site))) {
+                lgtd_errx(1, "incorrect site in the headers");
+            }
+        }
     }
 
     return 0;
diff --git a/tests/core/router/test_router_targets_to_devices.c b/tests/core/router/test_router_targets_to_devices.c
--- a/tests/core/router/test_router_targets_to_devices.c
+++ b/tests/core/router/test_router_targets_to_devices.c
@@ -169,5 +169,20 @@
         lgtd_errx(1, "expected 4 device but got %d", count);
     }
 
+    // targeting a label shouldn't break at the first match:
+    struct lgtd_lifx_bulb *bulb_3_gw_2 = lgtd_tests_insert_mock_bulb(gw_2, 7);
+    strcpy(bulb_3_gw_2->state.label, "desk");
+    targets = lgtd_tests_build_target_list("desk", NULL);
+    devices = lgtd_router_targets_to_devices(targets);
+    if ((count = count_device(devices, bulb_1_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_1_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = count_device(devices, bulb_3_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_3_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = len(devices)) != 2) {
+        lgtd_errx(1, "expected 2 device but got %d", count);
+    }
+
     return 0;
 }
diff --git a/tests/lifx/bulb/test_bulb_has_label.c b/tests/lifx/bulb/test_bulb_has_label.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/bulb/test_bulb_has_label.c
@@ -0,0 +1,47 @@
+#include "bulb.c"
+
+#include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
+
+void
+test_label(struct lgtd_lifx_bulb *bulb,
+           const char *bulb_label,
+           const char *label,
+           bool expected)
+{
+    memcpy(bulb->state.label, bulb_label, LGTD_MIN(
+        strlen(bulb_label) + 1, LGTD_LIFX_LABEL_SIZE
+    ));
+    bool rv = lgtd_lifx_bulb_has_label(bulb, label);
+    if (rv != expected) {
+        errx(
+            1, "bulb_has_label(%s, %s) -> %s (expected %s)",
+            bulb_label, label,
+            rv ? "true" : "false",
+            expected ? "true" : "false"
+        );
+    }
+}
+
+int
+main(void)
+{
+    struct lgtd_lifx_gateway gw;
+    uint8_t bulb_addr[LGTD_LIFX_ADDR_LENGTH] = { 5, 4, 3, 2, 1, 0 };
+    struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_open(&gw, bulb_addr);
+
+    test_label(bulb, "", "test", false);
+    test_label(bulb, "test", "test", true);
+    test_label(bulb, "testtest", "test", false);
+    test_label(bulb, "test", "testtest", false);
+    test_label(bulb, "", "", true);
+    test_label(
+        bulb,
+        "testtesttesttesttesttesttesttest",
+        "testtesttesttesttesttesttesttesttest",
+        true
+    );
+
+    return 0;
+}
