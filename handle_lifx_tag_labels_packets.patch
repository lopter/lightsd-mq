# HG changeset patch
# Parent  03dc3d776df993d419e3eb1eda6c14660d32440a
Handle the LIFX tag labels traffic

First step towards full tagging support.

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -32,6 +32,8 @@
 
 SET(CMAKE_C_FLAGS "-pipe -Wextra -Wall -Wstrict-prototypes -std=c99")
 
+ADD_DEFINITIONS("-DLGTD_SIZEOF_VOID_P=${CMAKE_SIZEOF_VOID_P}")
+
 # Only relevant for the GNU libc:
 ADD_DEFINITIONS(
     "-D_POSIX_C_SOURCE=200809L"
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -38,6 +38,7 @@
 #include "gateway.h"
 #include "broadcast.h"
 #include "timer.h"
+#include "tagging.h"
 #include "core/jsmn.h"
 #include "core/jsonrpc.h"
 #include "core/client.h"
@@ -48,6 +49,26 @@
 struct lgtd_lifx_gateway_list lgtd_lifx_gateways =
     LIST_HEAD_INITIALIZER(&lgtd_lifx_gateways);
 
+// Kim Walisch (2012)
+// http://chessprogramming.wikispaces.com/BitScan#DeBruijnMultiplation
+static inline int
+lgtd_lifx_bitscan64_forward(uint64_t n)
+{
+    enum { DEBRUIJN_NUMBER = 0x03f79d71b4cb0a89 };
+    static const int DEBRUIJN_SEQUENCE[64] = {
+        0, 47,  1, 56, 48, 27,  2, 60,
+       57, 49, 41, 37, 28, 16,  3, 61,
+       54, 58, 35, 52, 50, 42, 21, 44,
+       38, 32, 29, 23, 17, 11,  4, 62,
+       46, 55, 26, 59, 40, 36, 15, 53,
+       34, 51, 20, 43, 31, 22, 10, 45,
+       25, 39, 14, 33, 19, 30,  9, 24,
+       13, 18,  8, 12,  7,  6,  5, 63
+    };
+
+    return n ? DEBRUIJN_SEQUENCE[((n ^ (n - 1)) * DEBRUIJN_NUMBER) >> 58] : -1;
+}
+
 void
 lgtd_lifx_gateway_close(struct lgtd_lifx_gateway *gw)
 {
@@ -62,6 +83,11 @@
     event_free(gw->refresh_ev);
     event_free(gw->write_ev);
     evbuffer_free(gw->write_buf);
+    for (int i = 0; i != LGTD_LIFX_GATEWAY_MAX_TAGS; i++) {
+        if (gw->tags[i]) {
+            lgtd_lifx_tagging_decref(gw->tags[i], gw);
+        }
+    }
     struct lgtd_lifx_bulb *bulb, *next_bulb;
     SLIST_FOREACH_SAFE(bulb, &gw->bulbs, link_by_gw, next_bulb) {
         lgtd_lifx_bulb_close(bulb);
@@ -161,6 +187,18 @@
         gw, &hdr, LGTD_LIFX_GET_LIGHT_STATE, NULL, 0
     );
 
+    struct lgtd_lifx_packet_get_tag_labels pkt = { .tags = LGTD_LIFX_ALL_TAGS };
+    lgtd_lifx_wire_setup_header(
+        &hdr,
+        LGTD_LIFX_TARGET_SITE,
+        target,
+        gw->site.as_array,
+        LGTD_LIFX_GET_TAG_LABELS
+    );
+    lgtd_lifx_gateway_enqueue_packet(
+        gw, &hdr, LGTD_LIFX_GET_TAG_LABELS, &pkt, sizeof(pkt)
+    );
+
     gw->pending_refresh_req = true;
 }
 
@@ -458,3 +496,90 @@
 
     lgtd_lifx_bulb_set_power_state(b, pkt->power);
 }
+
+#if LGTD_SIZEOF_VOID_P == 8
+#   define TAG_ID_TO_VALUE(x) (1UL << (x))
+#elif LGTD_SIZEOF_VOID_P == 4
+#   define TAG_ID_TO_VALUE(x) (1ULL << (x))
+#endif
+
+int
+lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *gw,
+                                  int tag_id,
+                                  const char *tag_label)
+{
+    assert(gw);
+    assert(tag_label);
+    // allocating a new tag_id (tag_id == -1) isn't supported yet:
+    assert(tag_id >= 0);
+    assert(tag_id < LGTD_LIFX_GATEWAY_MAX_TAGS);
+
+    if (!(gw->tag_ids & TAG_ID_TO_VALUE(tag_id))) {
+        struct lgtd_lifx_tag *tag;
+        tag = lgtd_lifx_tagging_incref(tag_label, gw);
+        if (!tag) {
+            lgtd_warn(
+                "couldn't allocate a new reference to tag [%s] (site %s)",
+                tag_label, lgtd_addrtoa(gw->site.as_array)
+            );
+            return -1;
+        }
+        lgtd_debug(
+            "tag_id %d allocated for tag [%s] on gw [%s]:%hu (site %s)",
+            tag_id, tag_label, gw->ip_addr, gw->port,
+            lgtd_addrtoa(gw->site.as_array)
+        );
+        gw->tag_ids |= TAG_ID_TO_VALUE(tag_id);
+        gw->tags[tag_id] = tag;
+    }
+
+    return tag_id;
+}
+
+void
+lgtd_lifx_gateway_deallocate_tag_id(struct lgtd_lifx_gateway *gw, int tag_id)
+{
+    assert(gw);
+    assert(tag_id >= 0);
+    assert(tag_id < LGTD_LIFX_GATEWAY_MAX_TAGS);
+
+    if (gw->tag_ids & TAG_ID_TO_VALUE(tag_id)) {
+        lgtd_debug(
+            "tag_id %d deallocated for tag [%s] on gw [%s]:%hu (site %s)",
+            tag_id, gw->tags[tag_id]->label,
+            gw->ip_addr, gw->port,
+            lgtd_addrtoa(gw->site.as_array)
+        );
+        lgtd_lifx_tagging_decref(gw->tags[tag_id], gw);
+        gw->tag_ids &= ~TAG_ID_TO_VALUE(tag_id);
+        gw->tags[tag_id] = NULL;
+    }
+}
+
+void
+lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *gw,
+                                    const struct lgtd_lifx_packet_header *hdr,
+                                    const struct lgtd_lifx_packet_tag_labels *pkt)
+{
+    assert(gw && hdr && pkt);
+
+    lgtd_debug(
+        "SET_TAG_LABELS <-- [%s]:%hu - %s label=%s, tags=%jx",
+        gw->ip_addr, gw->port, lgtd_addrtoa(hdr->target.device_addr),
+        pkt->label, (uintmax_t)pkt->tags
+    );
+
+    uint64_t tags = pkt->tags;
+    while (true) {
+        int tag_id = lgtd_lifx_bitscan64_forward(tags);
+        if (tag_id == -1) {
+            break;
+        }
+        if (pkt->label[0]) {
+            lgtd_lifx_gateway_allocate_tag_id(gw, tag_id, pkt->label);
+        } else if (gw->tags[tag_id]) {
+            lgtd_lifx_gateway_deallocate_tag_id(gw, tag_id);
+        }
+        tags &= ~TAG_ID_TO_VALUE(tag_id);
+    }
+}
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -26,6 +26,8 @@
 // You can't send more than one lifx packet per UDP datagram.
 enum { LGTD_LIFX_GATEWAY_PACKET_RING_SIZE = 16 };
 
+enum { LGTD_LIFX_GATEWAY_MAX_TAGS = 64 };
+
 struct lgtd_lifx_message {
     enum lgtd_lifx_packet_type  type;
     int                         size;
@@ -47,6 +49,8 @@
         uint8_t                     as_array[LGTD_LIFX_ADDR_LENGTH];
         uint64_t                    as_integer;
     }                               site;
+    uint64_t                        tag_ids;
+    struct lgtd_lifx_tag            *tags[LGTD_LIFX_GATEWAY_MAX_TAGS];
     evutil_socket_t                 socket;
     // Those three timers let us measure the latency of the gateway. If we
     // aren't the only client on the network then this won't be accurate since
@@ -89,6 +93,9 @@
                                       const void *,
                                       int);
 
+int lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *, int, const char *);
+void lgtd_lifx_gateway_deallocate_tag_id(struct lgtd_lifx_gateway *, int);
+
 void lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *,
                                           const struct lgtd_lifx_packet_header *,
                                           const struct lgtd_lifx_packet_pan_gateway *);
@@ -98,3 +105,6 @@
 void lgtd_lifx_gateway_handle_power_state(struct lgtd_lifx_gateway *,
                                           const struct lgtd_lifx_packet_header *,
                                           const struct lgtd_lifx_packet_power_state *);
+void lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *,
+                                         const struct lgtd_lifx_packet_header *,
+                                         const struct lgtd_lifx_packet_tag_labels *);
diff --git a/lifx/tagging.c b/lifx/tagging.c
new file mode 100644
--- /dev/null
+++ b/lifx/tagging.c
@@ -0,0 +1,135 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <arpa/inet.h>
+#include <assert.h>
+#include <endian.h>
+#include <err.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <event2/util.h>
+
+#include "wire_proto.h"
+#include "core/time_monotonic.h"
+#include "bulb.h"
+#include "gateway.h"
+#include "tagging.h"
+#include "core/lightsd.h"
+
+struct lgtd_lifx_tag_list lgtd_lifx_tags =
+    LIST_HEAD_INITIALIZER(&lgtd_lifx_tags);
+
+static struct lgtd_lifx_tag *
+lgtd_lifx_tagging_find_tag(const char *tag_label)
+{
+    struct lgtd_lifx_tag *tag = NULL;
+    LIST_FOREACH(tag, &lgtd_lifx_tags, link) {
+        if (!strcmp(tag->label, tag_label)) {
+            break;
+        }
+    }
+    return tag;
+}
+
+static struct lgtd_lifx_site *
+lgtd_lifx_tagging_find_site(struct lgtd_lifx_site_list *sites,
+                            const struct lgtd_lifx_gateway *gw)
+{
+    struct lgtd_lifx_site *site = NULL;
+    LIST_FOREACH(site, sites, link) {
+        if (site->gw == gw) {
+            break;
+        }
+    }
+    return site;
+}
+
+struct lgtd_lifx_tag *
+lgtd_lifx_tagging_incref(const char *tag_label,
+                         const struct lgtd_lifx_gateway *gw)
+{
+    assert(strlen(tag_label) < LGTD_LIFX_LABEL_SIZE);
+    assert(gw);
+
+    bool dealloc_tag = false;
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(tag_label);
+    if (!tag) {
+        tag = calloc(1, sizeof(*tag));
+        if (!tag) {
+            return NULL;
+        }
+        strncpy(tag->label, tag_label, sizeof(tag->label) - 1);
+        LIST_INSERT_HEAD(&lgtd_lifx_tags, tag, link);
+        dealloc_tag = true;
+    }
+
+    struct lgtd_lifx_site *site = lgtd_lifx_tagging_find_site(&tag->sites, gw);
+    if (!site) {
+        site = calloc(1, sizeof(*site));
+        if (!site) {
+            if (dealloc_tag) {
+                LIST_REMOVE(tag, link);
+                free(tag);
+            }
+            errno = ENOMEM;
+            return NULL;
+        }
+        if (dealloc_tag) {
+            lgtd_info("discovered tag [%s]", tag_label);
+        }
+        lgtd_debug(
+            "tag [%s] added to gw [%s]:%hu (site %s)",
+            tag_label, gw->ip_addr, gw->port, lgtd_addrtoa(gw->site.as_array)
+        );
+        site->gw = gw;
+        LIST_INSERT_HEAD(&tag->sites, site, link);
+    }
+
+    return tag;
+}
+
+void
+lgtd_lifx_tagging_decref(struct lgtd_lifx_tag *tag,
+                         const struct lgtd_lifx_gateway *gw)
+{
+    assert(tag);
+    assert(gw);
+
+    struct lgtd_lifx_site *site;
+    site = lgtd_lifx_tagging_find_site(&tag->sites, gw);
+    if (site) {
+        lgtd_debug(
+            "tag [%s] removed from gw [%s]:%hu (site %s)",
+            tag->label, gw->ip_addr, gw->port,
+            lgtd_addrtoa(gw->site.as_array)
+        );
+        LIST_REMOVE(site, link);
+        free(site);
+    }
+    if (LIST_EMPTY(&tag->sites)) {
+        LIST_REMOVE(tag, link);
+        lgtd_info("forgetting unused tag [%s]", tag->label);
+        free(tag);
+    }
+}
diff --git a/lifx/tagging.h b/lifx/tagging.h
new file mode 100644
--- /dev/null
+++ b/lifx/tagging.h
@@ -0,0 +1,37 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#pragma once
+
+extern struct lgtd_lifx_tag_list lgtd_lifx_tags;
+
+struct lgtd_lifx_site {
+    LIST_ENTRY(lgtd_lifx_site)      link;
+    const struct lgtd_lifx_gateway  *gw;
+};
+LIST_HEAD(lgtd_lifx_site_list, lgtd_lifx_site);
+
+struct lgtd_lifx_tag {
+    LIST_ENTRY(lgtd_lifx_tag)   link;
+    char                        label[LGTD_LIFX_LABEL_SIZE];
+    struct lgtd_lifx_site_list  sites;
+};
+LIST_HEAD(lgtd_lifx_tag_list, lgtd_lifx_tag);
+
+struct lgtd_lifx_tag *lgtd_lifx_tagging_incref(const char *,
+                                               const struct lgtd_lifx_gateway *);
+void lgtd_lifx_tagging_decref(struct lgtd_lifx_tag *, const struct lgtd_lifx_gateway *);
diff --git a/lifx/wire_proto.c b/lifx/wire_proto.c
--- a/lifx/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -136,6 +136,21 @@
             .type = LGTD_LIFX_SET_WAVEFORM,
             .size = sizeof(struct lgtd_lifx_packet_waveform),
             .encode = ENCODER(lgtd_lifx_wire_encode_waveform)
+        },
+        {
+            REQUEST_ONLY,
+            .name = "GET_TAG_LABELS",
+            .type = LGTD_LIFX_GET_TAG_LABELS,
+            .size = sizeof(struct lgtd_lifx_packet_get_tag_labels),
+            .encode = lgtd_lifx_wire_null_packet_encoder_decoder
+        },
+        {
+            RESPONSE_ONLY,
+            .name = "TAG_LABELS",
+            .type = LGTD_LIFX_TAG_LABELS,
+            .size = sizeof(struct lgtd_lifx_packet_tag_labels),
+            .decode = DECODER(lgtd_lifx_wire_decode_tag_labels),
+            .handle = HANDLER(lgtd_lifx_gateway_handle_tag_labels)
         }
     };
 
@@ -320,3 +335,12 @@
     pkt->period = htole16(pkt->period);
     pkt->skew_ratio = htole16(pkt->skew_ratio);
 }
+
+void
+lgtd_lifx_wire_decode_tag_labels(struct lgtd_lifx_packet_tag_labels *pkt)
+{
+    assert(pkt);
+
+    pkt->label[sizeof(pkt->label) - 1] = '\0';
+    pkt->tags = le64toh(pkt->tags);
+}
diff --git a/lifx/wire_proto.h b/lifx/wire_proto.h
--- a/lifx/wire_proto.h
+++ b/lifx/wire_proto.h
@@ -199,6 +199,16 @@
     uint8_t     waveform; // see enum lgtd_lifx_waveform_type
 };
 
+enum { LGTD_LIFX_ALL_TAGS = ~0 };
+struct lgtd_lifx_packet_get_tag_labels {
+    uint64le_t  tags;
+};
+
+struct lgtd_lifx_packet_tag_labels {
+    uint64le_t  tags;
+    char        label[LGTD_LIFX_LABEL_SIZE];
+};
+
 #pragma pack(pop)
 
 struct lgtd_lifx_waveform_string_id {
diff --git a/tests/core/router/tests_router_utils.h b/tests/core/router/tests_router_utils.h
--- a/tests/core/router/tests_router_utils.h
+++ b/tests/core/router/tests_router_utils.h
@@ -1,3 +1,5 @@
+#pragma once
+
 int lgtd_tests_gw_pkt_queue_size = 0;
 struct {
     struct lgtd_lifx_gateway        *gw;
@@ -13,6 +15,8 @@
                                  const void *pkt,
                                  int pkt_size)
 {
+    (void)pkt_type;
+
     lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].gw = gw;
     // headers are created on the stack so we need to dup them:
     lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].hdr = malloc(
diff --git a/tests/core/tests_shims.c b/tests/core/tests_shims.c
--- a/tests/core/tests_shims.c
+++ b/tests/core/tests_shims.c
@@ -56,3 +56,12 @@
     (void)hdr;
     (void)pkt;
 }
+
+void lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *gw,
+                                         const struct lgtd_lifx_packet_header *hdr,
+                                         const struct lgtd_lifx_packet_tag_labels *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
diff --git a/tests/core/tests_utils.c b/tests/core/tests_utils.c
--- a/tests/core/tests_utils.c
+++ b/tests/core/tests_utils.c
@@ -14,6 +14,7 @@
 
 #include "lifx/wire_proto.h"
 #include "core/time_monotonic.h"
+#include "lifx/tagging.h"
 #include "core/jsmn.h"
 #include "core/jsonrpc.h"
 #include "core/client.h"
@@ -25,6 +26,9 @@
 struct lgtd_lifx_gateway_list lgtd_lifx_gateways =
     LIST_HEAD_INITIALIZER(&lgtd_lifx_gateways);
 
+struct lgtd_lifx_tag_list lgtd_lifx_tags =
+    LIST_HEAD_INITIALIZER(&lgtd_lifx_tags);
+
 struct lgtd_lifx_gateway *
 lgtd_tests_insert_mock_gateway(int id)
 {
@@ -75,3 +79,13 @@
 
     return targets;
 }
+
+struct lgtd_lifx_tag *
+lgtd_tests_insert_mock_tag(const char *tag_label)
+{
+    assert(strlen(tag_label) < LGTD_LIFX_LABEL_SIZE);
+    struct lgtd_lifx_tag *tag = calloc(1, sizeof(*tag));
+    strcpy(tag->label, tag_label);
+    LIST_INSERT_HEAD(&lgtd_lifx_tags, tag, link);
+    return tag;
+}
diff --git a/tests/core/tests_utils.h b/tests/core/tests_utils.h
--- a/tests/core/tests_utils.h
+++ b/tests/core/tests_utils.h
@@ -3,3 +3,4 @@
 struct lgtd_lifx_gateway *lgtd_tests_insert_mock_gateway(int);
 struct lgtd_lifx_bulb *lgtd_tests_insert_mock_bulb(struct lgtd_lifx_gateway *, uint64_t);
 struct lgtd_proto_target_list *lgtd_tests_build_target_list(const char *, ...);
+struct lgtd_lifx_tag *lgtd_tests_insert_mock_tag(const char *);
diff --git a/tests/lifx/gateway/test_gateway_allocate_tag_id_from_lifx_network.c b/tests/lifx/gateway/test_gateway_allocate_tag_id_from_lifx_network.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_allocate_tag_id_from_lifx_network.c
@@ -0,0 +1,122 @@
+#include <string.h>
+
+#include "gateway.c"
+
+#define MOCKED_LIFX_TAGGING_INCREF
+#include "test_gateway_utils.h"
+
+static bool tagging_incref_called = false;
+
+struct lgtd_lifx_tag *
+lgtd_lifx_tagging_incref(const char *label, const struct lgtd_lifx_gateway *gw)
+{
+    if (!label) {
+        errx(1, "missing tag label");
+    }
+    if (!gw) {
+        errx(1, "missing gateway");
+    }
+
+    static struct lgtd_lifx_tag *tag = NULL;
+
+    if (!tag) {
+        tag = calloc(1, sizeof(*tag));
+        strcpy(tag->label, label);
+        struct lgtd_lifx_site *site = calloc(1, sizeof(*site));
+        site->gw = gw;
+        LIST_INSERT_HEAD(&tag->sites, site, link);
+    }
+
+    tagging_incref_called = true;
+
+    return tag;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    struct lgtd_lifx_packet_header hdr;
+    memset(&hdr, 0, sizeof(hdr));
+
+    lgtd_lifx_gateway_allocate_tag_id(&gw, 4, "test");
+    if (!gw.tags[4]) {
+        errx(1, "gw.tag_ids[4] shouldn't be NULL");
+    }
+    if (strcmp(gw.tags[4]->label, "test")) {
+        errx(
+            1, "unexpected tag %.*s (expected test)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[4]->label
+        );
+    }
+    if (gw.tag_ids != TAG_ID_TO_VALUE(4)) {
+        errx(
+            1, "tag_ids = %jx (expected %jx)",
+            (uintmax_t)gw.tag_ids, (uintmax_t)TAG_ID_TO_VALUE(4)
+        );
+    }
+
+    lgtd_lifx_gateway_allocate_tag_id(&gw, 63, "test");
+    if (!gw.tags[4]) {
+        errx(1, "gw.tag_ids[4] shouldn't be NULL");
+    }
+    if (strcmp(gw.tags[4]->label, "test")) {
+        errx(
+            1, "unexpected tag %.*s (expected test)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[4]->label
+        );
+    }
+    if (!gw.tags[63]) {
+        errx(1, "gw.tag_ids[63] shouldn't be NULL");
+    }
+    if (strcmp(gw.tags[63]->label, "test")) {
+        errx(
+            1, "unexpected tag %.*s (expected test)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[4]->label
+        );
+    }
+    if (gw.tag_ids != (TAG_ID_TO_VALUE(4) | TAG_ID_TO_VALUE(63))) {
+        errx(
+            1, "tag_ids = %jx (expected %jx)",
+            (uintmax_t)gw.tag_ids,
+            (uintmax_t)(TAG_ID_TO_VALUE(4) | TAG_ID_TO_VALUE(63))
+        );
+    }
+
+    tagging_incref_called = false;
+    lgtd_lifx_gateway_allocate_tag_id(&gw, 4, "test");
+    if (!gw.tags[4]) {
+        errx(1, "gw.tag_ids[4] shouldn't be NULL");
+    }
+    if (strcmp(gw.tags[4]->label, "test")) {
+        errx(
+            1, "unexpected tag %.*s (expected test)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[4]->label
+        );
+    }
+    if (!gw.tags[63]) {
+        errx(1, "gw.tag_ids[63] shouldn't be NULL");
+    }
+    if (strcmp(gw.tags[63]->label, "test")) {
+        errx(
+            1, "unexpected tag %.*s (expected test)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[4]->label
+        );
+    }
+    if (gw.tag_ids != (TAG_ID_TO_VALUE(4) | TAG_ID_TO_VALUE(63))) {
+        errx(
+            1, "tag_ids = %jx (expected %jx)",
+            (uintmax_t)gw.tag_ids,
+            (uintmax_t)(TAG_ID_TO_VALUE(4) | TAG_ID_TO_VALUE(63))
+        );
+    }
+    if (tagging_incref_called) {
+        errx(1, "lgtd_lifx_tagging_incref shouldn't have been called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_deallocate_tag_id_from_lifx_network.c b/tests/lifx/gateway/test_gateway_deallocate_tag_id_from_lifx_network.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_deallocate_tag_id_from_lifx_network.c
@@ -0,0 +1,72 @@
+#include <string.h>
+
+#include "gateway.c"
+
+#define MOCKED_LIFX_TAGGING_DECREF
+#include "test_gateway_utils.h"
+
+static bool tagging_decref_called = false;
+
+void
+lgtd_lifx_tagging_decref(struct lgtd_lifx_tag *tag, const struct lgtd_lifx_gateway *gw)
+{
+    if (!tag) {
+        errx(1, "missing tag");
+    }
+    if (!gw) {
+        errx(1, "missing gateway");
+    }
+
+    tagging_decref_called = true;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    struct lgtd_lifx_packet_header hdr;
+    memset(&hdr, 0, sizeof(hdr));
+
+    struct lgtd_lifx_tag tag = {
+        .label = "test",
+        .sites = LIST_HEAD_INITIALIZER(&tag.sites)
+    };
+
+    gw.tags[0] = &tag;
+    gw.tag_ids = TAG_ID_TO_VALUE(0) | TAG_ID_TO_VALUE(42);
+
+    lgtd_lifx_gateway_deallocate_tag_id(&gw, 0);
+    if (gw.tags[0]) {
+        errx(1, "gw.tags[0] should have been set to NULL");
+    }
+    if (gw.tag_ids != TAG_ID_TO_VALUE(42)) {
+        errx(
+            1, "unexpected gw.tag_ids value = %jx (expected %jx)",
+            gw.tag_ids, TAG_ID_TO_VALUE(42)
+        );
+    }
+    if (!tagging_decref_called) {
+        errx(1, "lgtd_lifx_tagging_decref should have been called");
+    }
+
+    tagging_decref_called = false;
+    lgtd_lifx_gateway_deallocate_tag_id(&gw, 0);
+    if (gw.tags[0]) {
+        errx(1, "gw.tags[0] should be NULL");
+    }
+    if (gw.tag_ids != TAG_ID_TO_VALUE(42)) {
+        errx(
+            1, "unexpected gw.tag_ids value = %jx (expected %jx)",
+            gw.tag_ids, TAG_ID_TO_VALUE(42)
+        );
+    }
+    if (tagging_decref_called) {
+        errx(1, "lgtd_lifx_tagging_decref shouldn't have been called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_handle_tag_labels.c b/tests/lifx/gateway/test_gateway_handle_tag_labels.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_handle_tag_labels.c
@@ -0,0 +1,78 @@
+#include <string.h>
+
+#include "gateway.c"
+
+#include "test_gateway_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    struct lgtd_lifx_packet_header hdr;
+    memset(&hdr, 0, sizeof(hdr));
+
+    struct lgtd_lifx_packet_tag_labels pkt = {
+        .label = "test", .tags = 0
+    };
+
+    lgtd_lifx_gateway_handle_tag_labels(&gw, &hdr, &pkt);
+    if (gw.tag_ids != 0) {
+        errx(1, "expected gw.tags == 0 but got %jx", (uintmax_t)gw.tags);
+    }
+
+    pkt.tags = TAG_ID_TO_VALUE(42);
+    lgtd_lifx_gateway_handle_tag_labels(&gw, &hdr, &pkt);
+    if (gw.tag_ids != TAG_ID_TO_VALUE(42)) {
+        errx(
+            1, "expected gw.tags == %jx but got %jx",
+            TAG_ID_TO_VALUE(42), (uintmax_t)gw.tags
+        );
+    }
+    if (!gw.tags[42]) {
+        errx(1, "tag_id 42 should have been set");
+    }
+    if (strcmp(gw.tags[42]->label, pkt.label)) {
+        errx(
+            1, "unexpected label %.*s (expected %s)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[42]->label, pkt.label
+        );
+    }
+
+    strcpy(pkt.label, "toto");
+    pkt.tags = TAG_ID_TO_VALUE(2) | TAG_ID_TO_VALUE(4);
+    lgtd_lifx_gateway_handle_tag_labels(&gw, &hdr, &pkt);
+    memset(&pkt, 0, sizeof(pkt));
+    lgtd_lifx_gateway_handle_tag_labels(&gw, &hdr, &pkt);
+    uint64_t expected;
+    expected = TAG_ID_TO_VALUE(42) | TAG_ID_TO_VALUE(2) | TAG_ID_TO_VALUE(4);
+    if (gw.tag_ids != expected) {
+        errx(
+            1, "expected gw.tags == %jx but got %jx",
+            TAG_ID_TO_VALUE(42), (uintmax_t)gw.tags
+        );
+    }
+    if (strcmp(gw.tags[2]->label, "toto")) {
+        errx(
+            1, "unexpected label %.*s (expected %s)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[2]->label, "toto"
+        );
+    }
+    if (strcmp(gw.tags[4]->label, "toto")) {
+        errx(
+            1, "unexpected label %.*s (expected %s)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[4]->label, "toto"
+        );
+    }
+    if (strcmp(gw.tags[42]->label, "test")) {
+        errx(
+            1, "unexpected label %.*s (expected %s)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[42]->label, "test"
+        );
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/tagging/CMakeLists.txt b/tests/lifx/tagging/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/lifx/tagging/CMakeLists.txt
@@ -0,0 +1,19 @@
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+ADD_LIBRARY(
+    test_lifx_tagging STATIC
+    ${LIGHTSD_SOURCE_DIR}/core/log.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
+)
+
+FUNCTION(ADD_TAGGING_TEST TEST_SOURCE)
+    ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE} test_lifx_tagging)
+ENDFUNCTION()
+
+FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
+FOREACH(TEST ${TESTS})
+    ADD_TAGGING_TEST(${TEST})
+ENDFOREACH()
diff --git a/tests/lifx/tagging/test_tagging_decref.c b/tests/lifx/tagging/test_tagging_decref.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/tagging/test_tagging_decref.c
@@ -0,0 +1,67 @@
+#include "tagging.c"
+
+static int
+count_tag(const char *tag_label)
+{
+    int count = 0;
+    struct lgtd_lifx_tag *tag;
+    LIST_FOREACH(tag, &lgtd_lifx_tags, link) {
+        if (!strcmp(tag_label, tag->label)) {
+            count++;
+        }
+    }
+    return count;
+}
+
+static int
+count_site(struct lgtd_lifx_site_list *list, const struct lgtd_lifx_gateway *gw)
+{
+    int count = 0;
+    struct lgtd_lifx_site *site;
+    LIST_FOREACH(site, list, link) {
+        if (site->gw == gw) {
+            count++;
+        }
+    }
+    return count;
+}
+
+int
+main(void)
+{
+    struct lgtd_lifx_gateway gw1, gw2;
+    memset(&gw1, 0, sizeof(gw1));
+    memset(&gw2, 0, sizeof(gw2));
+
+    struct lgtd_lifx_site *site_gw1 = calloc(1, sizeof(*site_gw1));
+    site_gw1->gw = &gw1;
+    struct lgtd_lifx_site *site_gw2 = calloc(1, sizeof(*site_gw2));
+    site_gw2->gw = &gw2;
+
+    const char *rawr = "rawr";
+    struct lgtd_lifx_tag *tag = calloc(1, sizeof(*tag));
+    strcpy(tag->label, rawr);
+    LIST_INSERT_HEAD(&tag->sites, site_gw1, link);
+    LIST_INSERT_HEAD(&tag->sites, site_gw2, link);
+    LIST_INSERT_HEAD(&lgtd_lifx_tags, tag, link);
+
+    for (int i = 0; i != 2; i++) {
+        lgtd_lifx_tagging_decref(tag, &gw2);
+        if (count_site(&tag->sites, &gw2) != 0) {
+            errx(1, "gw2 shouldn't be in the sites list");
+        }
+        if (count_site(&tag->sites, &gw1) != 1) {
+            errx(1, "gw1 wasn't found once in the sites list");
+        }
+        if (count_tag(rawr) != 1) {
+            errx(1, "%s wasn't found once in the tags list");
+        }
+    }
+
+    lgtd_lifx_tagging_decref(tag, &gw1);
+    if (count_tag(rawr)) {
+        errx(1, "the tags list should be empty");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/tagging/test_tagging_incref.c b/tests/lifx/tagging/test_tagging_incref.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/tagging/test_tagging_incref.c
@@ -0,0 +1,65 @@
+#include "tagging.c"
+
+static int
+count_tag(const char *tag_label)
+{
+    int count = 0;
+    struct lgtd_lifx_tag *tag;
+    LIST_FOREACH(tag, &lgtd_lifx_tags, link) {
+        if (!strcmp(tag_label, tag->label)) {
+            count++;
+        }
+    }
+    return count;
+}
+
+static int
+count_site(struct lgtd_lifx_site_list *list, const struct lgtd_lifx_gateway *gw)
+{
+    int count = 0;
+    struct lgtd_lifx_site *site;
+    LIST_FOREACH(site, list, link) {
+        if (site->gw == gw) {
+            count++;
+        }
+    }
+    return count;
+}
+
+int
+main(void)
+{
+    struct lgtd_lifx_gateway gw1, gw2;
+    memset(&gw1, 0, sizeof(gw1));
+    memset(&gw2, 0, sizeof(gw2));
+
+    const char *rawr = "rawr";
+    const char *awww = "awww";
+
+    for (int i = 0; i != 2; i++) {
+        lgtd_lifx_tagging_incref(rawr, &gw1);
+        if (count_tag(rawr) != 1) {
+            errx(1, "%s wasn't found once the list of tags", rawr);
+        }
+        if (count_site(&LIST_FIRST(&lgtd_lifx_tags)->sites, &gw1) != 1) {
+            errx(1, "site %p wasn't found once in the list of sites", &gw1);
+        }
+    }
+
+    lgtd_lifx_tagging_incref(rawr, &gw2);
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(rawr);
+    if (count_site(&tag->sites, &gw2) != 1) {
+        errx(1, "gw2 wasn't found once in the sites of tag %s", tag->label);
+    }
+
+    lgtd_lifx_tagging_incref(awww, &gw1);
+    if (count_tag(awww) != 1) {
+        errx(1, "%s wasn't found once in the list of tags", awww);
+    }
+    tag = lgtd_lifx_tagging_find_tag(awww);
+    if (count_site(&tag->sites, &gw1) != 1) {
+        errx(1, "gw1 wasn't found once in the sites of tag %s", awww);
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/wire_proto/test_wire_proto_utils.h b/tests/lifx/wire_proto/test_wire_proto_utils.h
--- a/tests/lifx/wire_proto/test_wire_proto_utils.h
+++ b/tests/lifx/wire_proto/test_wire_proto_utils.h
@@ -26,3 +26,12 @@
     (void)hdr;
     (void)pkt;
 }
+
+void lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *gw,
+                                         const struct lgtd_lifx_packet_header *hdr,
+                                         const struct lgtd_lifx_packet_tag_labels *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
