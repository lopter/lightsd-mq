# HG changeset patch
# Parent  030a3143a5b087c2d7a65c32659135c63be00bb3
Add the toggle command: turn on a bulb if it's off and vice-versa

This lets you change the state of a bulb without having to query its
state first, super useful with the command pipe.

diff --git a/README.rst b/README.rst
--- a/README.rst
+++ b/README.rst
@@ -26,11 +26,11 @@
 
 - power_off (with auto-retry);
 - power_on (with auto-retry);
+- power_toggle (power on if off and vice-versa, with auto-retry);
 - set_light_from_hsbk;
 - set_waveform (change the light according to a function like SAW or SINE);
 - get_light_state;
-- tag/untag (group/ungroup bulbs together);
-- toggle (power on if off and vice-versa, coming up).
+- tag/untag (group/ungroup bulbs together).
 
 The JSON-RPC interface works on top of TCP/IPv4/v6, Unix sockets (coming up) or
 over a command pipe (named pipe, see mkfifo(1)).
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -938,44 +938,24 @@
     );
 }
 
-static void
-lgtd_jsonrpc_check_and_call_power_on(struct lgtd_client *client)
-{
-    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
-    bool ok = lgtd_jsonrpc_extract_target_list(&targets, client);
-    if (!ok) {
-        return;
-    }
-
-    lgtd_proto_power_on(client, &targets);
-    lgtd_proto_target_list_clear(&targets);
+#define CHECK_AND_CALL_TARGETS_ONLY_METHOD(proto_method)                       \
+static void                                                                    \
+lgtd_jsonrpc_check_and_call_##proto_method(struct lgtd_client *client)         \
+{                                                                              \
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);  \
+    bool ok = lgtd_jsonrpc_extract_target_list(&targets, client);              \
+    if (!ok) {                                                                 \
+        return;                                                                \
+    }                                                                          \
+                                                                               \
+    lgtd_proto_##proto_method(client, &targets);                               \
+    lgtd_proto_target_list_clear(&targets);                                    \
 }
 
-static void
-lgtd_jsonrpc_check_and_call_power_off(struct lgtd_client *client)
-{
-    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
-    bool ok = lgtd_jsonrpc_extract_target_list(&targets, client);
-    if (!ok) {
-        return;
-    }
-
-    lgtd_proto_power_off(client, &targets);
-    lgtd_proto_target_list_clear(&targets);
-}
-
-static void
-lgtd_jsonrpc_check_and_call_get_light_state(struct lgtd_client *client)
-{
-    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
-    bool ok = lgtd_jsonrpc_extract_target_list(&targets, client);
-    if (!ok) {
-        return;
-    }
-
-    lgtd_proto_get_light_state(client, &targets);
-    lgtd_proto_target_list_clear(&targets);
-}
+CHECK_AND_CALL_TARGETS_ONLY_METHOD(power_on);
+CHECK_AND_CALL_TARGETS_ONLY_METHOD(power_off);
+CHECK_AND_CALL_TARGETS_ONLY_METHOD(power_toggle);
+CHECK_AND_CALL_TARGETS_ONLY_METHOD(get_light_state);
 
 static void
 lgtd_jsonrpc_check_and_call_proto_tag_or_untag(struct lgtd_client *client,
@@ -1074,6 +1054,10 @@
             lgtd_jsonrpc_check_and_call_power_off
         ),
         LGTD_JSONRPC_METHOD(
+            "power_toggle", 1, // t
+            lgtd_jsonrpc_check_and_call_power_toggle
+        ),
+        LGTD_JSONRPC_METHOD(
             "set_light_from_hsbk", 6, // t, h, s, b, k, t
             lgtd_jsonrpc_check_and_call_set_light_from_hsbk
         ),
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -71,6 +71,35 @@
 }
 
 void
+lgtd_proto_power_toggle(struct lgtd_client *client,
+                        const struct lgtd_proto_target_list *targets)
+{
+    assert(targets);
+
+    struct lgtd_router_device_list *devices = NULL;
+    devices = lgtd_router_targets_to_devices(targets);
+    if (!devices) {
+        lgtd_client_send_error(
+            client, LGTD_CLIENT_INTERNAL_ERROR, "couldn't allocate memory"
+        );
+        return;
+    }
+
+    struct lgtd_router_device *device;
+    SLIST_FOREACH(device, devices, link) {
+        struct lgtd_lifx_bulb *bulb = device->device;
+        struct lgtd_lifx_packet_power_state pkt = {
+            .power = ~bulb->state.power
+        };
+        lgtd_router_send_to_device(bulb, LGTD_LIFX_SET_POWER_STATE, &pkt);
+    }
+
+    SEND_RESULT(client, true);
+
+    lgtd_router_device_list_free(devices);
+}
+
+void
 lgtd_proto_power_off(struct lgtd_client *client,
                      const struct lgtd_proto_target_list *targets)
 {
@@ -329,7 +358,6 @@
     );
 fini:
     lgtd_router_device_list_free(devices);
-    return;
 }
 
 void
diff --git a/core/proto.h b/core/proto.h
--- a/core/proto.h
+++ b/core/proto.h
@@ -38,6 +38,7 @@
                              int, float, int, bool);
 void lgtd_proto_power_on(struct lgtd_client *, const struct lgtd_proto_target_list *);
 void lgtd_proto_power_off(struct lgtd_client *, const struct lgtd_proto_target_list *);
+void lgtd_proto_power_toggle(struct lgtd_client *, const struct lgtd_proto_target_list *);
 void lgtd_proto_get_light_state(struct lgtd_client *, const struct lgtd_proto_target_list *);
 void lgtd_proto_tag(struct lgtd_client *, const struct lgtd_proto_target_list *, const char *);
 void lgtd_proto_untag(struct lgtd_client *, const struct lgtd_proto_target_list *, const char *);
diff --git a/docs/protocol.rst b/docs/protocol.rst
--- a/docs/protocol.rst
+++ b/docs/protocol.rst
@@ -37,6 +37,10 @@
 
    Power on the given bulb(s).
 
+.. function:: power_toggle(target)
+
+   Power on (if they are off) or power off (if they are on) the given bulb(s).
+
 .. function:: set_light_from_hsbk(target, h, s, b, k, t)
 
    :param float h: Hue from 0 to 360.
diff --git a/examples/lightsc.py b/examples/lightsc.py
--- a/examples/lightsc.py
+++ b/examples/lightsc.py
@@ -1,7 +1,6 @@
 #!/usr/bin/env python
 
 import json
-import pprint
 import socket
 import sys
 import time
@@ -69,6 +68,10 @@
     return jsonrpc_call(socket, "power_off", {"target": target})
 
 
+def power_toggle(socket, target):
+    return jsonrpc_call(socket, "power_toggle", {"target": target})
+
+
 def get_light_state(socket, target):
     return jsonrpc_call(socket, "get_light_state", [target])
 
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_toggle.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_toggle.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_toggle.c
@@ -0,0 +1,58 @@
+#include "jsonrpc.c"
+
+#include "mock_client_buf.h"
+
+#define MOCKED_LGTD_PROTO_POWER_TOGGLE
+#include "test_jsonrpc_utils.h"
+
+static bool power_toggle_called = false;
+
+void
+lgtd_proto_power_toggle(struct lgtd_client *client,
+                        const struct lgtd_proto_target_list *targets)
+{
+    if (!client) {
+        errx(1, "missing client!");
+    }
+
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+    power_toggle_called = true;
+}
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"power_toggle\","
+        "\"params\": {\"target\": \"*\"},"
+        "\"id\": \"42\""
+    "}");
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    bool ok;
+    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
+    struct lgtd_client client = {
+        .io = NULL, .current_request = &req, .json = json
+    };
+    ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
+    if (!ok) {
+        errx(1, "can't parse request");
+    }
+
+    lgtd_jsonrpc_check_and_call_power_toggle(&client);
+
+    if (!power_toggle_called) {
+        errx(1, "lgtd_proto_power_toggle wasn't called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_utils.h b/tests/core/jsonrpc/test_jsonrpc_utils.h
--- a/tests/core/jsonrpc/test_jsonrpc_utils.h
+++ b/tests/core/jsonrpc/test_jsonrpc_utils.h
@@ -121,3 +121,13 @@
     (void)tag_label;
 }
 #endif
+
+#ifndef MOCKED_LGTD_PROTO_POWER_TOGGLE
+void
+lgtd_proto_power_toggle(struct lgtd_client *client,
+                        const struct lgtd_proto_target_list *targets)
+{
+    (void)client;
+    (void)targets;
+}
+#endif
diff --git a/tests/core/proto/test_proto_toggle.c b/tests/core/proto/test_proto_power_toggle.c
rename from tests/core/proto/test_proto_toggle.c
rename to tests/core/proto/test_proto_power_toggle.c
--- a/tests/core/proto/test_proto_toggle.c
+++ b/tests/core/proto/test_proto_power_toggle.c
@@ -128,7 +128,7 @@
     struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
     struct lgtd_proto_target_list *targets = (void *)0x2a;
 
-    lgtd_proto_toggle(&client, targets);
+    lgtd_proto_power_toggle(&client, targets);
 
     const char expected[] = "true";
 
diff --git a/tests/core/proto/test_proto_power_toggle_targets_to_device_fails.c b/tests/core/proto/test_proto_power_toggle_targets_to_device_fails.c
new file mode 100644
--- /dev/null
+++ b/tests/core/proto/test_proto_power_toggle_targets_to_device_fails.c
@@ -0,0 +1,86 @@
+#include "proto.c"
+
+#include "mock_client_buf.h"
+#include "mock_daemon.h"
+#include "mock_gateway.h"
+#include "tests_utils.h"
+
+#define MOCKED_ROUTER_SEND_TO_DEVICE
+#define MOCKED_ROUTER_TARGETS_TO_DEVICES
+#define MOCKED_ROUTER_DEVICE_LIST_FREE
+#define MOCKED_CLIENT_SEND_ERROR
+#include "tests_proto_utils.h"
+
+static bool device_list_free_called = false;
+
+void
+lgtd_router_device_list_free(struct lgtd_router_device_list *devices)
+{
+    if (!devices) {
+        lgtd_errx(1, "the device list must be passed");
+    }
+
+    device_list_free_called = true;
+}
+
+struct lgtd_router_device_list *
+lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *targets)
+{
+    if (targets != (void *)0x2a) {
+        lgtd_errx(1, "unexpected targets list");
+    }
+
+    return NULL;
+}
+
+static int router_send_to_device_call_count = 0;
+
+void
+lgtd_router_send_to_device(struct lgtd_lifx_bulb *bulb,
+                           enum lgtd_lifx_packet_type pkt_type,
+                           void *pkt)
+{
+    (void)bulb;
+    (void)pkt_type;
+    (void)pkt;
+
+    router_send_to_device_call_count++;
+}
+
+static int client_send_error_call_count = 0;
+
+void
+lgtd_client_send_error(struct lgtd_client *client,
+                       enum lgtd_client_error_code error,
+                       const char *msg)
+{
+    (void)client;
+    (void)error;
+    (void)msg;
+
+    client_send_error_call_count++;
+}
+
+int
+main(void)
+{
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_proto_target_list *targets = (void *)0x2a;
+
+    lgtd_proto_power_toggle(&client, targets);
+
+    if (client_send_error_call_count != 1) {
+        errx(1, "lgtd_client_send_error called %d times (expected 1)",
+            client_send_error_call_count
+        );
+    }
+
+    if (router_send_to_device_call_count) {
+        errx(
+            1, "lgtd_router_send_to_device called %d times (expected 0)",
+            router_send_to_device_call_count
+        );
+    }
+
+    return 0;
+}
