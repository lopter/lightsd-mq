# HG changeset patch
# Parent  36017e76125b81cf10f409eb692fa186e587f66d
Add the --syslog (-S) and --syslog-facility (-F) logging options

Closes GH-1.

diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -13,6 +13,7 @@
 ADD_EXECUTABLE(
     lightsd
     client.c
+    console.c
     daemon.c
     jsmn.c
     jsonrpc.c
diff --git a/core/console.c b/core/console.c
new file mode 100644
--- /dev/null
+++ b/core/console.c
@@ -0,0 +1,140 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <assert.h>
+#include <err.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>
+
+#include "console.h"
+#include "lightsd.h"
+
+static void
+lgtd_console_isotime_now(char *strbuf, int bufsz)
+{
+    assert(strbuf);
+    assert(bufsz > 0);
+
+    struct timeval now;
+    if (gettimeofday(&now, NULL) == -1) {
+        goto error;
+    }
+    struct tm tm_now;
+    if (!localtime_r(&now.tv_sec, &tm_now)) {
+        goto error;
+    }
+    LGTD_TM_TO_ISOTIME(&tm_now, strbuf, bufsz, now.tv_usec);
+    return;
+error:
+    strbuf[0] = '\0';
+}
+
+static void
+lgtd_console_log_header(const char *loglvl, bool showprogname)
+{
+    if (lgtd_opts.log_timestamps) {
+        char timestr[64];
+        lgtd_console_isotime_now(timestr, sizeof(timestr));
+        fprintf(
+            stderr, "[%s] [%s] %s",
+            timestr, loglvl, showprogname ? "lightsd: " : ""
+        );
+        return;
+    }
+    fprintf(stderr, "[%s] %s", loglvl, showprogname ? "lightsd: " : "");
+}
+
+void
+lgtd_console_err(int eval, const char *fmt, va_list ap)
+{
+    int errsave = errno;
+    va_list aq;
+    va_copy(aq, ap);
+    // lgtd_cleanup is probably going to free some of the arguments we got, so
+    // let's print to a buffer before we call err.
+    char errmsg[LGTD_ERROR_MSG_BUFSIZE];
+    vsnprintf(errmsg, sizeof(errmsg), fmt, aq);
+    va_end(aq);
+    lgtd_cleanup();
+    lgtd_console_log_header("ERR", false);
+    errno = errsave;
+    err(eval, "%s", errmsg);
+}
+
+void
+lgtd_console_errx(int eval, const char *fmt, va_list ap)
+{
+    va_list aq;
+    va_copy(aq, ap);
+    // lgtd_cleanup is probably going to free some of the arguments we got, so
+    // let's print to a buffer before we call err.
+    char errmsg[LGTD_ERROR_MSG_BUFSIZE];
+    vsnprintf(errmsg, sizeof(errmsg), fmt, aq);
+    va_end(aq);
+    lgtd_cleanup();
+    lgtd_console_log_header("ERR", false);
+    errx(eval, "%s", errmsg);
+}
+
+void
+lgtd_console_warn(const char *fmt, va_list ap)
+{
+    va_list aq;
+    va_copy(aq, ap);
+    lgtd_console_log_header("WARN", false);
+    vwarn(fmt, aq);
+    va_end(aq);
+}
+
+void
+lgtd_console_warnx(const char *fmt, va_list ap)
+{
+    va_list aq;
+    va_copy(aq, ap);
+    lgtd_console_log_header("WARN", false);
+    vwarnx(fmt, aq);
+    va_end(aq);
+}
+
+void
+lgtd_console_info(const char *fmt, va_list ap)
+{
+    va_list aq;
+    va_copy(aq, ap);
+    lgtd_console_log_header("INFO", true);
+    vfprintf(stderr, fmt, aq);
+    va_end(aq);
+    fprintf(stderr, "\n");
+}
+
+void
+lgtd_console_debug(const char *fmt, va_list ap)
+{
+    va_list aq;
+    va_copy(aq, ap);
+    lgtd_console_log_header("DEBUG", true);
+    vfprintf(stderr, fmt, aq);
+    va_end(aq);
+    fprintf(stderr, "\n");
+}
diff --git a/core/console.h b/core/console.h
new file mode 100644
--- /dev/null
+++ b/core/console.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#pragma once
+
+#ifndef __attribute__
+# define __atttribute__(e)
+#endif
+
+void lgtd_console_err(int, const char *, va_list)
+    __attribute__((noreturn));
+void lgtd_console_errx(int, const char *, va_list)
+    __attribute__((noreturn));
+void lgtd_console_warn(const char *, va_list);
+void lgtd_console_warnx(const char *, va_list);
+void lgtd_console_info(const char *, va_list);
+void lgtd_console_debug(const char *, va_list);
diff --git a/core/daemon.c b/core/daemon.c
--- a/core/daemon.c
+++ b/core/daemon.c
@@ -29,11 +29,13 @@
 #include <grp.h>
 #include <libgen.h>
 #include <pwd.h>
+#include <stdarg.h>
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <syslog.h>
 #include <unistd.h>
 
 #include <event2/util.h>
@@ -368,3 +370,116 @@
 
     return true;
 }
+
+int
+lgtd_daemon_syslog_facilitytoi(const char *facility)
+{
+    struct {
+        const char  *name;
+        int         value;
+    } syslog_facilities[] = {
+        { "LOG_DAEMON", LOG_DAEMON },
+        { "LOG_USER",   LOG_USER   },
+        { "LOG_LOCAL0", LOG_LOCAL0 },
+        { "LOG_LOCAL1", LOG_LOCAL1 },
+        { "LOG_LOCAL2", LOG_LOCAL2 },
+        { "LOG_LOCAL3", LOG_LOCAL3 },
+        { "LOG_LOCAL4", LOG_LOCAL4 },
+        { "LOG_LOCAL5", LOG_LOCAL5 },
+        { "LOG_LOCAL6", LOG_LOCAL6 },
+        { "LOG_LOCAL7", LOG_LOCAL7 }
+    };
+
+    for (int i = 0; i != LGTD_ARRAY_SIZE(syslog_facilities); i++) {
+        if (!strcmp(facility, syslog_facilities[i].name)) {
+            return syslog_facilities[i].value;
+        }
+    }
+
+    lgtd_errx(
+        1,
+        "Invalid syslog facility %s (possible values: LOG_DAEMON, "
+        "LOG_USER, LOG_LOCAL0 through 7)", facility
+    );
+}
+
+static void
+lgtd_daemon_setup_errfmt(const char *fmt, char *errfmt, int sz)
+{
+    int n = LGTD_MIN(sz - 1, (int)strlen(fmt) + 1);
+    memcpy(errfmt, fmt, n);
+    if (n - 1 + (int)sizeof(": %m") <= sz) {
+        memcpy(errfmt + n - 1, ": %m", sizeof(": %m"));
+    } else {
+        errfmt[n] = '\0';
+#ifndef NDEBUG
+        abort();
+#endif
+    }
+}
+
+void
+lgtd_daemon_syslog_err(int eval, const char *fmt, va_list ap)
+{
+    char errfmt[LGTD_DAEMON_ERRFMT_SIZE];
+    lgtd_daemon_setup_errfmt(fmt, errfmt, sizeof(errfmt));
+
+    va_list aq;
+    va_copy(aq, ap);
+    vsyslog(LOG_PID|LOG_ERR|lgtd_opts.syslog_facility, errfmt, aq);
+    va_end(aq);
+
+    lgtd_cleanup();
+    exit(eval);
+}
+
+void
+lgtd_daemon_syslog_errx(int eval, const char *fmt, va_list ap)
+{
+    va_list aq;
+    va_copy(aq, ap);
+    vsyslog(LOG_PID|LOG_ERR|lgtd_opts.syslog_facility, fmt, aq);
+    va_end(aq);
+
+    lgtd_cleanup();
+    exit(eval);
+}
+
+void
+lgtd_daemon_syslog_warn(const char *fmt, va_list ap)
+{
+    char errfmt[LGTD_DAEMON_ERRFMT_SIZE];
+    lgtd_daemon_setup_errfmt(fmt, errfmt, sizeof(errfmt));
+
+    va_list aq;
+    va_copy(aq, ap);
+    vsyslog(LOG_PID|LOG_WARNING|lgtd_opts.syslog_facility, errfmt, aq);
+    va_end(aq);
+}
+
+void
+lgtd_daemon_syslog_warnx(const char *fmt, va_list ap)
+{
+    va_list aq;
+    va_copy(aq, ap);
+    vsyslog(LOG_PID|LOG_WARNING|lgtd_opts.syslog_facility, fmt, aq);
+    va_end(aq);
+}
+
+void
+lgtd_daemon_syslog_info(const char *fmt, va_list ap)
+{
+    va_list aq;
+    va_copy(aq, ap);
+    vsyslog(LOG_PID|LOG_INFO|lgtd_opts.syslog_facility, fmt, aq);
+    va_end(aq);
+}
+
+void
+lgtd_daemon_syslog_debug(const char *fmt, va_list ap)
+{
+    va_list aq;
+    va_copy(aq, ap);
+    vsyslog(LOG_PID|LOG_DEBUG|lgtd_opts.syslog_facility, fmt, aq);
+    va_end(aq);
+}
diff --git a/core/daemon.h b/core/daemon.h
--- a/core/daemon.h
+++ b/core/daemon.h
@@ -17,8 +17,14 @@
 
 #pragma once
 
+#ifndef __attribute__
+# define __atttribute__(e)
+#endif
+
 enum { LGTD_DAEMON_TITLE_SIZE = 2048 };
 
+enum { LGTD_DAEMON_ERRFMT_SIZE = 4096 };
+
 bool lgtd_daemon_unleash(void); // \_o<
 void lgtd_daemon_setup_proctitle(int, char *[], char *[]);
 void lgtd_daemon_update_proctitle(void);
@@ -27,3 +33,14 @@
 void lgtd_daemon_set_group(const char *);
 void lgtd_daemon_drop_privileges(void);
 bool lgtd_daemon_makedirs(const char *);
+
+
+int lgtd_daemon_syslog_facilitytoi(const char *);
+void lgtd_daemon_syslog_err(int, const char *, va_list)
+    __attribute__((noreturn));
+void lgtd_daemon_syslog_errx(int, const char *, va_list)
+    __attribute__((noreturn));
+void lgtd_daemon_syslog_warn(const char *, va_list);
+void lgtd_daemon_syslog_warnx(const char *, va_list);
+void lgtd_daemon_syslog_info(const char *, va_list);
+void lgtd_daemon_syslog_debug(const char *, va_list);
diff --git a/core/lightsd.c b/core/lightsd.c
--- a/core/lightsd.c
+++ b/core/lightsd.c
@@ -32,6 +32,7 @@
 #include <signal.h>
 #include <string.h>
 #include <strings.h>
+#include <syslog.h>
 
 #include <event2/event.h>
 #include <event2/event_struct.h>
@@ -61,11 +62,15 @@
     .verbosity = LGTD_WARN,
 #endif
     .user = NULL,
-    .group = NULL
+    .group = NULL,
+    .syslog = false,
+    .syslog_facility = LOG_DAEMON
 }; 
 
 struct event_base *lgtd_ev_base = NULL;
 
+static int lgtd_last_signal_received = 0;
+
 void
 lgtd_cleanup(void)
 {
@@ -87,9 +92,9 @@
 {
     assert(ctx);
 
-    lgtd_info(
-        "received signal %d (%s), exiting...", signum, strsignal(signum)
-    );
+    // NOTE: syslog isn't signal safe, don't log anything in this function.
+
+    lgtd_last_signal_received = signum;
     event_del((struct event *)ctx);  // restore default behavior
     event_base_loopbreak(lgtd_ev_base);
     (void)events;
@@ -143,7 +148,11 @@
 "                                       group of this user if -g is missing).\n"
 "  [-g,--group group]                   Drop privileges to this group (-g requires\n"
 "                                       the -u option to be used).\n"
-"  [-t,--no-timestamps]                 Disable timestamps in logs.\n"
+"  [-S,--syslog]                        Divert logging from the console to syslog.\n"
+"  [-F,--syslog-facility]               Facility to use with syslog (defaults to\n"
+"                                       LOG_DAEMON, other possible values are\n"
+"                                       LOG_USER and LOG_LOCAL0-7, see syslog(3)).\n"
+"  [-t,--no-timestamps]                 Disable timestamps in the console logs.\n"
 "  [-h,--help]                          Display this.\n"
 "  [-V,--version]                       Display version and build information.\n"
 "  [-v,--verbosity debug|info|warning|error]\n"
@@ -176,6 +185,8 @@
         {"daemonize",       no_argument,       NULL, 'd'},
         {"user",            required_argument, NULL, 'u'},
         {"group",           required_argument, NULL, 'g'},
+        {"syslog",          no_argument,       NULL, 'S'},
+        {"syslog-facility", required_argument, NULL, 'F'},
         {"no-timestamps",   no_argument,       NULL, 't'},
         {"help",            no_argument,       NULL, 'h'},
         {"verbosity",       required_argument, NULL, 'v'},
@@ -184,7 +195,7 @@
         {"rundir",          no_argument,       NULL, 'r'},
         {NULL,              0,                 NULL, 0}
     };
-    const char short_opts[] = "l:c:s:fdu:g:thv:V";
+    const char short_opts[] = "l:c:s:fdu:g:SF:thv:V";
 
     if (argc == 1) {
         lgtd_usage(progname);
@@ -226,6 +237,12 @@
         case 'g':
             lgtd_opts.group = optarg;
             break;
+        case 'S':
+            lgtd_opts.syslog = true;
+            break;
+        case 'F':
+            lgtd_opts.syslog_facility = lgtd_daemon_syslog_facilitytoi(optarg);
+            break;
         case 't':
             lgtd_opts.log_timestamps = false;
             break;
@@ -301,6 +318,13 @@
 
     event_base_dispatch(lgtd_ev_base);
 
+    if (lgtd_last_signal_received) {
+        lgtd_info(
+            "received signal %d (%s), exiting...",
+            lgtd_last_signal_received, strsignal(lgtd_last_signal_received)
+        );
+    }
+
     lgtd_cleanup();
 
     return 0;
diff --git a/core/lightsd.h b/core/lightsd.h
--- a/core/lightsd.h
+++ b/core/lightsd.h
@@ -109,6 +109,8 @@
     enum lgtd_verbosity verbosity;
     const char          *user;
     const char          *group;
+    bool                syslog;
+    int                 syslog_facility;
 };
 
 extern struct lgtd_opts lgtd_opts;
@@ -126,14 +128,12 @@
 #define LGTD_PRINT_DURATION(secs, arr) \
     lgtd_print_duration((secs), (arr), sizeof((arr)))
 
-void _lgtd_err(void (*)(int, const char *, ...), int, const char *, ...)
-    __attribute__((format(printf, 3, 4)));
-#define lgtd_err(eval, fmt, ...) _lgtd_err(err, (eval), (fmt), ##__VA_ARGS__);
-#define lgtd_errx(eval, fmt, ...) _lgtd_err(errx, (eval), (fmt), ##__VA_ARGS__);
-void _lgtd_warn(void (*)(const char *, va_list), const char *, ...)
-    __attribute__((format(printf, 2, 3)));
-#define lgtd_warn(fmt, ...) _lgtd_warn(vwarn, (fmt), ##__VA_ARGS__);
-#define lgtd_warnx(fmt, ...) _lgtd_warn(vwarnx, (fmt), ##__VA_ARGS__);
+void lgtd_err(int, const char *, ...)
+    __attribute__((format(printf, 2, 3), noreturn));
+void lgtd_errx(int, const char *, ...)
+    __attribute__((format(printf, 2, 3), noreturn));
+void lgtd_warn(const char *, ...) __attribute__((format(printf, 1, 2)));
+void lgtd_warnx(const char *, ...) __attribute__((format(printf, 1, 2)));
 void lgtd_info(const char *, ...) __attribute__((format(printf, 1, 2)));
 void lgtd_debug(const char *, ...) __attribute__((format(printf, 1, 2)));
 void lgtd_libevent_log(int, const char *);
diff --git a/core/log.c b/core/log.c
--- a/core/log.c
+++ b/core/log.c
@@ -17,62 +17,25 @@
 
 #include <sys/socket.h>
 #include <sys/tree.h>
-#include <sys/time.h>
 #include <sys/un.h>
 #include <arpa/inet.h>
 #include <assert.h>
 #include <endian.h>
-#include <err.h>
-#include <errno.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
 
 #include <event2/event.h>
 
 #include "lifx/wire_proto.h"
 #include "stats.h"
+#include "console.h"
+#include "daemon.h"
 #include "lightsd.h"
 
-static void
-lgtd_isotime_now(char *strbuf, int bufsz)
-{
-    assert(strbuf);
-    assert(bufsz > 0);
-
-    struct timeval now;
-    if (gettimeofday(&now, NULL) == -1) {
-        goto error;
-    }
-    struct tm tm_now;
-    if (!localtime_r(&now.tv_sec, &tm_now)) {
-        goto error;
-    }
-    LGTD_TM_TO_ISOTIME(&tm_now, strbuf, bufsz, now.tv_usec);
-    return;
-error:
-    strbuf[0] = '\0';
-}
-
-static void
-lgtd_log_header(const char *loglvl, bool showprogname)
-{
-    if (lgtd_opts.log_timestamps) {
-        char timestr[64];
-        lgtd_isotime_now(timestr, sizeof(timestr));
-        fprintf(
-            stderr, "[%s] [%s] %s",
-            timestr, loglvl, showprogname ? "lightsd: " : ""
-        );
-        return;
-    }
-    fprintf(stderr, "[%s] %s", loglvl, showprogname ? "lightsd: " : "");
-}
-
 char *
 lgtd_iee8023mactoa(const uint8_t *addr, char *buf, int buflen)
 {
@@ -163,63 +126,45 @@
     return buf;
 }
 
-void
-_lgtd_err(void (*errfn)(int, const char *, ...),
-           int eval,
-           const char *fmt,
-           ...)
-{
-    int errsave = errno;
-    va_list ap;
-    va_start(ap, fmt);
-    // lgtd_cleanup is probably going to free some of the arguments we got, so
-    // let's print to a buffer before we call err.
-    char errmsg[LGTD_ERROR_MSG_BUFSIZE];
-    vsnprintf(errmsg, sizeof(errmsg), fmt, ap);
-    va_end(ap);
-    lgtd_cleanup();
-    lgtd_log_header("ERR", false);
-    errno = errsave;
-    errfn(eval, errmsg);
+#define ERRFN(fn)                               \
+void                                            \
+lgtd_##fn(int eval, const char *fmt, ...)       \
+{                                               \
+    va_list ap;                                 \
+    va_start(ap, fmt);                          \
+    if (lgtd_opts.syslog) {                     \
+        lgtd_daemon_syslog_##fn(eval, fmt, ap); \
+    } else {                                    \
+        lgtd_console_##fn(eval, fmt, ap);       \
+    }                                           \
+    /* not reached */                           \
 }
 
-void
-_lgtd_warn(void (*warnfn)(const char *, va_list), const char *fmt, ...)
-{
-    if (lgtd_opts.verbosity <= LGTD_WARN) {
-        va_list ap;
-        va_start(ap, fmt);
-        lgtd_log_header("WARN", false);
-        warnfn(fmt, ap);
-        va_end(ap);
-    }
+ERRFN(err);
+ERRFN(errx);
+
+#define LOGFN(level ,fn)                    \
+void                                        \
+lgtd_##fn(const char *fmt, ...)             \
+{                                           \
+    if (lgtd_opts.verbosity > (level)) {    \
+        return;                             \
+    }                                       \
+                                            \
+    va_list ap;                             \
+    va_start(ap, fmt);                      \
+    if (lgtd_opts.syslog) {                 \
+        lgtd_daemon_syslog_##fn(fmt, ap);   \
+    } else {                                \
+        lgtd_console_##fn(fmt, ap);         \
+    }                                       \
+    va_end(ap);                             \
 }
 
-void
-lgtd_info(const char *fmt, ...)
-{
-    if (lgtd_opts.verbosity <= LGTD_INFO) {
-        va_list ap;
-        va_start(ap, fmt);
-        lgtd_log_header("INFO", true);
-        vfprintf(stderr, fmt, ap);
-        va_end(ap);
-        fprintf(stderr, "\n");
-    }
-}
-
-void
-lgtd_debug(const char *fmt, ...)
-{
-    if (lgtd_opts.verbosity <= LGTD_DEBUG) {
-        va_list ap;
-        va_start(ap, fmt);
-        lgtd_log_header("DEBUG", true);
-        vfprintf(stderr, fmt, ap);
-        va_end(ap);
-        fprintf(stderr, "\n");
-    }
-}
+LOGFN(LGTD_WARN, warn);
+LOGFN(LGTD_WARN, warnx);
+LOGFN(LGTD_INFO, info);
+LOGFN(LGTD_DEBUG, debug);
 
 void
 lgtd_libevent_log(int severity, const char *msg)
@@ -227,7 +172,7 @@
     switch (severity) {
     case EVENT_LOG_DEBUG:   lgtd_debug("%s", msg); break;
     case EVENT_LOG_MSG:     lgtd_info("%s", msg);  break;
-    case EVENT_LOG_WARN:    lgtd_warnx("%s", msg)  break;
+    case EVENT_LOG_WARN:    lgtd_warnx("%s", msg); break;
     case EVENT_LOG_ERR:     lgtd_warnx("%s", msg); break;
     default:                                       break;
     }
diff --git a/tests/core/mock_log.h b/tests/core/mock_log.h
new file mode 100644
--- /dev/null
+++ b/tests/core/mock_log.h
@@ -0,0 +1,98 @@
+#pragma once
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+void
+lgtd_err(int eval, const char *fmt, ...)
+{
+    if (lgtd_opts.verbosity > LGTD_ERN) {
+        return;
+    }
+
+    fprintf(stderr, "ERR: ");
+    va_list ap;
+    va_start(fmt, ap);
+    vfprintf(stderr, fmt, ap);
+    va_end(ap);
+    fprintf(stderr, ": %s\n", strerror(errno));
+    exit(eval);
+}
+
+void
+lgtd_errx(int eval, const char *fmt, ...)
+{
+    if (lgtd_opts.verbosity > LGTD_ERN) {
+        return;
+    }
+
+    fprintf(stderr, "ERR: ");
+    va_list ap;
+    va_start(fmt, ap);
+    vfprintf(stderr, fmt, ap);
+    va_end(ap);
+    fputc("\n", stderr);
+    exit(eval);
+}
+
+void
+lgtd_warn(const char *fmt, ...)
+{
+    if (lgtd_opts.verbosity > LGTD_WARN) {
+        return;
+    }
+
+    fprintf(stderr, "WARN: ");
+    va_list ap;
+    va_start(fmt, ap);
+    vfprintf(stderr, fmt, ap);
+    va_end(ap);
+    fprintf(stderr, ": %s\n", strerror(errno));
+}
+
+void
+lgtd_warnx(const char *fmt, ...)
+{
+    if (lgtd_opts.verbosity > LGTD_WARN) {
+        return;
+    }
+
+    fprintf(stderr, "WARN: ");
+    va_list ap;
+    va_start(fmt, ap);
+    vfprintf(stderr, fmt, ap);
+    va_end(ap);
+    fputc("\n", stderr);
+}
+
+void
+lgtd_info(const char *fmt, ...)
+{
+    if (lgtd_opts.verbosity > LGTD_INFO) {
+        return;
+    }
+
+    fprintf(stderr, "INFO: ");
+    va_list ap;
+    va_start(fmt, ap);
+    vfprintf(stderr, fmt, ap);
+    va_end(ap);
+    fputc("\n", stderr);
+}
+
+void
+lgtd_debug(const char *fmt, ...)
+{
+    if (lgtd_opts.verbosity > LGTD_DEBUG) {
+        return;
+    }
+
+    fprintf(stderr, "DEBUG: ");
+    va_list ap;
+    va_start(fmt, ap);
+    vfprintf(stderr, fmt, ap);
+    va_end(ap);
+    fputc("\n", stderr);
+}
