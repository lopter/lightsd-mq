# HG changeset patch
# Parent dabd434273eae71d1662b1650b24d9172061eef2
New network code, compatibility with firmwire 1.1 to 1.5.

Starting with version 1.2 of their firmwire LIFX bulbs don't expose a
TCP interface anymore. With this changeset lifxd now use UDP code and
also brings more comprehensive and more compatible network code by
looking at the code in LIFXKit and lifx-gem.




diff --git a/README.rst b/README.rst
--- a/README.rst
+++ b/README.rst
@@ -1,7 +1,9 @@
 lifxd, a LIFX broker
 ====================
 
-lifxd acts a central point of control for your LIFX_ WiFi bulbs.
+lifxd acts a central point of control for your LIFX_ WiFi bulbs. lifxd should be
+a small, simple and fast daemon exposing an easy to use protocol inspired by how
+musicpd_ works.
 
 Having to run a daemon to control your LIFX bulbs may seem a little bit
 backward but has some advantages:
@@ -13,13 +15,11 @@
 - For those of you with a high paranoia factor, lifxd let you place your bulbs
   in a totally separate and closed network.
 
-lifxd aims to be modular with a small core process that handles all the
-communications with the bulbs and a higher-level plugin API.
+.. _LIFX: http://lifx.co/
+.. _musicpd: http://www.musicpd.org/
 
-.. _LIFX: http://lifx.co/
-
-Features
---------
+Current features
+----------------
 
 lifxd doesn't do much yet, it just discovers your bulbs and stay in sync with
 them.
@@ -31,7 +31,7 @@
 feedback and share ideas.
 
 Be aware that some parts of the code aren't really clean yet: I'm more focused
-on getting things working and good abstractions.
+on getting things working and good abstractions. Testing is definitely missing.
 
 Requirements
 ------------
diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -2,9 +2,9 @@
 
 ADD_EXECUTABLE(
     lifxd
+    broadcast.c
     bulb.c
     client.c
-    discovery.c
     gateway.c
     lifxd.c
     log.c
diff --git a/core/broadcast.c b/core/broadcast.c
new file mode 100644
--- /dev/null
+++ b/core/broadcast.c
@@ -0,0 +1,380 @@
+// Copyright (c) 2014, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <arpa/inet.h>
+#include <assert.h>
+#include <err.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <event2/event.h>
+#include <event2/buffer.h>
+#include <event2/bufferevent.h>
+#include <event2/util.h>
+
+#include "wire_proto.h"
+#include "bulb.h"
+#include "gateway.h"
+#include "broadcast.h"
+#include "lifxd.h"
+
+static struct {
+    evutil_socket_t socket;
+    struct event    *read_ev;
+    struct event    *write_ev;
+    struct event    *discovery_timeout_ev;
+} lifxd_broadcast_endpoint = {
+    .socket = -1,
+    .read_ev = NULL,
+    .write_ev = NULL,
+    .discovery_timeout_ev = NULL
+};
+
+static bool
+lifxd_broadcast_handle_read(void)
+{
+    assert(lifxd_broadcast_endpoint.socket != -1);
+
+    while (true) {
+        struct sockaddr_storage peer;
+        ev_socklen_t addrlen = sizeof(peer);
+        union {
+            char buf[LIFXD_MAX_PACKET_SIZE];
+            struct lifxd_packet_header hdr;
+        } read;
+        int nbytes = recvfrom(
+            lifxd_broadcast_endpoint.socket,
+            read.buf,
+            sizeof(read.buf),
+            0,
+            (struct sockaddr *)&peer,
+            &addrlen
+        );
+        if (nbytes == -1) {
+            int error = EVUTIL_SOCKET_ERROR();
+            if (error == EINTR) {
+                continue;
+            }
+            if (error == EAGAIN) {
+                return true;
+            }
+            lifxd_warn("can't receive broadcast packet");
+            return false;
+        }
+
+        char peer_addr[INET6_ADDRSTRLEN];
+        lifxd_sockaddrtoa(&peer, peer_addr, sizeof(peer_addr));
+        short peer_port = lifxd_sockaddrport(&peer);
+
+        if (nbytes < LIFXD_PACKET_HEADER_SIZE) {
+            lifxd_warnx(
+                "broadcast packet too short from [%s]:%hu", peer_addr, peer_port
+            );
+            return false;
+        }
+
+        lifxd_wire_decode_header(&read.hdr);
+        if (read.hdr.size != nbytes) {
+            lifxd_warnx(
+                "incomplete broadcast packet from [%s]:%hu",
+                peer_addr, peer_port
+            );
+            return false;
+        }
+        if (read.hdr.protocol.version != LIFXD_LIFX_PROTOCOL_V1) {
+            lifxd_warnx(
+                "unsupported protocol %d from [%s]:%hu",
+                read.hdr.protocol.version, peer_addr, peer_port
+            );
+        }
+        if (read.hdr.packet_type == LIFXD_GET_PAN_GATEWAY) {
+            lifxd_debug(
+                "discarding GET_PAN_GATEWAY packet from [%s]:%hu",
+                peer_addr, peer_port
+            );
+            continue;
+        }
+
+        const struct lifxd_packet_infos *pkt_infos =
+            lifxd_wire_get_packet_infos(read.hdr.packet_type);
+        if (!pkt_infos) {
+            lifxd_warnx(
+                "received unknown packet %#x from [%s]:%hu",
+                read.hdr.packet_type, peer_addr, peer_port
+            )
+            continue;
+        }
+        if (read.hdr.protocol.tagged || !read.hdr.protocol.addressable) {
+            lifxd_warnx(
+                "received non-addressable packet %s from [%s]:%hu",
+                pkt_infos->name, peer_addr, peer_port
+            );
+            continue;
+        }
+        struct lifxd_gateway *gw = lifxd_gateway_get(&peer);
+        if (!gw && read.hdr.packet_type == LIFXD_PAN_GATEWAY) {
+            gw = lifxd_gateway_open(&peer, read.hdr.site);
+            if (!gw) {
+                lifxd_err(1, "can't allocate gateway");
+            }
+            if (event_del(lifxd_broadcast_endpoint.discovery_timeout_ev)) {
+                lifxd_err(1, "can't setup events");
+            }
+        }
+        if (gw) {
+            void *pkt = &read.buf[LIFXD_PACKET_HEADER_SIZE];
+            pkt_infos->decode(pkt);
+            pkt_infos->handle(gw, &read.hdr, pkt);
+        } else {
+            lifxd_warnx(
+                "got packet from unknown gateway [%s]:%hu", peer_addr, peer_port
+            );
+        }
+    }
+}
+
+static bool
+lifxd_broadcast_handle_write(void)
+{
+    assert(lifxd_broadcast_endpoint.socket != -1);
+
+    struct sockaddr_in lifx_addr = {
+        .sin_len = sizeof(lifx_addr),
+        .sin_family = AF_INET,
+        .sin_addr = { INADDR_BROADCAST },
+        .sin_port = htons(lifxd_opts.master_port)
+    };
+    struct lifxd_packet_header get_pan_gateway;
+    lifxd_wire_setup_header(
+        &get_pan_gateway,
+        LIFXD_TARGET_ALL_DEVICES,
+        LIFXD_UNSPEC_TARGET,
+        NULL,
+        LIFXD_GET_PAN_GATEWAY
+    );
+
+    int nbytes;
+retry:
+    nbytes = sendto(
+        lifxd_broadcast_endpoint.socket,
+        (void *)&get_pan_gateway,
+        sizeof(get_pan_gateway),
+        0,
+        (const struct sockaddr *)&lifx_addr,
+        sizeof(lifx_addr)
+    );
+    if (nbytes == sizeof(get_pan_gateway)) {
+        struct timeval tv = LIFXD_MSECS_TO_TV(
+            LIFXD_BROADCAST_DISCOVERY_TIMEOUT_MSEC
+        );
+        if (event_del(lifxd_broadcast_endpoint.write_ev)
+            || event_add(lifxd_broadcast_endpoint.discovery_timeout_ev, &tv)) {
+            lifxd_err(1, "can't setup events");
+        }
+        return true;
+    }
+    if (nbytes == -1) {
+        if (EVUTIL_SOCKET_ERROR() == EINTR) {
+            goto retry;
+        }
+        lifxd_warn("can't broadcast discovery packet");
+    } else {
+        lifxd_warnx("can't broadcast discovery packet");
+    }
+    return false;
+}
+
+static void
+lifxd_broadcast_event_callback(evutil_socket_t socket, short events, void *ctx)
+{
+    (void)socket;
+    (void)ctx;
+
+    if (events & EV_TIMEOUT) {
+        // not sure how that could happen but eh.
+        lifxd_warnx("timeout on the udp broadcast socket");
+        goto error_reset;
+    }
+    if (events & EV_READ) {
+        if (!lifxd_broadcast_handle_read()) {
+            goto error_reset;
+        }
+    }
+    if (events & EV_WRITE) {
+        if (!lifxd_broadcast_handle_write()) {
+            goto error_reset;
+        }
+    }
+
+    return;
+
+error_reset:
+    lifxd_broadcast_close();
+    lifxd_broadcast_setup();
+    lifxd_broadcast_discovery();
+}
+
+static void
+lifxd_broadcast_discovery_timeout_event_callback(evutil_socket_t socket,
+                                                 short events,
+                                                 void *ctx)
+{
+    (void)socket;
+    (void)events;
+    (void)ctx;
+
+    lifxd_info(
+        "discovery didn't returned anything in %dms, restarting it",
+        LIFXD_BROADCAST_DISCOVERY_TIMEOUT_MSEC
+    );
+
+    if (!lifxd_broadcast_discovery()) {
+        lifxd_err(1, "can't start discovery");
+    }
+}
+
+void
+lifxd_broadcast_close(void)
+{
+    if (lifxd_broadcast_endpoint.read_ev) {
+        event_del(lifxd_broadcast_endpoint.read_ev);
+        event_free(lifxd_broadcast_endpoint.read_ev);
+        lifxd_broadcast_endpoint.read_ev = NULL;
+    }
+    if (lifxd_broadcast_endpoint.write_ev) {
+        event_del(lifxd_broadcast_endpoint.write_ev);
+        event_free(lifxd_broadcast_endpoint.write_ev);
+        lifxd_broadcast_endpoint.write_ev = NULL;
+    }
+    if (lifxd_broadcast_endpoint.discovery_timeout_ev) {
+        event_del(lifxd_broadcast_endpoint.discovery_timeout_ev);
+        event_free(lifxd_broadcast_endpoint.discovery_timeout_ev);
+        lifxd_broadcast_endpoint.discovery_timeout_ev = NULL;
+    }
+    if (lifxd_broadcast_endpoint.socket != -1) {
+        evutil_closesocket(lifxd_broadcast_endpoint.socket);
+        lifxd_broadcast_endpoint.socket = -1;
+    }
+}
+
+bool
+lifxd_broadcast_setup(void)
+{
+    assert(lifxd_broadcast_endpoint.socket == -1);
+    assert(lifxd_broadcast_endpoint.read_ev == NULL);
+    assert(lifxd_broadcast_endpoint.write_ev == NULL);
+
+    lifxd_broadcast_endpoint.socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+    if (lifxd_broadcast_endpoint.socket == -1) {
+        return false;
+    }
+
+    int val = 1;
+    int err = setsockopt(
+        lifxd_broadcast_endpoint.socket,
+        SOL_SOCKET,
+        SO_BROADCAST,
+        &val,
+        sizeof(val)
+    );
+    if (err) {
+        goto error;
+    }
+
+    if (evutil_make_socket_nonblocking(lifxd_broadcast_endpoint.socket) == -1) {
+        goto error;
+    }
+
+    struct sockaddr_in lifx_addr = {
+        .sin_len = sizeof(lifx_addr),
+        .sin_family = AF_INET,
+        .sin_addr = { INADDR_ANY },
+        .sin_port = htons(lifxd_opts.master_port)
+    };
+
+    err = bind(
+        lifxd_broadcast_endpoint.socket,
+        (const struct sockaddr *)&lifx_addr,
+        sizeof(lifx_addr)
+    );
+    if (err) {
+        goto error;
+    }
+
+    lifxd_broadcast_endpoint.read_ev = event_new(
+        lifxd_ev_base,
+        lifxd_broadcast_endpoint.socket,
+        EV_READ|EV_PERSIST,
+        lifxd_broadcast_event_callback,
+        NULL
+    );
+    lifxd_broadcast_endpoint.write_ev = event_new(
+        lifxd_ev_base,
+        lifxd_broadcast_endpoint.socket,
+        EV_WRITE|EV_PERSIST,
+        lifxd_broadcast_event_callback,
+        NULL
+    );
+    lifxd_broadcast_endpoint.discovery_timeout_ev = event_new(
+        lifxd_ev_base,
+        -1,
+        EV_PERSIST,
+        lifxd_broadcast_discovery_timeout_event_callback,
+        NULL
+    );
+    if (!lifxd_broadcast_endpoint.read_ev
+        || !lifxd_broadcast_endpoint.write_ev
+        || !lifxd_broadcast_endpoint.discovery_timeout_ev) {
+        goto error;
+    }
+
+    if (!event_add(lifxd_broadcast_endpoint.read_ev, NULL)) {
+        return true;
+    }
+
+    int errsave;
+error:
+    errsave = errno;
+    lifxd_broadcast_close();
+    errno = errsave;
+    return false;
+}
+
+bool
+lifxd_broadcast_discovery(void)
+{
+    assert(lifxd_broadcast_endpoint.write_ev);
+    return event_add(lifxd_broadcast_endpoint.write_ev, NULL) == 0;
+}
diff --git a/core/broadcast.h b/core/broadcast.h
new file mode 100644
--- /dev/null
+++ b/core/broadcast.h
@@ -0,0 +1,36 @@
+// Copyright (c) 2014, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+enum { LIFXD_BROADCAST_DISCOVERY_TIMEOUT_MSEC = 2000 };
+
+bool lifxd_broadcast_setup(void);
+void lifxd_broadcast_close(void);
+bool lifxd_broadcast_discovery(void);
diff --git a/core/broker.c b/core/broker.c
new file mode 100644
--- /dev/null
+++ b/core/broker.c
@@ -0,0 +1,47 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <arpa/inet.h>
+#include <assert.h>
+#include <endian.h>
+#include <err.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "wire_proto.h"
+#include "lifxd.h"
+
+void
+lifxd_broker_send_command(enum lifxd_target_type target_type,
+                          union lifxd_target target,
+                          enum lifxd_packet_type packet_type,
+                          void *pkt)
+{
+}
diff --git a/core/broker.h b/core/broker.h
new file mode 100644
--- /dev/null
+++ b/core/broker.h
@@ -0,0 +1,35 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+void lifxd_broker_send_command(enum lifxd_target_type,
+                               union lifxd_target,
+                               enum lifxd_packet_type,
+                               void *);
diff --git a/core/bulb.c b/core/bulb.c
--- a/core/bulb.c
+++ b/core/bulb.c
@@ -37,27 +37,32 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include <event2/util.h>
+
 #include "wire_proto.h"
 #include "bulb.h"
 #include "gateway.h"
 #include "lifxd.h"
 
-static struct lifxd_bulb_list lifxd_bulbs = LIST_HEAD_INITIALIZER(&lifxd_bulbs);
+static struct lifxd_bulb_map lifxd_bulbs_table =
+    RB_INITIALIZER(&lifxd_bulbs_by_addr);
+
+RB_GENERATE_STATIC(
+    lifxd_bulb_map,
+    lifxd_bulb,
+    link,
+    lifxd_bulb_cmp
+);
 
 struct lifxd_bulb *
 lifxd_bulb_get(struct lifxd_gateway *gw, const uint8_t *addr)
 {
     assert(gw);
+    assert(addr);
 
-    struct lifxd_bulb *bulb, *next_bulb;
-    LIST_FOREACH_SAFE(bulb, &lifxd_bulbs, link, next_bulb) {
-        if (bulb->gw == gw
-            && (!addr || !memcmp(bulb->addr, addr, sizeof(bulb->addr)))) {
-            return bulb;
-        }
-    }
-
-    return NULL;
+    struct lifxd_bulb bulb;
+    memcpy(bulb.addr, addr, sizeof(bulb.addr));
+    return RB_FIND(lifxd_bulb_map, &lifxd_bulbs_table, &bulb);
 }
 
 struct lifxd_bulb *
@@ -74,27 +79,7 @@
 
     bulb->gw = gw;
     memcpy(bulb->addr, addr, sizeof(bulb->addr));
-    LIST_INSERT_HEAD(&lifxd_bulbs, bulb, link);
-
-    return bulb;
-}
-
-struct lifxd_bulb *
-lifxd_bulb_get_or_open(struct lifxd_gateway *gw, const uint8_t *addr)
-{
-    assert(gw);
-    assert(addr);
-
-    struct lifxd_bulb *bulb = lifxd_bulb_get(gw, addr);
-    if (!bulb) {
-        bulb = lifxd_bulb_open(gw, addr);
-        if (bulb) {
-            lifxd_info(
-                "discovered new bulb %s on [%s]:%hu",
-                lifxd_addrtoa(addr), gw->hostname, gw->port
-            );
-        }
-    }
+    RB_INSERT(lifxd_bulb_map, &lifxd_bulbs_table, bulb);
 
     return bulb;
 }
@@ -105,13 +90,29 @@
     assert(bulb);
     assert(bulb->gw);
 
-    LIST_REMOVE(bulb, link);
+    RB_REMOVE(lifxd_bulb_map, &lifxd_bulbs_table, bulb);
     lifxd_info(
         "closed bulb \"%.*s\" on [%s]:%hu",
         sizeof(bulb->status.label),
         bulb->status.label,
-        bulb->gw->hostname,
+        bulb->gw->ip_addr,
         bulb->gw->port
     );
     free(bulb);
 }
+
+void
+lifxd_bulb_set_light_status(struct lifxd_bulb *bulb,
+                            const struct lifxd_light_status *status)
+{
+    assert(bulb);
+    assert(status);
+    memcpy(&bulb->status, status, sizeof(bulb->status));
+}
+
+void
+lifxd_bulb_set_power_state(struct lifxd_bulb *bulb, uint16_t power)
+{
+    assert(bulb);
+    bulb->status.power = power;
+}
diff --git a/core/bulb.h b/core/bulb.h
--- a/core/bulb.h
+++ b/core/bulb.h
@@ -45,14 +45,24 @@
 #pragma pack(pop)
 
 struct lifxd_bulb {
-    LIST_ENTRY(lifxd_bulb)      link;
+    RB_ENTRY(lifxd_bulb)        link;
+    SLIST_ENTRY(lifxd_bulb)     link_by_gw;
     struct lifxd_gateway        *gw;
     uint8_t                     addr[LIFXD_ADDR_LENGTH];
     struct lifxd_light_status   status;
 };
-LIST_HEAD(lifxd_bulb_list, lifxd_bulb);
+RB_HEAD(lifxd_bulb_map, lifxd_bulb);
+SLIST_HEAD(lifxd_bulb_list, lifxd_bulb);
+
+static inline int
+lifxd_bulb_cmp(const struct lifxd_bulb *a, const struct lifxd_bulb *b)
+{
+    return memcmp(a->addr, b->addr, sizeof(a->addr));
+}
 
 struct lifxd_bulb *lifxd_bulb_get(struct lifxd_gateway *, const uint8_t *);
 struct lifxd_bulb *lifxd_bulb_open(struct lifxd_gateway *, const uint8_t *);
-struct lifxd_bulb *lifxd_bulb_get_or_open(struct lifxd_gateway *, const uint8_t *);
 void lifxd_bulb_close(struct lifxd_bulb *);
+
+void lifxd_bulb_set_light_status(struct lifxd_bulb *, const struct lifxd_light_status *);
+void lifxd_bulb_set_power_state(struct lifxd_bulb *, uint16_t);
diff --git a/core/discovery.c b/core/discovery.c
deleted file mode 100644
--- a/core/discovery.c
+++ /dev/null
@@ -1,429 +0,0 @@
-// Copyright (c) 2014, Louis Opter <kalessin@kalessin.fr>
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-//
-// 1. Redistributions of source code must retain the above copyright notice,
-//    this list of conditions and the following disclaimer.
-//
-// 2. Redistributions in binary form must reproduce the above copyright notice,
-//    this list of conditions and the following disclaimer in the documentation
-//    and/or other materials provided with the distribution.
-//
-// 3. Neither the name of the copyright holder nor the names of its contributors
-//    may be used to endorse or promote products derived from this software
-//    without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-// POSSIBILITY OF SUCH DAMAGE.
-
-#include <sys/queue.h>
-#include <sys/tree.h>
-#include <arpa/inet.h>
-#include <assert.h>
-#include <err.h>
-#include <errno.h>
-#include <stdarg.h>
-#include <stdbool.h>
-#include <stdint.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <event2/event.h>
-#include <event2/buffer.h>
-#include <event2/bufferevent.h>
-#include <event2/util.h>
-
-#include "wire_proto.h"
-#include "discovery.h"
-#include "bulb.h"
-#include "gateway.h"
-#include "lifxd.h"
-
-enum { LIFXD_DISCOVERY_BUF_SIZE = 1024 };
-
-struct lifxd_discovery_rd_ctx {
-    enum {
-        LIFXD_DISCOVERY_INIT,
-        LIFXD_DISCOVERY_HDR_RDY
-    }                           state;
-    struct event                *ev;
-    struct sockaddr_in          peer;
-    char                        buf[LIFXD_DISCOVERY_BUF_SIZE];
-    // TODO use pkt_offset and read_offset and keep everything in buf
-    unsigned                    offset;
-    struct lifxd_packet_header  hdr;
-    unsigned                    pkt_size;
-};
-
-struct lifxd_discovery_wr_ctx {
-    struct event                *ev;
-    struct lifxd_packet_header  command;
-    bool                        encoded;
-    unsigned                    to_write;
-};
-
-static struct {
-    evutil_socket_t                 socket;
-    struct lifxd_discovery_rd_ctx   read;
-    struct lifxd_discovery_wr_ctx   write;
-} lifxd_udp_endpoint = {
-    .socket = -1,
-    .write = {
-        .command = {
-            .size = LIFXD_PACKET_HEADER_SIZE,
-            .protocol = LIFXD_PROTOCOL_VERSION,
-            .packet_type = LIFXD_GET_PAN_GATEWAY
-        }
-    }
-};
-
-void
-lifxd_discovery_stop(void)
-{
-    if (lifxd_udp_endpoint.socket == -1)
-        return;
-
-    event_del(lifxd_udp_endpoint.write.ev);
-    event_free(lifxd_udp_endpoint.write.ev);
-    lifxd_udp_endpoint.write.ev = NULL;
-    event_del(lifxd_udp_endpoint.read.ev);
-    event_free(lifxd_udp_endpoint.read.ev);
-    lifxd_udp_endpoint.read.ev = NULL;
-
-    evutil_closesocket(lifxd_udp_endpoint.socket);
-    lifxd_udp_endpoint.socket = -1;
-
-    lifxd_udp_endpoint.read.offset = 0;
-    lifxd_udp_endpoint.read.state = LIFXD_DISCOVERY_INIT;
-    lifxd_udp_endpoint.write.to_write = 0;
-}
-
-static int
-lifxd_discovery_recvfrom(struct sockaddr_in *peer, int howmuch)
-{
-    struct lifxd_discovery_rd_ctx *read = &lifxd_udp_endpoint.read;
-
-    assert(howmuch > 0);
-    assert(read->offset + howmuch <= sizeof(read->buf));
-    
-    while (true) {
-        ev_socklen_t socklen = sizeof(*peer);
-        int nbytes = recvfrom(
-            lifxd_udp_endpoint.socket,
-            &read->buf[read->offset],
-            howmuch,
-            0,
-            (struct sockaddr *)peer,
-            &socklen
-        );
-        if (nbytes == -1) {
-            int error = EVUTIL_SOCKET_ERROR();
-            if (error == EAGAIN) {
-                return 0;
-            }
-            if (error != EINTR) {
-                lifxd_err(1, "read error on the udp discovery socket");
-            }
-        } else {
-            return nbytes;
-        }
-    }
-}
-
-static void
-lifxd_discovery_handle_read(void)
-{
-    struct lifxd_discovery_rd_ctx *read = &lifxd_udp_endpoint.read;
-    struct sockaddr_in peer;
-
-    while (1) {
-        if (read->state == LIFXD_DISCOVERY_INIT) {
-            read->offset += lifxd_discovery_recvfrom(
-                &peer, LIFXD_PACKET_HEADER_SIZE - read->offset
-            );
-            if (read->offset == LIFXD_PACKET_HEADER_SIZE) {
-                memcpy(&read->peer, &peer, sizeof(peer));
-                // TODO: leave the header in the buf and use its size as an offset:
-                memcpy(&read->hdr, read->buf, LIFXD_PACKET_HEADER_SIZE);
-                lifxd_wire_decode_header(&read->hdr);
-                read->pkt_size = read->hdr.size - LIFXD_PACKET_HEADER_SIZE;
-                if (read->pkt_size > LIFXD_DISCOVERY_BUF_SIZE) {
-                    lifxd_warnx(
-                        "received bugged header from [%s]:%hu "
-                        "with packet size = %d, type = %#x",
-                        inet_ntoa(peer.sin_addr),
-                        ntohs(peer.sin_port),
-                        read->pkt_size,
-                        read->hdr.packet_type
-                    );
-                    read->offset = 0;
-                    continue;
-                }
-                read->state = LIFXD_DISCOVERY_HDR_RDY;
-                int extra_bytes = read->offset - LIFXD_PACKET_HEADER_SIZE;
-                if (extra_bytes) {
-                    memmove(read->buf, &read->buf[read->offset], extra_bytes);
-                    read->offset = 0;
-                }
-            } else {
-                return;
-            }
-        }
-        if (read->state == LIFXD_DISCOVERY_HDR_RDY) {
-            while (read->offset < read->pkt_size) {
-                int nbytes = lifxd_discovery_recvfrom(
-                    &peer, read->pkt_size - read->offset
-                );
-                if (!nbytes) {
-                    return;
-                }
-                if (peer.sin_addr.s_addr != read->peer.sin_addr.s_addr) {
-                    lifxd_warnx("different bulbs are advertising on the network");
-                } else {
-                    read->offset += nbytes;
-                }
-            }
-            const struct lifxd_packet_infos *pkt_infos =
-                lifxd_gateway_get_packet_infos(read->hdr.packet_type);
-            // We can run into 4 scenarios at this point:
-            // 1. We get a packet we don't know how to handle: discard and restart
-            //    the discovery;
-            // 2. We get a packet we know how to handle but which is not part of
-            //    the discovery process (i.e: not GET_PAN_GW nor PAN_GW): try to
-            //    handle it if we already know the gateway where it is from and
-            //    restart the discovery processs;
-            // 3. We get a GET_PAN_GW packet, probably, our own packet: discard it;
-            // 4. We get a PAN_GW packet: handle it and stop the discovery process.
-            if (pkt_infos) {
-                if (pkt_infos->type != LIFXD_GET_PAN_GATEWAY) {
-                    struct lifxd_gateway *gw = lifxd_gateway_get(read->hdr.gw_addr);
-                    if (!gw && pkt_infos->type == LIFXD_PAN_GATEWAY) {
-                        gw = lifxd_gateway_open(
-                            inet_ntoa(peer.sin_addr),
-                            ntohs(peer.sin_port),
-                            read->hdr.gw_addr
-                        );
-                    }
-                    if (gw) {
-                        pkt_infos->decode(read->buf);
-                        pkt_infos->handle(gw, &read->hdr, read->buf);
-                        if (pkt_infos->type == LIFXD_PAN_GATEWAY) {
-                            lifxd_discovery_stop();
-                            return;
-                        } else if (!lifxd_discovery_start()) {
-                            lifxd_warn("can't start auto discovery");
-                        }
-                    } else {
-                        lifxd_err(1, "can't allocate gateway");
-                    }
-                } else {
-                    lifxd_debug(
-                        "discarding GET_PAN_GATEWAY packet from [%s]:%hu",
-                        inet_ntoa(peer.sin_addr),
-                        ntohs(peer.sin_port)
-                    );
-                }
-            } else {
-                lifxd_warnx(
-                    "received unknown packet %#x from [%s]:%hu",
-                    read->hdr.packet_type,
-                    inet_ntoa(peer.sin_addr),
-                    ntohs(peer.sin_port)
-                );
-                if (!lifxd_discovery_start()) {
-                    lifxd_warn("can't start auto discovery");
-                }
-            }
-            read->offset = 0;
-            read->state = LIFXD_DISCOVERY_INIT;
-        }
-    }
-}
-
-static void
-lifxd_discovery_handle_write(void)
-{
-    struct lifxd_discovery_wr_ctx *write = &lifxd_udp_endpoint.write;
-
-    if (write->to_write) {
-        struct sockaddr_in addr = {
-            .sin_family = AF_INET,
-            .sin_port = htons(lifxd_opts.master_port)
-        };
-        int nbytes;
-        inet_pton(AF_INET, "255.255.255.255", &addr.sin_addr);
-    retry:
-        nbytes = sendto(
-            lifxd_udp_endpoint.socket,
-            (void *)&write->command,
-            write->to_write,
-            0,
-            (struct sockaddr *)&addr,
-            sizeof(addr)
-        );
-        if (nbytes == -1) {
-            int error = EVUTIL_SOCKET_ERROR();
-            if (error == EINTR) {
-                goto retry;
-            } else if (error != EAGAIN) {
-                lifxd_warn("can't broadcast discovery packet");
-            }
-        } else {
-            write->to_write -= nbytes;
-        }
-    }
-
-    if (!write->to_write) {
-        lifxd_info("discovery packet has been broadcasted");
-        if (event_del(write->ev) == -1) {
-            lifxd_warn("can't stop discovery");
-        }
-    }
-}
-
-static void
-lifxd_discovery_event_callback(evutil_socket_t socket, short events, void *ctx)
-{
-    (void)socket;
-    (void)ctx;
-
-    if (events & EV_TIMEOUT) {
-        lifxd_errx(1, "timeout on the udp discovery socket");
-        // TODO: reset state and restart discovery.
-    }
-    if (events & EV_READ) {
-        lifxd_discovery_handle_read();
-    }
-    if (events & EV_WRITE) {
-        lifxd_discovery_handle_write();
-    }
-}
-
-static bool
-lifxd_discovery_setup(void)
-{
-    assert(lifxd_udp_endpoint.socket == -1);
-
-    if (!lifxd_udp_endpoint.write.encoded) {
-        lifxd_wire_encode_header(&lifxd_udp_endpoint.write.command);
-        lifxd_udp_endpoint.write.encoded = true;
-    }
-
-    lifxd_udp_endpoint.socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
-    if (lifxd_udp_endpoint.socket == -1) {
-        return false;
-    }
-
-    int val = 1;
-    int err = setsockopt(
-        lifxd_udp_endpoint.socket, SOL_SOCKET, SO_BROADCAST, &val, sizeof(val)
-    );
-    if (err == -1) {
-        goto err_setsockopt;
-    }
-
-    if (evutil_make_socket_nonblocking(lifxd_udp_endpoint.socket) == -1) {
-        goto err_ononblock;
-    }
-
-    struct evutil_addrinfo hints, *res = NULL;
-    memset(&hints, 0, sizeof(hints));
-    char port_str[6] = { 0 };
-    evutil_snprintf(
-        port_str, sizeof(port_str), "%hu", lifxd_opts.master_port
-    );
-    hints.ai_family = AF_INET;
-    hints.ai_socktype = SOCK_DGRAM;
-    hints.ai_protocol = IPPROTO_UDP;
-    hints.ai_flags = EVUTIL_AI_NUMERICHOST;
-
-    err = evutil_getaddrinfo("0.0.0.0", port_str, &hints, &res);
-    if (err || !res) {
-        goto err_getaddrinfo;
-    }
-    if (bind(lifxd_udp_endpoint.socket, res->ai_addr, res->ai_addrlen) == -1) {
-        evutil_freeaddrinfo(res);
-        goto err_bind;
-    }
-    freeaddrinfo(res);
-
-    lifxd_udp_endpoint.read.ev = event_new(
-        lifxd_ev_base,
-        lifxd_udp_endpoint.socket,
-        EV_READ|EV_PERSIST,
-        lifxd_discovery_event_callback,
-        NULL
-    );
-    lifxd_udp_endpoint.write.ev = event_new(
-        lifxd_ev_base,
-        lifxd_udp_endpoint.socket,
-        EV_WRITE|EV_PERSIST,
-        lifxd_discovery_event_callback,
-        NULL
-    );
-    if (!lifxd_udp_endpoint.read.ev || !lifxd_udp_endpoint.write.ev) {
-        goto err_event_new;
-    }
-    err = event_add(lifxd_udp_endpoint.read.ev, NULL);
-    if (err) {
-        goto err_event_add;
-    }
-
-    return true;
-
-err_event_add:
-err_event_new:
-    if (lifxd_udp_endpoint.read.ev) {
-        event_free(lifxd_udp_endpoint.read.ev);
-        lifxd_udp_endpoint.read.ev = NULL;
-    }
-    if (lifxd_udp_endpoint.write.ev) {
-        event_free(lifxd_udp_endpoint.write.ev);
-        lifxd_udp_endpoint.write.ev = NULL;
-    }
-err_bind:
-err_getaddrinfo:
-err_setsockopt:
-err_ononblock:
-    evutil_closesocket(lifxd_udp_endpoint.socket);
-    lifxd_udp_endpoint.socket = -1;
-    return false;
-}
-
-bool
-lifxd_discovery_start(void)
-{
-    assert(lifxd_udp_endpoint.write.to_write == 0);
-
-    if (lifxd_udp_endpoint.socket == -1 && !lifxd_discovery_setup()) {
-        return false;
-    }
-
-    lifxd_udp_endpoint.write.to_write = LIFXD_PACKET_HEADER_SIZE;
-    if (event_add(lifxd_udp_endpoint.write.ev, NULL) == -1) {
-        goto err_enable_writes;
-    }
-    if (event_add(lifxd_udp_endpoint.read.ev, NULL) == -1) {
-        goto err_enable_reads;
-    }
-
-    lifxd_info("starting auto-discovery");
-    return true;
-
-err_enable_reads:
-    event_del(lifxd_udp_endpoint.write.ev);
-err_enable_writes:
-    lifxd_udp_endpoint.write.to_write = 0;
-    return false;
-}
diff --git a/core/discovery.h b/core/discovery.h
deleted file mode 100644
--- a/core/discovery.h
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright (c) 2014, Louis Opter <kalessin@kalessin.fr>
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-//
-// 1. Redistributions of source code must retain the above copyright notice,
-//    this list of conditions and the following disclaimer.
-//
-// 2. Redistributions in binary form must reproduce the above copyright notice,
-//    this list of conditions and the following disclaimer in the documentation
-//    and/or other materials provided with the distribution.
-//
-// 3. Neither the name of the copyright holder nor the names of its contributors
-//    may be used to endorse or promote products derived from this software
-//    without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
-// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-// POSSIBILITY OF SUCH DAMAGE.
-
-#pragma once
-
-bool lifxd_discovery_start(void);
-void lifxd_discovery_stop(void);
diff --git a/core/gateway.c b/core/gateway.c
--- a/core/gateway.c
+++ b/core/gateway.c
@@ -30,294 +30,219 @@
 #include <sys/queue.h>
 #include <sys/tree.h>
 #include <assert.h>
+#include <endian.h>
 #include <err.h>
+#include <errno.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
 
 #include <event2/event.h>
 #include <event2/buffer.h>
-#include <event2/bufferevent.h>
 #include <event2/util.h>
 
 #include "wire_proto.h"
 #include "bulb.h"
 #include "gateway.h"
-#include "discovery.h"
+#include "broadcast.h"
+#include "broker.h"
 #include "lifxd.h"
 
 static struct lifxd_gateway_list lifxd_gateways = \
     LIST_HEAD_INITIALIZER(&lifxd_gateways);
 
-static struct lifxd_packet_infos_map lifxd_packet_infos = \
-    RB_INITIALIZER(&lifxd_packets_infos);
-
-RB_GENERATE_STATIC(
-    lifxd_packet_infos_map,
-    lifxd_packet_infos,
-    link,
-    lifxd_packet_infos_cmp
-);
-
-void
-lifxd_gateway_load_packet_infos_map(void)
-{
-#define DECODER(x)  ((void (*)(void *))(x))
-#define ENCODER(x)  ((void (*)(void *))(x))
-#define HANDLER(x)                                  \
-    ((void (*)(struct lifxd_gateway *,              \
-               const struct lifxd_packet_header *,  \
-               const void *))(x))
-
-    static struct lifxd_packet_infos packet_table[] = {
-        {
-            .name = "GET_PAN_GATEWAY",
-            .type = LIFXD_GET_PAN_GATEWAY
-        },
-        {
-            .name = "PAN_GATEWAY",
-            .type = LIFXD_PAN_GATEWAY,
-            .size = sizeof(struct lifxd_packet_pan_gateway),
-            .decode = DECODER(lifxd_wire_decode_pan_gateway),
-            .encode = ENCODER(lifxd_wire_encode_pan_gateway),
-            .handle = HANDLER(lifxd_gateway_handle_pan_gateway)
-        },
-        {
-            .name = "LIGHT_STATUS",
-            .type = LIFXD_LIGHT_STATUS,
-            .size = sizeof(struct lifxd_packet_light_status),
-            .decode = DECODER(lifxd_wire_decode_light_status),
-            .encode = ENCODER(lifxd_wire_encode_light_status),
-            .handle = HANDLER(lifxd_gateway_handle_light_status)
-        },
-        {
-            .name = "POWER_STATE",
-            .type = LIFXD_POWER_STATE,
-            .size = sizeof(struct lifxd_packet_power_state),
-            .decode = DECODER(lifxd_wire_decode_power_state),
-            .handle = HANDLER(lifxd_gateway_handle_power_state)
-        }
-    };
-
-    for (int i = 0; i != LIFXD_ARRAY_SIZE(packet_table); ++i) {
-        RB_INSERT(
-            lifxd_packet_infos_map, &lifxd_packet_infos, &packet_table[i]
-        );
-    }
-}
-
-const struct lifxd_packet_infos *
-lifxd_gateway_get_packet_infos(enum lifxd_packet_type packet_type)
-{
-    struct lifxd_packet_infos pkt_infos = { .type = packet_type };
-    return RB_FIND(lifxd_packet_infos_map, &lifxd_packet_infos, &pkt_infos);
-}
-
 static void
 lifxd_gateway_close(struct lifxd_gateway *gw)
 {
     assert(gw);
-    assert(gw->io);
 
-    int sockfd = bufferevent_getfd(gw->io);
-    if (sockfd != -1) {
-        evutil_closesocket(sockfd);
+    event_del(gw->refresh_ev);
+    event_del(gw->write_ev);
+    if (gw->socket != -1) {
+        evutil_closesocket(gw->socket);
         LIST_REMOVE(gw, link);
     }
-    bufferevent_free(gw->io);
-    for (struct lifxd_bulb *bulb = lifxd_bulb_get(gw, NULL);
-         bulb;
-         bulb = lifxd_bulb_get(gw, NULL)) {
+    event_free(gw->refresh_ev);
+    event_free(gw->write_ev);
+    evbuffer_free(gw->write_buf);
+    struct lifxd_bulb *bulb, *next_bulb;
+    SLIST_FOREACH_SAFE(bulb, &gw->bulbs, link_by_gw, next_bulb) {
         lifxd_bulb_close(bulb);
     }
+
     lifxd_info(
-        "connection with gateway bulb [%s]:%hu closed",
-        gw->hostname,
-        gw->port
+        "connection with gateway bulb [%s]:%hu closed", gw->ip_addr, gw->port
     );
-    free(gw->hostname);
     free(gw);
 }
 
 static void
-lifxd_gateway_event_callback(struct bufferevent *bev, short events, void *ctx)
+lifxd_gateway_write_callback(evutil_socket_t socket, short events, void *ctx)
 {
+    (void)socket;
+
     assert(ctx);
 
     struct lifxd_gateway *gw = (struct lifxd_gateway *)ctx;
-    if (events & BEV_EVENT_CONNECTED) {
-        lifxd_info(
-            "connected to gateway bulb: [%s]:%hu", gw->hostname, gw->port
+    if (events & EV_TIMEOUT) {  // Not sure how that could happen in UDP but eh.
+        lifxd_warn(
+            "lost connection with gateway bulb [%s]:%hu", gw->ip_addr, gw->port
         );
-        LIST_INSERT_HEAD(&lifxd_gateways, gw, link);
-        bufferevent_enable(bev, EV_READ|EV_WRITE|EV_TIMEOUT);
-    } else if (events & (BEV_EVENT_ERROR|BEV_EVENT_EOF)) {
-        if (events & BEV_EVENT_ERROR) {
-            int gai_error = bufferevent_socket_get_dns_error(gw->io);
-            if (gai_error) {
-                lifxd_warnx(
-                    "can't connect to %s: %s",
-                    gw->hostname,
-                    evutil_gai_strerror(gai_error)
-                );
-            } else {
-                lifxd_warn(
-                    "lost connection with gateway bulb [%s]:%hu",
-                    gw->hostname,
-                    gw->port
-                );
+        lifxd_gateway_close(gw);
+        if (!lifxd_broadcast_discovery()) {
+            lifxd_err(1, "can't start auto discovery");
+        }
+        return;
+    }
+    if (events & EV_WRITE) {
+        if (evbuffer_write(gw->write_buf, gw->socket) == -1 && errno != EAGAIN) {
+            lifxd_warn("can't write to [%s]:%hu", gw->ip_addr, gw->port);
+            lifxd_gateway_close(gw);
+            if (!lifxd_broadcast_discovery()) {
+                lifxd_err(1, "can't start auto discovery");
             }
+            return;
         }
-        lifxd_gateway_close(gw);
-        if (!lifxd_discovery_start()) {
-            lifxd_err(1, "can't start auto discovery");
+        if (!evbuffer_get_length(gw->write_buf)) {
+            event_del(gw->write_ev);
         }
     }
 }
 
 static void
-lifxd_gateway_data_read_callback(struct bufferevent *bev, void *ctx)
+lifxd_gateway_refresh_callback(evutil_socket_t socket, short events, void *ctx)
 {
+    (void)socket;
+    (void)events;
+
     assert(ctx);
 
-    const struct lifxd_packet_infos *pkt_infos = NULL;
     struct lifxd_gateway *gw = (struct lifxd_gateway *)ctx;
-    struct lifxd_packet_header *cur_hdr = &gw->cur_hdr;
 
-    if (gw->cur_hdr_offset != LIFXD_PACKET_HEADER_SIZE) {
-        gw->cur_hdr_offset += bufferevent_read(
-            bev,
-            ((void *)cur_hdr) + gw->cur_hdr_offset,
-            LIFXD_PACKET_HEADER_SIZE - gw->cur_hdr_offset
+    int buflen = evbuffer_get_length(gw->write_buf);
+    if (buflen < LIFXD_GATEWAY_WRITE_HIGH_WATERMARK) {
+        struct lifxd_packet_header hdr;
+        union lifxd_target target = { .addr = gw->site };
+        lifxd_wire_setup_header(
+            &hdr, LIFXD_TARGET_SITE, target, gw->site, LIFXD_GET_LIGHT_STATE
         );
-        if (gw->cur_hdr_offset == LIFXD_PACKET_HEADER_SIZE) {
-            lifxd_wire_decode_header(cur_hdr);
-            lifxd_debug(
-                "received header from [%s]:%hu for packet type %#x",
-                gw->hostname, gw->port, cur_hdr->packet_type
+        lifxd_debug("GET_LIGHT_STATE --> [%s]:%hu", gw->ip_addr, gw->port);
+        lifxd_gateway_send_packet(gw, &hdr, NULL, 0);
+        return;
+    }
+    lifxd_info(
+        "refresh skipped on gateway [%s]:%hu, (buflen=%d)",
+        gw->ip_addr, gw->port, buflen
+    );
+}
+
+static struct lifxd_bulb *
+lifxd_gateway_get_or_open_bulb(struct lifxd_gateway *gw, const uint8_t *bulb_addr)
+{
+    assert(gw);
+    assert(bulb_addr);
+
+    struct lifxd_bulb *bulb = lifxd_bulb_get(gw, bulb_addr);
+    if (!bulb) {
+        bulb = lifxd_bulb_open(gw, bulb_addr);
+        if (bulb) {
+            SLIST_INSERT_HEAD(&gw->bulbs, bulb, link_by_gw);
+            lifxd_info(
+                "bulb %s on [%s]:%hu",
+                lifxd_addrtoa(bulb_addr), gw->ip_addr, gw->port
             );
-            gw->cur_pkt_size = cur_hdr->size - LIFXD_PACKET_HEADER_SIZE;
-            if (gw->cur_pkt_size > LIFXD_MAX_PACKET_SIZE) {
-                lifxd_warnx(
-                    "unsupported packet size %hu (max = %d, packet_type = %#x) "
-                    "from [%s]:%hu",
-                    gw->cur_pkt_size,
-                    LIFXD_MAX_PACKET_SIZE,
-                    cur_hdr->packet_type,
-                    gw->hostname,
-                    gw->port
-                );
-                goto drop_gateway;
-            }
-            if (gw->cur_pkt_size) {
-                gw->cur_pkt = calloc(1, gw->cur_pkt_size);
-                if (!gw->cur_pkt) {
-                    lifxd_warn("can't allocate memory for a packet");
-                    goto drop_gateway;
-                }
-            }
         }
     }
-
-    if (gw->cur_hdr_offset == LIFXD_PACKET_HEADER_SIZE) {
-        if (gw->cur_pkt_offset != gw->cur_pkt_size) {
-            gw->cur_pkt_offset += bufferevent_read(
-                bev,
-                gw->cur_pkt + gw->cur_pkt_offset,
-                gw->cur_pkt_size - gw->cur_pkt_offset
-            );
-        }
-        if (gw->cur_pkt_offset == gw->cur_pkt_size) {
-            pkt_infos = lifxd_gateway_get_packet_infos(cur_hdr->packet_type);
-            if (pkt_infos) {
-                pkt_infos->decode(gw->cur_pkt);
-                pkt_infos->handle(gw, cur_hdr, gw->cur_pkt);
-            } else {
-                lifxd_warnx("discarding unknown packet %#x from [%s]:%hu",
-                    cur_hdr->packet_type, gw->hostname, gw->port
-                );
-            }
-            free(gw->cur_pkt);
-            gw->cur_pkt = NULL;
-            gw->cur_pkt_size = 0;
-            gw->cur_pkt_offset = 0;
-            gw->cur_hdr_offset = 0;
-        }
-    }
-
-    return;
-
-drop_gateway:
-    lifxd_gateway_close(gw);
-    if (!lifxd_discovery_start()) {
-        lifxd_err(1, "can't start auto discovery");
-    }
+    return bulb;
 }
 
-
 struct lifxd_gateway *
-lifxd_gateway_open(const char *hostname, uint16_t port, const uint8_t *site)
+lifxd_gateway_open(const struct sockaddr_storage *peer, const uint8_t *site)
 {
-    assert(hostname);
-    assert(port < UINT16_MAX);
-    assert(port > 0);
-
-    if (!site) {
-        lifxd_warnx("connecting directly to a bulb isn't supported yet");
-        return NULL;
-    }
+    assert(peer);
+    assert(site);
 
     struct lifxd_gateway *gw = calloc(1, sizeof(*gw));
     if (!gw) {
         lifxd_warn("can't allocate a new gateway bulb");
         return false;
     }
-    gw->io = bufferevent_socket_new(lifxd_ev_base, -1, 0);
-    if (!gw->io) {
-        lifxd_warn("can't allocate a new gateway bulb");
-        goto bev_alloc_error;
+    gw->socket = socket(peer->ss_family, SOCK_DGRAM, IPPROTO_UDP);
+    if (gw->socket == -1) {
+        lifxd_warn("can't open a new socket");
+        goto error_socket;
     }
-    gw->hostname = strdup(hostname);
-    if (!gw->hostname) {
-        lifxd_warn("can't allocate a new gateway bulb");
-        goto hostname_alloc_error;
+    if (connect(gw->socket, (const struct sockaddr *)peer, peer->ss_len) == -1
+        || evutil_make_socket_nonblocking(gw->socket) == -1) {
+        lifxd_warn("can't open a new socket");
+        goto error_connect;
     }
-    gw->port = port;
-    memcpy(gw->addr, site, sizeof(gw->addr));
-    bufferevent_setcb(
-        gw->io,
-        lifxd_gateway_data_read_callback,
-        NULL,
-        lifxd_gateway_event_callback,
+    gw->write_ev = event_new(
+        lifxd_ev_base,
+        gw->socket,
+        EV_WRITE|EV_PERSIST,
+        lifxd_gateway_write_callback,
         gw
     );
+    gw->write_buf = evbuffer_new();
+    gw->refresh_ev = event_new(
+        lifxd_ev_base,
+        -1,
+        EV_PERSIST,
+        lifxd_gateway_refresh_callback,
+        gw
+    );
+    memcpy(&gw->peer, peer, peer->ss_len);
+    lifxd_sockaddrtoa(peer, gw->ip_addr, sizeof(gw->ip_addr));
+    gw->port = lifxd_sockaddrport(peer);
+    memcpy(gw->site, site, sizeof(gw->site));
 
-    int error = bufferevent_socket_connect_hostname(
-        gw->io, NULL, AF_UNSPEC, hostname, port
+    struct timeval refresh_interval = LIFXD_MSECS_TO_TV(
+        LIFXD_GATEWAY_REFRESH_INTERVAL_MSEC
     );
-    if (!error) {
-        lifxd_info("new gateway at [%s]:%hu", hostname, port);
-        return gw;
+
+    if (!gw->write_ev || !gw->write_buf || !gw->refresh_ev
+        || event_add(gw->refresh_ev, &refresh_interval) != 0) {
+        lifxd_warn("can't allocate a new gateway bulb");
+        goto error_allocate;
     }
 
-    free(gw->hostname);
-hostname_alloc_error:
-    bufferevent_free(gw->io);
-bev_alloc_error:
+    lifxd_info(
+        "gateway for site %s at [%s]:%hu",
+        lifxd_addrtoa(gw->site), gw->ip_addr, gw->port
+    );
+    LIST_INSERT_HEAD(&lifxd_gateways, gw, link);
+    return gw;
+
+error_allocate:
+    if (gw->write_ev) {
+        event_free(gw->write_ev);
+    }
+    if (gw->write_buf) {
+        evbuffer_free(gw->write_buf);
+    }
+    if (gw->refresh_ev) {
+        event_free(gw->refresh_ev);
+    }
+error_connect:
+    close(gw->socket);
+error_socket:
     free(gw);
     return NULL;
 }
 
 struct lifxd_gateway *
-lifxd_gateway_get(const uint8_t *site)
+lifxd_gateway_get(const struct sockaddr_storage *peer)
 {
-    assert(site);
+    assert(peer);
 
     struct lifxd_gateway *gw, *next_gw;
     LIST_FOREACH_SAFE(gw, &lifxd_gateways, link, next_gw) {
-        if (!memcmp(gw->addr, site, sizeof(gw->addr))) {
+        if (peer->ss_family == gw->peer.ss_family
+            && !memcmp(&gw->peer, peer, peer->ss_len)) {
             return gw;
         }
     }
@@ -335,18 +260,21 @@
 }
 
 void
-lifxd_gateway_get_pan_gateway(struct lifxd_gateway *gw)
+lifxd_gateway_send_packet(struct lifxd_gateway *gw,
+                          const struct lifxd_packet_header *hdr,
+                          const void *pkt,
+                          int pkt_size)
 {
     assert(gw);
+    assert(hdr);
+    assert(!memcmp(hdr->site, gw->site, LIFXD_ADDR_LENGTH));
 
-    struct lifxd_packet_header hdr = {
-        .size = LIFXD_PACKET_HEADER_SIZE,
-        .protocol = LIFXD_PROTOCOL_VERSION,
-        .packet_type = LIFXD_GET_PAN_GATEWAY
-    };
-    lifxd_wire_encode_header(&hdr);
-    lifxd_debug("GET_PAN_GATEWAY  [%s]:%hu", gw->hostname, gw->port);
-    bufferevent_write(gw->io, &hdr, sizeof(hdr));
+    evbuffer_add(gw->write_buf, hdr, sizeof(*hdr));
+    if (pkt) {
+        assert(pkt_size == le16toh(hdr->size) - sizeof(*hdr));
+        evbuffer_add(gw->write_buf, pkt, pkt_size);
+    }
+    event_add(gw->write_ev, NULL);
 }
 
 void
@@ -357,27 +285,11 @@
     assert(gw && hdr && pkt);
 
     lifxd_debug(
-        "SET_PAN_GATEWAY  [%s]:%hu - %s gw_addr=%s",
-        gw->hostname, gw->port,
-        lifxd_addrtoa(hdr->bulb_addr),
-        lifxd_addrtoa(hdr->gw_addr)
+        "SET_PAN_GATEWAY <-- [%s]:%hu - %s site=%s",
+        gw->ip_addr, gw->port,
+        lifxd_addrtoa(hdr->target.device_addr),
+        lifxd_addrtoa(hdr->site)
     );
-    memcpy(gw->addr, &gw->cur_hdr.gw_addr, sizeof(gw->addr));
-}
-
-void
-lifxd_gateway_get_light_status(struct lifxd_gateway *gw)
-{
-    assert(gw);
-
-    struct lifxd_packet_header hdr = {
-        .size = LIFXD_PACKET_HEADER_SIZE,
-        .protocol = LIFXD_PROTOCOL_VERSION,
-        .packet_type = LIFXD_GET_LIGHT_STATE
-    };
-    lifxd_wire_encode_header(&hdr);
-    lifxd_debug("GET_LIGHT_STATE  [%s]:%hu", gw->hostname, gw->port);
-    bufferevent_write(gw->io, &hdr, sizeof(hdr));
 }
 
 void
@@ -388,19 +300,23 @@
     assert(gw && hdr && pkt);
 
     lifxd_debug(
-        "SET_LIGHT_STATUS  [%s]:%hu - %s "
+        "SET_LIGHT_STATUS <-- [%s]:%hu - %s "
         "hue=%#hx, saturation=%#hx, brightness=%#hx, "
-        "kelvin=%#hx, dim=%#hx, power=%#hx, label=%.*s, tags=%lx",
-        gw->hostname, gw->port, lifxd_addrtoa(hdr->bulb_addr),
+        "kelvin=%d, dim=%#hx, power=%#hx, label=%.*s, tags=%#lx",
+        gw->ip_addr, gw->port, lifxd_addrtoa(hdr->target.device_addr),
         pkt->hue, pkt->saturation, pkt->brightness, pkt->kelvin,
         pkt->dim, pkt->power, sizeof(pkt->label), pkt->label, pkt->tags
     );
 
-    struct lifxd_bulb *bulb = lifxd_bulb_get_or_open(gw, hdr->bulb_addr);
-    if (bulb) {
-        assert(sizeof(*pkt) == sizeof(bulb->status));
-        memcpy(&bulb->status, pkt, sizeof(*pkt));
+    struct lifxd_bulb *b = lifxd_gateway_get_or_open_bulb(
+        gw, hdr->target.device_addr
+    );
+    if (!b) {
+        return;
     }
+
+    assert(sizeof(*pkt) == sizeof(b->status));
+    lifxd_bulb_set_light_status(b, (const struct lifxd_light_status *)pkt);
 }
 
 void
@@ -411,12 +327,16 @@
     assert(gw && hdr && pkt);
 
     lifxd_debug(
-        "SET_POWER_STATE  [%s]:%hu - %s power=%#hx",
-        gw->hostname, gw->port, lifxd_addrtoa(hdr->bulb_addr), pkt->power
+        "SET_POWER_STATE <-- [%s]:%hu - %s power=%#hx",
+        gw->ip_addr, gw->port, lifxd_addrtoa(hdr->target.device_addr), pkt->power
     );
 
-    struct lifxd_bulb *bulb = lifxd_bulb_get_or_open(gw, hdr->bulb_addr);
-    if (bulb) {
-        bulb->status.power = pkt->power;
+    struct lifxd_bulb *b = lifxd_gateway_get_or_open_bulb(
+        gw, hdr->target.device_addr
+    );
+    if (!b) {
+        return;
     }
+
+    lifxd_bulb_set_power_state(b, pkt->power);
 }
diff --git a/core/gateway.h b/core/gateway.h
--- a/core/gateway.h
+++ b/core/gateway.h
@@ -29,58 +29,51 @@
 
 #pragma once
 
+// Let's start with something simple for now, in the future this will need to
+// account for each gateway response time. According to my own tests,
+// aggressively polling a bulb doesn't raise it's consumption at all (it's
+// interesting to note that a turned off bulb still draw about 2W in ZigBee and
+// about 3W in WiFi).
+enum { LIFXD_GATEWAY_REFRESH_INTERVAL_MSEC = 100 };
+
+// In the meantime skip a refresh if we have too many bytes in our write buffer:
+enum { LIFXD_GATEWAY_WRITE_HIGH_WATERMARK = 256 };
+
 struct lifxd_gateway {
     LIST_ENTRY(lifxd_gateway)   link;
-    char                        *hostname;
+    struct lifxd_bulb_list      bulbs;
+    // Multiple gateways can share the same site (that happens when bulbs are
+    // far away enough that ZigBee can't be used). Moreover the SET_PAN_GATEWAY
+    // packet doesn't include the device address in the header (i.e: site and
+    // device_addr have the same value) so we have no choice but to use the
+    // remote ip address to identify a gateway:
+    struct sockaddr_storage     peer;
+    char                        ip_addr[INET6_ADDRSTRLEN];
     uint16_t                    port;
-    struct bufferevent          *io;
-    uint8_t                     addr[LIFXD_ADDR_LENGTH];
-    struct lifxd_packet_header  cur_hdr;
-    unsigned                    cur_hdr_offset;
-    void                        *cur_pkt;
-    unsigned                    cur_pkt_offset;
-    unsigned                    cur_pkt_size;
+    uint8_t                     site[LIFXD_ADDR_LENGTH];
+    evutil_socket_t             socket;
+    struct event                *write_ev;
+    struct evbuffer             *write_buf;
+    struct event                *refresh_ev;
 };
 LIST_HEAD(lifxd_gateway_list, lifxd_gateway);
 
-struct lifxd_packet_infos {
-    RB_ENTRY(lifxd_packet_infos)    link;
-    const char                      *name;
-    enum lifxd_packet_type          type;
-    unsigned                        size;
-    void                            (*decode)(void *);
-    void                            (*encode)(void *);
-    void                            (*handle)(struct lifxd_gateway *,
-                                              const struct lifxd_packet_header *,
-                                              const void *);
-};
-RB_HEAD(lifxd_packet_infos_map, lifxd_packet_infos);
-
-static inline int
-lifxd_packet_infos_cmp(struct lifxd_packet_infos *a,
-                       struct lifxd_packet_infos *b)
-{
-    return a->type - b->type;
-}
-
-void lifxd_gateway_load_packet_infos_map(void);
-const struct lifxd_packet_infos *lifxd_gateway_get_packet_infos(enum lifxd_packet_type);
-
-struct lifxd_gateway *lifxd_gateway_get(const uint8_t *);
-struct lifxd_gateway *lifxd_gateway_open(const char *,
-                                         uint16_t,
+struct lifxd_gateway *lifxd_gateway_get(const struct sockaddr_storage *);
+struct lifxd_gateway *lifxd_gateway_open(const struct sockaddr_storage *,
                                          const uint8_t *);
 void lifxd_gateway_close_all(void);
 
-void lifxd_gateway_get_pan_gateway(struct lifxd_gateway *);
+void lifxd_gateway_send_packet(struct lifxd_gateway *,
+                               const struct lifxd_packet_header *,
+                               const void *,
+                               int);
+
 void lifxd_gateway_handle_pan_gateway(struct lifxd_gateway *,
                                       const struct lifxd_packet_header *,
                                       const struct lifxd_packet_pan_gateway *);
-void lifxd_gateway_get_light_status(struct lifxd_gateway *);
 void lifxd_gateway_handle_light_status(struct lifxd_gateway *,
                                        const struct lifxd_packet_header *,
                                        const struct lifxd_packet_light_status *);
-
 void lifxd_gateway_handle_power_state(struct lifxd_gateway *,
                                       const struct lifxd_packet_header *,
                                       const struct lifxd_packet_power_state *);
diff --git a/core/json_proto.h b/core/json_proto.h
deleted file mode 100644
diff --git a/core/lifxd.c b/core/lifxd.c
--- a/core/lifxd.c
+++ b/core/lifxd.c
@@ -29,6 +29,7 @@
 
 #include <sys/queue.h>
 #include <sys/tree.h>
+#include <arpa/inet.h>
 #include <assert.h>
 #include <err.h>
 #include <errno.h>
@@ -48,13 +49,13 @@
 #include "wire_proto.h"
 #include "bulb.h"
 #include "gateway.h"
-#include "discovery.h"
+#include "broadcast.h"
 #include "version.h"
 #include "lifxd.h"
 
 struct lifxd_opts lifxd_opts = {
     .foreground = false,
-    .master_host = NULL,
+    .log_timestamps = true,
     .master_port = 56700,
     .verbosity = LIFXD_DEBUG
 }; 
@@ -64,7 +65,7 @@
 void
 lifxd_cleanup(void)
 {
-    lifxd_discovery_stop();
+    lifxd_broadcast_close();
     lifxd_gateway_close_all();
     event_base_free(lifxd_ev_base);
 #if LIBEVENT_VERSION_NUMBER >= 0x02010100
@@ -72,6 +73,20 @@
 #endif
 }
 
+short
+lifxd_sockaddrport(const struct sockaddr_storage *peer)
+{
+    assert(peer);
+
+    if (peer->ss_family == AF_INET) {
+        const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
+        return ntohs(in_peer->sin_port);
+    } else {
+        const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
+        return ntohs(in6_peer->sin6_port);
+    }
+}
+
 static void
 lifxd_signal_event_callback(int signum, short events, void *ctx)
 {
@@ -115,8 +130,8 @@
 lifxd_usage(const char *progname)
 {
     printf(
-        "Usage: %s [-m master_bulb_host] [-p master_bulb_port] "
-        "[-v debug|info|warning|error] [-f] [-h] [-V]\n",
+        "Usage: %s [-p master_bulb_port] "
+        "[-v debug|info|warning|error] [-f] [-t] [-h] [-V]\n",
         progname
     );
     exit(0);
@@ -125,34 +140,35 @@
 int
 main(int argc, char *argv[])
 {
-    static const struct option opts[] = {
-        {"foreground",  no_argument,       NULL, 'f'},
-        {"help",        no_argument,       NULL, 'h'},
-        {"master-host", required_argument, NULL, 'm'},
-        {"master-port", required_argument, NULL, 'p'},
-        {"verbosity",   required_argument, NULL, 'v'},
-        {"version",     no_argument,       NULL, 'V'},
-        {NULL,          0,                 NULL, 0}
+    static const struct option long_opts[] = {
+        {"foreground",      no_argument,       NULL, 'f'},
+        {"no-timestamps",   no_argument,       NULL, 't'},
+        {"help",            no_argument,       NULL, 'h'},
+        {"master-port",     required_argument, NULL, 'p'},
+        {"verbosity",       required_argument, NULL, 'v'},
+        {"version",         no_argument,       NULL, 'V'},
+        {NULL,              0,                 NULL, 0}
     };
+    const char short_opts[] = "fthp:v:V";
 
-    for (int rv = getopt_long(argc, argv, "fhm:p:v:V", opts, NULL);
+    for (int rv = getopt_long(argc, argv, short_opts, long_opts, NULL);
          rv != -1;
-         rv = getopt_long(argc, argv, "fh:p:v:V", opts, NULL)) {
+         rv = getopt_long(argc, argv, short_opts, long_opts, NULL)) {
         switch (rv) {
         case 'f':
             lifxd_opts.foreground = true;
-            break ;
+            break;
+        case 't':
+            lifxd_opts.log_timestamps = false;
+            break;
         case 'h':
             lifxd_usage(argv[0]);
-        case 'm':
-            lifxd_opts.master_host = optarg;
-            break ;
         case 'p':
             errno = 0;
             long port = strtol(optarg, NULL, 10);
             if (!errno && port <= UINT16_MAX && port > 0) {
                 lifxd_opts.master_port = port;
-                break ;
+                break;
             }
             lifxd_errx(
                 1, "The master port must be between 1 and %d", UINT16_MAX
@@ -164,13 +180,13 @@
                 };
                 if (!strcasecmp(optarg, verbose_levels[i])) {
                     lifxd_opts.verbosity = i;
-                    break ;
+                    break;
                 }
                 if (++i == LIFXD_ARRAY_SIZE(verbose_levels)) {
                     lifxd_errx(1, "Unknown verbosity level: %s", optarg);
                 }
             }
-            break ;
+            break;
         case 'V':
             printf("%s v%s\n", argv[0], LIFXD_VERSION);
             return 0;
@@ -182,17 +198,11 @@
     argc -= optind;
     argv += optind;
 
-    lifxd_gateway_load_packet_infos_map();
     lifxd_configure_libevent();
     lifxd_configure_signal_handling();
 
-    if (lifxd_opts.master_host) {
-        struct lifxd_gateway *gw = lifxd_gateway_open(
-            lifxd_opts.master_host, lifxd_opts.master_port, NULL
-        );
-        if (!gw)
-            lifxd_errx(1, "no bulb to connect to");
-    } else if (!lifxd_discovery_start()) {
+    lifxd_wire_load_packet_infos_map();
+    if (!lifxd_broadcast_setup() || !lifxd_broadcast_discovery()) {
         lifxd_err(1, "can't start auto discovery");
     }
 
diff --git a/core/lifxd.h b/core/lifxd.h
--- a/core/lifxd.h
+++ b/core/lifxd.h
@@ -30,6 +30,10 @@
 #pragma once
 
 #define LIFXD_ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+#define LIFXD_MSECS_TO_TV(v) {      \
+    .tv_sec = (v) / 1000,           \
+    .tv_usec = ((v) % 1000) * 1000  \
+}
 
 enum lifxd_verbosity {
     LIFXD_DEBUG = 0,
@@ -42,7 +46,7 @@
 
 struct lifxd_opts {
     bool                    foreground;
-    const char              *master_host;
+    bool                    log_timestamps;
     uint16_t                master_port;
     enum lifxd_verbosity    verbosity;
 };
@@ -51,6 +55,9 @@
 extern struct event_base *lifxd_ev_base;
 
 const char *lifxd_addrtoa(const uint8_t *);
+void lifxd_sockaddrtoa(const struct sockaddr_storage *, char *buf, int buflen);
+short lifxd_sockaddrport(const struct sockaddr_storage *);
+
 void _lifxd_err(void (*)(int, const char *, ...), int, const char *, ...);
 #define lifxd_err(eval, fmt, ...) _lifxd_err(err, (eval), (fmt), ##__VA_ARGS__);
 #define lifxd_errx(eval, fmt, ...) _lifxd_err(errx, (eval), (fmt), ##__VA_ARGS__);
@@ -61,6 +68,4 @@
 void lifxd_debug(const char *, ...);
 void lifxd_libevent_log(int, const char *);
 
-#define lifxd_nop (void)0
-
 void lifxd_cleanup(void);
diff --git a/core/log.c b/core/log.c
--- a/core/log.c
+++ b/core/log.c
@@ -27,6 +27,9 @@
 // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 // POSSIBILITY OF SUCH DAMAGE.
 
+#include <sys/tree.h>
+#include <sys/time.h>
+#include <arpa/inet.h>
 #include <assert.h>
 #include <err.h>
 #include <errno.h>
@@ -34,12 +37,55 @@
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
+#include <time.h>
 
 #include <event2/event.h>
 
 #include "wire_proto.h"
 #include "lifxd.h"
 
+static void
+lifxd_isotime_now(char *strbuf, int bufsz)
+{
+    assert(strbuf);
+    assert(bufsz > 0);
+
+    struct timeval now;
+    if (gettimeofday(&now, NULL) == -1) {
+        goto error;
+    }
+    struct tm tm_now;
+    if (!localtime_r(&now.tv_sec, &tm_now)) {
+        goto error;
+    }
+    // '2015-01-02T10:13:16.132222+00:00'
+    snprintf(
+        strbuf, bufsz, "%d-%02d-%02dT%02d:%02d:%02d.%d+%02ld:%02ld",
+        1900 + tm_now.tm_year, 1 + tm_now.tm_mon, tm_now.tm_mday,
+        tm_now.tm_hour, tm_now.tm_min, tm_now.tm_sec,
+        now.tv_usec, tm_now.tm_gmtoff / 60 / 60,
+        tm_now.tm_gmtoff % (60 * 60)
+    );
+    return;
+error:
+    strbuf[0] = '\0';
+}
+
+static void
+lifxd_log_header(const char *loglvl, bool showprogname)
+{
+    if (lifxd_opts.log_timestamps) {
+        char timestr[64];
+        lifxd_isotime_now(timestr, sizeof(timestr));
+        fprintf(
+            stderr, "[%s] [%s] %s",
+            timestr, loglvl, showprogname ? "lifxd: " : ""
+        );
+        return;
+    }
+    fprintf(stderr, "[%s] %s", loglvl, showprogname ? "lifxd: " : "");
+}
+
 const char *
 lifxd_addrtoa(const uint8_t *addr)
 {
@@ -54,6 +100,22 @@
 }
 
 void
+lifxd_sockaddrtoa(const struct sockaddr_storage *peer, char *buf, int buflen)
+{
+    assert(peer);
+    assert(buf);
+    assert(buflen > 0);
+
+    if (peer->ss_family == AF_INET) {
+        const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
+        inet_ntop(AF_INET, &in_peer->sin_addr, buf, buflen);
+    } else {
+        const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
+        inet_ntop(AF_INET6, &in6_peer->sin6_addr, buf, buflen);
+    }
+}
+
+void
 _lifxd_err(void (*errfn)(int, const char *, ...),
            int eval,
            const char *fmt,
@@ -68,7 +130,7 @@
     vsnprintf(errmsg, sizeof(errmsg), fmt, ap);
     va_end(ap);
     lifxd_cleanup();
-    fputs("[ERR]   ", stderr);
+    lifxd_log_header("ERR", false);
     errno = errsave;
     errfn(eval, errmsg);
 }
@@ -79,7 +141,7 @@
     if (lifxd_opts.verbosity <= LIFXD_WARN) {
         va_list ap;
         va_start(ap, fmt);
-        fputs("[WARN]  ", stderr);
+        lifxd_log_header("WARN", false);
         warnfn(fmt, ap);
         va_end(ap);
     }
@@ -91,7 +153,7 @@
     if (lifxd_opts.verbosity <= LIFXD_INFO) {
         va_list ap;
         va_start(ap, fmt);
-        fprintf(stderr, "[INFO]  lifxd: ");
+        lifxd_log_header("INFO", true);
         vfprintf(stderr, fmt, ap);
         va_end(ap);
         fprintf(stderr, "\n");
@@ -104,7 +166,7 @@
     if (lifxd_opts.verbosity <= LIFXD_DEBUG) {
         va_list ap;
         va_start(ap, fmt);
-        fprintf(stderr, "[DEBUG] lifxd: ");
+        lifxd_log_header("DEBUG", true);
         vfprintf(stderr, fmt, ap);
         va_end(ap);
         fprintf(stderr, "\n");
diff --git a/core/wire_proto.c b/core/wire_proto.c
--- a/core/wire_proto.c
+++ b/core/wire_proto.c
@@ -27,89 +27,239 @@
 // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 // POSSIBILITY OF SUCH DAMAGE.
 
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <arpa/inet.h>
 #include <assert.h>
 #include <endian.h>
 #include <err.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <event2/util.h>
 
 #include "wire_proto.h"
+#include "bulb.h"
+#include "gateway.h"
 #include "lifxd.h"
 
+union lifxd_target LIFXD_UNSPEC_TARGET = { .tags = 0 };
+
+static struct lifxd_packet_infos_map lifxd_packet_infos =
+    RB_INITIALIZER(&lifxd_packets_infos);
+
+RB_GENERATE_STATIC(
+    lifxd_packet_infos_map,
+    lifxd_packet_infos,
+    link,
+    lifxd_packet_infos_cmp
+);
+
+static void
+lifxd_wire_null_packet_encoder_decoder(void *pkt)
+{
+    (void)pkt;
+}
+
+static void
+lifxd_wire_null_packet_handler(struct lifxd_gateway *gw,
+                               const struct lifxd_packet_header *hdr,
+                               const void *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+
+void
+lifxd_wire_load_packet_infos_map(void)
+{
+#define DECODER(x)  ((void (*)(void *))(x))
+#define ENCODER(x)  ((void (*)(void *))(x))
+#define HANDLER(x)                                  \
+    ((void (*)(struct lifxd_gateway *,              \
+               const struct lifxd_packet_header *,  \
+               const void *))(x))
+#define REQUEST_ONLY                                    \
+    .decode = lifxd_wire_null_packet_encoder_decoder,   \
+    .encode = lifxd_wire_null_packet_encoder_decoder,   \
+    .handle = lifxd_wire_null_packet_handler
+
+    static struct lifxd_packet_infos packet_table[] = {
+        {
+            REQUEST_ONLY,
+            .name = "GET_PAN_GATEWAY",
+            .type = LIFXD_GET_PAN_GATEWAY
+        },
+        {
+            .name = "PAN_GATEWAY",
+            .type = LIFXD_PAN_GATEWAY,
+            .size = sizeof(struct lifxd_packet_pan_gateway),
+            .decode = DECODER(lifxd_wire_decode_pan_gateway),
+            .encode = ENCODER(lifxd_wire_encode_pan_gateway),
+            .handle = HANDLER(lifxd_gateway_handle_pan_gateway)
+        },
+        {
+            REQUEST_ONLY,
+            .name = "GET_LIGHT_STATUS",
+            .type = LIFXD_GET_LIGHT_STATE
+        },
+        {
+            .name = "LIGHT_STATUS",
+            .type = LIFXD_LIGHT_STATUS,
+            .size = sizeof(struct lifxd_packet_light_status),
+            .decode = DECODER(lifxd_wire_decode_light_status),
+            .encode = ENCODER(lifxd_wire_encode_light_status),
+            .handle = HANDLER(lifxd_gateway_handle_light_status)
+        },
+        {
+            .name = "POWER_STATE",
+            .type = LIFXD_POWER_STATE,
+            .size = sizeof(struct lifxd_packet_power_state),
+            .decode = DECODER(lifxd_wire_decode_power_state),
+            .handle = HANDLER(lifxd_gateway_handle_power_state)
+        }
+    };
+
+    for (int i = 0; i != LIFXD_ARRAY_SIZE(packet_table); ++i) {
+        RB_INSERT(
+            lifxd_packet_infos_map, &lifxd_packet_infos, &packet_table[i]
+        );
+    }
+}
+
+const struct lifxd_packet_infos *
+lifxd_wire_get_packet_infos(enum lifxd_packet_type packet_type)
+{
+    struct lifxd_packet_infos pkt_infos = { .type = packet_type };
+    return RB_FIND(lifxd_packet_infos_map, &lifxd_packet_infos, &pkt_infos);
+}
+
 // Convert all the fields in the header to the host endianness.
 //
-// :returns: The payload size or -1 if the header is invalid.
+// \return The payload size or -1 if the header is invalid.
 void
 lifxd_wire_decode_header(struct lifxd_packet_header *hdr)
 {
     assert(hdr);
 
     hdr->size = le16toh(hdr->size);
-    hdr->protocol = be16toh(hdr->protocol);
-    hdr->timestamp = be64toh(hdr->timestamp);
+    hdr->protocol.version = le16toh(hdr->protocol.version);
+    if (hdr->protocol.tagged) {
+        le64toh(hdr->target.tags);
+    }
+    hdr->timestamp = le64toh(hdr->timestamp);
     hdr->packet_type = le16toh(hdr->packet_type);
 }
 
+const struct lifxd_packet_infos *
+lifxd_wire_setup_header(struct lifxd_packet_header *hdr,
+                        enum lifxd_target_type target_type,
+                        union lifxd_target target,
+                        const uint8_t *site,
+                        enum lifxd_packet_type packet_type)
+{
+    assert(hdr);
+
+    const struct lifxd_packet_infos *pkt_infos = lifxd_wire_get_packet_infos(
+        packet_type
+    );
+
+    memset(hdr, 0, sizeof(*hdr));
+    hdr->size = pkt_infos->size + sizeof(*hdr);
+    hdr->protocol.version = LIFXD_LIFX_PROTOCOL_V1;
+    hdr->packet_type = packet_type;
+    if (site) {
+        memcpy(hdr->site, site, sizeof(hdr->site));
+    } else {
+        assert(target_type == LIFXD_TARGET_ALL_DEVICES);
+    }
+
+    switch (target_type) {
+    case LIFXD_TARGET_SITE:
+        hdr->protocol.tagged = true;
+        break;
+    case LIFXD_TARGET_TAGS:
+        hdr->protocol.tagged = true;
+        hdr->target.tags = target.tags;
+        break;
+    case LIFXD_TARGET_DEVICE:
+        hdr->protocol.addressable = false;
+        memcpy(hdr->target.device_addr, target.addr, LIFXD_ADDR_LENGTH);
+        break;
+    case LIFXD_TARGET_ALL_DEVICES:
+        hdr->protocol.tagged = true;
+        break;
+    }
+
+    lifxd_wire_encode_header(hdr);
+
+    return pkt_infos;
+}
+
 void
 lifxd_wire_encode_header(struct lifxd_packet_header *hdr)
 {
     assert(hdr);
 
     hdr->size = htole16(hdr->size);
-    hdr->protocol = htobe16(hdr->protocol);
-    hdr->timestamp = htobe64(hdr->timestamp);
+    hdr->protocol.version = htole16(hdr->protocol.version);
+    if (hdr->protocol.tagged) {
+        le64toh(hdr->target.tags);
+    }
+    hdr->timestamp = htole64(hdr->timestamp);
     hdr->packet_type = htole16(hdr->packet_type);
 }
 
 void
-lifxd_wire_dump_header(const struct lifxd_packet_header *hdr)
-{
-    assert(hdr);
-    lifxd_debug(
-        "header @%p: size=%hu, protocol=%hu, timestamp=%lu, packet_type=%hx",
-        hdr, hdr->size, hdr->protocol, hdr->timestamp, hdr->packet_type
-    );
-}
-
-void
 lifxd_wire_decode_pan_gateway(struct lifxd_packet_pan_gateway *pkt)
 {
+    assert(pkt);
+
     pkt->port = le32toh(pkt->port);
 }
 
 void
 lifxd_wire_encode_pan_gateway(struct lifxd_packet_pan_gateway *pkt)
 {
+    assert(pkt);
+
     pkt->port = htole32(pkt->port);
 }
 
 void
 lifxd_wire_decode_light_status(struct lifxd_packet_light_status *pkt)
 {
+    assert(pkt);
+
     pkt->hue = le16toh(pkt->hue);
     pkt->saturation = le16toh(pkt->saturation);
     pkt->brightness = le16toh(pkt->brightness);
     pkt->kelvin = le16toh(pkt->kelvin);
     pkt->dim = le16toh(pkt->dim);
     pkt->power = le16toh(pkt->power);
-    pkt->tags = be64toh(pkt->tags);
+    pkt->tags = le64toh(pkt->tags);
 }
 
 void
 lifxd_wire_encode_light_status(struct lifxd_packet_light_status *pkt)
 {
+    assert(pkt);
+
     pkt->hue = htole16(pkt->hue);
     pkt->saturation = htole16(pkt->saturation);
     pkt->brightness = htole16(pkt->brightness);
     pkt->kelvin = htole16(pkt->kelvin);
     pkt->dim = htole16(pkt->dim);
     pkt->power = htole16(pkt->power);
-    pkt->tags = htobe64(pkt->tags);
+    pkt->tags = htole64(pkt->tags);
 }
 
 void
 lifxd_wire_decode_power_state(struct lifxd_packet_power_state *pkt)
 {
-    (void)pkt;
+    assert(pkt);
 }
diff --git a/core/wire_proto.h b/core/wire_proto.h
--- a/core/wire_proto.h
+++ b/core/wire_proto.h
@@ -29,8 +29,6 @@
 
 #pragma once
 
-#pragma pack(push, 1)
-
 typedef uint16_t uint16le_t;
 typedef uint16_t uint16be_t;
 typedef uint32_t uint32le_t;
@@ -40,21 +38,47 @@
 
 enum { LIFXD_ADDR_LENGTH = 6 };
 
+#pragma pack(push, 1)
+
 struct lifxd_packet_header {
-    uint16le_t  size;
-    uint16be_t  protocol;
-    uint8_t     reserved1[4];
-    uint8_t     bulb_addr[LIFXD_ADDR_LENGTH];
-    uint8_t     reserved2[2];
-    uint8_t     gw_addr[LIFXD_ADDR_LENGTH];
-    uint8_t     reserved3[2];
-    uint64be_t  timestamp;
-    uint16le_t  packet_type;
-    uint8_t     reserved4[2];
+    //! Packet size including the headers (i.e: this structure).
+    uint16le_t      size;
+    struct {
+        //! Protocol version should be LIFXD_LIFX_PROTOCOL_V1.
+        uint16le_t  version:12;
+        //! True when the target field holds a device address.
+        uint16le_t  addressable:1;
+        //! True when the target field holds tags.
+        uint16le_t  tagged:1;
+        //! LIFX internal use should be 0.
+        uint16le_t  origin:2;
+    }               protocol;
+    //! This seems to be for LIFX internal use only.
+    uint32le_t      source;
+    union {
+        //! All targeted tags ORed together.
+        uint64le_t  tags;
+        //! Address of the targeted device.
+        uint8_t     device_addr[LIFXD_ADDR_LENGTH];
+    }               target;
+    uint8_t         site[LIFXD_ADDR_LENGTH];
+    struct {
+        //! True when a response is required, called acknowledge in lifx-gem...
+        uint8_t     response_required:1;
+        //! True when an acknowledgement is required, no idea what it means.
+        uint8_t     ack_required:1;
+        uint8_t     reserved:6;
+    }               flags;
+    //! Wrap-around sequence number, LIFX internal use.
+    uint8_t         seqn;
+    uint64le_t      timestamp;
+    uint16le_t      packet_type;
+    uint8_t         reserved[2];
 };
 
 enum { LIFXD_PACKET_HEADER_SIZE = sizeof(struct lifxd_packet_header) };
-enum { LIFXD_PROTOCOL_VERSION = 0x54 };
+
+enum { LIFXD_LIFX_PROTOCOL_V1 = 1024 };
 
 // Let's define a maximum packet size just in case somebody sends us weird
 // headers:
@@ -143,15 +167,57 @@
     uint32le_t  port;
 };
 
+enum lifxd_target_type {
+    LIFXD_TARGET_SITE,
+    LIFXD_TARGET_TAGS,
+    LIFXD_TARGET_DEVICE,
+    LIFXD_TARGET_ALL_DEVICES
+};
+
+#pragma pack(pop)
+
+struct lifxd_gateway;
+
+struct lifxd_packet_infos {
+    RB_ENTRY(lifxd_packet_infos)    link;
+    const char                      *name;
+    enum lifxd_packet_type          type;
+    unsigned                        size;
+    void                            (*decode)(void *);
+    void                            (*encode)(void *);
+    void                            (*handle)(struct lifxd_gateway *,
+                                              const struct lifxd_packet_header *,
+                                              const void *);
+};
+RB_HEAD(lifxd_packet_infos_map, lifxd_packet_infos);
+
+static inline int
+lifxd_packet_infos_cmp(struct lifxd_packet_infos *a,
+                       struct lifxd_packet_infos *b)
+{
+    return a->type - b->type;
+}
+
+union lifxd_target {
+    uint64_t        tags;
+    const uint8_t   *addr; //! site or device address
+};
+
+extern union lifxd_target LIFXD_UNSPEC_TARGET;
+
+const struct lifxd_packet_infos *lifxd_wire_get_packet_infos(enum lifxd_packet_type);
+void lifxd_wire_load_packet_infos_map(void);
+
+const struct lifxd_packet_infos *lifxd_wire_setup_header(struct lifxd_packet_header *,
+                                                         enum lifxd_target_type,
+                                                         union lifxd_target,
+                                                         const uint8_t *,
+                                                         enum lifxd_packet_type);
 void lifxd_wire_decode_header(struct lifxd_packet_header *);
 void lifxd_wire_encode_header(struct lifxd_packet_header *);
-void lifxd_wire_dump_header(const struct lifxd_packet_header *);
-void lifxd_wire_encode_packet(void *, enum lifxd_packet_type);
 
 void lifxd_wire_decode_pan_gateway(struct lifxd_packet_pan_gateway *);
 void lifxd_wire_encode_pan_gateway(struct lifxd_packet_pan_gateway *);
 void lifxd_wire_decode_light_status(struct lifxd_packet_light_status *);
 void lifxd_wire_encode_light_status(struct lifxd_packet_light_status *);
 void lifxd_wire_decode_power_state(struct lifxd_packet_power_state *);
-
-#pragma pack(pop)
