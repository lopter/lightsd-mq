# HG changeset patch
# Parent  1e25f17960e56bccc311c28c0396834c8d31df46
Add the set_label command

diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -958,16 +958,17 @@
 CHECK_AND_CALL_TARGETS_ONLY_METHOD(get_light_state);
 
 static void
-lgtd_jsonrpc_check_and_call_proto_tag_or_untag(struct lgtd_client *client,
-                                               void (*lgtd_proto_fn)(struct lgtd_client *,
-                                                          const struct lgtd_proto_target_list *,
-                                                          const char *))
+lgtd_jsonrpc_check_and_call_proto_tag_or_untag_or_set_label(
+        struct lgtd_client *client,
+        void (*lgtd_proto_fn)(struct lgtd_client *,
+                              const struct lgtd_proto_target_list *,
+                              const char *))
 
 {
     struct lgtd_jsonrpc_target_args {
         const jsmntok_t *target;
         int             target_ntokens;
-        const jsmntok_t *tag;
+        const jsmntok_t *label;
     } params = { NULL, 0, NULL };
     static const struct lgtd_jsonrpc_node schema[] = {
         LGTD_JSONRPC_NODE(
@@ -978,8 +979,8 @@
             false
         ),
         LGTD_JSONRPC_NODE(
-            "tag",
-            offsetof(struct lgtd_jsonrpc_target_args, tag),
+            "label",
+            offsetof(struct lgtd_jsonrpc_target_args, label),
             -1,
             lgtd_jsonrpc_type_string,
             false
@@ -1010,20 +1011,20 @@
         return;
     }
 
-    char *tag = strndup(
-        &client->json[params.tag->start], LGTD_JSONRPC_TOKEN_LEN(params.tag)
+    char *label = strndup(
+        &client->json[params.label->start], LGTD_JSONRPC_TOKEN_LEN(params.label)
     );
-    if (!tag) {
-        lgtd_warn("can't allocate a tag");
+    if (!label) {
+        lgtd_warn("can't allocate a label");
         lgtd_jsonrpc_send_error(
             client, LGTD_JSONRPC_INTERNAL_ERROR, "Can't allocate memory"
         );
         goto error_strdup;
     }
 
-    lgtd_proto_fn(client, &targets, tag);
+    lgtd_proto_fn(client, &targets, label);
 
-    free(tag);
+    free(label);
 
 error_strdup:
     lgtd_proto_target_list_clear(&targets);
@@ -1032,13 +1033,25 @@
 static void
 lgtd_jsonrpc_check_and_call_tag(struct lgtd_client *client)
 {
-    return lgtd_jsonrpc_check_and_call_proto_tag_or_untag(client, lgtd_proto_tag);
+    return lgtd_jsonrpc_check_and_call_proto_tag_or_untag_or_set_label(
+        client, lgtd_proto_tag
+    );
 }
 
 static void
 lgtd_jsonrpc_check_and_call_untag(struct lgtd_client *client)
 {
-    return lgtd_jsonrpc_check_and_call_proto_tag_or_untag(client, lgtd_proto_untag);
+    return lgtd_jsonrpc_check_and_call_proto_tag_or_untag_or_set_label(
+        client, lgtd_proto_untag
+    );
+}
+
+static void
+lgtd_jsonrpc_check_and_call_set_label(struct lgtd_client *client)
+{
+    return lgtd_jsonrpc_check_and_call_proto_tag_or_untag_or_set_label(
+        client, lgtd_proto_set_label
+    );
 }
 
 void
@@ -1077,6 +1090,10 @@
         LGTD_JSONRPC_METHOD(
             "untag", 2, // t, tag
             lgtd_jsonrpc_check_and_call_untag
+        ),
+        LGTD_JSONRPC_METHOD(
+            "set_label", 2, // t, label
+            lgtd_jsonrpc_check_and_call_set_label
         )
     };
 
diff --git a/core/lightsd.h b/core/lightsd.h
--- a/core/lightsd.h
+++ b/core/lightsd.h
@@ -23,6 +23,7 @@
 
 #define LGTD_ABS(v) ((v) >= 0 ? (v) : (v) * -1)
 #define LGTD_MIN(a, b) ((a) < (b) ? (a) : (b))
+#define LGTD_MAX(a, b) ((a) > (b) ? (a) : (b))
 #define LGTD_ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
 #define LGTD_MSECS_TO_TIMEVAL(v) {  \
     .tv_sec = (v) / 1000,           \
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -512,3 +512,24 @@
 
     lgtd_router_device_list_free(devices);
 }
+
+void
+lgtd_proto_set_label(struct lgtd_client *client,
+                     const struct lgtd_proto_target_list *targets,
+                     const char *label)
+{
+    assert(client);
+    assert(targets);
+    assert(label);
+
+    int label_len = strlen(label);
+    struct lgtd_lifx_packet_label pkt;
+    memcpy(pkt.label, label, LGTD_MIN(label_len, (int)sizeof(pkt.label)));
+    // this will go out on the network don't leave garbage in it:
+    memset(&pkt.label[label_len], 0, LGTD_MAX(
+        (int)sizeof(pkt.label) - label_len, 0
+    ));
+    SEND_RESULT(
+        client, lgtd_router_send(targets, LGTD_LIFX_SET_BULB_LABEL, &pkt)
+    );
+}
diff --git a/core/proto.h b/core/proto.h
--- a/core/proto.h
+++ b/core/proto.h
@@ -42,3 +42,4 @@
 void lgtd_proto_get_light_state(struct lgtd_client *, const struct lgtd_proto_target_list *);
 void lgtd_proto_tag(struct lgtd_client *, const struct lgtd_proto_target_list *, const char *);
 void lgtd_proto_untag(struct lgtd_client *, const struct lgtd_proto_target_list *, const char *);
+void lgtd_proto_set_label(struct lgtd_client *, const struct lgtd_proto_target_list *, const char *);
diff --git a/docs/protocol.rst b/docs/protocol.rst
--- a/docs/protocol.rst
+++ b/docs/protocol.rst
@@ -26,6 +26,10 @@
 A target is either a string, a hexadecimal number (without any prefix like 0x)
 or an array of targets.
 
+.. note::
+
+   The maximum supported length for labels and tag names by LIFX bulbs is 32.
+
 Available methods
 -----------------
 
@@ -83,14 +87,22 @@
 
 .. function:: get_light_state(target)
 
-    Return a list of dictionnaries, each dict representing the state of one
-    targeted bulb, the list is not in any specific order. Each dict has the
-    following fields:
+   Return a list of dictionnaries, each dict representing the state of one
+   targeted bulb, the list is not in any specific order. Each dict has the
+   following fields:
 
-    - hsbk: tuple (h, s, b, k) see function:`set_light_from_hsbk`;
-    - label: bulb label (utf-8 encoded string);
-    - power: boolean, true when the bulb is powered on false otherwise;
-    - tags: list of tags applied to the bulb (utf-8 encoded strings).
+   - hsbk: tuple (h, s, b, k) see function:`set_light_from_hsbk`;
+   - label: bulb label (utf-8 encoded string);
+   - power: boolean, true when the bulb is powered on false otherwise;
+   - tags: list of tags applied to the bulb (utf-8 encoded strings).
+
+.. function:: set_label(target, label)
+
+   Label the target bulb(s) with the given label.
+
+   .. note:
+
+      Use :func:`tag` instead set_label to give a common name to multiple bulbs.
 
 .. function:: tag(target, label)
 
diff --git a/examples/lightsc.py b/examples/lightsc.py
--- a/examples/lightsc.py
+++ b/examples/lightsc.py
@@ -116,6 +116,10 @@
     return jsonrpc_call(socket, "untag", [target, tag])
 
 
+def set_label(socket, target, label):
+    return jsonrpc_call(socket, "set_label", [target, label])
+
+
 def adjust_brightness(socket, target, adjustment):
     bulbs = get_light_state(socket, target)["result"]
     for bulb in bulbs:
diff --git a/lifx/bulb.c b/lifx/bulb.c
--- a/lifx/bulb.c
+++ b/lifx/bulb.c
@@ -306,3 +306,12 @@
     bulb->runtime_info_updated_at = received_at;
     memcpy(&bulb->runtime_info, info, sizeof(bulb->runtime_info));
 }
+
+void
+lgtd_lifx_bulb_set_label(struct lgtd_lifx_bulb *bulb,
+                         const char label[LGTD_LIFX_LABEL_SIZE])
+{
+    assert(bulb);
+
+    memcpy(bulb->state.label, label, LGTD_LIFX_LABEL_SIZE);
+}
diff --git a/lifx/bulb.h b/lifx/bulb.h
--- a/lifx/bulb.h
+++ b/lifx/bulb.h
@@ -138,3 +138,5 @@
 void lgtd_lifx_bulb_set_runtime_info(struct lgtd_lifx_bulb *,
                                      const struct lgtd_lifx_runtime_info *,
                                      lgtd_time_mono_t);
+void lgtd_lifx_bulb_set_label(struct lgtd_lifx_bulb *,
+                              const char [LGTD_LIFX_LABEL_SIZE]);
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -847,3 +847,23 @@
         (const struct lgtd_lifx_runtime_info *)pkt, gw->last_pkt_at
     );
 }
+
+void
+lgtd_lifx_gateway_handle_bulb_label(struct lgtd_lifx_gateway *gw,
+                                    const struct lgtd_lifx_packet_header *hdr,
+                                    const struct lgtd_lifx_packet_label *pkt)
+{
+    assert(gw && hdr && pkt);
+
+    char addr[LGTD_LIFX_ADDR_STRLEN];
+    lgtd_info(
+        "BULB_LABEL <-- [%s]:%hu - %s label=%.*s",
+        gw->ip_addr, gw->port,
+        LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
+        (int)sizeof(pkt->label), pkt->label
+    );
+
+    LGTD_LIFX_GATEWAY_SET_BULB_ATTR(
+        gw, hdr->target.device_addr, lgtd_lifx_bulb_set_label, pkt->label
+    );
+}
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -145,3 +145,6 @@
 void lgtd_lifx_gateway_handle_runtime_info(struct lgtd_lifx_gateway *,
                                            const struct lgtd_lifx_packet_header *,
                                            const struct lgtd_lifx_packet_runtime_info *);
+void lgtd_lifx_gateway_handle_bulb_label(struct lgtd_lifx_gateway *,
+                                         const struct lgtd_lifx_packet_header *,
+                                         const struct lgtd_lifx_packet_label *);
diff --git a/lifx/wire_proto.c b/lifx/wire_proto.c
--- a/lifx/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -298,6 +298,21 @@
             .decode = DECODER(lgtd_lifx_wire_decode_runtime_info),
             .handle = HANDLER(lgtd_lifx_gateway_handle_runtime_info)
         },
+        {
+            REQUEST_ONLY,
+            .encode = lgtd_lifx_wire_null_packet_encoder_decoder,
+            .name = "SET_BULB_LABEL",
+            .type = LGTD_LIFX_SET_BULB_LABEL,
+            .size = sizeof(struct lgtd_lifx_packet_label)
+        },
+        {
+            RESPONSE_ONLY,
+            .name = "BULB_LABEL",
+            .type = LGTD_LIFX_BULB_LABEL,
+            .size = sizeof(struct lgtd_lifx_packet_label),
+            .decode = lgtd_lifx_wire_null_packet_encoder_decoder,
+            .handle = HANDLER(lgtd_lifx_gateway_handle_bulb_label)
+        },
         // Unimplemented but "known" packets
         {
             UNIMPLEMENTED,
@@ -331,16 +346,6 @@
         },
         {
             UNIMPLEMENTED,
-            .name = "SET_BULB_LABEL",
-            .type = LGTD_LIFX_SET_BULB_LABEL
-        },
-        {
-            UNIMPLEMENTED,
-            .name = "BULB_LABEL",
-            .type = LGTD_LIFX_BULB_LABEL
-        },
-        {
-            UNIMPLEMENTED,
             .name = "GET_MCU_RAIL_VOLTAGE",
             .type = LGTD_LIFX_GET_MCU_RAIL_VOLTAGE
         },
diff --git a/lifx/wire_proto.h b/lifx/wire_proto.h
--- a/lifx/wire_proto.h
+++ b/lifx/wire_proto.h
@@ -245,6 +245,10 @@
     uint64le_t  tags;
 };
 
+struct lgtd_lifx_packet_label {
+    char        label[LGTD_LIFX_LABEL_SIZE];
+};
+
 struct lgtd_lifx_packet_tag_labels {
     uint64le_t  tags;
     char        label[LGTD_LIFX_LABEL_SIZE];
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_label.c
copy from tests/core/jsonrpc/test_jsonrpc_check_and_call_tag.c
copy to tests/core/jsonrpc/test_jsonrpc_check_and_call_set_label.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_label.c
@@ -3,15 +3,15 @@
 #include "mock_client_buf.h"
 #include "mock_gateway.h"
 
-#define MOCKED_LGTD_TAG
+#define MOCKED_LGTD_PROTO_SET_LABEL
 #include "test_jsonrpc_utils.h"
 
 static bool tag_called = false;
 
 void
-lgtd_proto_tag(struct lgtd_client *client,
-               const struct lgtd_proto_target_list *targets,
-               const char *tag)
+lgtd_proto_set_label(struct lgtd_client *client,
+                     const struct lgtd_proto_target_list *targets,
+                     const char *label)
 {
     if (!client) {
         errx(1, "missing client!");
@@ -24,8 +24,8 @@
         );
     }
 
-    if (strcmp(tag, "suspensions")) {
-        errx(1, "Invalid tag [%s] (expected=[suspensions])", tag);
+    if (strcmp(label, "candle")) {
+        errx(1, "Invalid label [%s] (expected=[candle])", label);
     }
 
     tag_called = true;
@@ -37,8 +37,8 @@
     jsmntok_t tokens[32];
     const char json[] = ("{"
         "\"jsonrpc\": \"2.0\","
-        "\"method\": \"tag\","
-        "\"params\": {\"target\": \"*\", \"tag\": \"suspensions\"},"
+        "\"method\": \"set_label\","
+        "\"params\": {\"target\": \"*\", \"label\": \"candle\"},"
         "\"id\": \"42\""
     "}");
     int parsed = parse_json(
@@ -55,10 +55,10 @@
         errx(1, "can't parse request");
     }
 
-    lgtd_jsonrpc_check_and_call_proto_tag_or_untag(&client, lgtd_proto_tag);
+    lgtd_jsonrpc_check_and_call_set_label(&client);
 
     if (!tag_called) {
-        errx(1, "lgtd_proto_tag wasn't called");
+        errx(1, "lgtd_proto_label wasn't called");
     }
 
     return 0;
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag.c
@@ -38,7 +38,7 @@
     const char json[] = ("{"
         "\"jsonrpc\": \"2.0\","
         "\"method\": \"tag\","
-        "\"params\": {\"target\": \"*\", \"tag\": \"suspensions\"},"
+        "\"params\": {\"target\": \"*\", \"label\": \"suspensions\"},"
         "\"id\": \"42\""
     "}");
     int parsed = parse_json(
@@ -55,7 +55,7 @@
         errx(1, "can't parse request");
     }
 
-    lgtd_jsonrpc_check_and_call_proto_tag_or_untag(&client, lgtd_proto_tag);
+    lgtd_jsonrpc_check_and_call_tag(&client);
 
     if (!tag_called) {
         errx(1, "lgtd_proto_tag wasn't called");
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag_missing_params.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag_missing_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag_missing_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag_missing_params.c
@@ -43,7 +43,7 @@
         errx(1, "can't parse request");
     }
 
-    lgtd_jsonrpc_check_and_call_proto_tag_or_untag(&client, lgtd_proto_tag);
+    lgtd_jsonrpc_check_and_call_proto_tag_or_untag_or_set_label(&client, lgtd_proto_tag);
 
     if (tag_called) {
         errx(1, "lgtd_proto_tag was called");
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag.c
@@ -55,7 +55,7 @@
         errx(1, "can't parse request");
     }
 
-    lgtd_jsonrpc_check_and_call_proto_tag_or_untag(&client, lgtd_proto_untag);
+    lgtd_jsonrpc_check_and_call_proto_tag_or_untag_or_set_label(&client, lgtd_proto_untag);
 
     if (!untag_called) {
         errx(1, "lgtd_proto_tag wasn't called");
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag_invalid_params.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag_invalid_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag_invalid_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag_invalid_params.c
@@ -43,7 +43,7 @@
         errx(1, "can't parse request");
     }
 
-    lgtd_jsonrpc_check_and_call_proto_tag_or_untag(&client, lgtd_proto_untag);
+    lgtd_jsonrpc_check_and_call_proto_tag_or_untag_or_set_label(&client, lgtd_proto_untag);
 
     if (untag_called) {
         errx(1, "lgtd_proto_tag was called");
diff --git a/tests/core/jsonrpc/test_jsonrpc_utils.h b/tests/core/jsonrpc/test_jsonrpc_utils.h
--- a/tests/core/jsonrpc/test_jsonrpc_utils.h
+++ b/tests/core/jsonrpc/test_jsonrpc_utils.h
@@ -131,3 +131,15 @@
     (void)targets;
 }
 #endif
+
+#ifndef MOCKED_LGTD_PROTO_SET_LABEL
+void
+lgtd_proto_set_label(struct lgtd_client *client,
+                     const struct lgtd_proto_target_list *targets,
+                     const char *label)
+{
+    (void)client;
+    (void)targets;
+    (void)label;
+}
+#endif
diff --git a/tests/core/proto/test_proto_set_label.c b/tests/core/proto/test_proto_set_label.c
new file mode 100644
--- /dev/null
+++ b/tests/core/proto/test_proto_set_label.c
@@ -0,0 +1,85 @@
+#include "proto.c"
+
+#include "mock_client_buf.h"
+#include "mock_daemon.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
+#include "tests_utils.h"
+
+#define MOCKED_CLIENT_SEND_RESPONSE
+#define MOCKED_ROUTER_SEND
+#include "tests_proto_utils.h"
+
+static int router_send_call_count = 0;
+
+bool
+lgtd_router_send(const struct lgtd_proto_target_list *targets,
+                 enum lgtd_lifx_packet_type pkt_type,
+                 void *pkt)
+{
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+
+    if (pkt_type != LGTD_LIFX_SET_BULB_LABEL) {
+        errx(1, "invalid packet type %d (expected %d)",
+             pkt_type, LGTD_LIFX_SET_BULB_LABEL
+        );
+    }
+
+    struct lgtd_lifx_packet_label *set_label = pkt;
+    if (strcmp(set_label->label, "test")) {
+        errx(
+            1, "invalid packet label %.*s (expected test)",
+            LGTD_LIFX_LABEL_SIZE, set_label->label
+        );
+    }
+
+    if (router_send_call_count++) {
+        errx(1, "lgtd_router_send should be called once");
+    }
+
+    return true;
+}
+
+static int client_send_response_call_count = 0;
+
+void
+lgtd_client_send_response(struct lgtd_client *client, const char *msg)
+{
+    if (!client) {
+        errx(1, "client shouldn't be NULL");
+    }
+
+    if (strcmp(msg, "true")) {
+        errx(1, "unexpected response [%s] (expected [true])", msg);
+    }
+
+    if (client_send_response_call_count++) {
+        errx(1, "lgtd_client_send_response should be called once");
+    }
+}
+
+int
+main(void)
+{
+    struct lgtd_proto_target_list *targets;
+    targets = lgtd_tests_build_target_list("*", NULL);
+
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+
+    lgtd_proto_set_label(&client, targets, "test");
+
+    if (!router_send_call_count) {
+        errx(1, "lgtd_router_send wasn't called");
+    }
+
+    if (!client_send_response_call_count) {
+        errx(1, "lgtd_client_send_response wasn't called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/proto/test_proto_set_label_too_long.c b/tests/core/proto/test_proto_set_label_too_long.c
new file mode 100644
--- /dev/null
+++ b/tests/core/proto/test_proto_set_label_too_long.c
@@ -0,0 +1,87 @@
+#include "proto.c"
+
+#include "mock_client_buf.h"
+#include "mock_daemon.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
+#include "tests_utils.h"
+
+#define MOCKED_CLIENT_SEND_RESPONSE
+#define MOCKED_ROUTER_SEND
+#include "tests_proto_utils.h"
+
+static const char *test_label = "test of a very long label over 32 chars";
+
+static int router_send_call_count = 0;
+
+bool
+lgtd_router_send(const struct lgtd_proto_target_list *targets,
+                 enum lgtd_lifx_packet_type pkt_type,
+                 void *pkt)
+{
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+
+    if (pkt_type != LGTD_LIFX_SET_BULB_LABEL) {
+        errx(1, "invalid packet type %d (expected %d)",
+             pkt_type, LGTD_LIFX_SET_BULB_LABEL
+        );
+    }
+
+    struct lgtd_lifx_packet_label *set_label = pkt;
+    if (memcmp(set_label->label, test_label, sizeof(set_label->label))) {
+        errx(
+            1, "invalid packet label %2$.*1$s (expected %3$.*1$s)",
+            LGTD_LIFX_LABEL_SIZE, set_label->label, test_label
+        );
+    }
+
+    if (router_send_call_count++) {
+        errx(1, "lgtd_router_send should be called once");
+    }
+
+    return true;
+}
+
+static int client_send_response_call_count = 0;
+
+void
+lgtd_client_send_response(struct lgtd_client *client, const char *msg)
+{
+    if (!client) {
+        errx(1, "client shouldn't be NULL");
+    }
+
+    if (strcmp(msg, "true")) {
+        errx(1, "unexpected response [%s] (expected [true])", msg);
+    }
+
+    if (client_send_response_call_count++) {
+        errx(1, "lgtd_client_send_response should be called once");
+    }
+}
+
+int
+main(void)
+{
+    struct lgtd_proto_target_list *targets;
+    targets = lgtd_tests_build_target_list("*", NULL);
+
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+
+    lgtd_proto_set_label(&client, targets, test_label);
+
+    if (!router_send_call_count) {
+        errx(1, "lgtd_router_send wasn't called");
+    }
+
+    if (!client_send_response_call_count) {
+        errx(1, "lgtd_client_send_response wasn't called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/tests_utils.c b/tests/core/tests_utils.c
--- a/tests/core/tests_utils.c
+++ b/tests/core/tests_utils.c
@@ -31,9 +31,6 @@
 #include "lifx/gateway.h"
 #include "tests_utils.h"
 
-struct lgtd_lifx_gateway_list lgtd_lifx_gateways =
-    LIST_HEAD_INITIALIZER(&lgtd_lifx_gateways);
-
 struct lgtd_listen_list lgtd_listeners =
     SLIST_HEAD_INITIALIZER(&lgtd_listeners);
 
diff --git a/tests/lifx/gateway/CMakeLists.txt b/tests/lifx/gateway/CMakeLists.txt
--- a/tests/lifx/gateway/CMakeLists.txt
+++ b/tests/lifx/gateway/CMakeLists.txt
@@ -10,6 +10,7 @@
     ${LIGHTSD_SOURCE_DIR}/core/router.c
     ${LIGHTSD_SOURCE_DIR}/core/stats.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../../core/tests_utils.c
 )
 
 ADD_LIBRARY(
diff --git a/tests/lifx/gateway/test_gateway_handle_bulb_label.c b/tests/lifx/gateway/test_gateway_handle_bulb_label.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_handle_bulb_label.c
@@ -0,0 +1,34 @@
+#include <string.h>
+
+#include "gateway.c"
+
+#include "mock_timer.h"
+#include "test_gateway_utils.h"
+#include "tests_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_info_map();
+
+    struct lgtd_lifx_gateway gw = { .last_pkt_at = 42 };
+
+    struct lgtd_lifx_bulb *b = lgtd_tests_insert_mock_bulb(&gw, 42);
+
+    struct lgtd_lifx_packet_header hdr = {
+        .packet_type = LGTD_LIFX_BULB_LABEL
+    };
+    memcpy(&hdr.target.device_addr, &b->addr, sizeof(hdr.target.device_addr));
+    struct lgtd_lifx_packet_label pkt = { .label = "TEST LABEL" };
+
+    lgtd_lifx_gateway_handle_bulb_label(&gw, &hdr, &pkt);
+
+    if (memcmp(&b->state.label, &pkt.label, LGTD_LIFX_LABEL_SIZE)) {
+        errx(
+            1, "got label %2$.*1$s, (expected %3$.*1$s)",
+            LGTD_LIFX_LABEL_SIZE, b->state.label, pkt.label
+        );
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/mock_gateway.h b/tests/lifx/mock_gateway.h
--- a/tests/lifx/mock_gateway.h
+++ b/tests/lifx/mock_gateway.h
@@ -5,7 +5,9 @@
 #include "lifx/gateway.h"
 
 struct lgtd_lifx_tag;
-struct lgtd_lifx_gateway;
+
+struct lgtd_lifx_gateway_list lgtd_lifx_gateways =
+    LIST_HEAD_INITIALIZER(&lgtd_lifx_gateways);
 
 #ifndef MOCKED_LIFX_GATEWAY_SEND_TO_SITE
 bool
@@ -177,3 +179,15 @@
     (void)pkt;
 }
 #endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_HANDLE_BULB_LABEL
+void
+lgtd_lifx_gateway_handle_bulb_label(struct lgtd_lifx_gateway *gw,
+                                    const struct lgtd_lifx_packet_header *hdr,
+                                    const struct lgtd_lifx_packet_label *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+#endif
