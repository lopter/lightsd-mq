# HG changeset patch
# Parent  53fa843ad516a35dd7b58071f5c7642e0c5c7601
Add the tag list command

First step towards support for tagging bulbs and targeting tags.

diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -143,6 +143,18 @@
 }
 
 void
+lgtd_client_start_send_response(struct lgtd_client *client)
+{
+    lgtd_jsonrpc_start_send_response(client);
+}
+
+void
+lgtd_client_end_send_response(struct lgtd_client *client)
+{
+    lgtd_jsonrpc_end_send_response(client);
+}
+
+void
 lgtd_client_send_error(struct lgtd_client *client,
                        enum lgtd_client_error_code error,
                        const char *msg)
diff --git a/core/client.h b/core/client.h
--- a/core/client.h
+++ b/core/client.h
@@ -50,4 +50,6 @@
 void lgtd_client_close_all(void);
 
 void lgtd_client_send_response(struct lgtd_client *, const char *);
+void lgtd_client_start_send_response(struct lgtd_client *);
+void lgtd_client_end_send_response(struct lgtd_client *);
 void lgtd_client_send_error(struct lgtd_client *, enum lgtd_client_error_code, const char *);
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -459,6 +459,22 @@
     LGTD_CLIENT_WRITE_STRING(client, "}");
 }
 
+void
+lgtd_jsonrpc_start_send_response(struct lgtd_client *client)
+{
+    assert(client);
+
+    LGTD_CLIENT_WRITE_STRING(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
+    lgtd_jsonrpc_write_id(client);
+    LGTD_CLIENT_WRITE_STRING(client, ", \"result\": ");
+}
+
+void
+lgtd_jsonrpc_end_send_response(struct lgtd_client *client)
+{
+    LGTD_CLIENT_WRITE_STRING(client, "}");
+}
+
 static bool
 lgtd_jsonrpc_check_and_extract_request(struct lgtd_jsonrpc_request *request,
                                        const jsmntok_t *tokens,
@@ -856,7 +872,6 @@
 static void
 lgtd_jsonrpc_check_and_call_power_on(struct lgtd_client *client)
 {
-
     struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
     bool ok = lgtd_jsonrpc_extract_target_list(&targets, client);
     if (!ok) {
@@ -870,7 +885,6 @@
 static void
 lgtd_jsonrpc_check_and_call_power_off(struct lgtd_client *client)
 {
-
     struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
     bool ok = lgtd_jsonrpc_extract_target_list(&targets, client);
     if (!ok) {
@@ -902,6 +916,7 @@
             "set_waveform", 10,
             lgtd_jsonrpc_check_and_call_set_waveform
         ),
+        LGTD_JSONRPC_METHOD("list_tags", 0, lgtd_proto_list_tags),
     };
 
     assert(client);
diff --git a/core/jsonrpc.h b/core/jsonrpc.h
--- a/core/jsonrpc.h
+++ b/core/jsonrpc.h
@@ -88,3 +88,5 @@
                              const char *);
 void lgtd_jsonrpc_send_response(struct lgtd_client *,
                                 const char *);
+void lgtd_jsonrpc_start_send_response(struct lgtd_client *);
+void lgtd_jsonrpc_end_send_response(struct lgtd_client *);
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -26,11 +26,13 @@
 #include <stdint.h>
 #include <string.h>
 
+#include <event2/bufferevent.h>
 #include <event2/util.h>
 
 #include "lifx/wire_proto.h"
 #include "time_monotonic.h"
 #include "lifx/bulb.h"
+#include "lifx/tagging.h"
 #include "jsmn.h"
 #include "jsonrpc.h"
 #include "client.h"
@@ -39,7 +41,7 @@
 #include "lightsd.h"
 
 #define SEND_RESULT(client, ok) do {                                \
-    lgtd_jsonrpc_send_response((client), (ok) ? "true" : "false");  \
+    lgtd_client_send_response((client), (ok) ? "true" : "false");   \
 } while(0)
 
 void
@@ -105,8 +107,8 @@
 
     lgtd_lifx_wire_encode_light_color(&pkt);
     SEND_RESULT(
-        client, lgtd_router_send(targets, LGTD_LIFX_SET_LIGHT_COLOR, &pkt))
-    ;
+        client, lgtd_router_send(targets, LGTD_LIFX_SET_LIGHT_COLOR, &pkt)
+    );
 }
 
 void
@@ -146,3 +148,21 @@
         client, lgtd_router_send(targets, LGTD_LIFX_SET_WAVEFORM, &pkt)
     );
 }
+
+void
+lgtd_proto_list_tags(struct lgtd_client *client)
+{
+    lgtd_client_start_send_response(client);
+
+    LGTD_CLIENT_WRITE_STRING(client, "[");
+    struct lgtd_lifx_label_site_tags *label;
+    LIST_FOREACH(label, &lgtd_lifx_labels, link) {
+        LGTD_CLIENT_WRITE_STRING(client, label->label);
+        if (LIST_NEXT(label, link) != LIST_END(lgtd_lifx_labels)) {
+            LGTD_CLIENT_WRITE_STRING(client, ",");
+        }
+    }
+    LGTD_CLIENT_WRITE_STRING(client, "]");
+
+    lgtd_client_end_send_response(client);
+}
diff --git a/core/proto.h b/core/proto.h
--- a/core/proto.h
+++ b/core/proto.h
@@ -38,3 +38,4 @@
                              int, float, int, bool);
 void lgtd_proto_power_on(struct lgtd_client *, const struct lgtd_proto_target_list *);
 void lgtd_proto_power_off(struct lgtd_client *, const struct lgtd_proto_target_list *);
+void lgtd_proto_list_tags(struct lgtd_client *);
diff --git a/docs/protocol.rst b/docs/protocol.rst
--- a/docs/protocol.rst
+++ b/docs/protocol.rst
@@ -60,8 +60,9 @@
                           end of the waveform, otherwise it will revert back to
                           its original state.
 
-.. function:: tag_list(tag)
+.. function:: list_tags()
 
-    Return an array of labels or adresses of the devices having the given tag.
+    Return a dictionnary with tags as keys and arrays of devices addresses or
+    labels as values.
 
 .. vim: set tw=80 spelllang=en spell:
diff --git a/lifx/CMakeLists.txt b/lifx/CMakeLists.txt
--- a/lifx/CMakeLists.txt
+++ b/lifx/CMakeLists.txt
@@ -10,6 +10,7 @@
     broadcast.c
     bulb.c
     gateway.c
+    tagging.c
     timer.c
     wire_proto.c
 )
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -38,6 +38,7 @@
 #include "gateway.h"
 #include "broadcast.h"
 #include "timer.h"
+#include "tagging.h"
 #include "core/jsmn.h"
 #include "core/jsonrpc.h"
 #include "core/client.h"
@@ -67,6 +68,16 @@
         lgtd_lifx_bulb_close(bulb);
     }
 
+    struct lgtd_lifx_gateway *it;
+    LIST_FOREACH(it, &lgtd_lifx_gateways, link) {
+        if (!memcmp(it->site, gw->site, sizeof(it->site))) {
+            break;
+        }
+    }
+    if (it == LIST_END(&lgtd_lifx_gateways)) {
+        lgtd_lifx_tagging_remove_site(gw->site);
+    }
+
     lgtd_info(
         "connection with gateway bulb [%s]:%hu closed", gw->ip_addr, gw->port
     );
@@ -125,11 +136,21 @@
 
     struct lgtd_lifx_packet_header hdr;
     union lgtd_lifx_target target = { .addr = gw->site };
+    lgtd_debug(
+        "GET_LIGHT_STATE+GET_TAG_LABELS --> [%s]:%hu", gw->ip_addr, gw->port
+    );
+
     lgtd_lifx_wire_setup_header(
         &hdr, LGTD_LIFX_TARGET_SITE, target, gw->site, LGTD_LIFX_GET_LIGHT_STATE
     );
-    lgtd_debug("GET_LIGHT_STATE --> [%s]:%hu", gw->ip_addr, gw->port);
     lgtd_lifx_gateway_send_packet(gw, &hdr, NULL, 0);
+
+    struct lgtd_lifx_packet_get_tag_labels pkt = { .tags = LGTD_LIFX_ALL_TAGS };
+    lgtd_lifx_wire_setup_header(
+        &hdr, LGTD_LIFX_TARGET_SITE, target, gw->site, LGTD_LIFX_GET_TAG_LABELS
+    );
+    lgtd_lifx_gateway_send_packet(gw, &hdr, &pkt, sizeof(pkt));
+
     gw->pending_refresh_req = true;
 }
 
@@ -225,6 +246,13 @@
         goto error_allocate;
     }
 
+    if (!lgtd_lifx_tagging_add_site(gw->site)) {
+        lgtd_warn(
+            "can't allocate a new tag table for site %s", lgtd_addrtoa(gw->site)
+        );
+        goto error_allocate;
+    }
+
     lgtd_info(
         "gateway for site %s at [%s]:%hu",
         lgtd_addrtoa(gw->site), gw->ip_addr, gw->port
@@ -409,3 +437,16 @@
 
     lgtd_lifx_bulb_set_power_state(b, pkt->power);
 }
+
+void lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *gw,
+                                         const struct lgtd_lifx_packet_header *hdr,
+                                         const struct lgtd_lifx_packet_tag_labels *pkt)
+{
+    assert(gw && hdr && pkt);
+
+    lgtd_debug(
+        "SET_TAG_LABELS <-- [%s]:%hu - %s label=%.*s, tags=%jx",
+        gw->ip_addr, gw->port, lgtd_addrtoa(hdr->target.device_addr),
+        (int)sizeof(pkt->label), pkt->label, (uintmax_t)pkt->tags
+    );
+}
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -77,3 +77,6 @@
 void lgtd_lifx_gateway_handle_power_state(struct lgtd_lifx_gateway *,
                                           const struct lgtd_lifx_packet_header *,
                                           const struct lgtd_lifx_packet_power_state *);
+void lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *,
+                                         const struct lgtd_lifx_packet_header *,
+                                         const struct lgtd_lifx_packet_tag_labels *);
diff --git a/lifx/tagging.c b/lifx/tagging.c
new file mode 100644
--- /dev/null
+++ b/lifx/tagging.c
@@ -0,0 +1,152 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <arpa/inet.h>
+#include <assert.h>
+#include <endian.h>
+#include <err.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <event2/util.h>
+
+#include "wire_proto.h"
+#include "tagging.h"
+#include "core/lightsd.h"
+
+static struct lgtd_lifx_site_tags_list lgtd_lifx_site_tags_map =
+    LIST_HEAD_INITIALIZER(&lgtd_lifx_site_tags_map);
+struct lgtd_lifx_label_site_tags_list lgtd_lifx_labels =
+    LIST_HEAD_INITIALIZER(&lgtd_lifx_labels);
+
+// Kim Walisch (2012)
+// http://chessprogramming.wikispaces.com/BitScan#DeBruijnMultiplation
+static inline int
+lgtd_lifx_tagging_bitscan64_forward(uint64_t n)
+{
+    enum { DEBRUIJN_NUMBER = 0x03f79d71b4cb0a89 };
+    static const int DEBRUIJN_SEQUENCE[64] = {
+        0, 47,  1, 56, 48, 27,  2, 60,
+       57, 49, 41, 37, 28, 16,  3, 61,
+       54, 58, 35, 52, 50, 42, 21, 44,
+       38, 32, 29, 23, 17, 11,  4, 62,
+       46, 55, 26, 59, 40, 36, 15, 53,
+       34, 51, 20, 43, 31, 22, 10, 45,
+       25, 39, 14, 33, 19, 30,  9, 24,
+       13, 18,  8, 12,  7,  6,  5, 63
+    };
+ 
+    return n ? DEBRUIJN_SEQUENCE[((n ^ (n - 1)) * DEBRUIJN_NUMBER) >> 58] : -1;
+}
+
+bool
+lgtd_lifx_tagging_add_site(const uint8_t *site)
+{
+    assert(site);
+
+    struct lgtd_lifx_site_tags *site_map;
+    LIST_FOREACH(site_map, &lgtd_lifx_site_tags_map, link) {
+        if (!memcmp(site_map->site_id.as_array, site, LGTD_LIFX_ADDR_LENGTH)) {
+            return true; // site already exists
+        }
+    }
+
+    site_map = calloc(1, sizeof(*site_map));
+    memcpy(site_map->site_id.as_array, site, LGTD_LIFX_ADDR_LENGTH);
+    LIST_INSERT_HEAD(&lgtd_lifx_site_tags_map, site_map, link);
+
+    return true;
+}
+
+void
+lgtd_lifx_tagging_remove_site(const uint8_t *site)
+{
+    assert(site);
+
+    struct lgtd_lifx_site_tags *site_map, *next_site_map;
+    LIST_FOREACH_SAFE(site_map, &lgtd_lifx_site_tags_map, link, next_site_map) {
+        if (!memcmp(site_map->site_id.as_array, site, LGTD_LIFX_ADDR_LENGTH)) {
+            LIST_REMOVE(site_map, link);
+            free(site_map);
+            return;
+        }
+    }
+
+#ifndef NDEBUG
+    assert(site_map != LIST_END(&lgtd_lifx_site_tags_map));
+#else
+    lgtd_warnx(
+        "tried to remove unknown site %s from the tags list", lgtd_addrtoa(site)
+    );
+#endif
+}
+
+void
+lgtd_lifx_tagging_update(const uint8_t *site, const char *label, uint64be_t tags)
+{
+    assert(site);
+    assert(label);
+
+    struct lgtd_lifx_site_tags *site_map;
+    LIST_FOREACH(site_map, &lgtd_lifx_site_tags_map, link) {
+        if (!memcmp(site_map->site_id.as_array, site, LGTD_LIFX_ADDR_LENGTH)) {
+            break;
+        }
+    }
+
+#ifndef NDEBUG
+    assert(site_map != LIST_END(&lgtd_lifx_site_tags_map));
+#else
+    if (site_map == LIST_END(&lgtd_lifx_site_tags_map)) {
+        lgtd_warnx(
+            "tried to add tag %s on unknown site %s", label, lgtd_addrtoa(site)
+        );
+        return;
+    }
+#endif
+
+    while (true) {
+        int i = lgtd_lifx_tagging_bitscan64_forward(tags);
+        if (i == -1) {
+            break;
+        }
+        // NOTE: should we return an error if the label is too big? and/or
+        // print a warning:
+        int n = LGTD_MIN(LGTD_LIFX_LABEL_SIZE - 1, strlen(label));
+        if (memcmp(site_map->labels[i][n], label, n)) {
+            if (n) {
+                memcpy(site_map->labels[i], label, n);
+                lgtd_info(
+                    "adding tag %s (id %d) on site %s",
+                    label, i, lgtd_addrtoa(site)
+                );
+            } else {
+                lgtd_info(
+                    "removing tag %s (id %d) on site %s",
+                    site_map->labels[i], i, lgtd_addrtoa(site)
+                );
+            }
+            site_map->labels[i][n] = '\0';
+        }
+        tags &= ~(1 << i);
+    };
+}
diff --git a/lifx/tagging.h b/lifx/tagging.h
new file mode 100644
--- /dev/null
+++ b/lifx/tagging.h
@@ -0,0 +1,45 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#pragma once
+
+struct lgtd_lifx_site_tags {
+    LIST_ENTRY(lgtd_lifx_site_tags) link;
+    union {
+        uint8_t                     as_array[LGTD_LIFX_ADDR_LENGTH];
+        uint64_t                    as_integer;
+    }                               site_id;
+    // TODO?: uint64_t              tag_ids;
+    char                            labels[64][LGTD_LIFX_LABEL_SIZE];
+};
+LIST_HEAD(lgtd_lifx_site_tags_list, lgtd_lifx_site_tags);
+
+struct lgtd_lifx_label_site_tags {
+    LIST_ENTRY(lgtd_lifx_label_site_tags)   link;
+    const char                              label[LGTD_LIFX_LABEL_SIZE];
+    int                                     label_len;
+    const struct lgtd_lifx_site_tags        *site_tags;
+};
+LIST_HEAD(lgtd_lifx_label_site_tags_list, lgtd_lifx_label_site_tags);
+
+extern struct lgtd_lifx_label_site_tags_list lgtd_lifx_labels;
+
+bool lgtd_lifx_tagging_add_site(const uint8_t *site);
+void lgtd_lifx_tagging_remove_site(const uint8_t *site);
+
+// XXX: tout porte a croire que tags doit etre convertit depuis little endian:
+void lgtd_lifx_tagging_update(const uint8_t *, const char *, uint64be_t);
diff --git a/lifx/wire_proto.c b/lifx/wire_proto.c
--- a/lifx/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -136,6 +136,21 @@
             .type = LGTD_LIFX_SET_WAVEFORM,
             .size = sizeof(struct lgtd_lifx_packet_waveform),
             .encode = ENCODER(lgtd_lifx_wire_encode_waveform)
+        },
+        {
+            REQUEST_ONLY,
+            .name = "GET_TAG_LABELS",
+            .type = LGTD_LIFX_GET_TAG_LABELS,
+            .size = sizeof(struct lgtd_lifx_packet_get_tag_labels),
+            .encode = lgtd_lifx_wire_null_packet_encoder_decoder
+        },
+        {
+            RESPONSE_ONLY,
+            .name = "TAG_LABELS",
+            .type = LGTD_LIFX_TAG_LABELS,
+            .size = sizeof(struct lgtd_lifx_packet_tag_labels),
+            .decode = lgtd_lifx_wire_null_packet_encoder_decoder,
+            .handle = HANDLER(lgtd_lifx_gateway_handle_tag_labels)
         }
     };
 
diff --git a/lifx/wire_proto.h b/lifx/wire_proto.h
--- a/lifx/wire_proto.h
+++ b/lifx/wire_proto.h
@@ -198,6 +198,16 @@
     uint8_t     waveform; // see enum lgtd_lifx_waveform_type
 };
 
+enum { LGTD_LIFX_ALL_TAGS = ~0 };
+struct lgtd_lifx_packet_get_tag_labels {
+    uint64be_t  tags;
+};
+
+struct lgtd_lifx_packet_tag_labels {
+    uint64be_t  tags;
+    char        label[LGTD_LIFX_LABEL_SIZE];
+};
+
 #pragma pack(pop)
 
 struct lgtd_lifx_waveform_string_id {
diff --git a/tests/core/jsonrpc/test_jsonrpc_utils.h b/tests/core/jsonrpc/test_jsonrpc_utils.h
--- a/tests/core/jsonrpc/test_jsonrpc_utils.h
+++ b/tests/core/jsonrpc/test_jsonrpc_utils.h
@@ -36,6 +36,12 @@
     assert(targets);
 }
 
+void
+lgtd_proto_list_tags(struct lgtd_client *client)
+{
+    assert(client);
+}
+
 #ifndef LGTD_TESTING_SET_LIGHT_FROM_HSBK
 void
 lgtd_proto_set_light_from_hsbk(struct lgtd_client *client,
diff --git a/tests/core/tests_shims.c b/tests/core/tests_shims.c
--- a/tests/core/tests_shims.c
+++ b/tests/core/tests_shims.c
@@ -56,3 +56,12 @@
     (void)hdr;
     (void)pkt;
 }
+
+void lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *gw,
+                                         const struct lgtd_lifx_packet_header *hdr,
+                                         const struct lgtd_lifx_packet_tag_labels *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
