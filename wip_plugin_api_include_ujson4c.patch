# HG changeset patch
# Parent 9ed6608d7df6bf420d9259d385d5c6663742dbbb

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -33,7 +33,9 @@
     ${LIFXD_BINARY_DIR}/compat
     ${LIFXD_SOURCE_DIR}/core
     ${LIFXD_BINARY_DIR}/core
+    ${LIFXD_SOURCE_DIR}/vendors/ujson4c
 )
 
+ADD_SUBDIRECTORY(vendors)
 ADD_SUBDIRECTORY(core)
 ADD_SUBDIRECTORY(plugins)
diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -11,4 +11,4 @@
     wire_proto.c
 )
 
-TARGET_LINK_LIBRARIES(lifxd ${EVENT2_CORE_LIBRARY} bsd) # FIXME portability
+TARGET_LINK_LIBRARIES(lifxd ${EVENT2_CORE_LIBRARY} bsd ujson4c) # FIXME portability
diff --git a/plugins/CMakeLists.txt b/plugins/CMakeLists.txt
--- a/plugins/CMakeLists.txt
+++ b/plugins/CMakeLists.txt
@@ -5,7 +5,7 @@
 
 FUNCTION(ADD_PLUGIN NAME)
     ADD_EXECUTABLE(${NAME} ${ARGN})
-    TARGET_LINK_LIBRARIES(${NAME} plugin)
+    TARGET_LINK_LIBRARIES(${NAME} plugin ujson4c)
 ENDFUNCTION()
 
 ADD_PLUGIN(pulse pulse.c)
diff --git a/vendors/CMakeLists.txt b/vendors/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/vendors/CMakeLists.txt
@@ -0,0 +1,1 @@
+ADD_SUBDIRECTORY(ujson4c)
diff --git a/vendors/ujson4c/CMakeLists.txt b/vendors/ujson4c/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/vendors/ujson4c/CMakeLists.txt
@@ -0,0 +1,5 @@
+ADD_LIBRARY(
+    ujson4c
+    ujdecode.c
+    ultrajsondec.c
+)
diff --git a/vendors/ujson4c/LICENSE.txt b/vendors/ujson4c/LICENSE.txt
new file mode 100644
--- /dev/null
+++ b/vendors/ujson4c/LICENSE.txt
@@ -0,0 +1,31 @@
+ujson4c decoder helper 1.0
+Developed by ESN, an Electronic Arts Inc. studio. 
+Copyright (c) 2013, Electronic Arts Inc.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+* Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+* Neither the name of ESN, Electronic Arts Inc. nor the
+names of its contributors may be used to endorse or promote products
+derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL ELECTRONIC ARTS INC. BE LIABLE 
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+Uses UltraJSON library:
+Copyright (c) 2013, Electronic Arts Inc.
+All rights reserved.
+www.github.com/esnme/ultrajson
\ No newline at end of file
diff --git a/vendors/ujson4c/ujdecode.c b/vendors/ujson4c/ujdecode.c
new file mode 100644
--- /dev/null
+++ b/vendors/ujson4c/ujdecode.c
@@ -0,0 +1,836 @@
+/*
+ujson4c decoder helper 1.0
+Developed by ESN, an Electronic Arts Inc. studio. 
+Copyright (c) 2013, Electronic Arts Inc.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+* Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+* Neither the name of ESN, Electronic Arts Inc. nor the
+names of its contributors may be used to endorse or promote products
+derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL ELECTRONIC ARTS INC. BE LIABLE 
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+Uses UltraJSON library:
+Copyright (c) 2013, Electronic Arts Inc.
+All rights reserved.
+www.github.com/esnme/ultrajson
+*/
+
+#include "ujdecode.h"
+#include "ultrajson.h"
+#include <math.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+typedef struct __Item
+{
+	int type;
+} Item;
+
+typedef struct __StringItem
+{
+	Item item;
+	UJString str;
+} StringItem;
+
+typedef struct __KeyPair
+{
+	StringItem *name;
+	Item *value;
+	struct __KeyPair *next;
+} KeyPair;
+
+typedef struct __ObjectItem
+{
+	Item item;
+	KeyPair *head;
+	KeyPair *tail;
+} ObjectItem;
+
+typedef struct __ArrayEntry
+{
+	Item *item;
+	struct __ArrayEntry *next;
+} ArrayEntry;
+
+typedef struct __ArrayItem
+{
+	Item item;
+	ArrayEntry *head;
+	ArrayEntry *tail;
+} ArrayItem; 
+
+typedef struct __LongValue
+{
+	Item item;
+	long value;
+} LongValue;
+
+typedef struct __LongLongValue
+{
+	Item item;
+	long long value;
+} LongLongValue;
+
+typedef struct __DoubleValue
+{
+	Item item;
+	double value;
+} DoubleValue;
+
+typedef struct __NullValue
+{
+	Item item;
+} NullValue;
+
+typedef struct __FalseValue
+{
+	Item item;
+} FalseValue;
+
+typedef struct __TrueValue
+{
+	Item item;
+} TrueValue;
+
+typedef struct __HeapSlab
+{
+	unsigned char *start;
+	unsigned char *offset;
+	unsigned char *end;
+	size_t size;
+	char owned;
+	struct __HeapSlab *next;
+} HeapSlab;
+
+struct DecoderState
+{
+	HeapSlab *heap;
+	const char *error;
+	void *(*malloc)(size_t cbSize);
+	void (*free)(void *ptr);
+};
+
+
+static void *alloc(struct DecoderState *ds, size_t cbSize)
+{
+	unsigned char *ret;
+
+	if (ds->heap->offset + cbSize > ds->heap->end)
+	{
+		size_t newSize = ds->heap->size * 2;
+		HeapSlab *newSlab;
+
+		while (newSize < (cbSize + sizeof (HeapSlab)))
+			newSize *= 2;
+
+		newSlab = (HeapSlab *) ds->malloc(newSize);
+		newSlab->start = (unsigned char *) (newSlab + 1);
+		newSlab->end = (unsigned char *) newSlab + newSize;
+		newSlab->size = newSize;
+		newSlab->offset = newSlab->start;
+		newSlab->owned = 1;
+
+		newSlab->next = ds->heap;
+		ds->heap = newSlab;
+	}
+
+
+	ret = ds->heap->offset;
+	ds->heap->offset += cbSize;
+
+	return ret;
+}
+
+static JSOBJ newString(void* context, wchar_t *start, wchar_t *end)
+{
+	struct DecoderState *ds = context;
+	size_t len;
+	StringItem *si = (StringItem *) alloc(ds, sizeof(StringItem) + (end - start + 1) * sizeof(wchar_t));
+	len = end - start;
+
+	si->item.type = UJT_String;
+	si->str.ptr = (wchar_t *) (si + 1);
+	si->str.cchLen = len;
+
+	if (len < 4)
+	{
+		wchar_t *dst = si->str.ptr;
+		wchar_t *end = dst + len;
+
+		while (dst < end)
+		{
+			*(dst++) = *(start++);
+		}
+	}
+	else
+	{
+		memcpy (si->str.ptr, start, len * sizeof(wchar_t));
+	}
+	si->str.ptr[len] = '\0';
+	return (JSOBJ) si;
+}
+
+static void objectAddKey(void* context, JSOBJ obj, JSOBJ name, JSOBJ value)
+{
+	struct DecoderState *ds = context;
+	ObjectItem *oi = (ObjectItem *) obj;
+	KeyPair *kp = (KeyPair *) alloc(ds, sizeof(KeyPair));
+
+	kp->next = NULL;
+
+	kp->name = (StringItem *) name;
+	kp->value = (Item *) value;
+
+	if (oi->tail)
+	{
+		oi->tail->next = kp;
+	}
+	else
+	{
+		oi->head = kp;
+	}
+	oi->tail = kp;
+}
+
+static void arrayAddItem(void* context, JSOBJ obj, JSOBJ value)
+{
+	struct DecoderState *ds = context;
+	ArrayItem *ai = (ArrayItem *) obj;
+	ArrayEntry *ae = (ArrayEntry *) alloc(ds, sizeof(ArrayEntry));
+
+	ae->next = NULL;
+	ae->item = (Item *) value;
+
+	if (ai->tail)
+	{
+		ai->tail->next = ae;
+	}
+	else
+	{
+		ai->head = ae;
+	}
+	ai->tail = ae;
+
+}
+
+static JSOBJ newTrue(void* context)
+{
+	struct DecoderState *ds = context;
+	TrueValue *tv = (TrueValue *) alloc(ds, sizeof(TrueValue *));
+	tv->item.type = UJT_True;
+	return (JSOBJ) tv;
+}
+
+static JSOBJ newFalse(void *context)
+{
+	struct DecoderState *ds = context;
+	FalseValue *fv = (FalseValue *) alloc(ds, sizeof(FalseValue *));
+	fv->item.type = UJT_False;
+	return (JSOBJ) fv;
+}
+
+static JSOBJ newNull(void *context)
+{
+	struct DecoderState *ds = context;
+	NullValue *nv = (NullValue *) alloc(ds, sizeof(NullValue *));
+	nv->item.type = UJT_Null;
+	return (JSOBJ) nv;
+}
+
+static JSOBJ newObject(void *context)
+{
+	struct DecoderState *ds = context;
+	ObjectItem *oi = (ObjectItem *) alloc(ds, sizeof(ObjectItem));
+	oi->item.type = UJT_Object;
+	oi->head = NULL;
+	oi->tail = NULL;
+
+	return (JSOBJ) oi;
+}
+
+static JSOBJ newArray(void *context)
+{
+	struct DecoderState *ds = context;
+	ArrayItem *ai = (ArrayItem *) alloc(ds, sizeof(ArrayItem));
+	ai->head = NULL;
+	ai->tail = NULL;
+	ai->item.type = UJT_Array;
+	return (JSOBJ) ai;
+}
+
+static JSOBJ newInt(void *context, JSINT32 value)
+{
+	struct DecoderState *ds = context;
+	LongValue *lv = (LongValue *) alloc(ds, sizeof(LongValue));
+	lv->item.type = UJT_Long;
+	lv->value = (long) value;
+	return (JSOBJ) lv;
+}
+
+static JSOBJ newLong(void *context, JSINT64 value)
+{
+	struct DecoderState *ds = context;
+	LongLongValue *llv = (LongLongValue *) alloc(ds, sizeof(LongLongValue));
+	llv->item.type = UJT_LongLong;
+	llv->value = (long long) value;
+	return (JSOBJ) llv;
+}
+
+static JSOBJ newDouble(void *context, double value)
+{
+	struct DecoderState *ds = context;
+	DoubleValue *dv = (DoubleValue *) alloc(ds, sizeof(DoubleValue));
+	dv->item.type = UJT_Double;
+	dv->value = (double) value;
+	return (JSOBJ) dv;
+}
+
+static void releaseObject(void *context, JSOBJ obj)
+{
+	struct DecoderState *ds = context;
+	//NOTE: Fix for C4100 warning in L4 MSVC
+	ds = NULL;
+	obj = NULL;
+}
+
+static double GetDouble(UJObject obj)
+{
+	return ((DoubleValue *) obj)->value;
+}
+
+static long GetLong(UJObject obj)
+{
+	return ((LongValue *) obj)->value;
+}
+
+static long long GetLongLong(UJObject obj)
+{
+	return ((LongLongValue *) obj)->value;
+}
+
+void UJFree(void *state)
+{
+	struct DecoderState *ds = (struct DecoderState *) state;
+
+	HeapSlab *slab = ds->heap;
+	HeapSlab *next;
+	while (slab)
+	{
+		next = slab->next;
+
+		if (slab->owned)
+		{
+			ds->free(slab);
+		}
+
+		slab = next;
+	}
+}
+
+int UJIsNull(UJObject obj)
+{
+	if (((Item *) obj)->type == UJT_Null)
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+int UJIsTrue(UJObject obj)
+{
+	if (((Item *) obj)->type == UJT_True)
+	{
+		return 1;
+	}
+	
+	return 0;
+}
+
+int UJIsFalse(UJObject obj)
+{
+	if (((Item *) obj)->type == UJT_False)
+	{
+		return 1;
+	}
+	
+
+	return 0;
+}
+
+int UJIsLong(UJObject obj)
+{
+	if (((Item *) obj)->type == UJT_Long)
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+int UJIsLongLong(UJObject obj)
+{
+	if (((Item *) obj)->type == UJT_LongLong)
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+int UJIsInteger(UJObject *obj)
+{
+	if (((Item *) obj)->type == UJT_LongLong ||
+		((Item *) obj)->type == UJT_Long)
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+int UJIsDouble(UJObject obj)
+{
+	if (((Item *) obj)->type == UJT_Double)
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+int UJIsString(UJObject obj)
+{
+	if (((Item *) obj)->type == UJT_String)
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+int UJIsArray(UJObject obj)
+{
+	if (((Item *) obj)->type == UJT_Array)
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+int UJIsObject(UJObject obj)
+{
+	if (((Item *) obj)->type == UJT_Object)
+	{
+		return 1;
+	}
+
+	return 0;
+}
+
+void *UJBeginArray(UJObject arrObj)
+{
+	switch ( ((Item *) arrObj)->type)
+	{
+	case UJT_Array: return ((ObjectItem *) arrObj)->head;
+	default: break;
+	}
+
+	return NULL;
+}
+
+int UJIterArray(void **iter, UJObject *outObj)
+{
+	ArrayEntry *ae = (ArrayEntry *) *iter;
+
+	if (ae == NULL)
+	{
+		return 0;
+	}
+
+	*iter = ae->next;
+	*outObj = ae->item;
+
+	return 1;
+}
+
+void *UJBeginObject(UJObject objObj)
+{
+	switch ( ((Item *) objObj)->type)
+	{
+	case UJT_Object: return ((ObjectItem *) objObj)->head;
+	default: break;
+	}
+
+	return NULL;
+}
+
+int UJIterObject(void **iter, UJString *outKey, UJObject *outValue)
+{
+	KeyPair *kp;
+
+	if (*iter == NULL)
+	{
+		return 0;
+	}
+
+	kp = (KeyPair *) *iter;
+
+	if (kp == NULL)
+	{
+		return 0;
+	}
+
+	*outKey = ((StringItem *) kp->name)->str;
+	*outValue = kp->value;
+	*iter = kp->next;
+	return 1;
+}
+
+long long UJNumericLongLong(UJObject obj)
+{
+	switch ( ((Item *) obj)->type)
+	{
+	case UJT_Long: return (long long) GetLong(obj);
+	case UJT_LongLong: return (long long) GetLongLong(obj);
+	case UJT_Double: return (long long) GetDouble(obj);
+	default: break;
+	}
+
+	return 0;
+}
+
+int UJNumericInt(UJObject obj)
+{
+	switch ( ((Item *) obj)->type)
+	{
+	case UJT_Long: return (int) GetLong(obj);
+	case UJT_LongLong: return (int) GetLongLong(obj);
+	case UJT_Double: return (int) GetDouble(obj);
+	default: break;
+	}
+
+	return 0;
+}
+
+double UJNumericFloat(UJObject obj)
+{
+	switch ( ((Item *) obj)->type)
+	{
+	case UJT_Long: return (double) GetLong(obj);
+	case UJT_LongLong: return (double) GetLongLong(obj);
+	case UJT_Double: return (double) GetDouble(obj);
+	default: break;
+	}
+
+	return 0.0;
+}
+
+const wchar_t *UJReadString(UJObject obj, size_t *cchOutBuffer)
+{
+	switch ( ((Item *) obj)->type)
+	{
+	case UJT_String:
+		if (cchOutBuffer)
+			*cchOutBuffer = ( (StringItem *) obj)->str.cchLen;
+		return ( (StringItem *) obj)->str.ptr;
+
+	default:
+		break;
+	}
+
+	if (cchOutBuffer)
+		*cchOutBuffer = 0;
+	return L"";
+}
+
+const char *UJGetError(void *state)
+{
+	if (state == NULL)
+		return NULL;
+
+	return ( (struct DecoderState *) state)->error;
+}
+
+int UJGetType(UJObject obj)
+{
+	return ((Item *) obj)->type;
+}
+
+static int checkType(int ki, const char *format, UJObject obj)
+{
+	int c = (unsigned char) format[ki];
+	int type = UJGetType(obj);
+	int allowNull = 0;
+
+	switch (c)
+	{
+	case 'b':
+		allowNull = 1;
+	case 'B':
+		switch (type)
+		{
+			case UJT_Null:
+				if (!allowNull)
+					return 0;
+			case UJT_True:
+			case UJT_False:
+				return 1;
+
+			default:
+				return 0;
+		}
+		break;
+
+	case 'n':
+		allowNull = 1;
+	case 'N':
+		switch (type)
+		{
+			case UJT_Null:
+				if (!allowNull)
+					return 0;
+			case UJT_Long:
+			case UJT_LongLong:
+			case UJT_Double:
+				return 1;
+
+			default:
+				return 0;
+		}
+		break;
+
+	case 's':
+		allowNull = 1;
+	case 'S':
+		switch (type)
+		{
+			case UJT_Null:
+				if (!allowNull)
+					return 0;
+			case UJT_String:
+				return 1;
+
+			default:
+				return 0;
+		}
+		break;
+
+	case 'a':
+		allowNull = 1;
+	case 'A':
+		switch (type)
+		{
+			case UJT_Null:
+				if (!allowNull)
+					return 0;
+			case UJT_Array:
+				return 1;
+
+			default:
+				return 0;
+		}
+		break;
+
+	case 'o':
+		allowNull = 1;
+	case 'O':
+		switch (type)
+		{
+			case UJT_Null:
+				if (!allowNull)
+					return 0;
+			case UJT_Object:
+				return 1;
+			default:
+				return 0;
+		}
+
+		break;
+
+	case 'u':
+		allowNull = 1;
+	case 'U':
+		return 1;
+		break;
+	}
+
+	return 0;
+}
+
+int UJObjectUnpack(UJObject objObj, int keys, const char *format, const wchar_t **_keyNames, ...)
+{
+	void *iter;
+	UJString key;
+	UJObject value;
+	int found = 0;
+	int ki;
+	int ks = 0;
+	const wchar_t *keyNames[64];
+  va_list args;
+  UJObject *outValue;
+
+  va_start(args, _keyNames);
+
+  if (!UJIsObject(objObj))
+	{
+		return 0;
+	}
+  
+	iter = UJBeginObject(objObj);
+
+	if (keys > 64)
+	{
+		return -1;
+	}
+
+	for (ki = 0; ki < keys; ki ++)
+	{
+		keyNames[ki] = _keyNames[ki];
+	}
+	
+	while (UJIterObject(&iter, &key, &value))
+	{
+		for (ki = ks; ki < keys; ki ++)
+		{
+			const wchar_t *kn = keyNames[ki];
+
+			if (kn == NULL)
+			{
+				continue;
+			}
+
+			if (wcscmp(key.ptr, kn) != 0)
+			{
+				continue;
+			}
+
+			if (!checkType(ki, format, value))
+			{
+				continue;
+			}
+
+			found ++;
+
+      outValue = va_arg(args, UJObject);
+
+      if (outValue != NULL)
+      {
+  			*outValue = value;
+      }
+			keyNames[ki] = NULL;
+
+			if (ki == ks)
+			{
+				ks ++;
+			}
+		}
+	}
+
+  va_end(args);
+
+	return found;
+}
+
+UJObject UJDecode(const char *input, size_t cbInput, UJHeapFuncs *hf, void **outState)
+{
+	UJObject ret;
+	struct DecoderState *ds;
+	void *initialHeap;
+	size_t cbInitialHeap;
+	HeapSlab *slab;
+
+	JSONObjectDecoder decoder = {
+		newString,
+		objectAddKey,
+		arrayAddItem,
+		newTrue,
+		newFalse,
+		newNull,
+		newObject,
+		newArray,
+		newInt,
+		newLong,
+		newDouble,
+		releaseObject,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		NULL,
+		0, 
+		NULL
+	};
+
+	if (hf == NULL)
+	{
+		decoder.malloc = malloc;
+		decoder.free = free;
+		decoder.realloc = realloc;
+		cbInitialHeap = 16384;
+		initialHeap = malloc(cbInitialHeap);
+	}
+	else
+	{
+		decoder.malloc = hf->malloc;
+		decoder.free = hf->free;
+		decoder.realloc = hf->realloc;
+		initialHeap = hf->initalHeap;
+		cbInitialHeap = hf->cbInitialHeap;
+	
+		if (cbInitialHeap < sizeof(HeapSlab) + sizeof(struct DecoderState))
+		{
+			return NULL;
+		}
+	}
+
+	*outState = NULL;
+
+	slab = (HeapSlab * ) initialHeap;
+	slab->start = (unsigned char *) (slab + 1);
+	slab->offset = slab->start;
+	slab->end = (unsigned char *) initialHeap + cbInitialHeap;
+	slab->size = cbInitialHeap;
+	slab->owned = hf == NULL ? 1 : 0;
+	slab->next = NULL;
+
+	ds = (struct DecoderState *) slab->offset;
+	slab->offset += sizeof(struct DecoderState);
+	*outState = (void *) ds;
+
+	ds->heap = slab;
+	
+	ds->malloc = decoder.malloc;
+	ds->free = decoder.free;
+	ds->error = NULL; 
+
+	decoder.prv = (void *) ds;
+
+	ret = (UJObject) JSON_DecodeObject(&decoder, input, cbInput);
+
+	if (ret == NULL)
+	{
+		ds->error = decoder.errorStr;
+	}
+
+	return ret;
+}
diff --git a/vendors/ujson4c/ujdecode.h b/vendors/ujson4c/ujdecode.h
new file mode 100644
--- /dev/null
+++ b/vendors/ujson4c/ujdecode.h
@@ -0,0 +1,261 @@
+/*
+ujson4c decoder helper 1.0
+Developed by ESN, an Electronic Arts Inc. studio. 
+Copyright (c) 2013, Electronic Arts Inc.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+* Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+* Neither the name of ESN, Electronic Arts Inc. nor the
+names of its contributors may be used to endorse or promote products
+derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL ELECTRONIC ARTS INC. BE LIABLE 
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+Uses UltraJSON library:
+Copyright (c) 2013, Electronic Arts Inc.
+All rights reserved.
+www.github.com/esnme/ultrajson
+*/
+
+#pragma once
+
+#ifdef __cplusplus 
+extern "C" {
+#endif
+
+	enum UJTypes
+	{
+		UJT_Null,
+		UJT_True,
+		UJT_False,
+		UJT_Long,
+		UJT_LongLong,
+		UJT_Double,
+		UJT_String,
+		UJT_Array,
+		UJT_Object
+	};
+
+#include <wchar.h>
+	typedef void * UJObject;
+
+	typedef struct __UJString
+	{
+		wchar_t *ptr;
+		size_t cchLen;
+	} UJString;
+
+	typedef struct __UJHeapFuncs
+	{
+		void *initalHeap;
+		size_t cbInitialHeap;
+		void *(*malloc)(size_t cbSize);
+		void (*free)(void *ptr);
+		void *(*realloc)(void *ptr, size_t cbSize);
+	} UJHeapFuncs;
+
+	/*
+	===============================================================================
+	Decodes an input text octet stream into a JSON object structure
+
+	Arguments:
+	input - JSON data to decode in ANSI or UTF-8 format
+	cbInput - Length of input in bytes
+	hf - Heap functions, see UJHeapFuncs. Optional may be NULL
+	outState - Outputs the decoder state.
+
+	Not about heap functions:
+	Declare a UJHeapFuncs structure on the stack if you want to manage your own heap
+	and pass it as the hf argument to UJDecode.
+	initalHeap    - Pointer to a buffer for the initial heap handled by the caller. 
+	Preferably stored on the stack. MUST not be smaller than 1024 bytes
+	cbInitialHeap - Size of the initial heap in bytes
+	malloc        - Pointer to malloc function  
+	free          - Pointer to free function
+	realloc       - Pointer to realloc function  
+
+	Returns a JSON object structure representation or NULL in case of error.
+	Use UJGetError get obtain error message.
+
+	Example usage:
+
+	const char *input;
+	size_t cbInput;
+	void *state;
+
+	obj = UJDecode(input, cbInput, NULL, &state);
+
+	if (obj == NULL)
+	printf ("Error: %s\n", UJGetError(state));
+
+	...Poke around in returned obj...
+
+	UJFree(state);
+	===============================================================================
+	*/
+	UJObject UJDecode(const char *input, size_t cbInput, UJHeapFuncs *hf, void **outState);
+
+	/*
+	===============================================================================
+	Called to free the decoder state
+	===============================================================================
+	*/
+	void UJFree(void *state);
+
+	/*
+	===============================================================================
+	Check if object is of certain type 
+	===============================================================================
+	*/
+	int UJIsNull(UJObject obj);
+	int UJIsTrue(UJObject obj);
+	int UJIsFalse(UJObject obj);
+	int UJIsLong(UJObject obj);
+	int UJIsLongLong(UJObject obj);
+	int UJIsInteger(UJObject *obj);
+	int UJIsDouble(UJObject obj);
+	int UJIsString(UJObject obj);
+	int UJIsArray(UJObject obj);
+	int UJIsObject(UJObject obj);
+
+	/*
+	===============================================================================
+	See UJTypes enum for possible return values
+	===============================================================================
+	*/
+	int UJGetType(UJObject obj);
+
+	/*
+	===============================================================================
+	Called to initiate the iterator of an array object
+	May return NULL in case array is empty
+	===============================================================================
+	*/
+	void *UJBeginArray(UJObject arrObj);
+
+	/*
+	===============================================================================
+	Iterates an array object
+
+	Arguments:
+	iter   - Anonymous iterator
+	outObj - Object in array
+
+	Usage:
+	Get initial iterator from call to UJBeginArray. 
+	Call this function until it returns 0
+	===============================================================================
+	*/
+	int UJIterArray(void **iter, UJObject *outObj);
+
+	/*
+	===============================================================================
+	Called to initiate the iterator of an Object (key-value structure)
+	May return NULL in case Object is empty
+
+	===============================================================================
+	*/
+	void *UJBeginObject(UJObject objObj);
+
+	/*
+	===============================================================================
+	Iterates an Object
+
+	Arguments:
+	iter     - Anonymous iterator
+	outKey   - Key name
+	outValue - Value object
+
+	Usage:
+	Get initial iterator from call to UJBeginObject
+	Call this function until it returns 0
+	===============================================================================
+	*/
+	int UJIterObject(void **iter, UJString *outKey, UJObject *outValue);
+
+	/*
+	===============================================================================
+	Unpacks an Object by matching the key name with the requested format 
+
+	Each key name needs to be matched by the character in the format string 
+	representing the desired type of the value for that key
+	B - Boolean 
+	N - Numeric 
+	S - String
+	A - Array
+	O - Object
+	U - Unknown/any
+
+	Use lower case to accept JSON Null in place of the expected value.
+
+	Arguments:
+	objObj     - The object to unpack (JSON Object)
+	keys       - Number of keys to match. Keys can not exceed 64.
+	format     - Specified the expected types for the key value. 
+	keyNames   - An array of key names
+	...        - Output value objects (as UJObject *)
+
+	Return value:
+	Returns number of key pairs matched or -1 on error
+	===============================================================================
+	*/
+	int UJObjectUnpack(UJObject objObj, int keys, const char *format, const wchar_t **keyNames, ...);
+
+	/*
+	===============================================================================
+	Returns the value of a double, long or long long value as a double. 
+	If value is not any of these 0.0 is returned.
+	===============================================================================
+	*/
+	double UJNumericFloat(UJObject obj);
+
+	/*
+	===============================================================================
+	Returns the value of a double, long or long long value as an integer.
+	If value is not any of these types 0 is returned.
+
+	Truncation may arrise from word sizes and the presence of decimals when 
+	converting doubles to integers.
+	===============================================================================
+	*/
+	long long UJNumericLongLong(UJObject obj);
+	int UJNumericInt(UJObject obj);
+
+	
+
+	/*
+	===============================================================================
+	Returns the value of a string value as a wide character string pointer. Caller must NOT free returned pointer.
+	cchOutBuffer contains the character length of the returned string. 
+
+	If the value is not a string an empty string is returned.
+	===============================================================================
+	*/
+	const wchar_t *UJReadString(UJObject obj, size_t *cchOutBuffer);
+
+	/*
+	===============================================================================
+	Returns last error message if any as a string or NULL. 
+	Caller must NOT free returned pointer.
+	===============================================================================
+	*/
+	const char *UJGetError(void *state);
+
+#ifdef __cplusplus 
+}
+#endif
diff --git a/vendors/ujson4c/ultrajson.h b/vendors/ujson4c/ultrajson.h
new file mode 100644
--- /dev/null
+++ b/vendors/ujson4c/ultrajson.h
@@ -0,0 +1,310 @@
+/*
+Copyright (c) 2011-2013, ESN Social Software AB and Jonas Tarnstrom
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the ESN Social Software AB nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL ESN SOCIAL SOFTWARE AB OR JONAS TARNSTROM BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+Portions of code from MODP_ASCII - Ascii transformations (upper/lower, etc)
+http://code.google.com/p/stringencoders/
+Copyright (c) 2007  Nick Galbreath -- nickg [at] modp [dot] com. All rights reserved.
+
+Numeric decoder derived from from TCL library
+http://www.opensource.apple.com/source/tcl/tcl-14/tcl/license.terms
+ * Copyright (c) 1988-1993 The Regents of the University of California.
+ * Copyright (c) 1994 Sun Microsystems, Inc.
+*/
+
+/*
+Ultra fast JSON encoder and decoder
+Developed by Jonas Tarnstrom (jonas@esn.me).
+
+Encoder notes:
+------------------
+
+:: Cyclic references ::
+Cyclic referenced objects are not detected.
+Set JSONObjectEncoder.recursionMax to suitable value or make sure input object
+tree doesn't have cyclic references.
+
+*/
+
+#ifndef __ULTRAJSON_H__
+#define __ULTRAJSON_H__
+
+#include <stdio.h>
+#include <wchar.h>
+
+// Don't output any extra whitespaces when encoding
+#define JSON_NO_EXTRA_WHITESPACE
+
+// Max decimals to encode double floating point numbers with
+#ifndef JSON_DOUBLE_MAX_DECIMALS
+#define JSON_DOUBLE_MAX_DECIMALS 15
+#endif
+
+// Max recursion depth, default for encoder
+#ifndef JSON_MAX_RECURSION_DEPTH
+#define JSON_MAX_RECURSION_DEPTH 1024
+#endif
+
+// Max recursion depth, default for decoder
+#ifndef JSON_MAX_OBJECT_DEPTH
+#define JSON_MAX_OBJECT_DEPTH 1024
+#endif
+
+/*
+Dictates and limits how much stack space for buffers UltraJSON will use before resorting to provided heap functions */
+#ifndef JSON_MAX_STACK_BUFFER_SIZE
+#define JSON_MAX_STACK_BUFFER_SIZE 131072
+#endif
+
+#ifdef _WIN32
+
+typedef __int64 JSINT64;
+typedef unsigned __int64 JSUINT64;
+
+typedef __int32 JSINT32;
+typedef unsigned __int32 JSUINT32;
+typedef unsigned __int8 JSUINT8;
+typedef unsigned __int16 JSUTF16;
+typedef unsigned __int32 JSUTF32;
+typedef __int64 JSLONG;
+
+#define EXPORTFUNCTION __declspec(dllexport)
+
+#define FASTCALL_MSVC __fastcall
+#define FASTCALL_ATTR
+#define INLINE_PREFIX __inline
+
+#else
+
+#include <stdint.h>
+typedef int64_t JSINT64;
+typedef uint64_t JSUINT64;
+
+typedef int32_t JSINT32;
+typedef uint32_t JSUINT32;
+
+#define FASTCALL_MSVC
+
+#if !defined __x86_64__
+#define FASTCALL_ATTR __attribute__((fastcall))
+#else
+#define FASTCALL_ATTR
+#endif
+
+#define INLINE_PREFIX inline
+
+typedef uint8_t JSUINT8;
+typedef uint16_t JSUTF16;
+typedef uint32_t JSUTF32;
+
+typedef int64_t JSLONG;
+
+#define EXPORTFUNCTION
+#endif
+
+#if !(defined(__LITTLE_ENDIAN__) || defined(__BIG_ENDIAN__))
+
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+#define __LITTLE_ENDIAN__
+#else
+
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+#define __BIG_ENDIAN__
+#endif
+
+#endif
+
+#endif
+
+#if !defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
+#error "Endianess not supported"
+#endif
+
+enum JSTYPES
+{
+  JT_NULL,        // NULL
+  JT_TRUE,        //boolean true
+  JT_FALSE,       //boolean false
+  JT_INT,         //(JSINT32 (signed 32-bit))
+  JT_LONG,        //(JSINT64 (signed 64-bit))
+  JT_DOUBLE,    //(double)
+  JT_UTF8,        //(char 8-bit)
+  JT_ARRAY,       // Array structure
+  JT_OBJECT,    // Key/Value structure
+  JT_INVALID,    // Internal, do not return nor expect
+};
+
+typedef void * JSOBJ;
+typedef void * JSITER;
+
+typedef struct __JSONTypeContext
+{
+  int type;
+  void *prv;
+} JSONTypeContext;
+
+/*
+Function pointer declarations, suitable for implementing UltraJSON */
+typedef void (*JSPFN_ITERBEGIN)(JSOBJ obj, JSONTypeContext *tc);
+typedef int (*JSPFN_ITERNEXT)(JSOBJ obj, JSONTypeContext *tc);
+typedef void (*JSPFN_ITEREND)(JSOBJ obj, JSONTypeContext *tc);
+typedef JSOBJ (*JSPFN_ITERGETVALUE)(JSOBJ obj, JSONTypeContext *tc);
+typedef char *(*JSPFN_ITERGETNAME)(JSOBJ obj, JSONTypeContext *tc, size_t *outLen);
+typedef void *(*JSPFN_MALLOC)(size_t size);
+typedef void (*JSPFN_FREE)(void *pptr);
+typedef void *(*JSPFN_REALLOC)(void *base, size_t size);
+
+typedef struct __JSONObjectEncoder
+{
+  void (*beginTypeContext)(JSOBJ obj, JSONTypeContext *tc);
+  void (*endTypeContext)(JSOBJ obj, JSONTypeContext *tc);
+  const char *(*getStringValue)(JSOBJ obj, JSONTypeContext *tc, size_t *_outLen);
+  JSINT64 (*getLongValue)(JSOBJ obj, JSONTypeContext *tc);
+  JSINT32 (*getIntValue)(JSOBJ obj, JSONTypeContext *tc);
+  double (*getDoubleValue)(JSOBJ obj, JSONTypeContext *tc);
+
+  /*
+  Begin iteration of an iteratable object (JS_ARRAY or JS_OBJECT)
+  Implementor should setup iteration state in ti->prv
+  */
+  JSPFN_ITERBEGIN iterBegin;
+
+  /*
+  Retrieve next object in an iteration. Should return 0 to indicate iteration has reached end or 1 if there are more items.
+  Implementor is responsible for keeping state of the iteration. Use ti->prv fields for this
+  */
+  JSPFN_ITERNEXT iterNext;
+
+  /*
+  Ends the iteration of an iteratable object.
+  Any iteration state stored in ti->prv can be freed here
+  */
+  JSPFN_ITEREND iterEnd;
+
+  /*
+  Returns a reference to the value object of an iterator
+  The is responsible for the life-cycle of the returned string. Use iterNext/iterEnd and ti->prv to keep track of current object
+  */
+  JSPFN_ITERGETVALUE iterGetValue;
+
+  /*
+  Return name of iterator.
+  The is responsible for the life-cycle of the returned string. Use iterNext/iterEnd and ti->prv to keep track of current object
+  */
+  JSPFN_ITERGETNAME iterGetName;
+
+  /*
+  Release a value as indicated by setting ti->release = 1 in the previous getValue call.
+  The ti->prv array should contain the necessary context to release the value
+  */
+  void (*releaseObject)(JSOBJ obj);
+
+  /* Library functions
+  Set to NULL to use STDLIB malloc,realloc,free */
+  JSPFN_MALLOC malloc;
+  JSPFN_REALLOC realloc;
+  JSPFN_FREE free;
+
+  /*
+  Configuration for max recursion, set to 0 to use default (see JSON_MAX_RECURSION_DEPTH)*/
+  int recursionMax;
+
+  /*
+  Configuration for max decimals of double floating poiunt numbers to encode (0-9) */
+  int doublePrecision;
+
+  /*
+  If true output will be ASCII with all characters above 127 encoded as \uXXXX. If false output will be UTF-8 or what ever charset strings are brought as */
+  int forceASCII;
+
+  /*
+  If true, '<', '>', and '&' characters will be encoded as \u003c, \u003e, and \u0026, respectively. If false, no special encoding will be used. */
+  int encodeHTMLChars;
+
+  /*
+  Set to an error message if error occured */
+  const char *errorMsg;
+  JSOBJ errorObj;
+
+  /* Buffer stuff */
+  char *start;
+  char *offset;
+  char *end;
+  int heap;
+  int level;
+
+} JSONObjectEncoder;
+
+
+/*
+Encode an object structure into JSON.
+
+Arguments:
+obj - An anonymous type representing the object
+enc - Function definitions for querying JSOBJ type
+buffer - Preallocated buffer to store result in. If NULL function allocates own buffer
+cbBuffer - Length of buffer (ignored if buffer is NULL)
+
+Returns:
+Encoded JSON object as a null terminated char string.
+
+NOTE:
+If the supplied buffer wasn't enough to hold the result the function will allocate a new buffer.
+Life cycle of the provided buffer must still be handled by caller.
+
+If the return value doesn't equal the specified buffer caller must release the memory using
+JSONObjectEncoder.free or free() as specified when calling this function.
+*/
+EXPORTFUNCTION char *JSON_EncodeObject(JSOBJ obj, JSONObjectEncoder *enc, char *buffer, size_t cbBuffer);
+
+
+
+typedef struct __JSONObjectDecoder
+{
+  JSOBJ (*newString)(void *prv, wchar_t *start, wchar_t *end);
+  void (*objectAddKey)(void *prv, JSOBJ obj, JSOBJ name, JSOBJ value);
+  void (*arrayAddItem)(void *prv, JSOBJ obj, JSOBJ value);
+  JSOBJ (*newTrue)(void *prv);
+  JSOBJ (*newFalse)(void *prv);
+  JSOBJ (*newNull)(void *prv);
+  JSOBJ (*newObject)(void *prv);
+  JSOBJ (*newArray)(void *prv);
+  JSOBJ (*newInt)(void *prv, JSINT32 value);
+  JSOBJ (*newLong)(void *prv, JSINT64 value);
+  JSOBJ (*newDouble)(void *prv, double value);
+  void (*releaseObject)(void *prv, JSOBJ obj);
+  JSPFN_MALLOC malloc;
+  JSPFN_FREE free;
+  JSPFN_REALLOC realloc;
+  char *errorStr;
+  char *errorOffset;
+  int preciseFloat;
+  void *prv;
+} JSONObjectDecoder;
+
+EXPORTFUNCTION JSOBJ JSON_DecodeObject(JSONObjectDecoder *dec, const char *buffer, size_t cbBuffer);
+
+#endif
diff --git a/vendors/ujson4c/ultrajsondec.c b/vendors/ujson4c/ultrajsondec.c
new file mode 100644
--- /dev/null
+++ b/vendors/ujson4c/ultrajsondec.c
@@ -0,0 +1,891 @@
+/*
+Copyright (c) 2011-2013, ESN Social Software AB and Jonas Tarnstrom
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+* Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+* Neither the name of the ESN Social Software AB nor the
+names of its contributors may be used to endorse or promote products
+derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL ESN SOCIAL SOFTWARE AB OR JONAS TARNSTROM BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+Portions of code from MODP_ASCII - Ascii transformations (upper/lower, etc)
+http://code.google.com/p/stringencoders/
+Copyright (c) 2007  Nick Galbreath -- nickg [at] modp [dot] com. All rights reserved.
+
+Numeric decoder derived from from TCL library
+http://www.opensource.apple.com/source/tcl/tcl-14/tcl/license.terms
+* Copyright (c) 1988-1993 The Regents of the University of California.
+* Copyright (c) 1994 Sun Microsystems, Inc.
+*/
+
+#include "ultrajson.h"
+#include <math.h>
+#include <assert.h>
+#include <string.h>
+#include <limits.h>
+#include <wchar.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#ifndef TRUE
+#define TRUE 1
+#define FALSE 0
+#endif
+#ifndef NULL
+#define NULL 0
+#endif
+
+struct DecoderState
+{
+  char *start;
+  char *end;
+  wchar_t *escStart;
+  wchar_t *escEnd;
+  int escHeap;
+  int lastType;
+  JSUINT32 objDepth;
+  void *prv;
+  JSONObjectDecoder *dec;
+};
+
+JSOBJ FASTCALL_MSVC decode_any( struct DecoderState *ds) FASTCALL_ATTR;
+typedef JSOBJ (*PFN_DECODER)( struct DecoderState *ds);
+
+static JSOBJ SetError( struct DecoderState *ds, int offset, const char *message)
+{
+  ds->dec->errorOffset = ds->start + offset;
+  ds->dec->errorStr = (char *) message;
+  return NULL;
+}
+
+double createDouble(double intNeg, double intValue, double frcValue, int frcDecimalCount)
+{
+  static const double g_pow10[] = {1.0, 0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001,0.0000001, 0.00000001, 0.000000001, 0.0000000001, 0.00000000001, 0.000000000001, 0.0000000000001, 0.00000000000001, 0.000000000000001};
+  return (intValue + (frcValue * g_pow10[frcDecimalCount])) * intNeg;
+}
+
+FASTCALL_ATTR JSOBJ FASTCALL_MSVC decodePreciseFloat(struct DecoderState *ds)
+{
+  char *end;
+  double value;
+  errno = 0;
+
+  value = strtod(ds->start, &end);
+
+  if (errno == ERANGE)
+  {
+    return SetError(ds, -1, "Range error when decoding numeric as double");
+  }
+
+  ds->start = end;
+  return ds->dec->newDouble(ds->prv, value);
+}
+
+FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_numeric (struct DecoderState *ds)
+{
+  int intNeg = 1;
+  int mantSize = 0;
+  JSUINT64 intValue;
+  int chr;
+  int decimalCount = 0;
+  double frcValue = 0.0;
+  double expNeg;
+  double expValue;
+  char *offset = ds->start;
+
+  JSUINT64 overflowLimit = LLONG_MAX;
+
+  if (*(offset) == '-')
+  {
+    offset ++;
+    intNeg = -1;
+    overflowLimit = LLONG_MIN;
+  }
+
+  // Scan integer part
+  intValue = 0;
+
+  while (1)
+  {
+    chr = (int) (unsigned char) *(offset);
+
+    switch (chr)
+    {
+      case '0':
+      case '1':
+      case '2':
+      case '3':
+      case '4':
+      case '5':
+      case '6':
+      case '7':
+      case '8':
+      case '9':
+      {
+        //FIXME: Check for arithemtic overflow here
+        //PERF: Don't do 64-bit arithmetic here unless we know we have to
+        intValue = intValue * 10ULL + (JSLONG) (chr - 48);
+
+        if (intValue > overflowLimit)
+        {
+          return SetError(ds, -1, overflowLimit == LLONG_MAX ? "Value is too big" : "Value is too small");
+        }
+
+        offset ++;
+        mantSize ++;
+        break;
+      }
+      case '.':
+      {
+        offset ++;
+        goto DECODE_FRACTION;
+        break;
+      }
+      case 'e':
+      case 'E':
+      {
+        offset ++;
+        goto DECODE_EXPONENT;
+        break;
+      }
+
+      default:
+      {
+        goto BREAK_INT_LOOP;
+        break;
+      }
+    }
+  }
+
+BREAK_INT_LOOP:
+
+  ds->lastType = JT_INT;
+  ds->start = offset;
+
+  if ((intValue >> 31))
+  {
+    return ds->dec->newLong(ds->prv, (JSINT64) (intValue * (JSINT64) intNeg));
+  }
+  else
+  {
+    return ds->dec->newInt(ds->prv, (JSINT32) (intValue * intNeg));
+  }
+
+DECODE_FRACTION:
+
+  if (ds->dec->preciseFloat)
+  {
+    return decodePreciseFloat(ds);
+  }
+
+  // Scan fraction part
+  frcValue = 0.0;
+  for (;;)
+  {
+    chr = (int) (unsigned char) *(offset);
+
+    switch (chr)
+    {
+      case '0':
+      case '1':
+      case '2':
+      case '3':
+      case '4':
+      case '5':
+      case '6':
+      case '7':
+      case '8':
+      case '9':
+      {
+        if (decimalCount < JSON_DOUBLE_MAX_DECIMALS)
+        {
+          frcValue = frcValue * 10.0 + (double) (chr - 48);
+          decimalCount ++;
+        }
+        offset ++;
+        break;
+      }
+      case 'e':
+      case 'E':
+      {
+        offset ++;
+        goto DECODE_EXPONENT;
+        break;
+      }
+      default:
+      {
+        goto BREAK_FRC_LOOP;
+      }
+    }
+  }
+
+BREAK_FRC_LOOP:
+  //FIXME: Check for arithemtic overflow here
+  ds->lastType = JT_DOUBLE;
+  ds->start = offset;
+  return ds->dec->newDouble (ds->prv, createDouble( (double) intNeg, (double) intValue, frcValue, decimalCount));
+
+DECODE_EXPONENT:
+  if (ds->dec->preciseFloat)
+  {
+    return decodePreciseFloat(ds);
+  }
+
+  expNeg = 1.0;
+
+  if (*(offset) == '-')
+  {
+    expNeg = -1.0;
+    offset ++;
+  }
+  else
+  if (*(offset) == '+')
+  {
+    expNeg = +1.0;
+    offset ++;
+  }
+
+  expValue = 0.0;
+
+  for (;;)
+  {
+    chr = (int) (unsigned char) *(offset);
+
+    switch (chr)
+    {
+      case '0':
+      case '1':
+      case '2':
+      case '3':
+      case '4':
+      case '5':
+      case '6':
+      case '7':
+      case '8':
+      case '9':
+      {
+        expValue = expValue * 10.0 + (double) (chr - 48);
+        offset ++;
+        break;
+      }
+      default:
+      {
+        goto BREAK_EXP_LOOP;
+      }
+    }
+  }
+
+BREAK_EXP_LOOP:
+  //FIXME: Check for arithemtic overflow here
+  ds->lastType = JT_DOUBLE;
+  ds->start = offset;
+  return ds->dec->newDouble (ds->prv, createDouble( (double) intNeg, (double) intValue , frcValue, decimalCount) * pow(10.0, expValue * expNeg));
+}
+
+FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_true ( struct DecoderState *ds)
+{
+  char *offset = ds->start;
+  offset ++;
+
+  if (*(offset++) != 'r')
+    goto SETERROR;
+  if (*(offset++) != 'u')
+    goto SETERROR;
+  if (*(offset++) != 'e')
+    goto SETERROR;
+
+  ds->lastType = JT_TRUE;
+  ds->start = offset;
+  return ds->dec->newTrue(ds->prv);
+
+SETERROR:
+  return SetError(ds, -1, "Unexpected character found when decoding 'true'");
+}
+
+FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_false ( struct DecoderState *ds)
+{
+  char *offset = ds->start;
+  offset ++;
+
+  if (*(offset++) != 'a')
+    goto SETERROR;
+  if (*(offset++) != 'l')
+    goto SETERROR;
+  if (*(offset++) != 's')
+    goto SETERROR;
+  if (*(offset++) != 'e')
+    goto SETERROR;
+
+  ds->lastType = JT_FALSE;
+  ds->start = offset;
+  return ds->dec->newFalse(ds->prv);
+
+SETERROR:
+  return SetError(ds, -1, "Unexpected character found when decoding 'false'");
+}
+
+FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_null ( struct DecoderState *ds)
+{
+  char *offset = ds->start;
+  offset ++;
+
+  if (*(offset++) != 'u')
+    goto SETERROR;
+  if (*(offset++) != 'l')
+    goto SETERROR;
+  if (*(offset++) != 'l')
+    goto SETERROR;
+
+  ds->lastType = JT_NULL;
+  ds->start = offset;
+  return ds->dec->newNull(ds->prv);
+
+SETERROR:
+  return SetError(ds, -1, "Unexpected character found when decoding 'null'");
+}
+
+FASTCALL_ATTR void FASTCALL_MSVC SkipWhitespace(struct DecoderState *ds)
+{
+  char *offset = ds->start;
+
+  for (;;)
+  {
+    switch (*offset)
+    {
+      case ' ':
+      case '\t':
+      case '\r':
+      case '\n':
+        offset ++;
+        break;
+
+      default:
+        ds->start = offset;
+        return;
+    }
+  }
+}
+
+enum DECODESTRINGSTATE
+{
+  DS_ISNULL = 0x32,
+  DS_ISQUOTE,
+  DS_ISESCAPE,
+  DS_UTFLENERROR,
+
+};
+
+static const JSUINT8 g_decoderLookup[256] =
+{
+  /* 0x00 */ DS_ISNULL, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+  /* 0x10 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+  /* 0x20 */ 1, 1, DS_ISQUOTE, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+  /* 0x30 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+  /* 0x40 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+  /* 0x50 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, DS_ISESCAPE, 1, 1, 1,
+  /* 0x60 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+  /* 0x70 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+  /* 0x80 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+  /* 0x90 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+  /* 0xa0 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+  /* 0xb0 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+  /* 0xc0 */ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+  /* 0xd0 */ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+  /* 0xe0 */ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+  /* 0xf0 */ 4, 4, 4, 4, 4, 4, 4, 4, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR, DS_UTFLENERROR,
+};
+
+FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_string ( struct DecoderState *ds)
+{
+  JSUTF16 sur[2] = { 0 };
+  int iSur = 0;
+  int index;
+  wchar_t *escOffset;
+  wchar_t *escStart;
+  size_t escLen = (ds->escEnd - ds->escStart);
+  JSUINT8 *inputOffset;
+  JSUINT8 oct;
+  JSUTF32 ucs;
+  ds->lastType = JT_INVALID;
+  ds->start ++;
+
+  if ( (size_t) (ds->end - ds->start) > escLen)
+  {
+    size_t newSize = (ds->end - ds->start);
+
+    if (ds->escHeap)
+    {
+      if (newSize > (UINT_MAX / sizeof(wchar_t)))
+      {
+        return SetError(ds, -1, "Could not reserve memory block");
+      }
+      escStart = (wchar_t *)ds->dec->realloc(ds->escStart, newSize * sizeof(wchar_t));
+      if (!escStart)
+      {
+        ds->dec->free(ds->escStart);
+        return SetError(ds, -1, "Could not reserve memory block");
+      }
+      ds->escStart = escStart;
+    }
+    else
+    {
+      wchar_t *oldStart = ds->escStart;
+      ds->escHeap = 1;
+      if (newSize > (UINT_MAX / sizeof(wchar_t)))
+      {
+        return SetError(ds, -1, "Could not reserve memory block");
+      }
+      ds->escStart = (wchar_t *) ds->dec->malloc(newSize * sizeof(wchar_t));
+      if (!ds->escStart)
+      {
+        return SetError(ds, -1, "Could not reserve memory block");
+      }
+      memcpy(ds->escStart, oldStart, escLen * sizeof(wchar_t));
+    }
+
+    ds->escEnd = ds->escStart + newSize;
+  }
+
+  escOffset = ds->escStart;
+  inputOffset = (JSUINT8 *) ds->start;
+
+  for (;;)
+  {
+    switch (g_decoderLookup[(JSUINT8)(*inputOffset)])
+    {
+      case DS_ISNULL:
+      {
+        return SetError(ds, -1, "Unmatched ''\"' when when decoding 'string'");
+      }
+      case DS_ISQUOTE:
+      {
+        ds->lastType = JT_UTF8;
+        inputOffset ++;
+        ds->start += ( (char *) inputOffset - (ds->start));
+        return ds->dec->newString(ds->prv, ds->escStart, escOffset);
+      }
+      case DS_UTFLENERROR:
+      {
+        return SetError (ds, -1, "Invalid UTF-8 sequence length when decoding 'string'");
+      }
+      case DS_ISESCAPE:
+        inputOffset ++;
+        switch (*inputOffset)
+        {
+          case '\\': *(escOffset++) = L'\\'; inputOffset++; continue;
+          case '\"': *(escOffset++) = L'\"'; inputOffset++; continue;
+          case '/':  *(escOffset++) = L'/';  inputOffset++; continue;
+          case 'b':  *(escOffset++) = L'\b'; inputOffset++; continue;
+          case 'f':  *(escOffset++) = L'\f'; inputOffset++; continue;
+          case 'n':  *(escOffset++) = L'\n'; inputOffset++; continue;
+          case 'r':  *(escOffset++) = L'\r'; inputOffset++; continue;
+          case 't':  *(escOffset++) = L'\t'; inputOffset++; continue;
+
+          case 'u':
+          {
+            int index;
+            inputOffset ++;
+
+            for (index = 0; index < 4; index ++)
+            {
+              switch (*inputOffset)
+              {
+                case '\0': return SetError (ds, -1, "Unterminated unicode escape sequence when decoding 'string'");
+                default: return SetError (ds, -1, "Unexpected character in unicode escape sequence when decoding 'string'");
+
+                case '0':
+                case '1':
+                case '2':
+                case '3':
+                case '4':
+                case '5':
+                case '6':
+                case '7':
+                case '8':
+                case '9':
+                  sur[iSur] = (sur[iSur] << 4) + (JSUTF16) (*inputOffset - '0');
+                  break;
+
+                case 'a':
+                case 'b':
+                case 'c':
+                case 'd':
+                case 'e':
+                case 'f':
+                  sur[iSur] = (sur[iSur] << 4) + 10 + (JSUTF16) (*inputOffset - 'a');
+                  break;
+
+                case 'A':
+                case 'B':
+                case 'C':
+                case 'D':
+                case 'E':
+                case 'F':
+                  sur[iSur] = (sur[iSur] << 4) + 10 + (JSUTF16) (*inputOffset - 'A');
+                  break;
+              }
+
+              inputOffset ++;
+            }
+
+            if (iSur == 0)
+            {
+              if((sur[iSur] & 0xfc00) == 0xd800)
+              {
+                // First of a surrogate pair, continue parsing
+                iSur ++;
+                break;
+              }
+              (*escOffset++) = (wchar_t) sur[iSur];
+              iSur = 0;
+            }
+            else
+            {
+              // Decode pair
+              if ((sur[1] & 0xfc00) != 0xdc00)
+              {
+                return SetError (ds, -1, "Unpaired high surrogate when decoding 'string'");
+              }
+#if WCHAR_MAX == 0xffff
+              (*escOffset++) = (wchar_t) sur[0];
+              (*escOffset++) = (wchar_t) sur[1];
+#else
+              (*escOffset++) = (wchar_t) 0x10000 + (((sur[0] - 0xd800) << 10) | (sur[1] - 0xdc00));
+#endif
+              iSur = 0;
+            }
+          break;
+        }
+
+        case '\0': return SetError(ds, -1, "Unterminated escape sequence when decoding 'string'");
+        default: return SetError(ds, -1, "Unrecognized escape sequence when decoding 'string'");
+      }
+      break;
+
+      case 1:
+      {
+        *(escOffset++) = (wchar_t) (*inputOffset++);
+        break;
+      }
+
+      case 2:
+      {
+        ucs = (*inputOffset++) & 0x1f;
+        ucs <<= 6;
+        if (((*inputOffset) & 0x80) != 0x80)
+        {
+          return SetError(ds, -1, "Invalid octet in UTF-8 sequence when decoding 'string'");
+        }
+        ucs |= (*inputOffset++) & 0x3f;
+        if (ucs < 0x80) return SetError (ds, -1, "Overlong 2 byte UTF-8 sequence detected when decoding 'string'");
+        *(escOffset++) = (wchar_t) ucs;
+        break;
+      }
+
+      case 3:
+      {
+        JSUTF32 ucs = 0;
+        ucs |= (*inputOffset++) & 0x0f;
+
+        for (index = 0; index < 2; index ++)
+        {
+          ucs <<= 6;
+          oct = (*inputOffset++);
+
+          if ((oct & 0x80) != 0x80)
+          {
+            return SetError(ds, -1, "Invalid octet in UTF-8 sequence when decoding 'string'");
+          }
+
+          ucs |= oct & 0x3f;
+        }
+
+        if (ucs < 0x800) return SetError (ds, -1, "Overlong 3 byte UTF-8 sequence detected when encoding string");
+        *(escOffset++) = (wchar_t) ucs;
+        break;
+      }
+
+      case 4:
+      {
+        JSUTF32 ucs = 0;
+        ucs |= (*inputOffset++) & 0x07;
+
+        for (index = 0; index < 3; index ++)
+        {
+          ucs <<= 6;
+          oct = (*inputOffset++);
+
+          if ((oct & 0x80) != 0x80)
+          {
+            return SetError(ds, -1, "Invalid octet in UTF-8 sequence when decoding 'string'");
+          }
+
+          ucs |= oct & 0x3f;
+        }
+
+        if (ucs < 0x10000) return SetError (ds, -1, "Overlong 4 byte UTF-8 sequence detected when decoding 'string'");
+
+#if WCHAR_MAX == 0xffff
+        if (ucs >= 0x10000)
+        {
+          ucs -= 0x10000;
+          *(escOffset++) = (wchar_t) (ucs >> 10) + 0xd800;
+          *(escOffset++) = (wchar_t) (ucs & 0x3ff) + 0xdc00;
+        }
+        else
+        {
+          *(escOffset++) = (wchar_t) ucs;
+        }
+#else
+        *(escOffset++) = (wchar_t) ucs;
+#endif
+        break;
+      }
+    }
+  }
+}
+
+FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_array(struct DecoderState *ds)
+{
+  JSOBJ itemValue;
+  JSOBJ newObj;
+  int len;
+  ds->objDepth++;
+  if (ds->objDepth > JSON_MAX_OBJECT_DEPTH) {
+    return SetError(ds, -1, "Reached object decoding depth limit");
+  }
+
+  newObj = ds->dec->newArray(ds->prv);
+  len = 0;
+
+  ds->lastType = JT_INVALID;
+  ds->start ++;
+
+  for (;;)
+  {
+    SkipWhitespace(ds);
+
+    if ((*ds->start) == ']')
+    {
+      ds->objDepth--;
+      if (len == 0)
+      {
+        ds->start ++;
+        return newObj;
+      }
+
+      ds->dec->releaseObject(ds->prv, newObj);
+      return SetError(ds, -1, "Unexpected character found when decoding array value (1)");
+    }
+
+    itemValue = decode_any(ds);
+
+    if (itemValue == NULL)
+    {
+      ds->dec->releaseObject(ds->prv, newObj);
+      return NULL;
+    }
+
+    ds->dec->arrayAddItem (ds->prv, newObj, itemValue);
+
+    SkipWhitespace(ds);
+
+    switch (*(ds->start++))
+    {
+    case ']':
+    {
+      ds->objDepth--;
+      return newObj;
+    }
+    case ',':
+      break;
+
+    default:
+      ds->dec->releaseObject(ds->prv, newObj);
+      return SetError(ds, -1, "Unexpected character found when decoding array value (2)");
+    }
+
+    len ++;
+  }
+}
+
+FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_object( struct DecoderState *ds)
+{
+  JSOBJ itemName;
+  JSOBJ itemValue;
+  JSOBJ newObj;
+
+  ds->objDepth++;
+  if (ds->objDepth > JSON_MAX_OBJECT_DEPTH) {
+    return SetError(ds, -1, "Reached object decoding depth limit");
+  }
+
+  newObj = ds->dec->newObject(ds->prv);
+
+  ds->start ++;
+
+  for (;;)
+  {
+    SkipWhitespace(ds);
+
+    if ((*ds->start) == '}')
+    {
+      ds->objDepth--;
+      ds->start ++;
+      return newObj;
+    }
+
+    ds->lastType = JT_INVALID;
+    itemName = decode_any(ds);
+
+    if (itemName == NULL)
+    {
+      ds->dec->releaseObject(ds->prv, newObj);
+      return NULL;
+    }
+
+    if (ds->lastType != JT_UTF8)
+    {
+      ds->dec->releaseObject(ds->prv, newObj);
+      ds->dec->releaseObject(ds->prv, itemName);
+      return SetError(ds, -1, "Key name of object must be 'string' when decoding 'object'");
+    }
+
+    SkipWhitespace(ds);
+
+    if (*(ds->start++) != ':')
+    {
+      ds->dec->releaseObject(ds->prv, newObj);
+      ds->dec->releaseObject(ds->prv, itemName);
+      return SetError(ds, -1, "No ':' found when decoding object value");
+    }
+
+    SkipWhitespace(ds);
+
+    itemValue = decode_any(ds);
+
+    if (itemValue == NULL)
+    {
+      ds->dec->releaseObject(ds->prv, newObj);
+      ds->dec->releaseObject(ds->prv, itemName);
+      return NULL;
+    }
+
+    ds->dec->objectAddKey (ds->prv, newObj, itemName, itemValue);
+
+    SkipWhitespace(ds);
+
+    switch (*(ds->start++))
+    {
+      case '}':
+      {
+        ds->objDepth--;
+        return newObj;
+      }
+      case ',':
+        break;
+
+      default:
+        ds->dec->releaseObject(ds->prv, newObj);
+        return SetError(ds, -1, "Unexpected character in found when decoding object value");
+    }
+  }
+}
+
+FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_any(struct DecoderState *ds)
+{
+  for (;;)
+  {
+    switch (*ds->start)
+    {
+      case '\"':
+        return decode_string (ds);
+      case '0':
+      case '1':
+      case '2':
+      case '3':
+      case '4':
+      case '5':
+      case '6':
+      case '7':
+      case '8':
+      case '9':
+      case '-':
+        return decode_numeric (ds);
+
+      case '[': return decode_array (ds);
+      case '{': return decode_object (ds);
+      case 't': return decode_true (ds);
+      case 'f': return decode_false (ds);
+      case 'n': return decode_null (ds);
+
+      case ' ':
+      case '\t':
+      case '\r':
+      case '\n':
+        // White space
+        ds->start ++;
+        break;
+
+      default:
+        return SetError(ds, -1, "Expected object or value");
+    }
+  }
+}
+
+JSOBJ JSON_DecodeObject(JSONObjectDecoder *dec, const char *buffer, size_t cbBuffer)
+{
+  /*
+  FIXME: Base the size of escBuffer of that of cbBuffer so that the unicode escaping doesn't run into the wall each time */
+  struct DecoderState ds;
+  wchar_t escBuffer[(JSON_MAX_STACK_BUFFER_SIZE / sizeof(wchar_t))];
+  JSOBJ ret;
+
+  ds.start = (char *) buffer;
+  ds.end = ds.start + cbBuffer;
+
+  ds.escStart = escBuffer;
+  ds.escEnd = ds.escStart + (JSON_MAX_STACK_BUFFER_SIZE / sizeof(wchar_t));
+  ds.escHeap = 0;
+  ds.prv = dec->prv;
+  ds.dec = dec;
+  ds.dec->errorStr = NULL;
+  ds.dec->errorOffset = NULL;
+  ds.objDepth = 0;
+
+  ds.dec = dec;
+
+  ret = decode_any (&ds);
+
+  if (ds.escHeap)
+  {
+    dec->free(ds.escStart);
+  }
+
+  SkipWhitespace(&ds);
+
+  if (ds.start != ds.end && ret)
+  {
+    dec->releaseObject(ds.prv, ret);
+    return SetError(&ds, -1, "Trailing data");
+  }
+
+  return ret;
+}
