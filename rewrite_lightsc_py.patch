# HG changeset patch
# Parent  da8c0d7ea0acb3550b3cce73f5258fd9eef257ed
Rewrite lightsc.py to be simpler to use, more re-usable & BSD licensed

And to make things clear: unless clearly indicated like here; everything
in this repository is GPLv3, except:

- compat/generic/sys/{queue,tree}.h that I stole from OpenBSD (again);
- core/jsmn.{h,c} by Serge A. Zaitsev.

diff --git a/examples/lightsc.py b/examples/lightsc.py
--- a/examples/lightsc.py
+++ b/examples/lightsc.py
@@ -1,154 +1,220 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
+# Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice,
+#    this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice,
+#    this list of conditions and the following disclaimer in the documentation
+#    and/or other materials provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors
+#    may be used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
 
+import argparse
+import contextlib
 import json
 import socket
-import sys
-import time
 import uuid
 
-from IPython.terminal.embed import InteractiveShellEmbed
 
+class LightsClient:
 
-def jsonrpc_call(socket, method, params):
-    payload = {
-        "method": method,
-        "params": params,
-        "jsonrpc": "2.0",
-        "id": str(uuid.uuid4()),
-    }
-    socket.send(json.dumps(payload).encode("utf-8"))
-    response = socket.recv(8192).decode("utf-8")
+    def __init__(self, host, port):
+        self.host = host
+        self.port = port
+        self._socket = socket.create_connection((host, port))
+        self._pipeline = []
+        self._batch = False
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_value, exc_tb):
+        self.close()
+
+    @classmethod
+    def _make_payload(cls, method, params):
+        return {
+            "method": method,
+            "params": params,
+            "jsonrpc": "2.0",
+            "id": str(uuid.uuid4()),
+        }
+
+    def _execute_payload(self, payload):
+        self._socket.send(json.dumps(payload).encode("utf-8"))
+        response = self._socket.recv(8192).decode("utf-8")
+        try:
+            response = json.loads(response)
+        except Exception:
+            print("received invalid json: {}".format(response))
+
+        return response
+
+    def _jsonrpc_call(self, method, params):
+        payload = self._make_payload(method, params)
+        if self._batch:
+            self._pipeline.append(payload)
+            return
+        return self._execute_payload(payload)
+
+    def close(self):
+        self._socket.close()
+
+    @contextlib.contextmanager
+    def batch(self):
+        self._batch = True
+        response = []
+        yield response
+        self._batch = False
+        result = self._execute_payload(self._pipeline)
+        if isinstance(result, list):
+            response.extend(result)
+        else:
+            response.append(result)
+        self._pipeline = []
+
+    def set_light_from_hsbk(self, target, h, s, b, k, t):
+        return self._jsonrpc_call("set_light_from_hsbk", [
+            target, h, s, b, k, t
+        ])
+
+    def set_waveform(self, target, waveform,
+                     h, s, b, k,
+                     period, cycles, skew_ratio, transient):
+        return self._jsonrpc_call("set_waveform", [
+            target, waveform, h, s, b, k, period, cycles, skew_ratio, transient
+        ])
+
+    def saw(self, target, h, s, b, k, period, cycles, transient=True):
+        return self.set_waveform(
+            target, "SAW", h, s, b, k,
+            cycles=cycles,
+            period=period,
+            skew_ratio=0.5,
+            transient=transient
+        )
+
+    def sine(self, target, h, s, b, k,
+             period, cycles, peak=0.5, transient=True):
+        return self.set_waveform(
+            target, "SINE", h, s, b, k,
+            cycles=cycles,
+            period=period,
+            skew_ratio=peak,
+            transient=transient
+        )
+
+    def half_sine(self, target, h, s, b, k, period, cycles, transient=True):
+        return self.set_waveform(
+            target, "HALF_SINE", h, s, b, k,
+            cycles=cycles,
+            period=period,
+            skew_ratio=0.5,
+            transient=transient
+        )
+
+    def triangle(self, target, h, s, b, k,
+                 period, cycles, peak=0.5, transient=True):
+        return self.set_waveform(
+            target, "TRIANGLE", h, s, b, k,
+            cycles=cycles,
+            period=period,
+            skew_ratio=peak,
+            transient=transient
+        )
+
+    def square(self, target, h, s, b, k, period, cycles,
+               duty_cycle=0.5, transient=True):
+        return self.set_waveform(
+            target, "SQUARE", h, s, b, k,
+            cycles=cycles,
+            period=period,
+            skew_ratio=duty_cycle,
+            transient=transient
+        )
+
+    def power_on(self, target):
+        return self._jsonrpc_call("power_on", {"target": target})
+
+    def power_off(self, target):
+        return self._jsonrpc_call("power_off", {"target": target})
+
+    def power_toggle(self, target):
+        return self._jsonrpc_call("power_toggle", {"target": target})
+
+    def get_light_state(self, target):
+        return self._jsonrpc_call("get_light_state", [target])
+
+    def tag(self, target, tag):
+        return self._jsonrpc_call("tag", [target, tag])
+
+    def untag(self, target, tag):
+        return self._jsonrpc_call("untag", [target, tag])
+
+    def set_label(self, target, label):
+        return self._jsonrpc_call("set_label", [target, label])
+
+    def adjust_brightness(self, target, adjustment):
+        bulbs = self.get_light_state(target)["result"]
+        for bulb in bulbs:
+            h, s, b, k = bulb["hsbk"]
+            b = max(min(b + adjustment, 1.0), 0.0)
+            self.set_light_from_hsbk(bulb["label"], h, s, b, k, 500)
+
+
+def _drop_to_shell(lightsc):
+    c = lightsc  # noqa
+    nb = "d073d501a0d5"  # noqa
+    fugu = "d073d500603b"  # noqa
+    neko = "d073d5018fb6"  # noqa
+    middle = "d073d502e530"  # noqa
+
+    banner = """
+lightsc is connected to {}:{}, use the variable c to interact with your bulbs:
+
+>>> c.get_light_state("*")
+"""
+
     try:
-        response = json.loads(response)
-    except ValueError:
-        print("received invalid json: {}".format(response))
-        return None
-    return response
+        from IPython import embed
+        embed(header=banner)
+        return
+    except ImportError:
+        pass
 
-
-def set_light_from_hsbk(socket, target, h, s, b, k, t):
-    return jsonrpc_call(socket, "set_light_from_hsbk", [
-        target, h, s, b, k, t
-    ])
-
-
-def set_waveform(socket, target, waveform,
-                 h, s, b, k,
-                 period, cycles, skew_ratio, transient):
-    return jsonrpc_call(socket, "set_waveform", [
-        target, waveform, h, s, b, k, period, cycles, skew_ratio, transient
-    ])
-
-
-def saw(socket, target, h, s, b, k, period, cycles, transient=True):
-    return set_waveform(
-        socket, target, "SAW", h, s, b, k,
-        cycles=cycles,
-        period=period,
-        skew_ratio=0.5,
-        transient=transient
-    )
-
-
-def sine(socket, target, h, s, b, k, period, cycles, peak=0.5, transient=True):
-    return set_waveform(
-        socket, target, "SINE", h, s, b, k,
-        cycles=cycles,
-        period=period,
-        skew_ratio=peak,
-        transient=transient
-    )
-
-
-def half_sine(socket, target, h, s, b, k, period, cycles, transient=True):
-    return set_waveform(
-        socket, target, "HALF_SINE", h, s, b, k,
-        cycles=cycles,
-        period=period,
-        skew_ratio=0.5,
-        transient=transient
-    )
-
-
-def triangle(socket, target, h, s, b, k,
-             period, cycles, peak=0.5, transient=True):
-    return set_waveform(
-        socket, target, "TRIANGLE", h, s, b, k,
-        cycles=cycles,
-        period=period,
-        skew_ratio=peak,
-        transient=transient
-    )
-
-
-def square(socket, target, h, s, b, k, period, cycles,
-           duty_cycle=0.5, transient=True):
-    return set_waveform(
-        socket, target, "SQUARE", h, s, b, k,
-        cycles=cycles,
-        period=period,
-        skew_ratio=duty_cycle,
-        transient=transient
-    )
-
-
-def power_on(socket, target):
-    return jsonrpc_call(socket, "power_on", {"target": target})
-
-
-def power_off(socket, target):
-    return jsonrpc_call(socket, "power_off", {"target": target})
-
-
-def power_toggle(socket, target):
-    return jsonrpc_call(socket, "power_toggle", {"target": target})
-
-
-def get_light_state(socket, target):
-    return jsonrpc_call(socket, "get_light_state", [target])
-
-
-def tag(socket, target, tag):
-    return jsonrpc_call(socket, "tag", [target, tag])
-
-
-def untag(socket, target, tag):
-    return jsonrpc_call(socket, "untag", [target, tag])
-
-
-def set_label(socket, target, label):
-    return jsonrpc_call(socket, "set_label", [target, label])
-
-
-def adjust_brightness(socket, target, adjustment):
-    bulbs = get_light_state(socket, target)["result"]
-    for bulb in bulbs:
-        h, s, b, k = bulb["hsbk"]
-        b += adjustment
-        b = max(min(b, 1.0), 0.0)
-        set_light_from_hsbk(socket, bulb["label"], h, s, b, k, 500)
-
+    import code
+    code.interact(banner=banner)
 
 if __name__ == "__main__":
-    s = socket.create_connection(("localhost", 1234))
-    h = 0
-    id = 0
-    nb = "d073d501a0d5"
-    fugu = "d073d500603b"
-    neko = "d073d5018fb6"
-    middle = "d073d502e530"
-    target = "*"
-    try:
-        if len(sys.argv) == 2 and sys.argv[1] == "shell":
-            ipshell = InteractiveShellEmbed()
-            ipshell()
-            sys.exit(0)
-        power_on(s, target)
-        while True:
-            h = (h + 5) % 360
-            id += 1
-            set_light_from_hsbk(s, target, h, 0.8, 0.1, 2500, 450)
-            time.sleep(0.5)
-        power_off(s, target)
-    finally:
-        s.close()
+    parser = argparse.ArgumentParser(
+        description="lightsc.py is an interactive lightsd Python client"
+    )
+    parser.add_argument(
+        "-h", "--host", type=str, required=True,
+        help="The hostname or ip where lightsd is running"
+    )
+    parser.add_argument(
+        "-p", "--port", type=int, required=True,
+        help="The port on which lightsd is listening on"
+    )
+    args = parser.parse_args()
+    _drop_to_shell(LightsClient(args.host, args.port))
