# HG changeset patch
# Parent 0000000000000000000000000000000000000000

diff --git a/.hgignore b/.hgignore
new file mode 100644
--- /dev/null
+++ b/.hgignore
@@ -0,0 +1,3 @@
+.*\.sw[p-z]$
+.*\.py[co]$
+^build
diff --git a/.ycm_extra_conf.py b/.ycm_extra_conf.py
new file mode 100644
--- /dev/null
+++ b/.ycm_extra_conf.py
@@ -0,0 +1,148 @@
+# This file is NOT licensed under the GPLv3, which is the license for the rest
+# of YouCompleteMe.
+#
+# Here's the license text for this file:
+#
+# This is free and unencumbered software released into the public domain.
+#
+# Anyone is free to copy, modify, publish, use, compile, sell, or
+# distribute this software, either in source code form or as a compiled
+# binary, for any purpose, commercial or non-commercial, and by any
+# means.
+#
+# In jurisdictions that recognize copyright laws, the author or authors
+# of this software dedicate any and all copyright interest in the
+# software to the public domain. We make this dedication for the benefit
+# of the public at large and to the detriment of our heirs and
+# successors. We intend this dedication to be an overt act of
+# relinquishment in perpetuity of all present and future rights to this
+# software under copyright law.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+# OTHER DEALINGS IN THE SOFTWARE.
+#
+# For more information, please refer to <http://unlicense.org/>
+
+import os
+import ycm_core
+
+# These are the compilation flags that will be used in case there's no
+# compilation database set (by default, one is not set).
+# CHANGE THIS LIST OF FLAGS. YES, THIS IS THE DROID YOU HAVE BEEN LOOKING FOR.
+flags = [
+    '-Wall',
+    '-Wextra',
+    '-Werror',
+    '-Wstrict-prototypes',
+    '-std=c99',
+    '-D_POSIX_C_SOURCE=200809L',
+    '-D_BSD_SOURCE=1',
+    '-I./compat',
+    '-I./core',
+    '-I{}'.format(os.path.join(os.getenv("MY_BUILD", "./build"), "core")),
+]
+
+
+# Set this to the absolute path to the folder (NOT the file!) containing the
+# compile_commands.json file to use that instead of 'flags'. See here for
+# more details: http://clang.llvm.org/docs/JSONCompilationDatabase.html
+#
+# Most projects will NOT need to set this to anything; you can just change the
+# 'flags' list of compilation flags. Notice that YCM itself uses that approach.
+compilation_database_folder = ''
+
+if os.path.exists( compilation_database_folder ):
+  database = ycm_core.CompilationDatabase( compilation_database_folder )
+else:
+  database = None
+
+SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', '.m', '.mm' ]
+
+def DirectoryOfThisScript():
+  return os.path.dirname( os.path.abspath( __file__ ) )
+
+
+def MakeRelativePathsInFlagsAbsolute( flags, working_directory ):
+  if not working_directory:
+    return list( flags )
+  new_flags = []
+  make_next_absolute = False
+  path_flags = [ '-isystem', '-I', '-iquote', '--sysroot=' ]
+  for flag in flags:
+    new_flag = flag
+
+    if make_next_absolute:
+      make_next_absolute = False
+      if not flag.startswith( '/' ):
+        new_flag = os.path.join( working_directory, flag )
+
+    for path_flag in path_flags:
+      if flag == path_flag:
+        make_next_absolute = True
+        break
+
+      if flag.startswith( path_flag ):
+        path = flag[ len( path_flag ): ]
+        new_flag = path_flag + os.path.join( working_directory, path )
+        break
+
+    if new_flag:
+      new_flags.append( new_flag )
+  return new_flags
+
+
+def IsHeaderFile( filename ):
+  extension = os.path.splitext( filename )[ 1 ]
+  return extension in [ '.h', '.hxx', '.hpp', '.hh' ]
+
+
+def GetCompilationInfoForFile( filename ):
+  # The compilation_commands.json file generated by CMake does not have entries
+  # for header files. So we do our best by asking the db for flags for a
+  # corresponding source file, if any. If one exists, the flags for that file
+  # should be good enough.
+  if IsHeaderFile( filename ):
+    basename = os.path.splitext( filename )[ 0 ]
+    for extension in SOURCE_EXTENSIONS:
+      replacement_file = basename + extension
+      if os.path.exists( replacement_file ):
+        compilation_info = database.GetCompilationInfoForFile(
+          replacement_file )
+        if compilation_info.compiler_flags_:
+          return compilation_info
+    return None
+  return database.GetCompilationInfoForFile( filename )
+
+
+def FlagsForFile( filename, **kwargs ):
+  if database:
+    # Bear in mind that compilation_info.compiler_flags_ does NOT return a
+    # python list, but a "list-like" StringVec object
+    compilation_info = GetCompilationInfoForFile( filename )
+    if not compilation_info:
+      return None
+
+    final_flags = MakeRelativePathsInFlagsAbsolute(
+      compilation_info.compiler_flags_,
+      compilation_info.compiler_working_dir_ )
+
+    # NOTE: This is just for YouCompleteMe; it's highly likely that your project
+    # does NOT need to remove the stdlib flag. DO NOT USE THIS IN YOUR
+    # ycm_extra_conf IF YOU'RE NOT 100% SURE YOU NEED IT.
+    try:
+      final_flags.remove( '-stdlib=libc++' )
+    except ValueError:
+      pass
+  else:
+    relative_to = DirectoryOfThisScript()
+    final_flags = MakeRelativePathsInFlagsAbsolute( flags, relative_to )
+
+  return {
+    'flags': final_flags,
+    'do_cache': True
+  }
diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,36 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
+
+PROJECT(LIFXD C)
+
+SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${LIFXD_SOURCE_DIR}/CMakeScripts)
+
+SET(CPACK_PACKAGE_VERSION_MAJOR "0")
+SET(CPACK_PACKAGE_VERSION_MINOR "0")
+SET(CPACK_PACKAGE_VERSION_PATCH "1")
+SET(LIFXD_VERSION "${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}")
+
+MESSAGE(STATUS "CMake version: ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}")
+MESSAGE(STATUS "lifxd version: ${LIFXD_VERSION}")
+MESSAGE(STATUS "Build type: ${CMAKE_BUILD_TYPE}")
+MESSAGE(STATUS "System: ${CMAKE_SYSTEM_NAME} ${CMAKE_SYSTEM_VERSION}")
+MESSAGE(STATUS "Install prefix: ${CMAKE_INSTALL_PREFIX}")
+MESSAGE(STATUS "Source directory: ${LIFXD_SOURCE_DIR}")
+
+# TODO: we need at least 2.0.19-stable because of the logging defines
+FIND_PACKAGE(Event2 REQUIRED COMPONENTS core)
+
+SET(CMAKE_C_FLAGS "-pipe -Wextra -Wall -Wstrict-prototypes -std=c99")
+
+ADD_DEFINITIONS("-D_POSIX_C_SOURCE=200809L" "-D_BSD_SOURCE=1")
+
+IF (CMAKE_BUILD_TYPE MATCHES "DEBUG")
+    ADD_DEFINITIONS("-DQUEUE_MACRO_DEBUG=1")
+ENDIF ()
+
+INCLUDE_DIRECTORIES(
+    ${LIFXD_SOURCE_DIR}/compat
+    ${LIFXD_SOURCE_DIR}/core
+    ${LIFXD_BINARY_DIR}/core
+)
+
+ADD_SUBDIRECTORY(core)
diff --git a/CMakeScripts/FindEvent2.cmake b/CMakeScripts/FindEvent2.cmake
new file mode 100644
--- /dev/null
+++ b/CMakeScripts/FindEvent2.cmake
@@ -0,0 +1,18 @@
+FOREACH (COMPONENT ${Event2_FIND_COMPONENTS})
+    STRING(TOUPPER ${COMPONENT} UPPER_COMPONENT)
+    FIND_LIBRARY(EVENT2_${UPPER_COMPONENT}_LIBRARY event_${COMPONENT})
+    IF (EVENT2_${UPPER_COMPONENT}_LIBRARY)
+        SET(Event2_${COMPONENT}_FOUND TRUE)
+    ENDIF ()
+ENDFOREACH ()
+
+FIND_PATH(EVENT2_INCLUDE_DIR event2/event.h)
+
+INCLUDE(FindPackageHandleStandardArgs)
+
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(
+    Event2
+    FOUND_VAR Event2_FOUND
+    HANDLE_COMPONENTS
+    REQUIRED_VARS EVENT2_CORE_LIBRARY EVENT2_INCLUDE_DIR
+)
diff --git a/compat/sys/queue.h b/compat/sys/queue.h
new file mode 100644
--- /dev/null
+++ b/compat/sys/queue.h
@@ -0,0 +1,648 @@
+/*	$OpenBSD: queue.h,v 1.38 2013/07/03 15:05:21 fgsch Exp $	*/
+/*	$NetBSD: queue.h,v 1.11 1996/05/16 05:17:14 mycroft Exp $	*/
+
+/*
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)queue.h	8.5 (Berkeley) 8/20/94
+ */
+
+#ifndef	_SYS_QUEUE_H_
+#define	_SYS_QUEUE_H_
+
+/*
+ * This file defines five types of data structures: singly-linked lists, 
+ * lists, simple queues, tail queues, and circular queues.
+ *
+ *
+ * A singly-linked list is headed by a single forward pointer. The elements
+ * are singly linked for minimum space and pointer manipulation overhead at
+ * the expense of O(n) removal for arbitrary elements. New elements can be
+ * added to the list after an existing element or at the head of the list.
+ * Elements being removed from the head of the list should use the explicit
+ * macro for this purpose for optimum efficiency. A singly-linked list may
+ * only be traversed in the forward direction.  Singly-linked lists are ideal
+ * for applications with large datasets and few or no removals or for
+ * implementing a LIFO queue.
+ *
+ * A list is headed by a single forward pointer (or an array of forward
+ * pointers for a hash table header). The elements are doubly linked
+ * so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before
+ * or after an existing element or at the head of the list. A list
+ * may only be traversed in the forward direction.
+ *
+ * A simple queue is headed by a pair of pointers, one the head of the
+ * list and the other to the tail of the list. The elements are singly
+ * linked to save space, so elements can only be removed from the
+ * head of the list. New elements can be added to the list before or after
+ * an existing element, at the head of the list, or at the end of the
+ * list. A simple queue may only be traversed in the forward direction.
+ *
+ * A tail queue is headed by a pair of pointers, one to the head of the
+ * list and the other to the tail of the list. The elements are doubly
+ * linked so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before or
+ * after an existing element, at the head of the list, or at the end of
+ * the list. A tail queue may be traversed in either direction.
+ *
+ * A circle queue is headed by a pair of pointers, one to the head of the
+ * list and the other to the tail of the list. The elements are doubly
+ * linked so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before or after
+ * an existing element, at the head of the list, or at the end of the list.
+ * A circle queue may be traversed in either direction, but has a more
+ * complex end of list detection.
+ *
+ * For details on the use of these macros, see the queue(3) manual page.
+ */
+
+#if defined(QUEUE_MACRO_DEBUG) || (defined(_KERNEL) && defined(DIAGNOSTIC))
+#define _Q_INVALIDATE(a) (a) = ((void *)-1)
+#else
+#define _Q_INVALIDATE(a)
+#endif
+
+/*
+ * Singly-linked List definitions.
+ */
+#define SLIST_HEAD(name, type)						\
+struct name {								\
+	struct type *slh_first;	/* first element */			\
+}
+ 
+#define	SLIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+ 
+#define SLIST_ENTRY(type)						\
+struct {								\
+	struct type *sle_next;	/* next element */			\
+}
+ 
+/*
+ * Singly-linked List access methods.
+ */
+#define	SLIST_FIRST(head)	((head)->slh_first)
+#define	SLIST_END(head)		NULL
+#define	SLIST_EMPTY(head)	(SLIST_FIRST(head) == SLIST_END(head))
+#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)
+
+#define	SLIST_FOREACH(var, head, field)					\
+	for((var) = SLIST_FIRST(head);					\
+	    (var) != SLIST_END(head);					\
+	    (var) = SLIST_NEXT(var, field))
+
+#define	SLIST_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = SLIST_FIRST(head);				\
+	    (var) && ((tvar) = SLIST_NEXT(var, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * Singly-linked List functions.
+ */
+#define	SLIST_INIT(head) {						\
+	SLIST_FIRST(head) = SLIST_END(head);				\
+}
+
+#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
+	(elm)->field.sle_next = (slistelm)->field.sle_next;		\
+	(slistelm)->field.sle_next = (elm);				\
+} while (0)
+
+#define	SLIST_INSERT_HEAD(head, elm, field) do {			\
+	(elm)->field.sle_next = (head)->slh_first;			\
+	(head)->slh_first = (elm);					\
+} while (0)
+
+#define	SLIST_REMOVE_AFTER(elm, field) do {				\
+	(elm)->field.sle_next = (elm)->field.sle_next->field.sle_next;	\
+} while (0)
+
+#define	SLIST_REMOVE_HEAD(head, field) do {				\
+	(head)->slh_first = (head)->slh_first->field.sle_next;		\
+} while (0)
+
+#define SLIST_REMOVE(head, elm, type, field) do {			\
+	if ((head)->slh_first == (elm)) {				\
+		SLIST_REMOVE_HEAD((head), field);			\
+	} else {							\
+		struct type *curelm = (head)->slh_first;		\
+									\
+		while (curelm->field.sle_next != (elm))			\
+			curelm = curelm->field.sle_next;		\
+		curelm->field.sle_next =				\
+		    curelm->field.sle_next->field.sle_next;		\
+		_Q_INVALIDATE((elm)->field.sle_next);			\
+	}								\
+} while (0)
+
+/*
+ * List definitions.
+ */
+#define LIST_HEAD(name, type)						\
+struct name {								\
+	struct type *lh_first;	/* first element */			\
+}
+
+#define LIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define LIST_ENTRY(type)						\
+struct {								\
+	struct type *le_next;	/* next element */			\
+	struct type **le_prev;	/* address of previous next element */	\
+}
+
+/*
+ * List access methods
+ */
+#define	LIST_FIRST(head)		((head)->lh_first)
+#define	LIST_END(head)			NULL
+#define	LIST_EMPTY(head)		(LIST_FIRST(head) == LIST_END(head))
+#define	LIST_NEXT(elm, field)		((elm)->field.le_next)
+
+#define LIST_FOREACH(var, head, field)					\
+	for((var) = LIST_FIRST(head);					\
+	    (var)!= LIST_END(head);					\
+	    (var) = LIST_NEXT(var, field))
+
+#define	LIST_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = LIST_FIRST(head);				\
+	    (var) && ((tvar) = LIST_NEXT(var, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * List functions.
+ */
+#define	LIST_INIT(head) do {						\
+	LIST_FIRST(head) = LIST_END(head);				\
+} while (0)
+
+#define LIST_INSERT_AFTER(listelm, elm, field) do {			\
+	if (((elm)->field.le_next = (listelm)->field.le_next) != NULL)	\
+		(listelm)->field.le_next->field.le_prev =		\
+		    &(elm)->field.le_next;				\
+	(listelm)->field.le_next = (elm);				\
+	(elm)->field.le_prev = &(listelm)->field.le_next;		\
+} while (0)
+
+#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
+	(elm)->field.le_prev = (listelm)->field.le_prev;		\
+	(elm)->field.le_next = (listelm);				\
+	*(listelm)->field.le_prev = (elm);				\
+	(listelm)->field.le_prev = &(elm)->field.le_next;		\
+} while (0)
+
+#define LIST_INSERT_HEAD(head, elm, field) do {				\
+	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
+		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
+	(head)->lh_first = (elm);					\
+	(elm)->field.le_prev = &(head)->lh_first;			\
+} while (0)
+
+#define LIST_REMOVE(elm, field) do {					\
+	if ((elm)->field.le_next != NULL)				\
+		(elm)->field.le_next->field.le_prev =			\
+		    (elm)->field.le_prev;				\
+	*(elm)->field.le_prev = (elm)->field.le_next;			\
+	_Q_INVALIDATE((elm)->field.le_prev);				\
+	_Q_INVALIDATE((elm)->field.le_next);				\
+} while (0)
+
+#define LIST_REPLACE(elm, elm2, field) do {				\
+	if (((elm2)->field.le_next = (elm)->field.le_next) != NULL)	\
+		(elm2)->field.le_next->field.le_prev =			\
+		    &(elm2)->field.le_next;				\
+	(elm2)->field.le_prev = (elm)->field.le_prev;			\
+	*(elm2)->field.le_prev = (elm2);				\
+	_Q_INVALIDATE((elm)->field.le_prev);				\
+	_Q_INVALIDATE((elm)->field.le_next);				\
+} while (0)
+
+/*
+ * Simple queue definitions.
+ */
+#define SIMPLEQ_HEAD(name, type)					\
+struct name {								\
+	struct type *sqh_first;	/* first element */			\
+	struct type **sqh_last;	/* addr of last next element */		\
+}
+
+#define SIMPLEQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).sqh_first }
+
+#define SIMPLEQ_ENTRY(type)						\
+struct {								\
+	struct type *sqe_next;	/* next element */			\
+}
+
+/*
+ * Simple queue access methods.
+ */
+#define	SIMPLEQ_FIRST(head)	    ((head)->sqh_first)
+#define	SIMPLEQ_END(head)	    NULL
+#define	SIMPLEQ_EMPTY(head)	    (SIMPLEQ_FIRST(head) == SIMPLEQ_END(head))
+#define	SIMPLEQ_NEXT(elm, field)    ((elm)->field.sqe_next)
+
+#define SIMPLEQ_FOREACH(var, head, field)				\
+	for((var) = SIMPLEQ_FIRST(head);				\
+	    (var) != SIMPLEQ_END(head);					\
+	    (var) = SIMPLEQ_NEXT(var, field))
+
+#define	SIMPLEQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = SIMPLEQ_FIRST(head);				\
+	    (var) && ((tvar) = SIMPLEQ_NEXT(var, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * Simple queue functions.
+ */
+#define	SIMPLEQ_INIT(head) do {						\
+	(head)->sqh_first = NULL;					\
+	(head)->sqh_last = &(head)->sqh_first;				\
+} while (0)
+
+#define SIMPLEQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.sqe_next = (head)->sqh_first) == NULL)	\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+	(head)->sqh_first = (elm);					\
+} while (0)
+
+#define SIMPLEQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.sqe_next = NULL;					\
+	*(head)->sqh_last = (elm);					\
+	(head)->sqh_last = &(elm)->field.sqe_next;			\
+} while (0)
+
+#define SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.sqe_next = (listelm)->field.sqe_next) == NULL)\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+	(listelm)->field.sqe_next = (elm);				\
+} while (0)
+
+#define SIMPLEQ_REMOVE_HEAD(head, field) do {			\
+	if (((head)->sqh_first = (head)->sqh_first->field.sqe_next) == NULL) \
+		(head)->sqh_last = &(head)->sqh_first;			\
+} while (0)
+
+#define SIMPLEQ_REMOVE_AFTER(head, elm, field) do {			\
+	if (((elm)->field.sqe_next = (elm)->field.sqe_next->field.sqe_next) \
+	    == NULL)							\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+} while (0)
+
+/*
+ * XOR Simple queue definitions.
+ */
+#define XSIMPLEQ_HEAD(name, type)					\
+struct name {								\
+	struct type *sqx_first;	/* first element */			\
+	struct type **sqx_last;	/* addr of last next element */		\
+	unsigned long sqx_cookie;					\
+}
+
+#define XSIMPLEQ_ENTRY(type)						\
+struct {								\
+	struct type *sqx_next;	/* next element */			\
+}
+
+/*
+ * XOR Simple queue access methods.
+ */
+#define XSIMPLEQ_XOR(head, ptr)	    ((__typeof(ptr))((head)->sqx_cookie ^ \
+					(unsigned long)(ptr)))
+#define	XSIMPLEQ_FIRST(head)	    XSIMPLEQ_XOR(head, ((head)->sqx_first))
+#define	XSIMPLEQ_END(head)	    NULL
+#define	XSIMPLEQ_EMPTY(head)	    (XSIMPLEQ_FIRST(head) == XSIMPLEQ_END(head))
+#define	XSIMPLEQ_NEXT(head, elm, field)    XSIMPLEQ_XOR(head, ((elm)->field.sqx_next))
+
+
+#define XSIMPLEQ_FOREACH(var, head, field)				\
+	for ((var) = XSIMPLEQ_FIRST(head);				\
+	    (var) != XSIMPLEQ_END(head);				\
+	    (var) = XSIMPLEQ_NEXT(head, var, field))
+
+#define	XSIMPLEQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = XSIMPLEQ_FIRST(head);				\
+	    (var) && ((tvar) = XSIMPLEQ_NEXT(head, var, field), 1);	\
+	    (var) = (tvar))
+
+/*
+ * XOR Simple queue functions.
+ */
+#define	XSIMPLEQ_INIT(head) do {					\
+	arc4random_buf(&(head)->sqx_cookie, sizeof((head)->sqx_cookie)); \
+	(head)->sqx_first = XSIMPLEQ_XOR(head, NULL);			\
+	(head)->sqx_last = XSIMPLEQ_XOR(head, &(head)->sqx_first);	\
+} while (0)
+
+#define XSIMPLEQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.sqx_next = (head)->sqx_first) ==		\
+	    XSIMPLEQ_XOR(head, NULL))					\
+		(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next); \
+	(head)->sqx_first = XSIMPLEQ_XOR(head, (elm));			\
+} while (0)
+
+#define XSIMPLEQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.sqx_next = XSIMPLEQ_XOR(head, NULL);		\
+	*(XSIMPLEQ_XOR(head, (head)->sqx_last)) = XSIMPLEQ_XOR(head, (elm)); \
+	(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next);	\
+} while (0)
+
+#define XSIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.sqx_next = (listelm)->field.sqx_next) ==	\
+	    XSIMPLEQ_XOR(head, NULL))					\
+		(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next); \
+	(listelm)->field.sqx_next = XSIMPLEQ_XOR(head, (elm));		\
+} while (0)
+
+#define XSIMPLEQ_REMOVE_HEAD(head, field) do {				\
+	if (((head)->sqx_first = XSIMPLEQ_XOR(head,			\
+	    (head)->sqx_first)->field.sqx_next) == XSIMPLEQ_XOR(head, NULL)) \
+		(head)->sqx_last = XSIMPLEQ_XOR(head, &(head)->sqx_first); \
+} while (0)
+
+#define XSIMPLEQ_REMOVE_AFTER(head, elm, field) do {			\
+	if (((elm)->field.sqx_next = XSIMPLEQ_XOR(head,			\
+	    (elm)->field.sqx_next)->field.sqx_next)			\
+	    == XSIMPLEQ_XOR(head, NULL))				\
+		(head)->sqx_last = 					\
+		    XSIMPLEQ_XOR(head, &(elm)->field.sqx_next);		\
+} while (0)
+
+		    
+/*
+ * Tail queue definitions.
+ */
+#define TAILQ_HEAD(name, type)						\
+struct name {								\
+	struct type *tqh_first;	/* first element */			\
+	struct type **tqh_last;	/* addr of last next element */		\
+}
+
+#define TAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).tqh_first }
+
+#define TAILQ_ENTRY(type)						\
+struct {								\
+	struct type *tqe_next;	/* next element */			\
+	struct type **tqe_prev;	/* address of previous next element */	\
+}
+
+/* 
+ * tail queue access methods 
+ */
+#define	TAILQ_FIRST(head)		((head)->tqh_first)
+#define	TAILQ_END(head)			NULL
+#define	TAILQ_NEXT(elm, field)		((elm)->field.tqe_next)
+#define TAILQ_LAST(head, headname)					\
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+/* XXX */
+#define TAILQ_PREV(elm, headname, field)				\
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+#define	TAILQ_EMPTY(head)						\
+	(TAILQ_FIRST(head) == TAILQ_END(head))
+
+#define TAILQ_FOREACH(var, head, field)					\
+	for((var) = TAILQ_FIRST(head);					\
+	    (var) != TAILQ_END(head);					\
+	    (var) = TAILQ_NEXT(var, field))
+
+#define	TAILQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = TAILQ_FIRST(head);					\
+	    (var) != TAILQ_END(head) &&					\
+	    ((tvar) = TAILQ_NEXT(var, field), 1);			\
+	    (var) = (tvar))
+
+
+#define TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
+	for((var) = TAILQ_LAST(head, headname);				\
+	    (var) != TAILQ_END(head);					\
+	    (var) = TAILQ_PREV(var, headname, field))
+
+#define	TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
+	for ((var) = TAILQ_LAST(head, headname);			\
+	    (var) != TAILQ_END(head) &&					\
+	    ((tvar) = TAILQ_PREV(var, headname, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * Tail queue functions.
+ */
+#define	TAILQ_INIT(head) do {						\
+	(head)->tqh_first = NULL;					\
+	(head)->tqh_last = &(head)->tqh_first;				\
+} while (0)
+
+#define TAILQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.tqe_next = (head)->tqh_first) != NULL)	\
+		(head)->tqh_first->field.tqe_prev =			\
+		    &(elm)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm)->field.tqe_next;		\
+	(head)->tqh_first = (elm);					\
+	(elm)->field.tqe_prev = &(head)->tqh_first;			\
+} while (0)
+
+#define TAILQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.tqe_next = NULL;					\
+	(elm)->field.tqe_prev = (head)->tqh_last;			\
+	*(head)->tqh_last = (elm);					\
+	(head)->tqh_last = &(elm)->field.tqe_next;			\
+} while (0)
+
+#define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\
+		(elm)->field.tqe_next->field.tqe_prev =			\
+		    &(elm)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm)->field.tqe_next;		\
+	(listelm)->field.tqe_next = (elm);				\
+	(elm)->field.tqe_prev = &(listelm)->field.tqe_next;		\
+} while (0)
+
+#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
+	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
+	(elm)->field.tqe_next = (listelm);				\
+	*(listelm)->field.tqe_prev = (elm);				\
+	(listelm)->field.tqe_prev = &(elm)->field.tqe_next;		\
+} while (0)
+
+#define TAILQ_REMOVE(head, elm, field) do {				\
+	if (((elm)->field.tqe_next) != NULL)				\
+		(elm)->field.tqe_next->field.tqe_prev =			\
+		    (elm)->field.tqe_prev;				\
+	else								\
+		(head)->tqh_last = (elm)->field.tqe_prev;		\
+	*(elm)->field.tqe_prev = (elm)->field.tqe_next;			\
+	_Q_INVALIDATE((elm)->field.tqe_prev);				\
+	_Q_INVALIDATE((elm)->field.tqe_next);				\
+} while (0)
+
+#define TAILQ_REPLACE(head, elm, elm2, field) do {			\
+	if (((elm2)->field.tqe_next = (elm)->field.tqe_next) != NULL)	\
+		(elm2)->field.tqe_next->field.tqe_prev =		\
+		    &(elm2)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm2)->field.tqe_next;		\
+	(elm2)->field.tqe_prev = (elm)->field.tqe_prev;			\
+	*(elm2)->field.tqe_prev = (elm2);				\
+	_Q_INVALIDATE((elm)->field.tqe_prev);				\
+	_Q_INVALIDATE((elm)->field.tqe_next);				\
+} while (0)
+
+/*
+ * Circular queue definitions.
+ */
+#define CIRCLEQ_HEAD(name, type)					\
+struct name {								\
+	struct type *cqh_first;		/* first element */		\
+	struct type *cqh_last;		/* last element */		\
+}
+
+#define CIRCLEQ_HEAD_INITIALIZER(head)					\
+	{ CIRCLEQ_END(&head), CIRCLEQ_END(&head) }
+
+#define CIRCLEQ_ENTRY(type)						\
+struct {								\
+	struct type *cqe_next;		/* next element */		\
+	struct type *cqe_prev;		/* previous element */		\
+}
+
+/*
+ * Circular queue access methods 
+ */
+#define	CIRCLEQ_FIRST(head)		((head)->cqh_first)
+#define	CIRCLEQ_LAST(head)		((head)->cqh_last)
+#define	CIRCLEQ_END(head)		((void *)(head))
+#define	CIRCLEQ_NEXT(elm, field)	((elm)->field.cqe_next)
+#define	CIRCLEQ_PREV(elm, field)	((elm)->field.cqe_prev)
+#define	CIRCLEQ_EMPTY(head)						\
+	(CIRCLEQ_FIRST(head) == CIRCLEQ_END(head))
+
+#define CIRCLEQ_FOREACH(var, head, field)				\
+	for((var) = CIRCLEQ_FIRST(head);				\
+	    (var) != CIRCLEQ_END(head);					\
+	    (var) = CIRCLEQ_NEXT(var, field))
+
+#define	CIRCLEQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = CIRCLEQ_FIRST(head);				\
+	    (var) != CIRCLEQ_END(head) &&				\
+	    ((tvar) = CIRCLEQ_NEXT(var, field), 1);			\
+	    (var) = (tvar))
+
+#define CIRCLEQ_FOREACH_REVERSE(var, head, field)			\
+	for((var) = CIRCLEQ_LAST(head);					\
+	    (var) != CIRCLEQ_END(head);					\
+	    (var) = CIRCLEQ_PREV(var, field))
+
+#define	CIRCLEQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
+	for ((var) = CIRCLEQ_LAST(head, headname);			\
+	    (var) != CIRCLEQ_END(head) && 				\
+	    ((tvar) = CIRCLEQ_PREV(var, headname, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * Circular queue functions.
+ */
+#define	CIRCLEQ_INIT(head) do {						\
+	(head)->cqh_first = CIRCLEQ_END(head);				\
+	(head)->cqh_last = CIRCLEQ_END(head);				\
+} while (0)
+
+#define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	(elm)->field.cqe_next = (listelm)->field.cqe_next;		\
+	(elm)->field.cqe_prev = (listelm);				\
+	if ((listelm)->field.cqe_next == CIRCLEQ_END(head))		\
+		(head)->cqh_last = (elm);				\
+	else								\
+		(listelm)->field.cqe_next->field.cqe_prev = (elm);	\
+	(listelm)->field.cqe_next = (elm);				\
+} while (0)
+
+#define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {		\
+	(elm)->field.cqe_next = (listelm);				\
+	(elm)->field.cqe_prev = (listelm)->field.cqe_prev;		\
+	if ((listelm)->field.cqe_prev == CIRCLEQ_END(head))		\
+		(head)->cqh_first = (elm);				\
+	else								\
+		(listelm)->field.cqe_prev->field.cqe_next = (elm);	\
+	(listelm)->field.cqe_prev = (elm);				\
+} while (0)
+
+#define CIRCLEQ_INSERT_HEAD(head, elm, field) do {			\
+	(elm)->field.cqe_next = (head)->cqh_first;			\
+	(elm)->field.cqe_prev = CIRCLEQ_END(head);			\
+	if ((head)->cqh_last == CIRCLEQ_END(head))			\
+		(head)->cqh_last = (elm);				\
+	else								\
+		(head)->cqh_first->field.cqe_prev = (elm);		\
+	(head)->cqh_first = (elm);					\
+} while (0)
+
+#define CIRCLEQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.cqe_next = CIRCLEQ_END(head);			\
+	(elm)->field.cqe_prev = (head)->cqh_last;			\
+	if ((head)->cqh_first == CIRCLEQ_END(head))			\
+		(head)->cqh_first = (elm);				\
+	else								\
+		(head)->cqh_last->field.cqe_next = (elm);		\
+	(head)->cqh_last = (elm);					\
+} while (0)
+
+#define	CIRCLEQ_REMOVE(head, elm, field) do {				\
+	if ((elm)->field.cqe_next == CIRCLEQ_END(head))			\
+		(head)->cqh_last = (elm)->field.cqe_prev;		\
+	else								\
+		(elm)->field.cqe_next->field.cqe_prev =			\
+		    (elm)->field.cqe_prev;				\
+	if ((elm)->field.cqe_prev == CIRCLEQ_END(head))			\
+		(head)->cqh_first = (elm)->field.cqe_next;		\
+	else								\
+		(elm)->field.cqe_prev->field.cqe_next =			\
+		    (elm)->field.cqe_next;				\
+	_Q_INVALIDATE((elm)->field.cqe_prev);				\
+	_Q_INVALIDATE((elm)->field.cqe_next);				\
+} while (0)
+
+#define CIRCLEQ_REPLACE(head, elm, elm2, field) do {			\
+	if (((elm2)->field.cqe_next = (elm)->field.cqe_next) ==		\
+	    CIRCLEQ_END(head))						\
+		(head)->cqh_last = (elm2);				\
+	else								\
+		(elm2)->field.cqe_next->field.cqe_prev = (elm2);	\
+	if (((elm2)->field.cqe_prev = (elm)->field.cqe_prev) ==		\
+	    CIRCLEQ_END(head))						\
+		(head)->cqh_first = (elm2);				\
+	else								\
+		(elm2)->field.cqe_prev->field.cqe_next = (elm2);	\
+	_Q_INVALIDATE((elm)->field.cqe_prev);				\
+	_Q_INVALIDATE((elm)->field.cqe_next);				\
+} while (0)
+
+#endif	/* !_SYS_QUEUE_H_ */
diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/core/CMakeLists.txt
@@ -0,0 +1,13 @@
+CONFIGURE_FILE(version.h.in ${CMAKE_CURRENT_BINARY_DIR}/version.h)
+
+ADD_EXECUTABLE(
+    lifxd
+    bulb.c
+    client.c
+    gateway.c
+    lifxd.c
+    log.c
+    wire_proto.c
+)
+
+TARGET_LINK_LIBRARIES(lifxd ${EVENT2_CORE_LIBRARY})
diff --git a/core/bulb.c b/core/bulb.c
new file mode 100644
--- /dev/null
+++ b/core/bulb.c
@@ -0,0 +1,5 @@
+#include <sys/queue.h>
+#include <stdint.h>
+
+#include "wire_proto.h"
+#include "bulb.h"
diff --git a/core/bulb.h b/core/bulb.h
new file mode 100644
--- /dev/null
+++ b/core/bulb.h
@@ -0,0 +1,18 @@
+#pragma once
+
+struct lifxd_light_status {
+    uint16_t    hue;
+    uint16_t    saturation;
+    uint16_t    brightness;
+    uint16_t    kelvin;
+    uint16_t    dim;
+    uint16_t    power;
+    char        label[LIFXD_LABEL_SIZE];
+    uint64_t    tags;
+};
+
+struct lifxd_bulb {
+    SLIST_ENTRY(lifxd_bulb)     link;
+    struct lifxd_light_status   *status;
+};
+SLIST_HEAD(lifxd_bulb_list, lifxd_bulb);
diff --git a/core/client.c b/core/client.c
new file mode 100644
diff --git a/core/client.h b/core/client.h
new file mode 100644
--- /dev/null
+++ b/core/client.h
@@ -0,0 +1,6 @@
+#pragma once
+
+struct lifxd_client {
+    LIST_ENTRY(lifxd_client)    link;
+};
+LIST_HEAD(lifxd_client_list, lifxd_client);
diff --git a/core/gateway.c b/core/gateway.c
new file mode 100644
--- /dev/null
+++ b/core/gateway.c
@@ -0,0 +1,198 @@
+#include <sys/queue.h>
+#include <assert.h>
+#include <err.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <event2/event.h>
+#include <event2/buffer.h>
+#include <event2/bufferevent.h>
+#include <event2/util.h>
+
+#include "wire_proto.h"
+#include "bulb.h"
+#include "gateway.h"
+#include "lifxd.h"
+
+static struct lifxd_gateway_list lifxd_gateways = \
+    LIST_HEAD_INITIALIZER(&lifxd_gateways);
+
+static void
+lifxd_gateway_close(struct lifxd_gateway *gw)
+{
+    assert(gw);
+    assert(gw->io);
+
+    int sockfd = bufferevent_getfd(gw->io);
+    if (sockfd != -1) {
+        evutil_closesocket(sockfd);
+        LIST_REMOVE(gw, link);
+    }
+    bufferevent_free(gw->io);
+    lifxd_info(
+        "connection with gateway bulb [%s]:%hu closed",
+        gw->hostname,
+        gw->port
+    );
+    free(gw->hostname);
+    free(gw);
+}
+
+static void
+lifxd_gateway_event_callback(struct bufferevent *bev, short events, void *ctx)
+{
+    assert(ctx);
+
+    struct lifxd_gateway *gw = (struct lifxd_gateway *)ctx;
+    if (events & BEV_EVENT_CONNECTED) {
+        lifxd_info(
+            "connected to gateway bulb: [%s]:%hu", gw->hostname, gw->port
+        );
+        LIST_INSERT_HEAD(&lifxd_gateways, gw, link);
+        bufferevent_enable(bev, EV_READ|EV_WRITE|EV_TIMEOUT);
+        lifxd_gateway_get_light_status(gw);
+    } else if (events & (BEV_EVENT_ERROR|BEV_EVENT_EOF)) {
+        if (events & BEV_EVENT_ERROR) {
+            int gai_error = bufferevent_socket_get_dns_error(gw->io);
+            if (gai_error) {
+                lifxd_warnx(
+                    "can't connect to %s: %s",
+                    gw->hostname,
+                    evutil_gai_strerror(gai_error)
+                );
+            } else {
+                lifxd_warn(
+                    "lost connection with gateway bulb [%s]:%hu",
+                    gw->hostname,
+                    gw->port
+                );
+            }
+        }
+        lifxd_gateway_close(gw);
+    }
+}
+
+static void
+lifxd_gateway_data_read_callback(struct bufferevent *bev, void *ctx)
+{
+    assert(ctx);
+
+    struct lifxd_gateway *gw = (struct lifxd_gateway *)ctx;
+    struct lifxd_packet_header *cur_hdr = &gw->cur_hdr;
+    void *cur_pkt = gw->cur_pkt;
+
+    if (gw->cur_hdr_offset != LIFXD_PACKET_HEADER_SIZE) {
+        gw->cur_hdr_offset += bufferevent_read(
+            bev,
+            ((void *)cur_hdr) + gw->cur_hdr_offset,
+            LIFXD_PACKET_HEADER_SIZE - gw->cur_hdr_offset
+        );
+        if (gw->cur_hdr_offset == LIFXD_PACKET_HEADER_SIZE) {
+            lifxd_wire_decode_header(cur_hdr);
+            lifxd_wire_dump_header(cur_hdr);
+        }
+    }
+
+    if (gw->cur_hdr_offset == LIFXD_PACKET_HEADER_SIZE
+        && gw->cur_pkt_offset != gw->cur_pkt_size) {
+        gw->cur_pkt_offset += bufferevent_read(
+            bev,
+            cur_pkt + gw->cur_pkt_offset,
+            gw->cur_pkt_size - gw->cur_pkt_offset
+        );
+
+        return;
+    }
+
+    lifxd_warnx(
+        "read event on [%s]:%hu while handling a packet already",
+        gw->hostname,
+        gw->port
+    );
+}
+
+bool
+lifxd_gateway_open(const char *hostname, uint16_t port)
+{
+    assert(hostname);
+    assert(port < UINT16_MAX);
+    assert(port > 0);
+
+    struct lifxd_gateway *gw = calloc(1, sizeof(*gw));
+    if (!gw) {
+        lifxd_warn("can't allocate a new gateway bulb");
+        return false;
+    }
+    gw->io = bufferevent_socket_new(lifxd_ev_base, -1, 0);
+    if (!gw->io) {
+        lifxd_warn("can't allocate a new gateway bulb");
+        goto bev_alloc_error;
+    }
+    gw->hostname = strdup(hostname);
+    if (!gw->hostname) {
+        lifxd_warn("can't allocate a new gateway bulb");
+        goto hostname_alloc_error;
+    }
+    gw->port = port;
+    bufferevent_setcb(
+        gw->io,
+        lifxd_gateway_data_read_callback,
+        NULL,
+        lifxd_gateway_event_callback,
+        gw
+    );
+
+    int error = bufferevent_socket_connect_hostname(
+        gw->io, NULL, AF_UNSPEC, hostname, port
+    );
+    if (!error) {
+        return true;
+    }
+
+    free(gw->hostname);
+hostname_alloc_error:
+    bufferevent_free(gw->io);
+bev_alloc_error:
+    free(gw);
+    return false;
+}
+
+bool
+lifxd_gateway_discover_all(void)
+{
+    return false;
+}
+
+void
+lifxd_gateway_close_all(void)
+{
+    struct lifxd_gateway *gw, *next_gw;
+    LIST_FOREACH_SAFE(gw, &lifxd_gateways, link, next_gw) {
+        lifxd_gateway_close(gw);
+    }
+}
+
+void
+lifxd_gateway_get_light_status(struct lifxd_gateway *gw)
+{
+    assert(gw);
+
+    struct lifxd_packet_header hdr = {
+        .size = LIFXD_PACKET_HEADER_SIZE,
+        .protocol = 13312,
+        .reserved1 = { 0 },
+        .bulb_addr = { 0 },
+        .reserved2 = { 0 },
+        .gw_addr = { 0. },
+        .reserved3 = { 0 },
+        .timestamp = 0,
+        .packet_type = LIFXD_GET_LIGHT_STATE,
+        .reserved4 = { 0 }
+    };
+    lifxd_wire_encode_header(&hdr);
+    lifxd_debug("GET_LIGHT_STATE â†’ [%s]:%hu", gw->hostname, gw->port);
+    bufferevent_write(gw->io, &hdr, sizeof(hdr));
+}
diff --git a/core/gateway.h b/core/gateway.h
new file mode 100644
--- /dev/null
+++ b/core/gateway.h
@@ -0,0 +1,22 @@
+#pragma once
+
+struct lifxd_gateway {
+    LIST_ENTRY(lifxd_gateway)  link;
+    char                        *hostname;
+    uint16_t                    port;
+    struct bufferevent          *io;
+    uint8_t                     addr[LIFXD_ADDR_LENGTH];
+    struct lifxd_bulb_list      *bulbs;
+    struct lifxd_packet_header  cur_hdr;
+    unsigned                    cur_hdr_offset;
+    void                        *cur_pkt;
+    unsigned                    cur_pkt_offset;
+    unsigned                    cur_pkt_size;
+};
+LIST_HEAD(lifxd_gateway_list, lifxd_gateway);
+
+bool lifxd_gateway_discover_all(void);
+bool lifxd_gateway_open(const char *, uint16_t);
+void lifxd_gateway_close_all(void);
+
+void lifxd_gateway_get_light_status(struct lifxd_gateway *);
diff --git a/core/json_proto.h b/core/json_proto.h
new file mode 100644
diff --git a/core/lifxd.c b/core/lifxd.c
new file mode 100644
--- /dev/null
+++ b/core/lifxd.c
@@ -0,0 +1,139 @@
+#include <sys/queue.h>
+#include <err.h>
+#include <errno.h>
+#include <getopt.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <strings.h>
+
+#include <event2/event.h>
+
+#include "wire_proto.h"
+#include "gateway.h"
+#include "version.h"
+#include "lifxd.h"
+
+struct lifxd_opts lifxd_opts = {
+    .foreground = false,
+    .master_host = NULL,
+    .master_port = 56700,
+    .verbosity = LIFXD_DEBUG
+}; 
+
+struct event_base *lifxd_ev_base = NULL;
+
+void
+lifxd_cleanup(void)
+{
+    lifxd_gateway_close_all();
+    event_base_free(lifxd_ev_base);
+#if LIBEVENT_VERSION_NUMBER >= 0x02010100
+    libevent_global_shutdown();
+#endif
+}
+
+static void
+lifxd_configure_libevent(void)
+{
+    lifxd_gateway_close_all();
+    event_set_log_callback(lifxd_libevent_log);
+#ifndef NDEBUG
+    // NOTE: let's keep in mind that we need to call event_debug_unassign when
+    // using that and event_assign:
+    event_enable_debug_mode();
+#endif
+    lifxd_ev_base = event_base_new();
+}
+
+static void
+lifxd_usage(const char *progname)
+{
+    printf(
+        "Usage: %s [-m master_bulb_host] [-p master_bulb_port] "
+        "[-v debug|info|warning|error] [-f] [-h] [-V]\n",
+        progname
+    );
+    exit(0);
+}
+
+int
+main(int argc, char *argv[])
+{
+    static const struct option opts[] = {
+        {"foreground",  no_argument,       NULL, 'f'},
+        {"help",        no_argument,       NULL, 'h'},
+        {"master-host", required_argument, NULL, 'm'},
+        {"master-port", required_argument, NULL, 'p'},
+        {"verbosity",   required_argument, NULL, 'v'},
+        {"version",     no_argument,       NULL, 'V'},
+        {NULL,          0,                 NULL, 0}
+    };
+
+    for (int rv = getopt_long(argc, argv, "fhm:p:v:V", opts, NULL);
+         rv != -1;
+         rv = getopt_long(argc, argv, "fh:p:v:V", opts, NULL)) {
+        switch (rv) {
+        case 'f':
+            lifxd_opts.foreground = true;
+            break ;
+        case 'h':
+            lifxd_usage(argv[0]);
+        case 'm':
+            lifxd_opts.master_host = optarg;
+            break ;
+        case 'p':
+            errno = 0;
+            long port = strtol(optarg, NULL, 10);
+            if (!errno && port <= UINT16_MAX && port > 0) {
+                lifxd_opts.master_port = port;
+                break ;
+            }
+            lifxd_errx(
+                1, "The master port must be between 1 and %d", UINT16_MAX
+            );
+        case 'v':
+            for (int i = 0;;) {
+                const char *verbose_levels[] = {
+                    "debug", "info", "warning", "error"
+                };
+                if (!strcasecmp(optarg, verbose_levels[i])) {
+                    lifxd_opts.verbosity = i;
+                    break ;
+                }
+                if (++i == LIFXD_ARRAY_SIZE(verbose_levels)) {
+                    lifxd_errx(1, "Unknown verbosity level: %s", optarg);
+                }
+            }
+            break ;
+        case 'V':
+            printf("%s v%s\n", argv[0], LIFXD_VERSION);
+            return 0;
+        default:
+            lifxd_usage(argv[0]);
+        }
+    }
+
+    argc -= optind;
+    argv += optind;
+
+    lifxd_configure_libevent();
+
+    if (lifxd_opts.master_host) {
+        bool ok = lifxd_gateway_open(
+            lifxd_opts.master_host, lifxd_opts.master_port
+        );
+        if (!ok)
+            lifxd_errx(1, "no bulb to connect to");
+    } else {
+        lifxd_errx(1, "automatic discovery isn't supported yet");
+    }
+
+    event_base_dispatch(lifxd_ev_base);
+
+    lifxd_cleanup();
+
+    return 0;
+}
diff --git a/core/lifxd.h b/core/lifxd.h
new file mode 100644
--- /dev/null
+++ b/core/lifxd.h
@@ -0,0 +1,34 @@
+#pragma once
+
+#define LIFXD_ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+
+enum lifxd_verbosity {
+    LIFXD_DEBUG = 0,
+    LIFXD_INFO,
+    LIFXD_WARN,
+    LIFXD_ERR
+};
+
+struct lifxd_opts {
+    bool                    foreground;
+    const char              *master_host;
+    uint16_t                master_port;
+    enum lifxd_verbosity    verbosity;
+};
+
+extern struct lifxd_opts lifxd_opts;
+extern struct event_base *lifxd_ev_base;
+
+void _lifxd_err(void (*)(int, const char *, va_list), int, const char *, ...);
+#define lifxd_err(eval, fmt, ...) _lifxd_err(verr, (eval), (fmt), ##__VA_ARGS__);
+#define lifxd_errx(eval, fmt, ...) _lifxd_err(verrx, (eval), (fmt), ##__VA_ARGS__);
+void _lifxd_warn(void (*)(const char *, va_list), const char *, ...);
+#define lifxd_warn(fmt, ...) _lifxd_warn(vwarn, (fmt), ##__VA_ARGS__);
+#define lifxd_warnx(fmt, ...) _lifxd_warn(vwarnx, (fmt), ##__VA_ARGS__);
+void lifxd_info(const char *, ...);
+void lifxd_debug(const char *, ...);
+void lifxd_libevent_log(int, const char *);
+
+#define lifxd_nop (void)0
+
+void lifxd_cleanup(void);
diff --git a/core/log.c b/core/log.c
new file mode 100644
--- /dev/null
+++ b/core/log.c
@@ -0,0 +1,75 @@
+#include <err.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#include <event2/event.h>
+
+#include "lifxd.h"
+
+void
+_lifxd_err(void (*errfn)(int, const char *, va_list),
+           int eval,
+           const char *fmt,
+           ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+    int errsave = errno;
+    lifxd_cleanup();
+    errno = errsave;
+    fprintf(stderr, "[ERR] ");
+    errfn(eval, fmt, ap);
+}
+
+void
+_lifxd_warn(void (*warnfn)(const char *, va_list), const char *fmt, ...)
+{
+    if (lifxd_opts.verbosity <= LIFXD_WARN) {
+        va_list ap;
+        va_start(ap, fmt);
+        fprintf(stderr, "[WARN] ");
+        warnfn(fmt, ap);
+        va_end(ap);
+    }
+}
+
+void
+lifxd_info(const char *fmt, ...)
+{
+    if (lifxd_opts.verbosity <= LIFXD_INFO) {
+        va_list ap;
+        va_start(ap, fmt);
+        fprintf(stderr, "[INFO] lifxd: ");
+        vfprintf(stderr, fmt, ap);
+        va_end(ap);
+        fprintf(stderr, "\n");
+    }
+}
+
+void
+lifxd_debug(const char *fmt, ...)
+{
+    if (lifxd_opts.verbosity <= LIFXD_DEBUG) {
+        va_list ap;
+        va_start(ap, fmt);
+        fprintf(stderr, "[DEBUG] lifxd: ");
+        vfprintf(stderr, fmt, ap);
+        va_end(ap);
+        fprintf(stderr, "\n");
+    }
+}
+
+void
+lifxd_libevent_log(int severity, const char *msg)
+{
+    switch (severity) {
+    case EVENT_LOG_DEBUG:   lifxd_debug(msg);   break;
+    case EVENT_LOG_MSG:     lifxd_info(msg);    break;
+    case EVENT_LOG_WARN:    lifxd_warnx(msg)    break;
+    case EVENT_LOG_ERR:     lifxd_warnx(msg);   break;
+    default:                                    break;
+    }
+}
diff --git a/core/version.h.in b/core/version.h.in
new file mode 100644
--- /dev/null
+++ b/core/version.h.in
@@ -0,0 +1,3 @@
+#pragma once
+
+const char LIFXD_VERSION[] = "@LIFXD_VERSION@";
diff --git a/core/wire_proto.c b/core/wire_proto.c
new file mode 100644
--- /dev/null
+++ b/core/wire_proto.c
@@ -0,0 +1,69 @@
+#include <assert.h>
+#include <endian.h>
+#include <err.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "wire_proto.h"
+#include "lifxd.h"
+
+// Convert all the fields in the header to the host endianness.
+//
+// :returns: The payload size or -1 if the header is invalid.
+int
+lifxd_wire_decode_header(struct lifxd_packet_header *hdr)
+{
+    assert(hdr);
+
+    hdr->size = le16toh(hdr->size);
+    hdr->protocol = be16toh(hdr->protocol);
+    hdr->timestamp = be64toh(hdr->timestamp);
+    hdr->packet_type = le16toh(hdr->packet_type);
+
+    return -1;
+}
+
+void
+lifxd_wire_encode_header(struct lifxd_packet_header *hdr)
+{
+    assert(hdr);
+
+    hdr->size = htole16(hdr->size);
+    hdr->protocol = htobe16(hdr->protocol);
+    hdr->timestamp = htobe64(hdr->timestamp);
+    hdr->packet_type = htole16(hdr->packet_type);
+}
+
+void
+lifxd_wire_dump_header(const struct lifxd_packet_header *hdr)
+{
+    assert(hdr);
+    lifxd_debug(
+        "header @%p: size=%hu, protocol=%hu, timestamp=%lu, packet_type=%hx",
+        hdr, hdr->size, hdr->protocol, hdr->timestamp, hdr->packet_type
+    );
+}
+
+void
+lifxd_wire_encode_packet(void *data, enum lifxd_packet_type packet_type)
+{
+    assert(data);
+
+    switch (packet_type) {
+    case LIFXD_GET_LIGHT_STATE:
+        lifxd_nop;
+        struct lifxd_packet_light_status *pkt = data;
+        pkt->hue = htole16(pkt->hue);
+        pkt->saturation = htole16(pkt->saturation);
+        pkt->brightness = htole16(pkt->brightness);
+        pkt->kelvin = htole16(pkt->kelvin);
+        pkt->dim = htole16(pkt->dim);
+        pkt->power = htole16(pkt->power);
+        pkt->tags = htobe64(pkt->tags);
+        break;
+    default:
+        lifxd_warnx("can't encode packet type: %x", packet_type);
+        break;
+    }
+}
diff --git a/core/wire_proto.h b/core/wire_proto.h
new file mode 100644
--- /dev/null
+++ b/core/wire_proto.h
@@ -0,0 +1,99 @@
+#pragma once
+
+#pragma pack(push, 1)
+
+typedef uint16_t uint16le_t;
+typedef uint16_t uint16be_t;
+typedef uint32_t uint32le_t;
+typedef uint32_t uint32be_t;
+typedef uint64_t uint64le_t;
+typedef uint64_t uint64be_t;
+
+enum { LIFXD_ADDR_LENGTH = 6 };
+
+struct lifxd_packet_header {
+    uint16le_t  size;
+    uint16be_t  protocol;
+    uint8_t     reserved1[4];
+    uint8_t     bulb_addr[LIFXD_ADDR_LENGTH];
+    uint8_t     reserved2[2];
+    uint8_t     gw_addr[LIFXD_ADDR_LENGTH];
+    uint8_t     reserved3[2];
+    uint64be_t  timestamp;
+    uint16le_t  packet_type;
+    uint8_t     reserved4[2];
+};
+
+enum { LIFXD_PACKET_HEADER_SIZE = sizeof(struct lifxd_packet_header) };
+
+enum lifxd_packet_type {
+    LIFXD_GET_PAN_GATEWAY = 0x02,
+    LIFXD_PAN_GATEWAY = 0x03,
+    LIFXD_GET_TIME = 0x04,
+    LIFXD_SET_TIME = 0x05,
+    LIFXD_TIME_STATE = 0x06,
+    LIFXD_GET_RESET_SWITCH_STATE = 0x07,
+    LIFXD_RESET_SWITCH_STATE = 0x08,
+    LIFXD_GET_MESH_INFO = 0x0c,
+    LIFXD_MESH_INFO = 0x0d,
+    LIFXD_GET_MESH_FIRMWARE = 0x0e,
+    LIFXD_MESH_FIRMWARE = 0x0f,
+    LIFXD_GET_WIFI_INFO = 0x10,
+    LIFXD_WIFI_INFO = 0x11,
+    LIFXD_GET_WIFI_FIRMWARE_STATE = 0x12,
+    LIFXD_WIFI_FIRMWARE_STATE = 0x13,
+    LIFXD_GET_POWER_STATE = 0x14,
+    LIFXD_SET_POWER_STATE = 0x15,
+    LIFXD_POWER_STATE = 0x16,
+    LIFXD_GET_BULB_LABEL = 0x17,
+    LIFXD_SET_BULB_LABEL = 0x18,
+    LIFXD_BULB_LABEL = 0x19,
+    LIFXD_GET_TAGS = 0x1a,
+    LIFXD_SET_TAGS = 0x1b,
+    LIFXD_TAGS = 0x1c,
+    LIFXD_GET_TAG_LABELS = 0x1d,
+    LIFXD_SET_TAG_LABELS = 0x1e,
+    LIFXD_TAG_LABELS = 0x1f,
+    LIFXD_GET_VERSION = 0x20,
+    LIFXD_VERSION_STATE = 0x21,
+    LIFXD_GET_INFO = 0x22,
+    LIFXD_INFO_STATE = 0x23,
+    LIFXD_GET_MCU_RAIL_VOLTAGE = 0x24,
+    LIFXD_MCU_RAIL_VOLTAGE = 0x25,
+    LIFXD_REBOOT = 0x26,
+    LIFXD_SET_FACTORY_TEST_MODE = 0x27,
+    LIFXD_DISABLE_FACTORY_TEST_MODE = 0x28,
+    LIFXD_GET_LIGHT_STATE = 0x65,
+    LIFXD_SET_LIGHT_COLOUR = 0x66,
+    LIFXD_SET_WAVEFORM = 0x67,
+    LIFXD_SET_DIM_ABSOLUTE = 0x68,
+    LIFXD_SET_DIM_RELATIVE = 0x69,
+    LIFXD_LIGHT_STATUS = 0x6b,
+    LIFXD_GET_WIFI_STATE = 0x12d,
+    LIFXD_SET_WIFI_STATE = 0x12e,
+    LIFXD_WIFI_STATE = 0x12f,
+    LIFXD_GET_ACCESS_POINTS = 0x130,
+    LIFXD_SET_ACCESS_POINTS = 0x131,
+    LIFXD_ACCESS_POINT = 0x132,
+};
+
+enum { LIFXD_LABEL_SIZE = 32 };
+
+struct lifxd_packet_light_status {
+    uint16le_t  hue;
+    uint16le_t  saturation;
+    uint16le_t  brightness;
+    uint16le_t  kelvin;
+    uint16le_t  dim;
+    uint16le_t  power;
+    uint8_t     label[LIFXD_LABEL_SIZE];
+    uint64be_t  tags;
+};
+
+int lifxd_wire_decode_header(struct lifxd_packet_header *);
+void lifxd_wire_encode_header(struct lifxd_packet_header *);
+void lifxd_wire_dump_header(const struct lifxd_packet_header *);
+void lifxd_wire_encode_packet(void *, enum lifxd_packet_type);
+void lifxd_wire_decode_packet(void *, enum lifxd_packet_type);
+
+#pragma pack(pop)
