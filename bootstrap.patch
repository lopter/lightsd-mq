# HG changeset patch
# Parent 0000000000000000000000000000000000000000

diff --git a/.hgignore b/.hgignore
new file mode 100644
--- /dev/null
+++ b/.hgignore
@@ -0,0 +1,3 @@
+.*\.sw[p-z]$
+.*\.py[co]$
+^build
diff --git a/.ycm_extra_conf.py b/.ycm_extra_conf.py
new file mode 100644
--- /dev/null
+++ b/.ycm_extra_conf.py
@@ -0,0 +1,148 @@
+# This file is NOT licensed under the GPLv3, which is the license for the rest
+# of YouCompleteMe.
+#
+# Here's the license text for this file:
+#
+# This is free and unencumbered software released into the public domain.
+#
+# Anyone is free to copy, modify, publish, use, compile, sell, or
+# distribute this software, either in source code form or as a compiled
+# binary, for any purpose, commercial or non-commercial, and by any
+# means.
+#
+# In jurisdictions that recognize copyright laws, the author or authors
+# of this software dedicate any and all copyright interest in the
+# software to the public domain. We make this dedication for the benefit
+# of the public at large and to the detriment of our heirs and
+# successors. We intend this dedication to be an overt act of
+# relinquishment in perpetuity of all present and future rights to this
+# software under copyright law.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+# OTHER DEALINGS IN THE SOFTWARE.
+#
+# For more information, please refer to <http://unlicense.org/>
+
+import os
+import ycm_core
+
+# These are the compilation flags that will be used in case there's no
+# compilation database set (by default, one is not set).
+# CHANGE THIS LIST OF FLAGS. YES, THIS IS THE DROID YOU HAVE BEEN LOOKING FOR.
+flags = [
+    '-Wall',
+    '-Wextra',
+    '-Werror',
+    '-Wstrict-prototypes',
+    '-std=c99',
+    '-D_POSIX_C_SOURCE=200809L',
+    '-D_BSD_SOURCE=1',
+    '-I./compat',
+    '-I./core',
+    '-I{}'.format(os.path.join(os.getenv("MY_BUILD", "./build"), "core")),
+]
+
+
+# Set this to the absolute path to the folder (NOT the file!) containing the
+# compile_commands.json file to use that instead of 'flags'. See here for
+# more details: http://clang.llvm.org/docs/JSONCompilationDatabase.html
+#
+# Most projects will NOT need to set this to anything; you can just change the
+# 'flags' list of compilation flags. Notice that YCM itself uses that approach.
+compilation_database_folder = ''
+
+if os.path.exists( compilation_database_folder ):
+  database = ycm_core.CompilationDatabase( compilation_database_folder )
+else:
+  database = None
+
+SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', '.m', '.mm' ]
+
+def DirectoryOfThisScript():
+  return os.path.dirname( os.path.abspath( __file__ ) )
+
+
+def MakeRelativePathsInFlagsAbsolute( flags, working_directory ):
+  if not working_directory:
+    return list( flags )
+  new_flags = []
+  make_next_absolute = False
+  path_flags = [ '-isystem', '-I', '-iquote', '--sysroot=' ]
+  for flag in flags:
+    new_flag = flag
+
+    if make_next_absolute:
+      make_next_absolute = False
+      if not flag.startswith( '/' ):
+        new_flag = os.path.join( working_directory, flag )
+
+    for path_flag in path_flags:
+      if flag == path_flag:
+        make_next_absolute = True
+        break
+
+      if flag.startswith( path_flag ):
+        path = flag[ len( path_flag ): ]
+        new_flag = path_flag + os.path.join( working_directory, path )
+        break
+
+    if new_flag:
+      new_flags.append( new_flag )
+  return new_flags
+
+
+def IsHeaderFile( filename ):
+  extension = os.path.splitext( filename )[ 1 ]
+  return extension in [ '.h', '.hxx', '.hpp', '.hh' ]
+
+
+def GetCompilationInfoForFile( filename ):
+  # The compilation_commands.json file generated by CMake does not have entries
+  # for header files. So we do our best by asking the db for flags for a
+  # corresponding source file, if any. If one exists, the flags for that file
+  # should be good enough.
+  if IsHeaderFile( filename ):
+    basename = os.path.splitext( filename )[ 0 ]
+    for extension in SOURCE_EXTENSIONS:
+      replacement_file = basename + extension
+      if os.path.exists( replacement_file ):
+        compilation_info = database.GetCompilationInfoForFile(
+          replacement_file )
+        if compilation_info.compiler_flags_:
+          return compilation_info
+    return None
+  return database.GetCompilationInfoForFile( filename )
+
+
+def FlagsForFile( filename, **kwargs ):
+  if database:
+    # Bear in mind that compilation_info.compiler_flags_ does NOT return a
+    # python list, but a "list-like" StringVec object
+    compilation_info = GetCompilationInfoForFile( filename )
+    if not compilation_info:
+      return None
+
+    final_flags = MakeRelativePathsInFlagsAbsolute(
+      compilation_info.compiler_flags_,
+      compilation_info.compiler_working_dir_ )
+
+    # NOTE: This is just for YouCompleteMe; it's highly likely that your project
+    # does NOT need to remove the stdlib flag. DO NOT USE THIS IN YOUR
+    # ycm_extra_conf IF YOU'RE NOT 100% SURE YOU NEED IT.
+    try:
+      final_flags.remove( '-stdlib=libc++' )
+    except ValueError:
+      pass
+  else:
+    relative_to = DirectoryOfThisScript()
+    final_flags = MakeRelativePathsInFlagsAbsolute( flags, relative_to )
+
+  return {
+    'flags': final_flags,
+    'do_cache': True
+  }
diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,38 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
+
+PROJECT(LIFXD C)
+
+SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${LIFXD_SOURCE_DIR}/CMakeScripts)
+
+SET(CPACK_PACKAGE_VERSION_MAJOR "0")
+SET(CPACK_PACKAGE_VERSION_MINOR "0")
+SET(CPACK_PACKAGE_VERSION_PATCH "1")
+SET(LIFXD_VERSION "${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}")
+
+MESSAGE(STATUS "CMake version: ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}")
+MESSAGE(STATUS "lifxd version: ${LIFXD_VERSION}")
+MESSAGE(STATUS "Build type: ${CMAKE_BUILD_TYPE}")
+MESSAGE(STATUS "System: ${CMAKE_SYSTEM_NAME} ${CMAKE_SYSTEM_VERSION}")
+MESSAGE(STATUS "Install prefix: ${CMAKE_INSTALL_PREFIX}")
+MESSAGE(STATUS "Source directory: ${LIFXD_SOURCE_DIR}")
+
+# TODO: we need at least 2.0.19-stable because of the logging defines
+FIND_PACKAGE(Event2 REQUIRED COMPONENTS core)
+FIND_PACKAGE(Endian REQUIRED)
+
+SET(CMAKE_C_FLAGS "-pipe -Wextra -Wall -Wstrict-prototypes -std=c99")
+
+ADD_DEFINITIONS("-D_POSIX_C_SOURCE=200809L" "-D_BSD_SOURCE=1")
+
+IF (CMAKE_BUILD_TYPE MATCHES "DEBUG")
+    ADD_DEFINITIONS("-DQUEUE_MACRO_DEBUG=1")
+ENDIF ()
+
+INCLUDE_DIRECTORIES(
+    ${LIFXD_SOURCE_DIR}/compat/generic
+    ${LIFXD_BINARY_DIR}/compat
+    ${LIFXD_SOURCE_DIR}/core
+    ${LIFXD_BINARY_DIR}/core
+)
+
+ADD_SUBDIRECTORY(core)
diff --git a/CMakeScripts/FindEndian.cmake b/CMakeScripts/FindEndian.cmake
new file mode 100644
--- /dev/null
+++ b/CMakeScripts/FindEndian.cmake
@@ -0,0 +1,20 @@
+INCLUDE(CheckIncludeFile)
+
+SET(COMPAT_ENDIAN_H "${LIFXD_SOURCE_DIR}/compat/${CMAKE_SYSTEM_NAME}/endian.h")
+
+IF (NOT ENDIAN_H_PATH)
+    CHECK_INCLUDE_FILE("endian.h" HAVE_ENDIAN_H)
+
+    IF (HAVE_ENDIAN_H)
+        SET(ENDIAN_H_PATH "using native header" CACHE INTERNAL "endian.h path")
+    ELSEIF (EXISTS "${COMPAT_ENDIAN_H}")
+        FILE(
+            COPY "${COMPAT_ENDIAN_H}"
+            DESTINATION "${LIFXD_BINARY_DIR}/compat/"
+        )
+        MESSAGE(STATUS "Using compatibility endian.h for ${CMAKE_SYSTEM_NAME}")
+        SET(ENDIAN_H_PATH "${COMPAT_ENDIAN_H}" CACHE INTERNAL "endian.h path")
+    ENDIF ()
+ENDIF ()
+
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(Endian DEFAULT_MSG ENDIAN_H_PATH)
diff --git a/CMakeScripts/FindEvent2.cmake b/CMakeScripts/FindEvent2.cmake
new file mode 100644
--- /dev/null
+++ b/CMakeScripts/FindEvent2.cmake
@@ -0,0 +1,18 @@
+FOREACH (COMPONENT ${Event2_FIND_COMPONENTS})
+    STRING(TOUPPER ${COMPONENT} UPPER_COMPONENT)
+    FIND_LIBRARY(EVENT2_${UPPER_COMPONENT}_LIBRARY event_${COMPONENT})
+    IF (EVENT2_${UPPER_COMPONENT}_LIBRARY)
+        SET(Event2_${COMPONENT}_FOUND TRUE)
+    ENDIF ()
+ENDFOREACH ()
+
+FIND_PATH(EVENT2_INCLUDE_DIR event2/event.h)
+
+INCLUDE(FindPackageHandleStandardArgs)
+
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(
+    Event2
+    FOUND_VAR Event2_FOUND
+    HANDLE_COMPONENTS
+    REQUIRED_VARS EVENT2_CORE_LIBRARY EVENT2_INCLUDE_DIR
+)
diff --git a/compat/Darwin/endian.h b/compat/Darwin/endian.h
new file mode 100644
--- /dev/null
+++ b/compat/Darwin/endian.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include <libkern/OSByteOrder.h>
+
+#define htobe16(x) OSSwapHostToBigInt16(x)
+#define htole16(x) OSSwapHostToLittleInt16(x)
+#define be16toh(x) OSSwapBigToHostInt16(x)
+#define le16toh(x) OSSwapLittleToHostInt16(x)
+
+#define htobe32(x) OSSwapHostToBigInt32(x)
+#define htole32(x) OSSwapHostToLittleInt32(x)
+#define be32toh(x) OSSwapBigToHostInt32(x)
+#define le32toh(x) OSSwapLittleToHostInt32(x)
+
+#define htobe64(x) OSSwapHostToBigInt64(x)
+#define htole64(x) OSSwapHostToLittleInt64(x)
+#define be64toh(x) OSSwapBigToHostInt64(x)
+#define le64toh(x) OSSwapLittleToHostInt64(x)
diff --git a/compat/generic/sys/queue.h b/compat/generic/sys/queue.h
new file mode 100644
--- /dev/null
+++ b/compat/generic/sys/queue.h
@@ -0,0 +1,648 @@
+/*	$OpenBSD: queue.h,v 1.38 2013/07/03 15:05:21 fgsch Exp $	*/
+/*	$NetBSD: queue.h,v 1.11 1996/05/16 05:17:14 mycroft Exp $	*/
+
+/*
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)queue.h	8.5 (Berkeley) 8/20/94
+ */
+
+#ifndef	_SYS_QUEUE_H_
+#define	_SYS_QUEUE_H_
+
+/*
+ * This file defines five types of data structures: singly-linked lists, 
+ * lists, simple queues, tail queues, and circular queues.
+ *
+ *
+ * A singly-linked list is headed by a single forward pointer. The elements
+ * are singly linked for minimum space and pointer manipulation overhead at
+ * the expense of O(n) removal for arbitrary elements. New elements can be
+ * added to the list after an existing element or at the head of the list.
+ * Elements being removed from the head of the list should use the explicit
+ * macro for this purpose for optimum efficiency. A singly-linked list may
+ * only be traversed in the forward direction.  Singly-linked lists are ideal
+ * for applications with large datasets and few or no removals or for
+ * implementing a LIFO queue.
+ *
+ * A list is headed by a single forward pointer (or an array of forward
+ * pointers for a hash table header). The elements are doubly linked
+ * so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before
+ * or after an existing element or at the head of the list. A list
+ * may only be traversed in the forward direction.
+ *
+ * A simple queue is headed by a pair of pointers, one the head of the
+ * list and the other to the tail of the list. The elements are singly
+ * linked to save space, so elements can only be removed from the
+ * head of the list. New elements can be added to the list before or after
+ * an existing element, at the head of the list, or at the end of the
+ * list. A simple queue may only be traversed in the forward direction.
+ *
+ * A tail queue is headed by a pair of pointers, one to the head of the
+ * list and the other to the tail of the list. The elements are doubly
+ * linked so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before or
+ * after an existing element, at the head of the list, or at the end of
+ * the list. A tail queue may be traversed in either direction.
+ *
+ * A circle queue is headed by a pair of pointers, one to the head of the
+ * list and the other to the tail of the list. The elements are doubly
+ * linked so that an arbitrary element can be removed without a need to
+ * traverse the list. New elements can be added to the list before or after
+ * an existing element, at the head of the list, or at the end of the list.
+ * A circle queue may be traversed in either direction, but has a more
+ * complex end of list detection.
+ *
+ * For details on the use of these macros, see the queue(3) manual page.
+ */
+
+#if defined(QUEUE_MACRO_DEBUG) || (defined(_KERNEL) && defined(DIAGNOSTIC))
+#define _Q_INVALIDATE(a) (a) = ((void *)-1)
+#else
+#define _Q_INVALIDATE(a)
+#endif
+
+/*
+ * Singly-linked List definitions.
+ */
+#define SLIST_HEAD(name, type)						\
+struct name {								\
+	struct type *slh_first;	/* first element */			\
+}
+ 
+#define	SLIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+ 
+#define SLIST_ENTRY(type)						\
+struct {								\
+	struct type *sle_next;	/* next element */			\
+}
+ 
+/*
+ * Singly-linked List access methods.
+ */
+#define	SLIST_FIRST(head)	((head)->slh_first)
+#define	SLIST_END(head)		NULL
+#define	SLIST_EMPTY(head)	(SLIST_FIRST(head) == SLIST_END(head))
+#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)
+
+#define	SLIST_FOREACH(var, head, field)					\
+	for((var) = SLIST_FIRST(head);					\
+	    (var) != SLIST_END(head);					\
+	    (var) = SLIST_NEXT(var, field))
+
+#define	SLIST_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = SLIST_FIRST(head);				\
+	    (var) && ((tvar) = SLIST_NEXT(var, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * Singly-linked List functions.
+ */
+#define	SLIST_INIT(head) {						\
+	SLIST_FIRST(head) = SLIST_END(head);				\
+}
+
+#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
+	(elm)->field.sle_next = (slistelm)->field.sle_next;		\
+	(slistelm)->field.sle_next = (elm);				\
+} while (0)
+
+#define	SLIST_INSERT_HEAD(head, elm, field) do {			\
+	(elm)->field.sle_next = (head)->slh_first;			\
+	(head)->slh_first = (elm);					\
+} while (0)
+
+#define	SLIST_REMOVE_AFTER(elm, field) do {				\
+	(elm)->field.sle_next = (elm)->field.sle_next->field.sle_next;	\
+} while (0)
+
+#define	SLIST_REMOVE_HEAD(head, field) do {				\
+	(head)->slh_first = (head)->slh_first->field.sle_next;		\
+} while (0)
+
+#define SLIST_REMOVE(head, elm, type, field) do {			\
+	if ((head)->slh_first == (elm)) {				\
+		SLIST_REMOVE_HEAD((head), field);			\
+	} else {							\
+		struct type *curelm = (head)->slh_first;		\
+									\
+		while (curelm->field.sle_next != (elm))			\
+			curelm = curelm->field.sle_next;		\
+		curelm->field.sle_next =				\
+		    curelm->field.sle_next->field.sle_next;		\
+		_Q_INVALIDATE((elm)->field.sle_next);			\
+	}								\
+} while (0)
+
+/*
+ * List definitions.
+ */
+#define LIST_HEAD(name, type)						\
+struct name {								\
+	struct type *lh_first;	/* first element */			\
+}
+
+#define LIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define LIST_ENTRY(type)						\
+struct {								\
+	struct type *le_next;	/* next element */			\
+	struct type **le_prev;	/* address of previous next element */	\
+}
+
+/*
+ * List access methods
+ */
+#define	LIST_FIRST(head)		((head)->lh_first)
+#define	LIST_END(head)			NULL
+#define	LIST_EMPTY(head)		(LIST_FIRST(head) == LIST_END(head))
+#define	LIST_NEXT(elm, field)		((elm)->field.le_next)
+
+#define LIST_FOREACH(var, head, field)					\
+	for((var) = LIST_FIRST(head);					\
+	    (var)!= LIST_END(head);					\
+	    (var) = LIST_NEXT(var, field))
+
+#define	LIST_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = LIST_FIRST(head);				\
+	    (var) && ((tvar) = LIST_NEXT(var, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * List functions.
+ */
+#define	LIST_INIT(head) do {						\
+	LIST_FIRST(head) = LIST_END(head);				\
+} while (0)
+
+#define LIST_INSERT_AFTER(listelm, elm, field) do {			\
+	if (((elm)->field.le_next = (listelm)->field.le_next) != NULL)	\
+		(listelm)->field.le_next->field.le_prev =		\
+		    &(elm)->field.le_next;				\
+	(listelm)->field.le_next = (elm);				\
+	(elm)->field.le_prev = &(listelm)->field.le_next;		\
+} while (0)
+
+#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
+	(elm)->field.le_prev = (listelm)->field.le_prev;		\
+	(elm)->field.le_next = (listelm);				\
+	*(listelm)->field.le_prev = (elm);				\
+	(listelm)->field.le_prev = &(elm)->field.le_next;		\
+} while (0)
+
+#define LIST_INSERT_HEAD(head, elm, field) do {				\
+	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
+		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
+	(head)->lh_first = (elm);					\
+	(elm)->field.le_prev = &(head)->lh_first;			\
+} while (0)
+
+#define LIST_REMOVE(elm, field) do {					\
+	if ((elm)->field.le_next != NULL)				\
+		(elm)->field.le_next->field.le_prev =			\
+		    (elm)->field.le_prev;				\
+	*(elm)->field.le_prev = (elm)->field.le_next;			\
+	_Q_INVALIDATE((elm)->field.le_prev);				\
+	_Q_INVALIDATE((elm)->field.le_next);				\
+} while (0)
+
+#define LIST_REPLACE(elm, elm2, field) do {				\
+	if (((elm2)->field.le_next = (elm)->field.le_next) != NULL)	\
+		(elm2)->field.le_next->field.le_prev =			\
+		    &(elm2)->field.le_next;				\
+	(elm2)->field.le_prev = (elm)->field.le_prev;			\
+	*(elm2)->field.le_prev = (elm2);				\
+	_Q_INVALIDATE((elm)->field.le_prev);				\
+	_Q_INVALIDATE((elm)->field.le_next);				\
+} while (0)
+
+/*
+ * Simple queue definitions.
+ */
+#define SIMPLEQ_HEAD(name, type)					\
+struct name {								\
+	struct type *sqh_first;	/* first element */			\
+	struct type **sqh_last;	/* addr of last next element */		\
+}
+
+#define SIMPLEQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).sqh_first }
+
+#define SIMPLEQ_ENTRY(type)						\
+struct {								\
+	struct type *sqe_next;	/* next element */			\
+}
+
+/*
+ * Simple queue access methods.
+ */
+#define	SIMPLEQ_FIRST(head)	    ((head)->sqh_first)
+#define	SIMPLEQ_END(head)	    NULL
+#define	SIMPLEQ_EMPTY(head)	    (SIMPLEQ_FIRST(head) == SIMPLEQ_END(head))
+#define	SIMPLEQ_NEXT(elm, field)    ((elm)->field.sqe_next)
+
+#define SIMPLEQ_FOREACH(var, head, field)				\
+	for((var) = SIMPLEQ_FIRST(head);				\
+	    (var) != SIMPLEQ_END(head);					\
+	    (var) = SIMPLEQ_NEXT(var, field))
+
+#define	SIMPLEQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = SIMPLEQ_FIRST(head);				\
+	    (var) && ((tvar) = SIMPLEQ_NEXT(var, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * Simple queue functions.
+ */
+#define	SIMPLEQ_INIT(head) do {						\
+	(head)->sqh_first = NULL;					\
+	(head)->sqh_last = &(head)->sqh_first;				\
+} while (0)
+
+#define SIMPLEQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.sqe_next = (head)->sqh_first) == NULL)	\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+	(head)->sqh_first = (elm);					\
+} while (0)
+
+#define SIMPLEQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.sqe_next = NULL;					\
+	*(head)->sqh_last = (elm);					\
+	(head)->sqh_last = &(elm)->field.sqe_next;			\
+} while (0)
+
+#define SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.sqe_next = (listelm)->field.sqe_next) == NULL)\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+	(listelm)->field.sqe_next = (elm);				\
+} while (0)
+
+#define SIMPLEQ_REMOVE_HEAD(head, field) do {			\
+	if (((head)->sqh_first = (head)->sqh_first->field.sqe_next) == NULL) \
+		(head)->sqh_last = &(head)->sqh_first;			\
+} while (0)
+
+#define SIMPLEQ_REMOVE_AFTER(head, elm, field) do {			\
+	if (((elm)->field.sqe_next = (elm)->field.sqe_next->field.sqe_next) \
+	    == NULL)							\
+		(head)->sqh_last = &(elm)->field.sqe_next;		\
+} while (0)
+
+/*
+ * XOR Simple queue definitions.
+ */
+#define XSIMPLEQ_HEAD(name, type)					\
+struct name {								\
+	struct type *sqx_first;	/* first element */			\
+	struct type **sqx_last;	/* addr of last next element */		\
+	unsigned long sqx_cookie;					\
+}
+
+#define XSIMPLEQ_ENTRY(type)						\
+struct {								\
+	struct type *sqx_next;	/* next element */			\
+}
+
+/*
+ * XOR Simple queue access methods.
+ */
+#define XSIMPLEQ_XOR(head, ptr)	    ((__typeof(ptr))((head)->sqx_cookie ^ \
+					(unsigned long)(ptr)))
+#define	XSIMPLEQ_FIRST(head)	    XSIMPLEQ_XOR(head, ((head)->sqx_first))
+#define	XSIMPLEQ_END(head)	    NULL
+#define	XSIMPLEQ_EMPTY(head)	    (XSIMPLEQ_FIRST(head) == XSIMPLEQ_END(head))
+#define	XSIMPLEQ_NEXT(head, elm, field)    XSIMPLEQ_XOR(head, ((elm)->field.sqx_next))
+
+
+#define XSIMPLEQ_FOREACH(var, head, field)				\
+	for ((var) = XSIMPLEQ_FIRST(head);				\
+	    (var) != XSIMPLEQ_END(head);				\
+	    (var) = XSIMPLEQ_NEXT(head, var, field))
+
+#define	XSIMPLEQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = XSIMPLEQ_FIRST(head);				\
+	    (var) && ((tvar) = XSIMPLEQ_NEXT(head, var, field), 1);	\
+	    (var) = (tvar))
+
+/*
+ * XOR Simple queue functions.
+ */
+#define	XSIMPLEQ_INIT(head) do {					\
+	arc4random_buf(&(head)->sqx_cookie, sizeof((head)->sqx_cookie)); \
+	(head)->sqx_first = XSIMPLEQ_XOR(head, NULL);			\
+	(head)->sqx_last = XSIMPLEQ_XOR(head, &(head)->sqx_first);	\
+} while (0)
+
+#define XSIMPLEQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.sqx_next = (head)->sqx_first) ==		\
+	    XSIMPLEQ_XOR(head, NULL))					\
+		(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next); \
+	(head)->sqx_first = XSIMPLEQ_XOR(head, (elm));			\
+} while (0)
+
+#define XSIMPLEQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.sqx_next = XSIMPLEQ_XOR(head, NULL);		\
+	*(XSIMPLEQ_XOR(head, (head)->sqx_last)) = XSIMPLEQ_XOR(head, (elm)); \
+	(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next);	\
+} while (0)
+
+#define XSIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.sqx_next = (listelm)->field.sqx_next) ==	\
+	    XSIMPLEQ_XOR(head, NULL))					\
+		(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next); \
+	(listelm)->field.sqx_next = XSIMPLEQ_XOR(head, (elm));		\
+} while (0)
+
+#define XSIMPLEQ_REMOVE_HEAD(head, field) do {				\
+	if (((head)->sqx_first = XSIMPLEQ_XOR(head,			\
+	    (head)->sqx_first)->field.sqx_next) == XSIMPLEQ_XOR(head, NULL)) \
+		(head)->sqx_last = XSIMPLEQ_XOR(head, &(head)->sqx_first); \
+} while (0)
+
+#define XSIMPLEQ_REMOVE_AFTER(head, elm, field) do {			\
+	if (((elm)->field.sqx_next = XSIMPLEQ_XOR(head,			\
+	    (elm)->field.sqx_next)->field.sqx_next)			\
+	    == XSIMPLEQ_XOR(head, NULL))				\
+		(head)->sqx_last = 					\
+		    XSIMPLEQ_XOR(head, &(elm)->field.sqx_next);		\
+} while (0)
+
+		    
+/*
+ * Tail queue definitions.
+ */
+#define TAILQ_HEAD(name, type)						\
+struct name {								\
+	struct type *tqh_first;	/* first element */			\
+	struct type **tqh_last;	/* addr of last next element */		\
+}
+
+#define TAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).tqh_first }
+
+#define TAILQ_ENTRY(type)						\
+struct {								\
+	struct type *tqe_next;	/* next element */			\
+	struct type **tqe_prev;	/* address of previous next element */	\
+}
+
+/* 
+ * tail queue access methods 
+ */
+#define	TAILQ_FIRST(head)		((head)->tqh_first)
+#define	TAILQ_END(head)			NULL
+#define	TAILQ_NEXT(elm, field)		((elm)->field.tqe_next)
+#define TAILQ_LAST(head, headname)					\
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+/* XXX */
+#define TAILQ_PREV(elm, headname, field)				\
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+#define	TAILQ_EMPTY(head)						\
+	(TAILQ_FIRST(head) == TAILQ_END(head))
+
+#define TAILQ_FOREACH(var, head, field)					\
+	for((var) = TAILQ_FIRST(head);					\
+	    (var) != TAILQ_END(head);					\
+	    (var) = TAILQ_NEXT(var, field))
+
+#define	TAILQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = TAILQ_FIRST(head);					\
+	    (var) != TAILQ_END(head) &&					\
+	    ((tvar) = TAILQ_NEXT(var, field), 1);			\
+	    (var) = (tvar))
+
+
+#define TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
+	for((var) = TAILQ_LAST(head, headname);				\
+	    (var) != TAILQ_END(head);					\
+	    (var) = TAILQ_PREV(var, headname, field))
+
+#define	TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
+	for ((var) = TAILQ_LAST(head, headname);			\
+	    (var) != TAILQ_END(head) &&					\
+	    ((tvar) = TAILQ_PREV(var, headname, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * Tail queue functions.
+ */
+#define	TAILQ_INIT(head) do {						\
+	(head)->tqh_first = NULL;					\
+	(head)->tqh_last = &(head)->tqh_first;				\
+} while (0)
+
+#define TAILQ_INSERT_HEAD(head, elm, field) do {			\
+	if (((elm)->field.tqe_next = (head)->tqh_first) != NULL)	\
+		(head)->tqh_first->field.tqe_prev =			\
+		    &(elm)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm)->field.tqe_next;		\
+	(head)->tqh_first = (elm);					\
+	(elm)->field.tqe_prev = &(head)->tqh_first;			\
+} while (0)
+
+#define TAILQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.tqe_next = NULL;					\
+	(elm)->field.tqe_prev = (head)->tqh_last;			\
+	*(head)->tqh_last = (elm);					\
+	(head)->tqh_last = &(elm)->field.tqe_next;			\
+} while (0)
+
+#define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\
+		(elm)->field.tqe_next->field.tqe_prev =			\
+		    &(elm)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm)->field.tqe_next;		\
+	(listelm)->field.tqe_next = (elm);				\
+	(elm)->field.tqe_prev = &(listelm)->field.tqe_next;		\
+} while (0)
+
+#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
+	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
+	(elm)->field.tqe_next = (listelm);				\
+	*(listelm)->field.tqe_prev = (elm);				\
+	(listelm)->field.tqe_prev = &(elm)->field.tqe_next;		\
+} while (0)
+
+#define TAILQ_REMOVE(head, elm, field) do {				\
+	if (((elm)->field.tqe_next) != NULL)				\
+		(elm)->field.tqe_next->field.tqe_prev =			\
+		    (elm)->field.tqe_prev;				\
+	else								\
+		(head)->tqh_last = (elm)->field.tqe_prev;		\
+	*(elm)->field.tqe_prev = (elm)->field.tqe_next;			\
+	_Q_INVALIDATE((elm)->field.tqe_prev);				\
+	_Q_INVALIDATE((elm)->field.tqe_next);				\
+} while (0)
+
+#define TAILQ_REPLACE(head, elm, elm2, field) do {			\
+	if (((elm2)->field.tqe_next = (elm)->field.tqe_next) != NULL)	\
+		(elm2)->field.tqe_next->field.tqe_prev =		\
+		    &(elm2)->field.tqe_next;				\
+	else								\
+		(head)->tqh_last = &(elm2)->field.tqe_next;		\
+	(elm2)->field.tqe_prev = (elm)->field.tqe_prev;			\
+	*(elm2)->field.tqe_prev = (elm2);				\
+	_Q_INVALIDATE((elm)->field.tqe_prev);				\
+	_Q_INVALIDATE((elm)->field.tqe_next);				\
+} while (0)
+
+/*
+ * Circular queue definitions.
+ */
+#define CIRCLEQ_HEAD(name, type)					\
+struct name {								\
+	struct type *cqh_first;		/* first element */		\
+	struct type *cqh_last;		/* last element */		\
+}
+
+#define CIRCLEQ_HEAD_INITIALIZER(head)					\
+	{ CIRCLEQ_END(&head), CIRCLEQ_END(&head) }
+
+#define CIRCLEQ_ENTRY(type)						\
+struct {								\
+	struct type *cqe_next;		/* next element */		\
+	struct type *cqe_prev;		/* previous element */		\
+}
+
+/*
+ * Circular queue access methods 
+ */
+#define	CIRCLEQ_FIRST(head)		((head)->cqh_first)
+#define	CIRCLEQ_LAST(head)		((head)->cqh_last)
+#define	CIRCLEQ_END(head)		((void *)(head))
+#define	CIRCLEQ_NEXT(elm, field)	((elm)->field.cqe_next)
+#define	CIRCLEQ_PREV(elm, field)	((elm)->field.cqe_prev)
+#define	CIRCLEQ_EMPTY(head)						\
+	(CIRCLEQ_FIRST(head) == CIRCLEQ_END(head))
+
+#define CIRCLEQ_FOREACH(var, head, field)				\
+	for((var) = CIRCLEQ_FIRST(head);				\
+	    (var) != CIRCLEQ_END(head);					\
+	    (var) = CIRCLEQ_NEXT(var, field))
+
+#define	CIRCLEQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = CIRCLEQ_FIRST(head);				\
+	    (var) != CIRCLEQ_END(head) &&				\
+	    ((tvar) = CIRCLEQ_NEXT(var, field), 1);			\
+	    (var) = (tvar))
+
+#define CIRCLEQ_FOREACH_REVERSE(var, head, field)			\
+	for((var) = CIRCLEQ_LAST(head);					\
+	    (var) != CIRCLEQ_END(head);					\
+	    (var) = CIRCLEQ_PREV(var, field))
+
+#define	CIRCLEQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
+	for ((var) = CIRCLEQ_LAST(head, headname);			\
+	    (var) != CIRCLEQ_END(head) && 				\
+	    ((tvar) = CIRCLEQ_PREV(var, headname, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * Circular queue functions.
+ */
+#define	CIRCLEQ_INIT(head) do {						\
+	(head)->cqh_first = CIRCLEQ_END(head);				\
+	(head)->cqh_last = CIRCLEQ_END(head);				\
+} while (0)
+
+#define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	(elm)->field.cqe_next = (listelm)->field.cqe_next;		\
+	(elm)->field.cqe_prev = (listelm);				\
+	if ((listelm)->field.cqe_next == CIRCLEQ_END(head))		\
+		(head)->cqh_last = (elm);				\
+	else								\
+		(listelm)->field.cqe_next->field.cqe_prev = (elm);	\
+	(listelm)->field.cqe_next = (elm);				\
+} while (0)
+
+#define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {		\
+	(elm)->field.cqe_next = (listelm);				\
+	(elm)->field.cqe_prev = (listelm)->field.cqe_prev;		\
+	if ((listelm)->field.cqe_prev == CIRCLEQ_END(head))		\
+		(head)->cqh_first = (elm);				\
+	else								\
+		(listelm)->field.cqe_prev->field.cqe_next = (elm);	\
+	(listelm)->field.cqe_prev = (elm);				\
+} while (0)
+
+#define CIRCLEQ_INSERT_HEAD(head, elm, field) do {			\
+	(elm)->field.cqe_next = (head)->cqh_first;			\
+	(elm)->field.cqe_prev = CIRCLEQ_END(head);			\
+	if ((head)->cqh_last == CIRCLEQ_END(head))			\
+		(head)->cqh_last = (elm);				\
+	else								\
+		(head)->cqh_first->field.cqe_prev = (elm);		\
+	(head)->cqh_first = (elm);					\
+} while (0)
+
+#define CIRCLEQ_INSERT_TAIL(head, elm, field) do {			\
+	(elm)->field.cqe_next = CIRCLEQ_END(head);			\
+	(elm)->field.cqe_prev = (head)->cqh_last;			\
+	if ((head)->cqh_first == CIRCLEQ_END(head))			\
+		(head)->cqh_first = (elm);				\
+	else								\
+		(head)->cqh_last->field.cqe_next = (elm);		\
+	(head)->cqh_last = (elm);					\
+} while (0)
+
+#define	CIRCLEQ_REMOVE(head, elm, field) do {				\
+	if ((elm)->field.cqe_next == CIRCLEQ_END(head))			\
+		(head)->cqh_last = (elm)->field.cqe_prev;		\
+	else								\
+		(elm)->field.cqe_next->field.cqe_prev =			\
+		    (elm)->field.cqe_prev;				\
+	if ((elm)->field.cqe_prev == CIRCLEQ_END(head))			\
+		(head)->cqh_first = (elm)->field.cqe_next;		\
+	else								\
+		(elm)->field.cqe_prev->field.cqe_next =			\
+		    (elm)->field.cqe_next;				\
+	_Q_INVALIDATE((elm)->field.cqe_prev);				\
+	_Q_INVALIDATE((elm)->field.cqe_next);				\
+} while (0)
+
+#define CIRCLEQ_REPLACE(head, elm, elm2, field) do {			\
+	if (((elm2)->field.cqe_next = (elm)->field.cqe_next) ==		\
+	    CIRCLEQ_END(head))						\
+		(head)->cqh_last = (elm2);				\
+	else								\
+		(elm2)->field.cqe_next->field.cqe_prev = (elm2);	\
+	if (((elm2)->field.cqe_prev = (elm)->field.cqe_prev) ==		\
+	    CIRCLEQ_END(head))						\
+		(head)->cqh_first = (elm2);				\
+	else								\
+		(elm2)->field.cqe_prev->field.cqe_next = (elm2);	\
+	_Q_INVALIDATE((elm)->field.cqe_prev);				\
+	_Q_INVALIDATE((elm)->field.cqe_next);				\
+} while (0)
+
+#endif	/* !_SYS_QUEUE_H_ */
diff --git a/compat/generic/sys/tree.h b/compat/generic/sys/tree.h
new file mode 100644
--- /dev/null
+++ b/compat/generic/sys/tree.h
@@ -0,0 +1,748 @@
+/*	$OpenBSD: tree.h,v 1.13 2011/07/09 00:19:45 pirofti Exp $	*/
+/*
+ * Copyright 2002 Niels Provos <provos@citi.umich.edu>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef	_SYS_TREE_H_
+#define	_SYS_TREE_H_
+
+/*
+ * This file defines data structures for different types of trees:
+ * splay trees and red-black trees.
+ *
+ * A splay tree is a self-organizing data structure.  Every operation
+ * on the tree causes a splay to happen.  The splay moves the requested
+ * node to the root of the tree and partly rebalances it.
+ *
+ * This has the benefit that request locality causes faster lookups as
+ * the requested nodes move to the top of the tree.  On the other hand,
+ * every lookup causes memory writes.
+ *
+ * The Balance Theorem bounds the total access time for m operations
+ * and n inserts on an initially empty tree as O((m + n)lg n).  The
+ * amortized cost for a sequence of m accesses to a splay tree is O(lg n);
+ *
+ * A red-black tree is a binary search tree with the node color as an
+ * extra attribute.  It fulfills a set of conditions:
+ *	- every search path from the root to a leaf consists of the
+ *	  same number of black nodes,
+ *	- each red node (except for the root) has a black parent,
+ *	- each leaf node is black.
+ *
+ * Every operation on a red-black tree is bounded as O(lg n).
+ * The maximum height of a red-black tree is 2lg (n+1).
+ */
+
+#define SPLAY_HEAD(name, type)						\
+struct name {								\
+	struct type *sph_root; /* root of the tree */			\
+}
+
+#define SPLAY_INITIALIZER(root)						\
+	{ NULL }
+
+#define SPLAY_INIT(root) do {						\
+	(root)->sph_root = NULL;					\
+} while (0)
+
+#define SPLAY_ENTRY(type)						\
+struct {								\
+	struct type *spe_left; /* left element */			\
+	struct type *spe_right; /* right element */			\
+}
+
+#define SPLAY_LEFT(elm, field)		(elm)->field.spe_left
+#define SPLAY_RIGHT(elm, field)		(elm)->field.spe_right
+#define SPLAY_ROOT(head)		(head)->sph_root
+#define SPLAY_EMPTY(head)		(SPLAY_ROOT(head) == NULL)
+
+/* SPLAY_ROTATE_{LEFT,RIGHT} expect that tmp hold SPLAY_{RIGHT,LEFT} */
+#define SPLAY_ROTATE_RIGHT(head, tmp, field) do {			\
+	SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(tmp, field);	\
+	SPLAY_RIGHT(tmp, field) = (head)->sph_root;			\
+	(head)->sph_root = tmp;						\
+} while (0)
+	
+#define SPLAY_ROTATE_LEFT(head, tmp, field) do {			\
+	SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(tmp, field);	\
+	SPLAY_LEFT(tmp, field) = (head)->sph_root;			\
+	(head)->sph_root = tmp;						\
+} while (0)
+
+#define SPLAY_LINKLEFT(head, tmp, field) do {				\
+	SPLAY_LEFT(tmp, field) = (head)->sph_root;			\
+	tmp = (head)->sph_root;						\
+	(head)->sph_root = SPLAY_LEFT((head)->sph_root, field);		\
+} while (0)
+
+#define SPLAY_LINKRIGHT(head, tmp, field) do {				\
+	SPLAY_RIGHT(tmp, field) = (head)->sph_root;			\
+	tmp = (head)->sph_root;						\
+	(head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);	\
+} while (0)
+
+#define SPLAY_ASSEMBLE(head, node, left, right, field) do {		\
+	SPLAY_RIGHT(left, field) = SPLAY_LEFT((head)->sph_root, field);	\
+	SPLAY_LEFT(right, field) = SPLAY_RIGHT((head)->sph_root, field);\
+	SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(node, field);	\
+	SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(node, field);	\
+} while (0)
+
+/* Generates prototypes and inline functions */
+
+#define SPLAY_PROTOTYPE(name, type, field, cmp)				\
+void name##_SPLAY(struct name *, struct type *);			\
+void name##_SPLAY_MINMAX(struct name *, int);				\
+struct type *name##_SPLAY_INSERT(struct name *, struct type *);		\
+struct type *name##_SPLAY_REMOVE(struct name *, struct type *);		\
+									\
+/* Finds the node with the same key as elm */				\
+static __inline struct type *						\
+name##_SPLAY_FIND(struct name *head, struct type *elm)			\
+{									\
+	if (SPLAY_EMPTY(head))						\
+		return(NULL);						\
+	name##_SPLAY(head, elm);					\
+	if ((cmp)(elm, (head)->sph_root) == 0)				\
+		return (head->sph_root);				\
+	return (NULL);							\
+}									\
+									\
+static __inline struct type *						\
+name##_SPLAY_NEXT(struct name *head, struct type *elm)			\
+{									\
+	name##_SPLAY(head, elm);					\
+	if (SPLAY_RIGHT(elm, field) != NULL) {				\
+		elm = SPLAY_RIGHT(elm, field);				\
+		while (SPLAY_LEFT(elm, field) != NULL) {		\
+			elm = SPLAY_LEFT(elm, field);			\
+		}							\
+	} else								\
+		elm = NULL;						\
+	return (elm);							\
+}									\
+									\
+static __inline struct type *						\
+name##_SPLAY_MIN_MAX(struct name *head, int val)			\
+{									\
+	name##_SPLAY_MINMAX(head, val);					\
+        return (SPLAY_ROOT(head));					\
+}
+
+/* Main splay operation.
+ * Moves node close to the key of elm to top
+ */
+#define SPLAY_GENERATE(name, type, field, cmp)				\
+struct type *								\
+name##_SPLAY_INSERT(struct name *head, struct type *elm)		\
+{									\
+    if (SPLAY_EMPTY(head)) {						\
+	    SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL;	\
+    } else {								\
+	    int __comp;							\
+	    name##_SPLAY(head, elm);					\
+	    __comp = (cmp)(elm, (head)->sph_root);			\
+	    if(__comp < 0) {						\
+		    SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)->sph_root, field);\
+		    SPLAY_RIGHT(elm, field) = (head)->sph_root;		\
+		    SPLAY_LEFT((head)->sph_root, field) = NULL;		\
+	    } else if (__comp > 0) {					\
+		    SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)->sph_root, field);\
+		    SPLAY_LEFT(elm, field) = (head)->sph_root;		\
+		    SPLAY_RIGHT((head)->sph_root, field) = NULL;	\
+	    } else							\
+		    return ((head)->sph_root);				\
+    }									\
+    (head)->sph_root = (elm);						\
+    return (NULL);							\
+}									\
+									\
+struct type *								\
+name##_SPLAY_REMOVE(struct name *head, struct type *elm)		\
+{									\
+	struct type *__tmp;						\
+	if (SPLAY_EMPTY(head))						\
+		return (NULL);						\
+	name##_SPLAY(head, elm);					\
+	if ((cmp)(elm, (head)->sph_root) == 0) {			\
+		if (SPLAY_LEFT((head)->sph_root, field) == NULL) {	\
+			(head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);\
+		} else {						\
+			__tmp = SPLAY_RIGHT((head)->sph_root, field);	\
+			(head)->sph_root = SPLAY_LEFT((head)->sph_root, field);\
+			name##_SPLAY(head, elm);			\
+			SPLAY_RIGHT((head)->sph_root, field) = __tmp;	\
+		}							\
+		return (elm);						\
+	}								\
+	return (NULL);							\
+}									\
+									\
+void									\
+name##_SPLAY(struct name *head, struct type *elm)			\
+{									\
+	struct type __node, *__left, *__right, *__tmp;			\
+	int __comp;							\
+\
+	SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\
+	__left = __right = &__node;					\
+\
+	while ((__comp = (cmp)(elm, (head)->sph_root))) {		\
+		if (__comp < 0) {					\
+			__tmp = SPLAY_LEFT((head)->sph_root, field);	\
+			if (__tmp == NULL)				\
+				break;					\
+			if ((cmp)(elm, __tmp) < 0){			\
+				SPLAY_ROTATE_RIGHT(head, __tmp, field);	\
+				if (SPLAY_LEFT((head)->sph_root, field) == NULL)\
+					break;				\
+			}						\
+			SPLAY_LINKLEFT(head, __right, field);		\
+		} else if (__comp > 0) {				\
+			__tmp = SPLAY_RIGHT((head)->sph_root, field);	\
+			if (__tmp == NULL)				\
+				break;					\
+			if ((cmp)(elm, __tmp) > 0){			\
+				SPLAY_ROTATE_LEFT(head, __tmp, field);	\
+				if (SPLAY_RIGHT((head)->sph_root, field) == NULL)\
+					break;				\
+			}						\
+			SPLAY_LINKRIGHT(head, __left, field);		\
+		}							\
+	}								\
+	SPLAY_ASSEMBLE(head, &__node, __left, __right, field);		\
+}									\
+									\
+/* Splay with either the minimum or the maximum element			\
+ * Used to find minimum or maximum element in tree.			\
+ */									\
+void name##_SPLAY_MINMAX(struct name *head, int __comp) \
+{									\
+	struct type __node, *__left, *__right, *__tmp;			\
+\
+	SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\
+	__left = __right = &__node;					\
+\
+	while (1) {							\
+		if (__comp < 0) {					\
+			__tmp = SPLAY_LEFT((head)->sph_root, field);	\
+			if (__tmp == NULL)				\
+				break;					\
+			if (__comp < 0){				\
+				SPLAY_ROTATE_RIGHT(head, __tmp, field);	\
+				if (SPLAY_LEFT((head)->sph_root, field) == NULL)\
+					break;				\
+			}						\
+			SPLAY_LINKLEFT(head, __right, field);		\
+		} else if (__comp > 0) {				\
+			__tmp = SPLAY_RIGHT((head)->sph_root, field);	\
+			if (__tmp == NULL)				\
+				break;					\
+			if (__comp > 0) {				\
+				SPLAY_ROTATE_LEFT(head, __tmp, field);	\
+				if (SPLAY_RIGHT((head)->sph_root, field) == NULL)\
+					break;				\
+			}						\
+			SPLAY_LINKRIGHT(head, __left, field);		\
+		}							\
+	}								\
+	SPLAY_ASSEMBLE(head, &__node, __left, __right, field);		\
+}
+
+#define SPLAY_NEGINF	-1
+#define SPLAY_INF	1
+
+#define SPLAY_INSERT(name, x, y)	name##_SPLAY_INSERT(x, y)
+#define SPLAY_REMOVE(name, x, y)	name##_SPLAY_REMOVE(x, y)
+#define SPLAY_FIND(name, x, y)		name##_SPLAY_FIND(x, y)
+#define SPLAY_NEXT(name, x, y)		name##_SPLAY_NEXT(x, y)
+#define SPLAY_MIN(name, x)		(SPLAY_EMPTY(x) ? NULL	\
+					: name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))
+#define SPLAY_MAX(name, x)		(SPLAY_EMPTY(x) ? NULL	\
+					: name##_SPLAY_MIN_MAX(x, SPLAY_INF))
+
+#define SPLAY_FOREACH(x, name, head)					\
+	for ((x) = SPLAY_MIN(name, head);				\
+	     (x) != NULL;						\
+	     (x) = SPLAY_NEXT(name, head, x))
+
+/* Macros that define a red-black tree */
+#define RB_HEAD(name, type)						\
+struct name {								\
+	struct type *rbh_root; /* root of the tree */			\
+}
+
+#define RB_INITIALIZER(root)						\
+	{ NULL }
+
+#define RB_INIT(root) do {						\
+	(root)->rbh_root = NULL;					\
+} while (0)
+
+#define RB_BLACK	0
+#define RB_RED		1
+#define RB_ENTRY(type)							\
+struct {								\
+	struct type *rbe_left;		/* left element */		\
+	struct type *rbe_right;		/* right element */		\
+	struct type *rbe_parent;	/* parent element */		\
+	int rbe_color;			/* node color */		\
+}
+
+#define RB_LEFT(elm, field)		(elm)->field.rbe_left
+#define RB_RIGHT(elm, field)		(elm)->field.rbe_right
+#define RB_PARENT(elm, field)		(elm)->field.rbe_parent
+#define RB_COLOR(elm, field)		(elm)->field.rbe_color
+#define RB_ROOT(head)			(head)->rbh_root
+#define RB_EMPTY(head)			(RB_ROOT(head) == NULL)
+
+#define RB_SET(elm, parent, field) do {					\
+	RB_PARENT(elm, field) = parent;					\
+	RB_LEFT(elm, field) = RB_RIGHT(elm, field) = NULL;		\
+	RB_COLOR(elm, field) = RB_RED;					\
+} while (0)
+
+#define RB_SET_BLACKRED(black, red, field) do {				\
+	RB_COLOR(black, field) = RB_BLACK;				\
+	RB_COLOR(red, field) = RB_RED;					\
+} while (0)
+
+#ifndef RB_AUGMENT
+#define RB_AUGMENT(x)	do {} while (0)
+#endif
+
+#define RB_ROTATE_LEFT(head, elm, tmp, field) do {			\
+	(tmp) = RB_RIGHT(elm, field);					\
+	if ((RB_RIGHT(elm, field) = RB_LEFT(tmp, field))) {		\
+		RB_PARENT(RB_LEFT(tmp, field), field) = (elm);		\
+	}								\
+	RB_AUGMENT(elm);						\
+	if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field))) {		\
+		if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))	\
+			RB_LEFT(RB_PARENT(elm, field), field) = (tmp);	\
+		else							\
+			RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);	\
+	} else								\
+		(head)->rbh_root = (tmp);				\
+	RB_LEFT(tmp, field) = (elm);					\
+	RB_PARENT(elm, field) = (tmp);					\
+	RB_AUGMENT(tmp);						\
+	if ((RB_PARENT(tmp, field)))					\
+		RB_AUGMENT(RB_PARENT(tmp, field));			\
+} while (0)
+
+#define RB_ROTATE_RIGHT(head, elm, tmp, field) do {			\
+	(tmp) = RB_LEFT(elm, field);					\
+	if ((RB_LEFT(elm, field) = RB_RIGHT(tmp, field))) {		\
+		RB_PARENT(RB_RIGHT(tmp, field), field) = (elm);		\
+	}								\
+	RB_AUGMENT(elm);						\
+	if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field))) {		\
+		if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))	\
+			RB_LEFT(RB_PARENT(elm, field), field) = (tmp);	\
+		else							\
+			RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);	\
+	} else								\
+		(head)->rbh_root = (tmp);				\
+	RB_RIGHT(tmp, field) = (elm);					\
+	RB_PARENT(elm, field) = (tmp);					\
+	RB_AUGMENT(tmp);						\
+	if ((RB_PARENT(tmp, field)))					\
+		RB_AUGMENT(RB_PARENT(tmp, field));			\
+} while (0)
+
+/* Generates prototypes and inline functions */
+#define	RB_PROTOTYPE(name, type, field, cmp)				\
+	RB_PROTOTYPE_INTERNAL(name, type, field, cmp,)
+#define	RB_PROTOTYPE_STATIC(name, type, field, cmp)			\
+	RB_PROTOTYPE_INTERNAL(name, type, field, cmp, __attribute__((__unused__)) static)
+#define RB_PROTOTYPE_INTERNAL(name, type, field, cmp, attr)		\
+attr void name##_RB_INSERT_COLOR(struct name *, struct type *);		\
+attr void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *);\
+attr struct type *name##_RB_REMOVE(struct name *, struct type *);	\
+attr struct type *name##_RB_INSERT(struct name *, struct type *);	\
+attr struct type *name##_RB_FIND(struct name *, struct type *);		\
+attr struct type *name##_RB_NFIND(struct name *, struct type *);	\
+attr struct type *name##_RB_NEXT(struct type *);			\
+attr struct type *name##_RB_PREV(struct type *);			\
+attr struct type *name##_RB_MINMAX(struct name *, int);			\
+									\
+
+/* Main rb operation.
+ * Moves node close to the key of elm to top
+ */
+#define	RB_GENERATE(name, type, field, cmp)				\
+	RB_GENERATE_INTERNAL(name, type, field, cmp,)
+#define	RB_GENERATE_STATIC(name, type, field, cmp)			\
+	RB_GENERATE_INTERNAL(name, type, field, cmp, __attribute__((__unused__)) static)
+#define RB_GENERATE_INTERNAL(name, type, field, cmp, attr)		\
+attr void								\
+name##_RB_INSERT_COLOR(struct name *head, struct type *elm)		\
+{									\
+	struct type *parent, *gparent, *tmp;				\
+	while ((parent = RB_PARENT(elm, field)) &&			\
+	    RB_COLOR(parent, field) == RB_RED) {			\
+		gparent = RB_PARENT(parent, field);			\
+		if (parent == RB_LEFT(gparent, field)) {		\
+			tmp = RB_RIGHT(gparent, field);			\
+			if (tmp && RB_COLOR(tmp, field) == RB_RED) {	\
+				RB_COLOR(tmp, field) = RB_BLACK;	\
+				RB_SET_BLACKRED(parent, gparent, field);\
+				elm = gparent;				\
+				continue;				\
+			}						\
+			if (RB_RIGHT(parent, field) == elm) {		\
+				RB_ROTATE_LEFT(head, parent, tmp, field);\
+				tmp = parent;				\
+				parent = elm;				\
+				elm = tmp;				\
+			}						\
+			RB_SET_BLACKRED(parent, gparent, field);	\
+			RB_ROTATE_RIGHT(head, gparent, tmp, field);	\
+		} else {						\
+			tmp = RB_LEFT(gparent, field);			\
+			if (tmp && RB_COLOR(tmp, field) == RB_RED) {	\
+				RB_COLOR(tmp, field) = RB_BLACK;	\
+				RB_SET_BLACKRED(parent, gparent, field);\
+				elm = gparent;				\
+				continue;				\
+			}						\
+			if (RB_LEFT(parent, field) == elm) {		\
+				RB_ROTATE_RIGHT(head, parent, tmp, field);\
+				tmp = parent;				\
+				parent = elm;				\
+				elm = tmp;				\
+			}						\
+			RB_SET_BLACKRED(parent, gparent, field);	\
+			RB_ROTATE_LEFT(head, gparent, tmp, field);	\
+		}							\
+	}								\
+	RB_COLOR(head->rbh_root, field) = RB_BLACK;			\
+}									\
+									\
+attr void								\
+name##_RB_REMOVE_COLOR(struct name *head, struct type *parent, struct type *elm) \
+{									\
+	struct type *tmp;						\
+	while ((elm == NULL || RB_COLOR(elm, field) == RB_BLACK) &&	\
+	    elm != RB_ROOT(head)) {					\
+		if (RB_LEFT(parent, field) == elm) {			\
+			tmp = RB_RIGHT(parent, field);			\
+			if (RB_COLOR(tmp, field) == RB_RED) {		\
+				RB_SET_BLACKRED(tmp, parent, field);	\
+				RB_ROTATE_LEFT(head, parent, tmp, field);\
+				tmp = RB_RIGHT(parent, field);		\
+			}						\
+			if ((RB_LEFT(tmp, field) == NULL ||		\
+			    RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&\
+			    (RB_RIGHT(tmp, field) == NULL ||		\
+			    RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {\
+				RB_COLOR(tmp, field) = RB_RED;		\
+				elm = parent;				\
+				parent = RB_PARENT(elm, field);		\
+			} else {					\
+				if (RB_RIGHT(tmp, field) == NULL ||	\
+				    RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK) {\
+					struct type *oleft;		\
+					if ((oleft = RB_LEFT(tmp, field)))\
+						RB_COLOR(oleft, field) = RB_BLACK;\
+					RB_COLOR(tmp, field) = RB_RED;	\
+					RB_ROTATE_RIGHT(head, tmp, oleft, field);\
+					tmp = RB_RIGHT(parent, field);	\
+				}					\
+				RB_COLOR(tmp, field) = RB_COLOR(parent, field);\
+				RB_COLOR(parent, field) = RB_BLACK;	\
+				if (RB_RIGHT(tmp, field))		\
+					RB_COLOR(RB_RIGHT(tmp, field), field) = RB_BLACK;\
+				RB_ROTATE_LEFT(head, parent, tmp, field);\
+				elm = RB_ROOT(head);			\
+				break;					\
+			}						\
+		} else {						\
+			tmp = RB_LEFT(parent, field);			\
+			if (RB_COLOR(tmp, field) == RB_RED) {		\
+				RB_SET_BLACKRED(tmp, parent, field);	\
+				RB_ROTATE_RIGHT(head, parent, tmp, field);\
+				tmp = RB_LEFT(parent, field);		\
+			}						\
+			if ((RB_LEFT(tmp, field) == NULL ||		\
+			    RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&\
+			    (RB_RIGHT(tmp, field) == NULL ||		\
+			    RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {\
+				RB_COLOR(tmp, field) = RB_RED;		\
+				elm = parent;				\
+				parent = RB_PARENT(elm, field);		\
+			} else {					\
+				if (RB_LEFT(tmp, field) == NULL ||	\
+				    RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) {\
+					struct type *oright;		\
+					if ((oright = RB_RIGHT(tmp, field)))\
+						RB_COLOR(oright, field) = RB_BLACK;\
+					RB_COLOR(tmp, field) = RB_RED;	\
+					RB_ROTATE_LEFT(head, tmp, oright, field);\
+					tmp = RB_LEFT(parent, field);	\
+				}					\
+				RB_COLOR(tmp, field) = RB_COLOR(parent, field);\
+				RB_COLOR(parent, field) = RB_BLACK;	\
+				if (RB_LEFT(tmp, field))		\
+					RB_COLOR(RB_LEFT(tmp, field), field) = RB_BLACK;\
+				RB_ROTATE_RIGHT(head, parent, tmp, field);\
+				elm = RB_ROOT(head);			\
+				break;					\
+			}						\
+		}							\
+	}								\
+	if (elm)							\
+		RB_COLOR(elm, field) = RB_BLACK;			\
+}									\
+									\
+attr struct type *							\
+name##_RB_REMOVE(struct name *head, struct type *elm)			\
+{									\
+	struct type *child, *parent, *old = elm;			\
+	int color;							\
+	if (RB_LEFT(elm, field) == NULL)				\
+		child = RB_RIGHT(elm, field);				\
+	else if (RB_RIGHT(elm, field) == NULL)				\
+		child = RB_LEFT(elm, field);				\
+	else {								\
+		struct type *left;					\
+		elm = RB_RIGHT(elm, field);				\
+		while ((left = RB_LEFT(elm, field)))			\
+			elm = left;					\
+		child = RB_RIGHT(elm, field);				\
+		parent = RB_PARENT(elm, field);				\
+		color = RB_COLOR(elm, field);				\
+		if (child)						\
+			RB_PARENT(child, field) = parent;		\
+		if (parent) {						\
+			if (RB_LEFT(parent, field) == elm)		\
+				RB_LEFT(parent, field) = child;		\
+			else						\
+				RB_RIGHT(parent, field) = child;	\
+			RB_AUGMENT(parent);				\
+		} else							\
+			RB_ROOT(head) = child;				\
+		if (RB_PARENT(elm, field) == old)			\
+			parent = elm;					\
+		(elm)->field = (old)->field;				\
+		if (RB_PARENT(old, field)) {				\
+			if (RB_LEFT(RB_PARENT(old, field), field) == old)\
+				RB_LEFT(RB_PARENT(old, field), field) = elm;\
+			else						\
+				RB_RIGHT(RB_PARENT(old, field), field) = elm;\
+			RB_AUGMENT(RB_PARENT(old, field));		\
+		} else							\
+			RB_ROOT(head) = elm;				\
+		RB_PARENT(RB_LEFT(old, field), field) = elm;		\
+		if (RB_RIGHT(old, field))				\
+			RB_PARENT(RB_RIGHT(old, field), field) = elm;	\
+		if (parent) {						\
+			left = parent;					\
+			do {						\
+				RB_AUGMENT(left);			\
+			} while ((left = RB_PARENT(left, field)));	\
+		}							\
+		goto color;						\
+	}								\
+	parent = RB_PARENT(elm, field);					\
+	color = RB_COLOR(elm, field);					\
+	if (child)							\
+		RB_PARENT(child, field) = parent;			\
+	if (parent) {							\
+		if (RB_LEFT(parent, field) == elm)			\
+			RB_LEFT(parent, field) = child;			\
+		else							\
+			RB_RIGHT(parent, field) = child;		\
+		RB_AUGMENT(parent);					\
+	} else								\
+		RB_ROOT(head) = child;					\
+color:									\
+	if (color == RB_BLACK)						\
+		name##_RB_REMOVE_COLOR(head, parent, child);		\
+	return (old);							\
+}									\
+									\
+/* Inserts a node into the RB tree */					\
+attr struct type *							\
+name##_RB_INSERT(struct name *head, struct type *elm)			\
+{									\
+	struct type *tmp;						\
+	struct type *parent = NULL;					\
+	int comp = 0;							\
+	tmp = RB_ROOT(head);						\
+	while (tmp) {							\
+		parent = tmp;						\
+		comp = (cmp)(elm, parent);				\
+		if (comp < 0)						\
+			tmp = RB_LEFT(tmp, field);			\
+		else if (comp > 0)					\
+			tmp = RB_RIGHT(tmp, field);			\
+		else							\
+			return (tmp);					\
+	}								\
+	RB_SET(elm, parent, field);					\
+	if (parent != NULL) {						\
+		if (comp < 0)						\
+			RB_LEFT(parent, field) = elm;			\
+		else							\
+			RB_RIGHT(parent, field) = elm;			\
+		RB_AUGMENT(parent);					\
+	} else								\
+		RB_ROOT(head) = elm;					\
+	name##_RB_INSERT_COLOR(head, elm);				\
+	return (NULL);							\
+}									\
+									\
+/* Finds the node with the same key as elm */				\
+attr struct type *							\
+name##_RB_FIND(struct name *head, struct type *elm)			\
+{									\
+	struct type *tmp = RB_ROOT(head);				\
+	int comp;							\
+	while (tmp) {							\
+		comp = cmp(elm, tmp);					\
+		if (comp < 0)						\
+			tmp = RB_LEFT(tmp, field);			\
+		else if (comp > 0)					\
+			tmp = RB_RIGHT(tmp, field);			\
+		else							\
+			return (tmp);					\
+	}								\
+	return (NULL);							\
+}									\
+									\
+/* Finds the first node greater than or equal to the search key */	\
+attr struct type *							\
+name##_RB_NFIND(struct name *head, struct type *elm)			\
+{									\
+	struct type *tmp = RB_ROOT(head);				\
+	struct type *res = NULL;					\
+	int comp;							\
+	while (tmp) {							\
+		comp = cmp(elm, tmp);					\
+		if (comp < 0) {						\
+			res = tmp;					\
+			tmp = RB_LEFT(tmp, field);			\
+		}							\
+		else if (comp > 0)					\
+			tmp = RB_RIGHT(tmp, field);			\
+		else							\
+			return (tmp);					\
+	}								\
+	return (res);							\
+}									\
+									\
+/* ARGSUSED */								\
+attr struct type *							\
+name##_RB_NEXT(struct type *elm)					\
+{									\
+	if (RB_RIGHT(elm, field)) {					\
+		elm = RB_RIGHT(elm, field);				\
+		while (RB_LEFT(elm, field))				\
+			elm = RB_LEFT(elm, field);			\
+	} else {							\
+		if (RB_PARENT(elm, field) &&				\
+		    (elm == RB_LEFT(RB_PARENT(elm, field), field)))	\
+			elm = RB_PARENT(elm, field);			\
+		else {							\
+			while (RB_PARENT(elm, field) &&			\
+			    (elm == RB_RIGHT(RB_PARENT(elm, field), field)))\
+				elm = RB_PARENT(elm, field);		\
+			elm = RB_PARENT(elm, field);			\
+		}							\
+	}								\
+	return (elm);							\
+}									\
+									\
+/* ARGSUSED */								\
+attr struct type *							\
+name##_RB_PREV(struct type *elm)					\
+{									\
+	if (RB_LEFT(elm, field)) {					\
+		elm = RB_LEFT(elm, field);				\
+		while (RB_RIGHT(elm, field))				\
+			elm = RB_RIGHT(elm, field);			\
+	} else {							\
+		if (RB_PARENT(elm, field) &&				\
+		    (elm == RB_RIGHT(RB_PARENT(elm, field), field)))	\
+			elm = RB_PARENT(elm, field);			\
+		else {							\
+			while (RB_PARENT(elm, field) &&			\
+			    (elm == RB_LEFT(RB_PARENT(elm, field), field)))\
+				elm = RB_PARENT(elm, field);		\
+			elm = RB_PARENT(elm, field);			\
+		}							\
+	}								\
+	return (elm);							\
+}									\
+									\
+attr struct type *							\
+name##_RB_MINMAX(struct name *head, int val)				\
+{									\
+	struct type *tmp = RB_ROOT(head);				\
+	struct type *parent = NULL;					\
+	while (tmp) {							\
+		parent = tmp;						\
+		if (val < 0)						\
+			tmp = RB_LEFT(tmp, field);			\
+		else							\
+			tmp = RB_RIGHT(tmp, field);			\
+	}								\
+	return (parent);						\
+}
+
+#define RB_NEGINF	-1
+#define RB_INF	1
+
+#define RB_INSERT(name, x, y)	name##_RB_INSERT(x, y)
+#define RB_REMOVE(name, x, y)	name##_RB_REMOVE(x, y)
+#define RB_FIND(name, x, y)	name##_RB_FIND(x, y)
+#define RB_NFIND(name, x, y)	name##_RB_NFIND(x, y)
+#define RB_NEXT(name, x, y)	name##_RB_NEXT(y)
+#define RB_PREV(name, x, y)	name##_RB_PREV(y)
+#define RB_MIN(name, x)		name##_RB_MINMAX(x, RB_NEGINF)
+#define RB_MAX(name, x)		name##_RB_MINMAX(x, RB_INF)
+
+#define RB_FOREACH(x, name, head)					\
+	for ((x) = RB_MIN(name, head);					\
+	     (x) != NULL;						\
+	     (x) = name##_RB_NEXT(x))
+
+#define RB_FOREACH_SAFE(x, name, head, y)				\
+	for ((x) = RB_MIN(name, head);					\
+	    ((x) != NULL) && ((y) = name##_RB_NEXT(x), 1);		\
+	     (x) = (y))
+
+#define RB_FOREACH_REVERSE(x, name, head)				\
+	for ((x) = RB_MAX(name, head);					\
+	     (x) != NULL;						\
+	     (x) = name##_RB_PREV(x))
+
+#define RB_FOREACH_REVERSE_SAFE(x, name, head, y)			\
+	for ((x) = RB_MAX(name, head);					\
+	    ((x) != NULL) && ((y) = name##_RB_PREV(x), 1);		\
+	     (x) = (y))
+
+#endif	/* _SYS_TREE_H_ */
diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/core/CMakeLists.txt
@@ -0,0 +1,14 @@
+CONFIGURE_FILE(version.h.in ${CMAKE_CURRENT_BINARY_DIR}/version.h)
+
+ADD_EXECUTABLE(
+    lifxd
+    bulb.c
+    client.c
+    discovery.c
+    gateway.c
+    lifxd.c
+    log.c
+    wire_proto.c
+)
+
+TARGET_LINK_LIBRARIES(lifxd ${EVENT2_CORE_LIBRARY})
diff --git a/core/bulb.c b/core/bulb.c
new file mode 100644
--- /dev/null
+++ b/core/bulb.c
@@ -0,0 +1,7 @@
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "wire_proto.h"
+#include "bulb.h"
diff --git a/core/bulb.h b/core/bulb.h
new file mode 100644
--- /dev/null
+++ b/core/bulb.h
@@ -0,0 +1,19 @@
+#pragma once
+
+struct lifxd_light_status {
+    uint8_t     addr[LIFXD_ADDR_LENGTH];
+    uint16_t    hue;
+    uint16_t    saturation;
+    uint16_t    brightness;
+    uint16_t    kelvin;
+    uint16_t    dim;
+    uint16_t    power;
+    char        label[LIFXD_LABEL_SIZE];
+    uint64_t    tags;
+};
+
+struct lifxd_bulb {
+    SLIST_ENTRY(lifxd_bulb)     link;
+    struct lifxd_light_status   *status;
+};
+SLIST_HEAD(lifxd_bulb_list, lifxd_bulb);
diff --git a/core/client.c b/core/client.c
new file mode 100644
diff --git a/core/client.h b/core/client.h
new file mode 100644
--- /dev/null
+++ b/core/client.h
@@ -0,0 +1,6 @@
+#pragma once
+
+struct lifxd_client {
+    LIST_ENTRY(lifxd_client)    link;
+};
+LIST_HEAD(lifxd_client_list, lifxd_client);
diff --git a/core/discovery.c b/core/discovery.c
new file mode 100644
--- /dev/null
+++ b/core/discovery.c
@@ -0,0 +1,376 @@
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <arpa/inet.h>
+#include <assert.h>
+#include <err.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <event2/event.h>
+#include <event2/buffer.h>
+#include <event2/bufferevent.h>
+#include <event2/util.h>
+
+#include "wire_proto.h"
+#include "discovery.h"
+#include "gateway.h"
+#include "lifxd.h"
+
+enum { LIFXD_DISCOVERY_BUF_SIZE = 1024 };
+
+struct lifxd_discovery_rd_ctx {
+    enum {
+        LIFXD_DISCOVERY_INIT,
+        LIFXD_DISCOVERY_HDR_RDY
+    }                           state;
+    struct event                *ev;
+    struct sockaddr_in          peer;
+    char                        buf[LIFXD_DISCOVERY_BUF_SIZE];
+    // TODO use pkt_offset and read_offset and keep everything in buf
+    unsigned                    offset;
+    struct lifxd_packet_header  hdr;
+    unsigned                    pkt_size;
+};
+
+struct lifxd_discovery_wr_ctx {
+    struct event                *ev;
+    struct lifxd_packet_header  command;
+    bool                        encoded;
+    unsigned                    to_write;
+};
+
+static struct {
+    evutil_socket_t                 socket;
+    struct lifxd_discovery_rd_ctx   read;
+    struct lifxd_discovery_wr_ctx   write;
+} lifxd_udp_endpoint = {
+    .socket = -1,
+    .write = {
+        .command = {
+            .size = LIFXD_PACKET_HEADER_SIZE,
+            .protocol = LIFXD_PROTOCOL_VERSION,
+            .packet_type = LIFXD_GET_PAN_GATEWAY
+        }
+    }
+};
+
+static int
+lifxd_discovery_recvfrom(struct sockaddr_in *peer, int howmuch)
+{
+    struct lifxd_discovery_rd_ctx *read = &lifxd_udp_endpoint.read;
+
+    assert(howmuch > 0);
+    assert(read->offset + howmuch <= sizeof(read->buf));
+    
+    while (true) {
+        ev_socklen_t socklen = sizeof(*peer);
+        int nbytes = recvfrom(
+            lifxd_udp_endpoint.socket,
+            &read->buf[read->offset],
+            howmuch,
+            0,
+            (struct sockaddr *)peer,
+            &socklen
+        );
+        if (nbytes == -1) {
+            int error = EVUTIL_SOCKET_ERROR();
+            if (error == EAGAIN) {
+                return 0;
+            }
+            if (error != EINTR) {
+                lifxd_err(1, "read error on the udp discovery socket");
+            }
+        } else {
+            return nbytes;
+        }
+    }
+}
+
+static void
+lifxd_discovery_handle_read(void)
+{
+    struct lifxd_discovery_rd_ctx *read = &lifxd_udp_endpoint.read;
+    struct sockaddr_in peer;
+
+    while (1) {
+        if (read->state == LIFXD_DISCOVERY_INIT) {
+            read->offset += lifxd_discovery_recvfrom(
+                &peer, LIFXD_PACKET_HEADER_SIZE - read->offset
+            );
+            if (read->offset == LIFXD_PACKET_HEADER_SIZE) {
+                memcpy(&read->peer, &peer, sizeof(peer));
+                // TODO: leave the header in the buf and use its size as an offset:
+                memcpy(&read->hdr, read->buf, LIFXD_PACKET_HEADER_SIZE);
+                lifxd_wire_decode_header(&read->hdr);
+                read->pkt_size = read->hdr.size - LIFXD_PACKET_HEADER_SIZE;
+                if (read->pkt_size > LIFXD_DISCOVERY_BUF_SIZE) {
+                    lifxd_warnx(
+                        "received bugged header from [%s]:%hu "
+                        "with packet size = %d, type = %#x",
+                        inet_ntoa(peer.sin_addr),
+                        ntohs(peer.sin_port),
+                        read->pkt_size,
+                        read->hdr.packet_type
+                    );
+                    read->offset = 0;
+                    continue;
+                }
+                read->state = LIFXD_DISCOVERY_HDR_RDY;
+                int extra_bytes = read->offset - LIFXD_PACKET_HEADER_SIZE;
+                if (extra_bytes) {
+                    memmove(read->buf, &read->buf[read->offset], extra_bytes);
+                    read->offset = 0;
+                }
+            } else {
+                return;
+            }
+        }
+        if (read->state == LIFXD_DISCOVERY_HDR_RDY) {
+            while (read->offset < read->pkt_size) {
+                int nbytes = lifxd_discovery_recvfrom(
+                    &peer, read->pkt_size - read->offset
+                );
+                if (!nbytes) {
+                    return;
+                }
+                if (peer.sin_addr.s_addr != read->peer.sin_addr.s_addr) {
+                    lifxd_warnx("different bulbs are advertising on the network");
+                } else {
+                    read->offset += nbytes;
+                }
+            }
+            const struct lifxd_packet_infos *pkt_infos =
+                lifxd_gateway_get_packet_infos(read->hdr.packet_type);
+            // We can run into 4 scenarios at this point:
+            // 1. We get a packet we don't know how to handle: discard and restart
+            //    the discovery;
+            // 2. We get a packet we know how to handle but which is not part of
+            //    the discovery process (i.e: not GET_PAN_GW nor PAN_GW): try to
+            //    handle it if we already know the gateway where it is from and
+            //    restart the discovery processs;
+            // 3. We get a GET_PAN_GW packet, probably, our own packet: discard it;
+            // 4. We get a PAN_GW packet: handle it and stop the discovery process.
+            if (pkt_infos) {
+                if (pkt_infos->type != LIFXD_GET_PAN_GATEWAY) {
+                    struct lifxd_gateway *gw = lifxd_gateway_get(read->hdr.gw_addr);
+                    if (!gw && pkt_infos->type == LIFXD_PAN_GATEWAY) {
+                        gw = lifxd_gateway_open(
+                            inet_ntoa(peer.sin_addr),
+                            ntohs(peer.sin_port),
+                            read->hdr.gw_addr
+                        );
+                    }
+                    if (gw) {
+                        pkt_infos->decode(read->buf);
+                        pkt_infos->handle(gw, &read->hdr, read->buf);
+                        if (pkt_infos->type == LIFXD_PAN_GATEWAY) {
+                            if (event_del(read->ev) == -1) {
+                                lifxd_warn("can't stop auto discovery");
+                            }
+                        } else if (!lifxd_discovery_start()) {
+                            lifxd_warn("can't start auto discovery");
+                        }
+                    }
+                } else {
+                    lifxd_debug(
+                        "discarding GET_PAN_GATEWAY packet from [%s]:%hu",
+                        inet_ntoa(peer.sin_addr),
+                        ntohs(peer.sin_port)
+                    );
+                }
+            } else {
+                lifxd_warnx(
+                    "received unknown packet %#x from [%s]:%hu",
+                    read->hdr.packet_type,
+                    inet_ntoa(peer.sin_addr),
+                    ntohs(peer.sin_port)
+                );
+                if (!lifxd_discovery_start()) {
+                    lifxd_warn("can't start auto discovery");
+                }
+            }
+            read->offset = 0;
+            read->state = LIFXD_DISCOVERY_INIT;
+        }
+    }
+}
+
+static void
+lifxd_discovery_handle_write(void)
+{
+    struct lifxd_discovery_wr_ctx *write = &lifxd_udp_endpoint.write;
+
+    if (write->to_write) {
+        struct sockaddr_in addr = {
+            .sin_family = AF_INET,
+            .sin_port = htons(lifxd_opts.master_port)
+        };
+        int nbytes;
+        inet_pton(AF_INET, "255.255.255.255", &addr.sin_addr);
+    retry:
+        nbytes = sendto(
+            lifxd_udp_endpoint.socket,
+            (void *)&write->command,
+            write->to_write,
+            0,
+            (struct sockaddr *)&addr,
+            sizeof(addr)
+        );
+        if (nbytes == -1) {
+            int error = EVUTIL_SOCKET_ERROR();
+            if (error == EINTR) {
+                goto retry;
+            } else if (error != EAGAIN) {
+                lifxd_warn("can't broadcast discovery packet");
+            }
+        } else {
+            write->to_write -= nbytes;
+        }
+    }
+
+    if (!write->to_write) {
+        lifxd_info("discovery packet has been broadcasted");
+        if (event_del(write->ev) == -1) {
+            lifxd_warn("can't stop discovery");
+        }
+    }
+}
+
+static void
+lifxd_discovery_event_callback(evutil_socket_t socket, short events, void *ctx)
+{
+    (void)socket;
+    (void)ctx;
+
+    if (events & EV_TIMEOUT) {
+        lifxd_errx(1, "timeout on the udp discovery socket");
+        // TODO: reset state and restart discovery.
+    }
+    if (events & EV_READ) {
+        lifxd_discovery_handle_read();
+    }
+    if (events & EV_WRITE) {
+        lifxd_discovery_handle_write();
+    }
+}
+
+bool
+lifxd_discovery_setup(void)
+{
+    assert(lifxd_udp_endpoint.socket == -1);
+
+    if (!lifxd_udp_endpoint.write.encoded) {
+        lifxd_wire_encode_header(&lifxd_udp_endpoint.write.command);
+        lifxd_udp_endpoint.write.encoded = true;
+    }
+
+    lifxd_udp_endpoint.socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+    if (lifxd_udp_endpoint.socket == -1) {
+        return false;
+    }
+
+    int val = 1;
+    int err = setsockopt(
+        lifxd_udp_endpoint.socket, SOL_SOCKET, SO_BROADCAST, &val, sizeof(val)
+    );
+    if (err == -1) {
+        goto err_setsockopt;
+    }
+
+    if (evutil_make_socket_nonblocking(lifxd_udp_endpoint.socket) == -1) {
+        goto err_ononblock;
+    }
+
+    struct evutil_addrinfo hints, *res = NULL;
+    memset(&hints, 0, sizeof(hints));
+    char port_str[6] = { 0 };
+    evutil_snprintf(
+        port_str, sizeof(port_str), "%hu", lifxd_opts.master_port
+    );
+    hints.ai_family = AF_INET;
+    hints.ai_socktype = SOCK_DGRAM;
+    hints.ai_protocol = IPPROTO_UDP;
+    hints.ai_flags = EVUTIL_AI_NUMERICHOST;
+
+    err = evutil_getaddrinfo("0.0.0.0", port_str, &hints, &res);
+    if (err || !res) {
+        goto err_getaddrinfo;
+    }
+    if (bind(lifxd_udp_endpoint.socket, res->ai_addr, res->ai_addrlen) == -1) {
+        evutil_freeaddrinfo(res);
+        goto err_bind;
+    }
+    freeaddrinfo(res);
+
+    lifxd_udp_endpoint.read.ev = event_new(
+        lifxd_ev_base,
+        lifxd_udp_endpoint.socket,
+        EV_READ|EV_PERSIST,
+        lifxd_discovery_event_callback,
+        NULL
+    );
+    lifxd_udp_endpoint.write.ev = event_new(
+        lifxd_ev_base,
+        lifxd_udp_endpoint.socket,
+        EV_WRITE|EV_PERSIST,
+        lifxd_discovery_event_callback,
+        NULL
+    );
+    if (!lifxd_udp_endpoint.read.ev || !lifxd_udp_endpoint.write.ev) {
+        goto err_event_new;
+    }
+    err = event_add(lifxd_udp_endpoint.read.ev, NULL);
+    if (err) {
+        goto err_event_add;
+    }
+
+    return true;
+
+err_event_add:
+err_event_new:
+    if (lifxd_udp_endpoint.read.ev) {
+        event_free(lifxd_udp_endpoint.read.ev);
+        lifxd_udp_endpoint.read.ev = NULL;
+    }
+    if (lifxd_udp_endpoint.write.ev) {
+        event_free(lifxd_udp_endpoint.write.ev);
+        lifxd_udp_endpoint.write.ev = NULL;
+    }
+err_bind:
+err_getaddrinfo:
+err_setsockopt:
+err_ononblock:
+    evutil_closesocket(lifxd_udp_endpoint.socket);
+    lifxd_udp_endpoint.socket = -1;
+    return false;
+}
+
+bool
+lifxd_discovery_start(void)
+{
+    assert(lifxd_udp_endpoint.write.to_write == 0);
+    assert(lifxd_udp_endpoint.socket != -1);
+    assert(lifxd_udp_endpoint.write.ev);
+    assert(lifxd_udp_endpoint.read.ev);
+
+    lifxd_udp_endpoint.write.to_write = LIFXD_PACKET_HEADER_SIZE;
+    if (event_add(lifxd_udp_endpoint.write.ev, NULL) == -1) {
+        goto err_enable_writes;
+    }
+    if (event_add(lifxd_udp_endpoint.read.ev, NULL) == -1) {
+        goto err_enable_reads;
+    }
+
+    lifxd_info("starting auto-discovery");
+    return true;
+
+err_enable_reads:
+    event_del(lifxd_udp_endpoint.write.ev);
+err_enable_writes:
+    lifxd_udp_endpoint.write.to_write = 0;
+    return false;
+}
diff --git a/core/discovery.h b/core/discovery.h
new file mode 100644
--- /dev/null
+++ b/core/discovery.h
@@ -0,0 +1,4 @@
+#pragma once
+
+bool lifxd_discovery_setup(void);
+bool lifxd_discovery_start(void);
diff --git a/core/gateway.c b/core/gateway.c
new file mode 100644
--- /dev/null
+++ b/core/gateway.c
@@ -0,0 +1,356 @@
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <assert.h>
+#include <err.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <event2/event.h>
+#include <event2/buffer.h>
+#include <event2/bufferevent.h>
+#include <event2/util.h>
+
+#include "wire_proto.h"
+#include "bulb.h"
+#include "gateway.h"
+#include "lifxd.h"
+
+static struct lifxd_gateway_list lifxd_gateways = \
+    LIST_HEAD_INITIALIZER(&lifxd_gateways);
+
+static struct lifxd_packet_infos_map lifxd_packet_infos = \
+    RB_INITIALIZER(&lifxd_packets_infos);
+
+RB_GENERATE_STATIC(
+    lifxd_packet_infos_map,
+    lifxd_packet_infos,
+    link,
+    lifxd_packet_infos_cmp
+);
+
+void
+lifxd_gateway_load_packet_infos_map(void)
+{
+#define DECODER(x)  ((void (*)(void *))(x))
+#define ENCODER(x)  ((void (*)(void *))(x))
+#define HANDLER(x)                                  \
+    ((void (*)(struct lifxd_gateway *,              \
+               const struct lifxd_packet_header *,  \
+               const void *))(x))
+
+    static struct lifxd_packet_infos packet_table[] = {
+        {
+            .name = "GET_PAN_GATEWAY",
+            .type = LIFXD_GET_PAN_GATEWAY
+        },
+        {
+            .name = "PAN_GATEWAY",
+            .type = LIFXD_PAN_GATEWAY,
+            .size = sizeof(struct lifxd_packet_pan_gateway),
+            .decode = DECODER(lifxd_wire_decode_pan_gateway),
+            .encode = ENCODER(lifxd_wire_encode_pan_gateway),
+            .handle = HANDLER(lifxd_gateway_handle_pan_gateway)
+        },
+        {
+            .name = "LIGHT_STATUS",
+            .type = LIFXD_LIGHT_STATUS,
+            .size = sizeof(struct lifxd_packet_light_status),
+            .decode = DECODER(lifxd_wire_decode_light_status),
+            .encode = ENCODER(lifxd_wire_encode_light_status),
+            .handle = HANDLER(lifxd_gateway_handle_light_status)
+        }
+    };
+
+    for (int i = 0; i != LIFXD_ARRAY_SIZE(packet_table); ++i) {
+        RB_INSERT(
+            lifxd_packet_infos_map, &lifxd_packet_infos, &packet_table[i]
+        );
+    }
+}
+
+const struct lifxd_packet_infos *
+lifxd_gateway_get_packet_infos(enum lifxd_packet_type packet_type)
+{
+    struct lifxd_packet_infos pkt_infos = { .type = packet_type };
+    return RB_FIND(lifxd_packet_infos_map, &lifxd_packet_infos, &pkt_infos);
+}
+
+static void
+lifxd_gateway_close(struct lifxd_gateway *gw)
+{
+    assert(gw);
+    assert(gw->io);
+
+    int sockfd = bufferevent_getfd(gw->io);
+    if (sockfd != -1) {
+        evutil_closesocket(sockfd);
+        LIST_REMOVE(gw, link);
+    }
+    bufferevent_free(gw->io);
+    lifxd_info(
+        "connection with gateway bulb [%s]:%hu closed",
+        gw->hostname,
+        gw->port
+    );
+    free(gw->hostname);
+    free(gw);
+}
+
+static void
+lifxd_gateway_event_callback(struct bufferevent *bev, short events, void *ctx)
+{
+    assert(ctx);
+
+    struct lifxd_gateway *gw = (struct lifxd_gateway *)ctx;
+    if (events & BEV_EVENT_CONNECTED) {
+        lifxd_info(
+            "connected to gateway bulb: [%s]:%hu", gw->hostname, gw->port
+        );
+        LIST_INSERT_HEAD(&lifxd_gateways, gw, link);
+        bufferevent_enable(bev, EV_READ|EV_WRITE|EV_TIMEOUT);
+    } else if (events & (BEV_EVENT_ERROR|BEV_EVENT_EOF)) {
+        if (events & BEV_EVENT_ERROR) {
+            int gai_error = bufferevent_socket_get_dns_error(gw->io);
+            if (gai_error) {
+                lifxd_warnx(
+                    "can't connect to %s: %s",
+                    gw->hostname,
+                    evutil_gai_strerror(gai_error)
+                );
+            } else {
+                lifxd_warn(
+                    "lost connection with gateway bulb [%s]:%hu",
+                    gw->hostname,
+                    gw->port
+                );
+            }
+        }
+        lifxd_gateway_close(gw);
+    }
+}
+
+static void
+lifxd_gateway_data_read_callback(struct bufferevent *bev, void *ctx)
+{
+    assert(ctx);
+
+    const struct lifxd_packet_infos *pkt_infos = NULL;
+    struct lifxd_gateway *gw = (struct lifxd_gateway *)ctx;
+    struct lifxd_packet_header *cur_hdr = &gw->cur_hdr;
+    void *cur_pkt = gw->cur_pkt;
+
+    if (gw->cur_hdr_offset != LIFXD_PACKET_HEADER_SIZE) {
+        gw->cur_hdr_offset += bufferevent_read(
+            bev,
+            ((void *)cur_hdr) + gw->cur_hdr_offset,
+            LIFXD_PACKET_HEADER_SIZE - gw->cur_hdr_offset
+        );
+        if (gw->cur_hdr_offset == LIFXD_PACKET_HEADER_SIZE) {
+            lifxd_wire_decode_header(cur_hdr);
+            lifxd_wire_dump_header(cur_hdr);
+            pkt_infos = lifxd_gateway_get_packet_infos(cur_hdr->packet_type);
+            if (pkt_infos) {
+                lifxd_debug(
+                    "received header from [%s]:%hu for packet %s",
+                    gw->hostname, gw->port, pkt_infos->name
+                );
+                gw->cur_pkt_size = pkt_infos->size;
+                if (gw->cur_pkt_size) {
+                    gw->cur_pkt = calloc(1, gw->cur_pkt_size);
+                    if (!gw->cur_pkt) {
+                        lifxd_err(1, "can't allocate memory for a packet");
+                    }
+                }
+            } else {
+                // TODO: discard the packet using the size in the header.
+                lifxd_errx(
+                    1,
+                    "received header from [%s]:%hu for unknown packet %#x",
+                    gw->hostname, gw->port, cur_hdr->packet_type
+                );
+                gw->cur_hdr_offset = 0;
+            }
+        }
+    }
+
+    if (gw->cur_hdr_offset == LIFXD_PACKET_HEADER_SIZE
+        && gw->cur_pkt_offset != gw->cur_pkt_size) {
+        gw->cur_pkt_offset += bufferevent_read(
+            bev,
+            cur_pkt + gw->cur_pkt_offset,
+            gw->cur_pkt_size - gw->cur_pkt_offset
+        );
+        if (gw->cur_pkt_offset == gw->cur_pkt_size) {
+            if (!pkt_infos) {
+                pkt_infos = lifxd_gateway_get_packet_infos(
+                    cur_hdr->packet_type
+                );
+                assert(pkt_infos);
+            }
+            pkt_infos->decode(gw->cur_pkt);
+            pkt_infos->handle(gw, cur_hdr, gw->cur_pkt);
+            free(gw->cur_pkt);
+            gw->cur_pkt = NULL;
+            gw->cur_pkt_size = 0;
+            gw->cur_pkt_offset = 0;
+            gw->cur_hdr_offset = 0;
+        }
+    }
+
+    if (gw->cur_hdr_offset == LIFXD_PACKET_HEADER_SIZE
+        && gw->cur_pkt_offset == gw->cur_pkt_size) {
+        lifxd_warnx(
+            "read event on [%s]:%hu while already handling a packet",
+            gw->hostname,
+            gw->port
+        );
+    }
+}
+
+struct lifxd_gateway *
+lifxd_gateway_open(const char *hostname, uint16_t port, const uint8_t *site)
+{
+    assert(hostname);
+    assert(port < UINT16_MAX);
+    assert(port > 0);
+
+    if (!site) {
+        lifxd_warnx("connecting directly to a bulb isn't supported yet");
+        return NULL;
+    }
+
+    struct lifxd_gateway *gw = calloc(1, sizeof(*gw));
+    if (!gw) {
+        lifxd_warn("can't allocate a new gateway bulb");
+        return false;
+    }
+    gw->io = bufferevent_socket_new(lifxd_ev_base, -1, 0);
+    if (!gw->io) {
+        lifxd_warn("can't allocate a new gateway bulb");
+        goto bev_alloc_error;
+    }
+    gw->hostname = strdup(hostname);
+    if (!gw->hostname) {
+        lifxd_warn("can't allocate a new gateway bulb");
+        goto hostname_alloc_error;
+    }
+    gw->port = port;
+    memcpy(gw->addr, site, sizeof(gw->addr));
+    bufferevent_setcb(
+        gw->io,
+        lifxd_gateway_data_read_callback,
+        NULL,
+        lifxd_gateway_event_callback,
+        gw
+    );
+
+    int error = bufferevent_socket_connect_hostname(
+        gw->io, NULL, AF_UNSPEC, hostname, port
+    );
+    if (!error) {
+        lifxd_info("new gateway at [%s]:%hu", hostname, port);
+        return gw;
+    }
+
+    free(gw->hostname);
+hostname_alloc_error:
+    bufferevent_free(gw->io);
+bev_alloc_error:
+    free(gw);
+    return NULL;
+}
+
+struct lifxd_gateway *
+lifxd_gateway_get(const uint8_t *site)
+{
+    assert(site);
+
+    struct lifxd_gateway *gw;
+    LIST_FOREACH(gw, &lifxd_gateways, link) {
+        if (!memcmp(gw->addr, site, sizeof(gw->addr))) {
+            return gw;
+        }
+    }
+
+    return NULL;
+}
+
+void
+lifxd_gateway_close_all(void)
+{
+    struct lifxd_gateway *gw, *next_gw;
+    LIST_FOREACH_SAFE(gw, &lifxd_gateways, link, next_gw) {
+        lifxd_gateway_close(gw);
+    }
+}
+
+void
+lifxd_gateway_get_pan_gateway(struct lifxd_gateway *gw)
+{
+    assert(gw);
+
+    struct lifxd_packet_header hdr = {
+        .size = LIFXD_PACKET_HEADER_SIZE,
+        .protocol = LIFXD_PROTOCOL_VERSION,
+        .packet_type = LIFXD_GET_PAN_GATEWAY
+    };
+    lifxd_wire_encode_header(&hdr);
+    lifxd_debug("GET_PAN_GATEWAY → [%s]:%hu", gw->hostname, gw->port);
+    bufferevent_write(gw->io, &hdr, sizeof(hdr));
+}
+
+void
+lifxd_gateway_handle_pan_gateway(struct lifxd_gateway *gw,
+                                 const struct lifxd_packet_header *hdr,
+                                 const struct lifxd_packet_pan_gateway *pkt)
+{
+    assert(gw && hdr && pkt);
+
+    lifxd_debug(
+        "SET_PAN_GATEWAY ← [%s]:%hu - %hhx:%hhx:%hhx:%hhx:%hhx:%hhx ",
+        "gw_addr=%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+        gw->hostname, gw->port,
+        &hdr->bulb_addr[0], &hdr->bulb_addr[1], &hdr->bulb_addr[2],
+        &hdr->bulb_addr[3], &hdr->bulb_addr[4], &hdr->bulb_addr[5],
+        &hdr->gw_addr[0], &hdr->gw_addr[1], &hdr->gw_addr[2],
+        &hdr->gw_addr[3], &hdr->gw_addr[4], &hdr->gw_addr[5]
+    );
+    memcpy(gw->addr, &gw->cur_hdr.gw_addr, sizeof(gw->addr));
+}
+
+void
+lifxd_gateway_get_light_status(struct lifxd_gateway *gw)
+{
+    assert(gw);
+
+    struct lifxd_packet_header hdr = {
+        .size = LIFXD_PACKET_HEADER_SIZE,
+        .protocol = LIFXD_PROTOCOL_VERSION,
+        .packet_type = LIFXD_GET_LIGHT_STATE
+    };
+    lifxd_wire_encode_header(&hdr);
+    lifxd_debug("GET_LIGHT_STATE → [%s]:%hu", gw->hostname, gw->port);
+    bufferevent_write(gw->io, &hdr, sizeof(hdr));
+}
+
+void
+lifxd_gateway_handle_light_status(struct lifxd_gateway *gw,
+                                  const struct lifxd_packet_header *hdr,
+                                  const struct lifxd_packet_light_status *pkt)
+{
+    assert(gw && hdr && pkt);
+
+    lifxd_debug(
+        "SET_LIGHT_STATUS ← [%s]:%hu - %hhx.%hhx.%hhx.%hhx.%hhx.%hhx "
+        "hue=%#hx, saturation=%#hx, brightness=%#hx, "
+        "kelvin=%hx, dim=%#hx, power=%#hx, label=%.*s, tags=%lx",
+        gw->hostname, gw->port,
+        &hdr->bulb_addr[0], &hdr->bulb_addr[1], &hdr->bulb_addr[2],
+        &hdr->bulb_addr[3], &hdr->bulb_addr[4], &hdr->bulb_addr[5],
+        pkt->hue, pkt->saturation, pkt->brightness, pkt->kelvin,
+        pkt->dim, pkt->power, pkt->label, pkt->tags
+    );
+}
diff --git a/core/gateway.h b/core/gateway.h
new file mode 100644
--- /dev/null
+++ b/core/gateway.h
@@ -0,0 +1,54 @@
+#pragma once
+
+struct lifxd_gateway {
+    LIST_ENTRY(lifxd_gateway)   link;
+    char                        *hostname;
+    uint16_t                    port;
+    struct bufferevent          *io;
+    uint8_t                     addr[LIFXD_ADDR_LENGTH];
+    struct lifxd_bulb_list      *bulbs;
+    struct lifxd_packet_header  cur_hdr;
+    unsigned                    cur_hdr_offset;
+    void                        *cur_pkt;
+    unsigned                    cur_pkt_offset;
+    unsigned                    cur_pkt_size;
+};
+LIST_HEAD(lifxd_gateway_list, lifxd_gateway);
+
+struct lifxd_packet_infos {
+    RB_ENTRY(lifxd_packet_infos)    link;
+    const char                      *name;
+    enum lifxd_packet_type          type;
+    unsigned                        size;
+    void                            (*decode)(void *);
+    void                            (*encode)(void *);
+    void                            (*handle)(struct lifxd_gateway *,
+                                              const struct lifxd_packet_header *,
+                                              const void *);
+};
+RB_HEAD(lifxd_packet_infos_map, lifxd_packet_infos);
+
+static inline int
+lifxd_packet_infos_cmp(struct lifxd_packet_infos *a,
+                       struct lifxd_packet_infos *b)
+{
+    return a->type - b->type;
+}
+
+void lifxd_gateway_load_packet_infos_map(void);
+const struct lifxd_packet_infos *lifxd_gateway_get_packet_infos(enum lifxd_packet_type);
+
+struct lifxd_gateway *lifxd_gateway_get(const uint8_t *);
+struct lifxd_gateway *lifxd_gateway_open(const char *,
+                                         uint16_t,
+                                         const uint8_t *);
+void lifxd_gateway_close_all(void);
+
+void lifxd_gateway_get_pan_gateway(struct lifxd_gateway *);
+void lifxd_gateway_handle_pan_gateway(struct lifxd_gateway *,
+                                      const struct lifxd_packet_header *,
+                                      const struct lifxd_packet_pan_gateway *);
+void lifxd_gateway_get_light_status(struct lifxd_gateway *);
+void lifxd_gateway_handle_light_status(struct lifxd_gateway *,
+                                       const struct lifxd_packet_header *,
+                                       const struct lifxd_packet_light_status *);
diff --git a/core/json_proto.h b/core/json_proto.h
new file mode 100644
diff --git a/core/lifxd.c b/core/lifxd.c
new file mode 100644
--- /dev/null
+++ b/core/lifxd.c
@@ -0,0 +1,145 @@
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <err.h>
+#include <errno.h>
+#include <getopt.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <strings.h>
+
+#include <event2/event.h>
+
+#include "wire_proto.h"
+#include "gateway.h"
+#include "discovery.h"
+#include "version.h"
+#include "lifxd.h"
+
+struct lifxd_opts lifxd_opts = {
+    .foreground = false,
+    .master_host = NULL,
+    .master_port = 56700,
+    .verbosity = LIFXD_DEBUG
+}; 
+
+struct event_base *lifxd_ev_base = NULL;
+
+void
+lifxd_cleanup(void)
+{
+    lifxd_gateway_close_all();
+    event_base_free(lifxd_ev_base);
+#if LIBEVENT_VERSION_NUMBER >= 0x02010100
+    libevent_global_shutdown();
+#endif
+}
+
+static void
+lifxd_configure_libevent(void)
+{
+    lifxd_gateway_close_all();
+    event_set_log_callback(lifxd_libevent_log);
+#ifndef NDEBUG
+    // NOTE: let's keep in mind that we need to call event_debug_unassign when
+    // using that and event_assign:
+    event_enable_debug_mode();
+#endif
+    lifxd_ev_base = event_base_new();
+}
+
+static void
+lifxd_usage(const char *progname)
+{
+    printf(
+        "Usage: %s [-m master_bulb_host] [-p master_bulb_port] "
+        "[-v debug|info|warning|error] [-f] [-h] [-V]\n",
+        progname
+    );
+    exit(0);
+}
+
+int
+main(int argc, char *argv[])
+{
+    static const struct option opts[] = {
+        {"foreground",  no_argument,       NULL, 'f'},
+        {"help",        no_argument,       NULL, 'h'},
+        {"master-host", required_argument, NULL, 'm'},
+        {"master-port", required_argument, NULL, 'p'},
+        {"verbosity",   required_argument, NULL, 'v'},
+        {"version",     no_argument,       NULL, 'V'},
+        {NULL,          0,                 NULL, 0}
+    };
+
+    for (int rv = getopt_long(argc, argv, "fhm:p:v:V", opts, NULL);
+         rv != -1;
+         rv = getopt_long(argc, argv, "fh:p:v:V", opts, NULL)) {
+        switch (rv) {
+        case 'f':
+            lifxd_opts.foreground = true;
+            break ;
+        case 'h':
+            lifxd_usage(argv[0]);
+        case 'm':
+            lifxd_opts.master_host = optarg;
+            break ;
+        case 'p':
+            errno = 0;
+            long port = strtol(optarg, NULL, 10);
+            if (!errno && port <= UINT16_MAX && port > 0) {
+                lifxd_opts.master_port = port;
+                break ;
+            }
+            lifxd_errx(
+                1, "The master port must be between 1 and %d", UINT16_MAX
+            );
+        case 'v':
+            for (int i = 0;;) {
+                const char *verbose_levels[] = {
+                    "debug", "info", "warning", "error"
+                };
+                if (!strcasecmp(optarg, verbose_levels[i])) {
+                    lifxd_opts.verbosity = i;
+                    break ;
+                }
+                if (++i == LIFXD_ARRAY_SIZE(verbose_levels)) {
+                    lifxd_errx(1, "Unknown verbosity level: %s", optarg);
+                }
+            }
+            break ;
+        case 'V':
+            printf("%s v%s\n", argv[0], LIFXD_VERSION);
+            return 0;
+        default:
+            lifxd_usage(argv[0]);
+        }
+    }
+
+    argc -= optind;
+    argv += optind;
+
+    lifxd_configure_libevent();
+    lifxd_gateway_load_packet_infos_map();
+
+    if (lifxd_opts.master_host) {
+        struct lifxd_gateway *gw = lifxd_gateway_open(
+            lifxd_opts.master_host, lifxd_opts.master_port, NULL
+        );
+        if (!gw)
+            lifxd_errx(1, "no bulb to connect to");
+    } else {
+        lifxd_discovery_setup();
+        if (!lifxd_discovery_start()) {
+            lifxd_err(1, "can't start auto discovery");
+        }
+    }
+
+    event_base_dispatch(lifxd_ev_base);
+
+    lifxd_cleanup();
+
+    return 0;
+}
diff --git a/core/lifxd.h b/core/lifxd.h
new file mode 100644
--- /dev/null
+++ b/core/lifxd.h
@@ -0,0 +1,34 @@
+#pragma once
+
+#define LIFXD_ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+
+enum lifxd_verbosity {
+    LIFXD_DEBUG = 0,
+    LIFXD_INFO,
+    LIFXD_WARN,
+    LIFXD_ERR
+};
+
+struct lifxd_opts {
+    bool                    foreground;
+    const char              *master_host;
+    uint16_t                master_port;
+    enum lifxd_verbosity    verbosity;
+};
+
+extern struct lifxd_opts lifxd_opts;
+extern struct event_base *lifxd_ev_base;
+
+void _lifxd_err(void (*)(int, const char *, va_list), int, const char *, ...);
+#define lifxd_err(eval, fmt, ...) _lifxd_err(verr, (eval), (fmt), ##__VA_ARGS__);
+#define lifxd_errx(eval, fmt, ...) _lifxd_err(verrx, (eval), (fmt), ##__VA_ARGS__);
+void _lifxd_warn(void (*)(const char *, va_list), const char *, ...);
+#define lifxd_warn(fmt, ...) _lifxd_warn(vwarn, (fmt), ##__VA_ARGS__);
+#define lifxd_warnx(fmt, ...) _lifxd_warn(vwarnx, (fmt), ##__VA_ARGS__);
+void lifxd_info(const char *, ...);
+void lifxd_debug(const char *, ...);
+void lifxd_libevent_log(int, const char *);
+
+#define lifxd_nop (void)0
+
+void lifxd_cleanup(void);
diff --git a/core/log.c b/core/log.c
new file mode 100644
--- /dev/null
+++ b/core/log.c
@@ -0,0 +1,75 @@
+#include <err.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#include <event2/event.h>
+
+#include "lifxd.h"
+
+void
+_lifxd_err(void (*errfn)(int, const char *, va_list),
+           int eval,
+           const char *fmt,
+           ...)
+{
+    va_list ap;
+    va_start(ap, fmt);
+    int errsave = errno;
+    lifxd_cleanup();
+    errno = errsave;
+    fputs("[ERR]   ", stderr);
+    errfn(eval, fmt, ap);
+}
+
+void
+_lifxd_warn(void (*warnfn)(const char *, va_list), const char *fmt, ...)
+{
+    if (lifxd_opts.verbosity <= LIFXD_WARN) {
+        va_list ap;
+        va_start(ap, fmt);
+        fputs("[WARN]  ", stderr);
+        warnfn(fmt, ap);
+        va_end(ap);
+    }
+}
+
+void
+lifxd_info(const char *fmt, ...)
+{
+    if (lifxd_opts.verbosity <= LIFXD_INFO) {
+        va_list ap;
+        va_start(ap, fmt);
+        fprintf(stderr, "[INFO]  lifxd: ");
+        vfprintf(stderr, fmt, ap);
+        va_end(ap);
+        fprintf(stderr, "\n");
+    }
+}
+
+void
+lifxd_debug(const char *fmt, ...)
+{
+    if (lifxd_opts.verbosity <= LIFXD_DEBUG) {
+        va_list ap;
+        va_start(ap, fmt);
+        fprintf(stderr, "[DEBUG] lifxd: ");
+        vfprintf(stderr, fmt, ap);
+        va_end(ap);
+        fprintf(stderr, "\n");
+    }
+}
+
+void
+lifxd_libevent_log(int severity, const char *msg)
+{
+    switch (severity) {
+    case EVENT_LOG_DEBUG:   lifxd_debug(msg);   break;
+    case EVENT_LOG_MSG:     lifxd_info(msg);    break;
+    case EVENT_LOG_WARN:    lifxd_warnx(msg)    break;
+    case EVENT_LOG_ERR:     lifxd_warnx(msg);   break;
+    default:                                    break;
+    }
+}
diff --git a/core/version.h.in b/core/version.h.in
new file mode 100644
--- /dev/null
+++ b/core/version.h.in
@@ -0,0 +1,3 @@
+#pragma once
+
+const char LIFXD_VERSION[] = "@LIFXD_VERSION@";
diff --git a/core/wire_proto.c b/core/wire_proto.c
new file mode 100644
--- /dev/null
+++ b/core/wire_proto.c
@@ -0,0 +1,80 @@
+#include <assert.h>
+#include <endian.h>
+#include <err.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "wire_proto.h"
+#include "lifxd.h"
+
+// Convert all the fields in the header to the host endianness.
+//
+// :returns: The payload size or -1 if the header is invalid.
+void
+lifxd_wire_decode_header(struct lifxd_packet_header *hdr)
+{
+    assert(hdr);
+
+    hdr->size = le16toh(hdr->size);
+    hdr->protocol = be16toh(hdr->protocol);
+    hdr->timestamp = be64toh(hdr->timestamp);
+    hdr->packet_type = le16toh(hdr->packet_type);
+}
+
+void
+lifxd_wire_encode_header(struct lifxd_packet_header *hdr)
+{
+    assert(hdr);
+
+    hdr->size = htole16(hdr->size);
+    hdr->protocol = htobe16(hdr->protocol);
+    hdr->timestamp = htobe64(hdr->timestamp);
+    hdr->packet_type = htole16(hdr->packet_type);
+}
+
+void
+lifxd_wire_dump_header(const struct lifxd_packet_header *hdr)
+{
+    assert(hdr);
+    lifxd_debug(
+        "header @%p: size=%hu, protocol=%hu, timestamp=%lu, packet_type=%hx",
+        hdr, hdr->size, hdr->protocol, hdr->timestamp, hdr->packet_type
+    );
+}
+
+void
+lifxd_wire_decode_pan_gateway(struct lifxd_packet_pan_gateway *pkt)
+{
+    pkt->port = le32toh(pkt->port);
+}
+
+void
+lifxd_wire_encode_pan_gateway(struct lifxd_packet_pan_gateway *pkt)
+{
+    pkt->port = htole32(pkt->port);
+}
+
+void
+lifxd_wire_decode_light_status(struct lifxd_packet_light_status *pkt)
+{
+    pkt->hue = le16toh(pkt->hue);
+    pkt->saturation = le16toh(pkt->saturation);
+    pkt->brightness = le16toh(pkt->brightness);
+    pkt->kelvin = le16toh(pkt->kelvin);
+    pkt->dim = le16toh(pkt->dim);
+    pkt->power = le16toh(pkt->power);
+    pkt->tags = be64toh(pkt->tags);
+}
+
+void
+lifxd_wire_encode_light_status(struct lifxd_packet_light_status *pkt)
+{
+    pkt->hue = htole16(pkt->hue);
+    pkt->saturation = htole16(pkt->saturation);
+    pkt->brightness = htole16(pkt->brightness);
+    pkt->kelvin = htole16(pkt->kelvin);
+    pkt->dim = htole16(pkt->dim);
+    pkt->power = htole16(pkt->power);
+    pkt->tags = htobe64(pkt->tags);
+}
diff --git a/core/wire_proto.h b/core/wire_proto.h
new file mode 100644
--- /dev/null
+++ b/core/wire_proto.h
@@ -0,0 +1,114 @@
+#pragma once
+
+#pragma pack(push, 1)
+
+typedef uint16_t uint16le_t;
+typedef uint16_t uint16be_t;
+typedef uint32_t uint32le_t;
+typedef uint32_t uint32be_t;
+typedef uint64_t uint64le_t;
+typedef uint64_t uint64be_t;
+
+enum { LIFXD_ADDR_LENGTH = 6 };
+
+struct lifxd_packet_header {
+    uint16le_t  size;
+    uint16be_t  protocol;
+    uint8_t     reserved1[4];
+    uint8_t     bulb_addr[LIFXD_ADDR_LENGTH];
+    uint8_t     reserved2[2];
+    uint8_t     gw_addr[LIFXD_ADDR_LENGTH];
+    uint8_t     reserved3[2];
+    uint64be_t  timestamp;
+    uint16le_t  packet_type;
+    uint8_t     reserved4[2];
+};
+
+enum { LIFXD_PACKET_HEADER_SIZE = sizeof(struct lifxd_packet_header) };
+enum { LIFXD_PROTOCOL_VERSION = 0x54 };
+
+enum lifxd_packet_type {
+    LIFXD_GET_PAN_GATEWAY = 0x02,
+    LIFXD_PAN_GATEWAY = 0x03,
+    LIFXD_GET_TIME = 0x04,
+    LIFXD_SET_TIME = 0x05,
+    LIFXD_TIME_STATE = 0x06,
+    LIFXD_GET_RESET_SWITCH_STATE = 0x07,
+    LIFXD_RESET_SWITCH_STATE = 0x08,
+    LIFXD_GET_MESH_INFO = 0x0c,
+    LIFXD_MESH_INFO = 0x0d,
+    LIFXD_GET_MESH_FIRMWARE = 0x0e,
+    LIFXD_MESH_FIRMWARE = 0x0f,
+    LIFXD_GET_WIFI_INFO = 0x10,
+    LIFXD_WIFI_INFO = 0x11,
+    LIFXD_GET_WIFI_FIRMWARE_STATE = 0x12,
+    LIFXD_WIFI_FIRMWARE_STATE = 0x13,
+    LIFXD_GET_POWER_STATE = 0x14,
+    LIFXD_SET_POWER_STATE = 0x15,
+    LIFXD_POWER_STATE = 0x16,
+    LIFXD_GET_BULB_LABEL = 0x17,
+    LIFXD_SET_BULB_LABEL = 0x18,
+    LIFXD_BULB_LABEL = 0x19,
+    LIFXD_GET_TAGS = 0x1a,
+    LIFXD_SET_TAGS = 0x1b,
+    LIFXD_TAGS = 0x1c,
+    LIFXD_GET_TAG_LABELS = 0x1d,
+    LIFXD_SET_TAG_LABELS = 0x1e,
+    LIFXD_TAG_LABELS = 0x1f,
+    LIFXD_GET_VERSION = 0x20,
+    LIFXD_VERSION_STATE = 0x21,
+    LIFXD_GET_INFO = 0x22,
+    LIFXD_INFO_STATE = 0x23,
+    LIFXD_GET_MCU_RAIL_VOLTAGE = 0x24,
+    LIFXD_MCU_RAIL_VOLTAGE = 0x25,
+    LIFXD_REBOOT = 0x26,
+    LIFXD_SET_FACTORY_TEST_MODE = 0x27,
+    LIFXD_DISABLE_FACTORY_TEST_MODE = 0x28,
+    LIFXD_GET_LIGHT_STATE = 0x65,
+    LIFXD_SET_LIGHT_COLOUR = 0x66,
+    LIFXD_SET_WAVEFORM = 0x67,
+    LIFXD_SET_DIM_ABSOLUTE = 0x68,
+    LIFXD_SET_DIM_RELATIVE = 0x69,
+    LIFXD_LIGHT_STATUS = 0x6b,
+    LIFXD_GET_WIFI_STATE = 0x12d,
+    LIFXD_SET_WIFI_STATE = 0x12e,
+    LIFXD_WIFI_STATE = 0x12f,
+    LIFXD_GET_ACCESS_POINTS = 0x130,
+    LIFXD_SET_ACCESS_POINTS = 0x131,
+    LIFXD_ACCESS_POINT = 0x132,
+};
+
+enum { LIFXD_LABEL_SIZE = 32 };
+
+struct lifxd_packet_light_status {
+    uint16le_t  hue;
+    uint16le_t  saturation;
+    uint16le_t  brightness;
+    uint16le_t  kelvin;
+    uint16le_t  dim;
+    uint16le_t  power;
+    uint8_t     label[LIFXD_LABEL_SIZE];
+    uint64be_t  tags;
+};
+
+enum lifxd_service_type {
+    LIFXD_SERVICE_TCP = 1,
+    LIFXD_SERVICE_UDP = 2
+};
+
+struct lifxd_packet_pan_gateway {
+    uint8_t     service_type; // see enum lifxd_service_type
+    uint32le_t  port;
+};
+
+void lifxd_wire_decode_header(struct lifxd_packet_header *);
+void lifxd_wire_encode_header(struct lifxd_packet_header *);
+void lifxd_wire_dump_header(const struct lifxd_packet_header *);
+void lifxd_wire_encode_packet(void *, enum lifxd_packet_type);
+
+void lifxd_wire_decode_pan_gateway(struct lifxd_packet_pan_gateway *);
+void lifxd_wire_encode_pan_gateway(struct lifxd_packet_pan_gateway *);
+void lifxd_wire_decode_light_status(struct lifxd_packet_light_status *);
+void lifxd_wire_encode_light_status(struct lifxd_packet_light_status *);
+
+#pragma pack(pop)
