# HG changeset patch
# Parent d03081a756d820aeaedd6548055fd3bb71ce929c

diff --git a/core/broadcast.c b/core/broadcast.c
--- a/core/broadcast.c
+++ b/core/broadcast.c
@@ -50,7 +50,7 @@
 #include "broadcast.h"
 #include "lifxd.h"
 
-static struct lifxd_packet_infos_map lifxd_packet_infos = \
+static struct lifxd_packet_infos_map lifxd_packet_infos =
     RB_INITIALIZER(&lifxd_packets_infos);
 
 RB_GENERATE_STATIC(
diff --git a/core/bulb.c b/core/bulb.c
--- a/core/bulb.c
+++ b/core/bulb.c
@@ -44,22 +44,25 @@
 #include "gateway.h"
 #include "lifxd.h"
 
-static struct lifxd_bulb_list lifxd_bulbs = LIST_HEAD_INITIALIZER(&lifxd_bulbs);
+static struct lifxd_bulb_map lifxd_bulbs_table =
+    RB_INITIALIZER(&lifxd_bulbs_by_addr);
+
+RB_GENERATE_STATIC(
+    lifxd_bulb_map,
+    lifxd_bulb,
+    link,
+    lifxd_bulb_cmp
+);
 
 struct lifxd_bulb *
 lifxd_bulb_get(struct lifxd_gateway *gw, const uint8_t *addr)
 {
     assert(gw);
+    assert(addr);
 
-    struct lifxd_bulb *bulb, *next_bulb;
-    LIST_FOREACH_SAFE(bulb, &lifxd_bulbs, link, next_bulb) {
-        if (bulb->gw == gw
-            && (!addr || !memcmp(bulb->addr, addr, sizeof(bulb->addr)))) {
-            return bulb;
-        }
-    }
-
-    return NULL;
+    struct lifxd_bulb bulb;
+    memcpy(bulb.addr, addr, sizeof(bulb.addr));
+    return RB_FIND(lifxd_bulb_map, &lifxd_bulbs_table, &bulb);
 }
 
 struct lifxd_bulb *
@@ -76,27 +79,7 @@
 
     bulb->gw = gw;
     memcpy(bulb->addr, addr, sizeof(bulb->addr));
-    LIST_INSERT_HEAD(&lifxd_bulbs, bulb, link);
-
-    return bulb;
-}
-
-struct lifxd_bulb *
-lifxd_bulb_get_or_open(struct lifxd_gateway *gw, const uint8_t *addr)
-{
-    assert(gw);
-    assert(addr);
-
-    struct lifxd_bulb *bulb = lifxd_bulb_get(gw, addr);
-    if (!bulb) {
-        bulb = lifxd_bulb_open(gw, addr);
-        if (bulb) {
-            lifxd_info(
-                "discovered new bulb %s on [%s]:%hu",
-                lifxd_addrtoa(addr), gw->ip_addr, gw->port
-            );
-        }
-    }
+    RB_INSERT(lifxd_bulb_map, &lifxd_bulbs_table, bulb);
 
     return bulb;
 }
@@ -107,7 +90,7 @@
     assert(bulb);
     assert(bulb->gw);
 
-    LIST_REMOVE(bulb, link);
+    RB_REMOVE(lifxd_bulb_map, &lifxd_bulbs_table, bulb);
     lifxd_info(
         "closed bulb \"%.*s\" on [%s]:%hu",
         sizeof(bulb->status.label),
@@ -117,3 +100,20 @@
     );
     free(bulb);
 }
+
+void
+lifxd_bulb_set_light_status(struct lifxd_bulb *bulb,
+                            const struct lifxd_light_status *status)
+{
+    assert(bulb);
+    assert(status);
+    memcpy(&bulb->status, status, sizeof(bulb->status));
+}
+
+
+void
+lifxd_bulb_set_power_state(struct lifxd_bulb *bulb, uint16_t power)
+{
+    assert(bulb);
+    bulb->status.power = power;
+}
diff --git a/core/bulb.h b/core/bulb.h
--- a/core/bulb.h
+++ b/core/bulb.h
@@ -45,14 +45,24 @@
 #pragma pack(pop)
 
 struct lifxd_bulb {
-    LIST_ENTRY(lifxd_bulb)      link;
+    RB_ENTRY(lifxd_bulb)        link;
+    SLIST_ENTRY(lifxd_bulb)     link_by_gw;
     struct lifxd_gateway        *gw;
     uint8_t                     addr[LIFXD_ADDR_LENGTH];
     struct lifxd_light_status   status;
 };
-LIST_HEAD(lifxd_bulb_list, lifxd_bulb);
+RB_HEAD(lifxd_bulb_map, lifxd_bulb);
+SLIST_HEAD(lifxd_bulb_list, lifxd_bulb);
+
+static inline int
+lifxd_bulb_cmp(const struct lifxd_bulb *a, const struct lifxd_bulb *b)
+{
+    return memcmp(a->addr, b->addr, sizeof(a->addr));
+}
 
 struct lifxd_bulb *lifxd_bulb_get(struct lifxd_gateway *, const uint8_t *);
 struct lifxd_bulb *lifxd_bulb_open(struct lifxd_gateway *, const uint8_t *);
-struct lifxd_bulb *lifxd_bulb_get_or_open(struct lifxd_gateway *, const uint8_t *);
 void lifxd_bulb_close(struct lifxd_bulb *);
+
+void lifxd_bulb_set_light_status(struct lifxd_bulb *, const struct lifxd_light_status *);
+void lifxd_bulb_set_power_state(struct lifxd_bulb *, uint16_t);
diff --git a/core/gateway.c b/core/gateway.c
--- a/core/gateway.c
+++ b/core/gateway.c
@@ -57,18 +57,20 @@
 {
     assert(gw);
 
+    event_del(gw->refresh_ev);
     event_del(gw->write_ev);
     if (gw->socket != -1) {
         evutil_closesocket(gw->socket);
         LIST_REMOVE(gw, link);
     }
+    event_free(gw->refresh_ev);
     event_free(gw->write_ev);
     evbuffer_free(gw->write_buf);
-    for (struct lifxd_bulb *bulb = lifxd_bulb_get(gw, NULL);
-         bulb;
-         bulb = lifxd_bulb_get(gw, NULL)) {
+    struct lifxd_bulb *bulb, *next_bulb;
+    SLIST_FOREACH_SAFE(bulb, &gw->bulbs, link_by_gw, next_bulb) {
         lifxd_bulb_close(bulb);
     }
+
     lifxd_info(
         "connection with gateway bulb [%s]:%hu closed", gw->ip_addr, gw->port
     );
@@ -76,26 +78,7 @@
 }
 
 static void
-lifxd_gateway_handle_write(struct lifxd_gateway *gw)
-{
-    assert(gw);
-
-    if (evbuffer_write(gw->write_buf, gw->socket) == -1 && errno != EAGAIN) {
-        lifxd_warn("can't write to [%s]:%hu", gw->ip_addr, gw->port);
-        lifxd_gateway_close(gw);
-        if (!lifxd_broadcast_discovery()) {
-            lifxd_err(1, "can't start auto discovery");
-        }
-        return;
-    }
-
-    if (!evbuffer_get_length(gw->write_buf)) {
-        event_del(gw->write_ev);
-    }
-}
-
-static void
-lifxd_gateway_event_callback(evutil_socket_t socket, short events, void *ctx)
+lifxd_gateway_write_callback(evutil_socket_t socket, short events, void *ctx)
 {
     (void)socket;
 
@@ -113,10 +96,64 @@
         return;
     }
     if (events & EV_WRITE) {
-        lifxd_gateway_handle_write(gw);
+        if (evbuffer_write(gw->write_buf, gw->socket) == -1 && errno != EAGAIN) {
+            lifxd_warn("can't write to [%s]:%hu", gw->ip_addr, gw->port);
+            lifxd_gateway_close(gw);
+            if (!lifxd_broadcast_discovery()) {
+                lifxd_err(1, "can't start auto discovery");
+            }
+            return;
+        }
+        if (!evbuffer_get_length(gw->write_buf)) {
+            event_del(gw->write_ev);
+        }
     }
 }
 
+static void
+lifxd_gateway_refresh_callback(evutil_socket_t socket, short events, void *ctx)
+{
+    (void)socket;
+    (void)events;
+
+    assert(ctx);
+
+    struct lifxd_gateway *gw = (struct lifxd_gateway *)ctx;
+
+    int buflen = evbuffer_get_length(gw->write_buf);
+    if (buflen < LIFXD_GATEWAY_WRITE_HIGH_WATERMARK) {
+        struct lifxd_bulb *bulb;
+        SLIST_FOREACH(bulb, &gw->bulbs, link_by_gw) {
+            lifxd_gateway_get_light_status(gw, bulb);
+        }
+        return;
+    }
+    lifxd_info(
+        "refresh skipped on gateway [%s]:%hu, (buflen=%d)",
+        gw->ip_addr, gw->port, buflen
+    );
+}
+
+static struct lifxd_bulb *
+lifxd_gateway_get_or_open_bulb(struct lifxd_gateway *gw, const uint8_t *bulb_addr)
+{
+    assert(gw);
+    assert(bulb_addr);
+
+    struct lifxd_bulb *bulb = lifxd_bulb_get(gw, bulb_addr);
+    if (!bulb) {
+        bulb = lifxd_bulb_open(gw, bulb_addr);
+        if (bulb) {
+            SLIST_INSERT_HEAD(&gw->bulbs, bulb, link_by_gw);
+            lifxd_info(
+                "discovered new bulb %s on [%s]:%hu",
+                lifxd_addrtoa(bulb_addr), gw->ip_addr, gw->port
+            );
+        }
+    }
+    return bulb;
+}
+
 struct lifxd_gateway *
 lifxd_gateway_open(const struct sockaddr_storage *peer, const uint8_t *site)
 {
@@ -146,33 +183,53 @@
         lifxd_ev_base,
         gw->socket,
         EV_WRITE|EV_PERSIST,
-        lifxd_gateway_event_callback,
+        lifxd_gateway_write_callback,
         gw
     );
     gw->write_buf = evbuffer_new();
+    gw->refresh_ev = event_new(
+        lifxd_ev_base,
+        -1,
+        EV_PERSIST,
+        lifxd_gateway_refresh_callback,
+        gw
+    );
     lifxd_sockaddrtoa(peer, gw->ip_addr, sizeof(gw->ip_addr));
     gw->port = lifxd_sockaddrport(peer);
     memcpy(gw->addr, site, sizeof(gw->addr));
 
-    if (gw->write_ev && gw->write_buf) {
-        lifxd_info(
-            "gateway %s at [%s]:%hu",
-            lifxd_addrtoa(gw->addr),
-            gw->ip_addr,
-            gw->port
-        );
-        LIST_INSERT_HEAD(&lifxd_gateways, gw, link);
-        return gw;
+    struct timeval refresh_interval = {
+        .tv_usec = LIFXD_GATEWAY_REFRESH_INTERVAL_MSEC * 1000
+    };
+
+    // The gateway is also a bulb:
+    struct lifxd_bulb *bulb = lifxd_gateway_get_or_open_bulb(gw, gw->addr);
+
+    if (!gw->write_ev || !gw->write_buf || !gw->refresh_ev || !bulb
+        || event_add(gw->refresh_ev, &refresh_interval) != 0) {
+        lifxd_warn("can't allocate a new gateway bulb");
+        goto error_allocate;
     }
 
-    lifxd_warn("can't allocate a new gateway bulb");
+    lifxd_info(
+        "gateway %s at [%s]:%hu",
+        lifxd_addrtoa(gw->addr),
+        gw->ip_addr,
+        gw->port
+    );
+    LIST_INSERT_HEAD(&lifxd_gateways, gw, link);
+    return gw;
 
+error_allocate:
     if (gw->write_ev) {
         event_free(gw->write_ev);
     }
     if (gw->write_buf) {
         evbuffer_free(gw->write_buf);
     }
+    if (gw->refresh_ev) {
+        event_free(gw->refresh_ev);
+    }
 error_connect:
     close(gw->socket);
 error_socket:
@@ -215,7 +272,7 @@
         .packet_type = LIFXD_GET_PAN_GATEWAY
     };
     lifxd_wire_encode_header(&hdr);
-    lifxd_debug("GET_PAN_GATEWAY → [%s]:%hu", gw->ip_addr, gw->port);
+    lifxd_debug("GET_PAN_GATEWAY →  [%s]:%hu", gw->ip_addr, gw->port);
     evbuffer_add(gw->write_buf, &hdr, sizeof(hdr));
     event_add(gw->write_ev, NULL);
 }
@@ -228,7 +285,7 @@
     assert(gw && hdr && pkt);
 
     lifxd_debug(
-        "SET_PAN_GATEWAY ← [%s]:%hu - %s gw_addr=%s",
+        "SET_PAN_GATEWAY ←  [%s]:%hu - %s gw_addr=%s",
         gw->ip_addr, gw->port,
         lifxd_addrtoa(hdr->bulb_addr),
         lifxd_addrtoa(hdr->gw_addr)
@@ -237,17 +294,20 @@
 }
 
 void
-lifxd_gateway_get_light_status(struct lifxd_gateway *gw)
+lifxd_gateway_get_light_status(struct lifxd_gateway *gw,
+                               const struct lifxd_bulb *bulb)
 {
     assert(gw);
+    assert(bulb);
 
     struct lifxd_packet_header hdr = {
         .size = LIFXD_PACKET_HEADER_SIZE,
         .protocol = LIFXD_PROTOCOL_VERSION,
         .packet_type = LIFXD_GET_LIGHT_STATE
     };
+    memcpy(hdr.bulb_addr, bulb->addr, sizeof(hdr.bulb_addr));
     lifxd_wire_encode_header(&hdr);
-    lifxd_debug("GET_LIGHT_STATE → [%s]:%hu", gw->ip_addr, gw->port);
+    lifxd_debug("GET_LIGHT_STATE →  [%s]:%hu", gw->ip_addr, gw->port);
     evbuffer_add(gw->write_buf, &hdr, sizeof(hdr));
     event_add(gw->write_ev, NULL);
 }
@@ -260,7 +320,7 @@
     assert(gw && hdr && pkt);
 
     lifxd_debug(
-        "SET_LIGHT_STATUS ← [%s]:%hu - %s "
+        "SET_LIGHT_STATUS ←  [%s]:%hu - %s "
         "hue=%#hx, saturation=%#hx, brightness=%#hx, "
         "kelvin=%#hx, dim=%#hx, power=%#hx, label=%.*s, tags=%lx",
         gw->ip_addr, gw->port, lifxd_addrtoa(hdr->bulb_addr),
@@ -268,11 +328,13 @@
         pkt->dim, pkt->power, sizeof(pkt->label), pkt->label, pkt->tags
     );
 
-    struct lifxd_bulb *bulb = lifxd_bulb_get_or_open(gw, hdr->bulb_addr);
-    if (bulb) {
-        assert(sizeof(*pkt) == sizeof(bulb->status));
-        memcpy(&bulb->status, pkt, sizeof(*pkt));
+    struct lifxd_bulb *b = lifxd_gateway_get_or_open_bulb(gw, hdr->bulb_addr);
+    if (!b) {
+        return;
     }
+
+    assert(sizeof(*pkt) == sizeof(b->status));
+    lifxd_bulb_set_light_status(b, (const struct lifxd_light_status *)pkt);
 }
 
 void
@@ -283,12 +345,14 @@
     assert(gw && hdr && pkt);
 
     lifxd_debug(
-        "SET_POWER_STATE ← [%s]:%hu - %s power=%#hx",
+        "SET_POWER_STATE ←  [%s]:%hu - %s power=%#hx",
         gw->ip_addr, gw->port, lifxd_addrtoa(hdr->bulb_addr), pkt->power
     );
 
-    struct lifxd_bulb *bulb = lifxd_bulb_get_or_open(gw, hdr->bulb_addr);
-    if (bulb) {
-        bulb->status.power = pkt->power;
+    struct lifxd_bulb *b = lifxd_gateway_get_or_open_bulb(gw, hdr->bulb_addr);
+    if (!b) {
+        return;
     }
+
+    lifxd_bulb_set_power_state(b, pkt->power);
 }
diff --git a/core/gateway.h b/core/gateway.h
--- a/core/gateway.h
+++ b/core/gateway.h
@@ -29,14 +29,24 @@
 
 #pragma once
 
+// Let's start with something simple for now, in the future this will need to
+// account for each gateway response time and it would be interesting to see if
+// aggressively querying the bulbs raises their power consumption:
+enum { LIFXD_GATEWAY_REFRESH_INTERVAL_MSEC = 70 };
+
+// In the meantime skip a refresh if we have too many bytes in our write buffer:
+enum { LIFXD_GATEWAY_WRITE_HIGH_WATERMARK = 1024 };
+
 struct lifxd_gateway {
     LIST_ENTRY(lifxd_gateway)   link;
+    struct lifxd_bulb_list      bulbs;
     char                        ip_addr[INET6_ADDRSTRLEN];
     uint16_t                    port;
     uint8_t                     addr[LIFXD_ADDR_LENGTH];
     evutil_socket_t             socket;
     struct event                *write_ev;
     struct evbuffer             *write_buf;
+    struct event                *refresh_ev;
 };
 LIST_HEAD(lifxd_gateway_list, lifxd_gateway);
 
@@ -49,7 +59,7 @@
 void lifxd_gateway_handle_pan_gateway(struct lifxd_gateway *,
                                       const struct lifxd_packet_header *,
                                       const struct lifxd_packet_pan_gateway *);
-void lifxd_gateway_get_light_status(struct lifxd_gateway *);
+void lifxd_gateway_get_light_status(struct lifxd_gateway *, const struct lifxd_bulb *);
 void lifxd_gateway_handle_light_status(struct lifxd_gateway *,
                                        const struct lifxd_packet_header *,
                                        const struct lifxd_packet_light_status *);
