# HG changeset patch
# Parent d03081a756d820aeaedd6548055fd3bb71ce929c

diff --git a/core/broadcast.c b/core/broadcast.c
--- a/core/broadcast.c
+++ b/core/broadcast.c
@@ -50,7 +50,7 @@
 #include "broadcast.h"
 #include "lifxd.h"
 
-static struct lifxd_packet_infos_map lifxd_packet_infos = \
+static struct lifxd_packet_infos_map lifxd_packet_infos =
     RB_INITIALIZER(&lifxd_packets_infos);
 
 RB_GENERATE_STATIC(
@@ -72,10 +72,6 @@
 
     static struct lifxd_packet_infos packet_table[] = {
         {
-            .name = "GET_PAN_GATEWAY",
-            .type = LIFXD_GET_PAN_GATEWAY
-        },
-        {
             .name = "PAN_GATEWAY",
             .type = LIFXD_PAN_GATEWAY,
             .size = sizeof(struct lifxd_packet_pan_gateway),
@@ -118,10 +114,12 @@
     evutil_socket_t socket;
     struct event    *read_ev;
     struct event    *write_ev;
+    struct event    *discovery_timeout_ev;
 } lifxd_broadcast_endpoint = {
     .socket = -1,
     .read_ev = NULL,
-    .write_ev = NULL
+    .write_ev = NULL,
+    .discovery_timeout_ev = NULL
 };
 
 static bool
@@ -189,18 +187,20 @@
             lifxd_broadcast_get_packet_infos(read.hdr.packet_type);
         if (pkt_infos) {
             struct lifxd_gateway *gw = lifxd_gateway_get(read.hdr.gw_addr);
-            if (!gw && pkt_infos->type == LIFXD_PAN_GATEWAY) {
-                gw = lifxd_gateway_open(&peer, read.hdr.gw_addr);
+            if (!gw) {
+                gw = lifxd_gateway_open(
+                    &peer, read.hdr.gw_addr, read.hdr.bulb_addr
+                );
+                if (!gw) {
+                    lifxd_err(1, "can't allocate gateway");
+                }
+                if (event_del(lifxd_broadcast_endpoint.discovery_timeout_ev)) {
+                    lifxd_err(1, "can't setup events");
+                }
             }
-            if (gw) {
-                void *pkt = &read.buf[LIFXD_PACKET_HEADER_SIZE];
-                if (pkt_infos->decode) {
-                    pkt_infos->decode(pkt);
-                }
-                pkt_infos->handle(gw, &read.hdr, pkt);
-            } else {
-                lifxd_err(1, "can't allocate gateway");
-            }
+            void *pkt = &read.buf[LIFXD_PACKET_HEADER_SIZE];
+            pkt_infos->decode(pkt);
+            pkt_infos->handle(gw, &read.hdr, pkt);
         } else {
             lifxd_warnx(
                 "received unknown packet %#x from [%s]:%hu",
@@ -241,7 +241,14 @@
         sizeof(lifx_addr)
     );
     if (nbytes == sizeof(get_pan_gateway)) {
-        event_del(lifxd_broadcast_endpoint.write_ev);
+        struct timeval tv = {
+            .tv_sec = LIFXD_BROADCAST_DISCOVERY_TIMEOUT_MSEC / 1000,
+            .tv_usec = (LIFXD_BROADCAST_DISCOVERY_TIMEOUT_MSEC % 1000) * 1000
+        };
+        if (event_del(lifxd_broadcast_endpoint.write_ev)
+            || event_add(lifxd_broadcast_endpoint.discovery_timeout_ev, &tv)) {
+            lifxd_err(1, "can't setup events");
+        }
         return true;
     }
     if (nbytes == -1) {
@@ -285,6 +292,25 @@
     lifxd_broadcast_discovery();
 }
 
+static void
+lifxd_broadcast_discovery_timeout_event_callback(evutil_socket_t socket,
+                                                 short events,
+                                                 void *ctx)
+{
+    (void)socket;
+    (void)events;
+    (void)ctx;
+
+    lifxd_info(
+        "discovery didn't returned anything in %dms, restarting it",
+        LIFXD_BROADCAST_DISCOVERY_TIMEOUT_MSEC
+    );
+
+    if (!lifxd_broadcast_discovery()) {
+        lifxd_err(1, "can't start discovery");
+    }
+}
+
 void
 lifxd_broadcast_close(void)
 {
@@ -298,6 +324,11 @@
         event_free(lifxd_broadcast_endpoint.write_ev);
         lifxd_broadcast_endpoint.write_ev = NULL;
     }
+    if (lifxd_broadcast_endpoint.discovery_timeout_ev) {
+        event_del(lifxd_broadcast_endpoint.discovery_timeout_ev);
+        event_free(lifxd_broadcast_endpoint.discovery_timeout_ev);
+        lifxd_broadcast_endpoint.discovery_timeout_ev = NULL;
+    }
     if (lifxd_broadcast_endpoint.socket != -1) {
         evutil_closesocket(lifxd_broadcast_endpoint.socket);
         lifxd_broadcast_endpoint.socket = -1;
@@ -365,7 +396,16 @@
         lifxd_broadcast_event_callback,
         NULL
     );
-    if (!lifxd_broadcast_endpoint.read_ev || !lifxd_broadcast_endpoint.write_ev) {
+    lifxd_broadcast_endpoint.discovery_timeout_ev = event_new(
+        lifxd_ev_base,
+        -1,
+        EV_PERSIST,
+        lifxd_broadcast_discovery_timeout_event_callback,
+        NULL
+    );
+    if (!lifxd_broadcast_endpoint.read_ev
+        || !lifxd_broadcast_endpoint.write_ev
+        || !lifxd_broadcast_endpoint.discovery_timeout_ev) {
         goto error;
     }
 
diff --git a/core/broadcast.h b/core/broadcast.h
--- a/core/broadcast.h
+++ b/core/broadcast.h
@@ -49,6 +49,8 @@
     return a->type - b->type;
 }
 
+enum { LIFXD_BROADCAST_DISCOVERY_TIMEOUT_MSEC = 2000 };
+
 bool lifxd_broadcast_setup(void);
 void lifxd_broadcast_close(void);
 bool lifxd_broadcast_discovery(void);
diff --git a/core/bulb.c b/core/bulb.c
--- a/core/bulb.c
+++ b/core/bulb.c
@@ -44,22 +44,25 @@
 #include "gateway.h"
 #include "lifxd.h"
 
-static struct lifxd_bulb_list lifxd_bulbs = LIST_HEAD_INITIALIZER(&lifxd_bulbs);
+static struct lifxd_bulb_map lifxd_bulbs_table =
+    RB_INITIALIZER(&lifxd_bulbs_by_addr);
+
+RB_GENERATE_STATIC(
+    lifxd_bulb_map,
+    lifxd_bulb,
+    link,
+    lifxd_bulb_cmp
+);
 
 struct lifxd_bulb *
 lifxd_bulb_get(struct lifxd_gateway *gw, const uint8_t *addr)
 {
     assert(gw);
+    assert(addr);
 
-    struct lifxd_bulb *bulb, *next_bulb;
-    LIST_FOREACH_SAFE(bulb, &lifxd_bulbs, link, next_bulb) {
-        if (bulb->gw == gw
-            && (!addr || !memcmp(bulb->addr, addr, sizeof(bulb->addr)))) {
-            return bulb;
-        }
-    }
-
-    return NULL;
+    struct lifxd_bulb bulb;
+    memcpy(bulb.addr, addr, sizeof(bulb.addr));
+    return RB_FIND(lifxd_bulb_map, &lifxd_bulbs_table, &bulb);
 }
 
 struct lifxd_bulb *
@@ -76,27 +79,7 @@
 
     bulb->gw = gw;
     memcpy(bulb->addr, addr, sizeof(bulb->addr));
-    LIST_INSERT_HEAD(&lifxd_bulbs, bulb, link);
-
-    return bulb;
-}
-
-struct lifxd_bulb *
-lifxd_bulb_get_or_open(struct lifxd_gateway *gw, const uint8_t *addr)
-{
-    assert(gw);
-    assert(addr);
-
-    struct lifxd_bulb *bulb = lifxd_bulb_get(gw, addr);
-    if (!bulb) {
-        bulb = lifxd_bulb_open(gw, addr);
-        if (bulb) {
-            lifxd_info(
-                "discovered new bulb %s on [%s]:%hu",
-                lifxd_addrtoa(addr), gw->ip_addr, gw->port
-            );
-        }
-    }
+    RB_INSERT(lifxd_bulb_map, &lifxd_bulbs_table, bulb);
 
     return bulb;
 }
@@ -107,7 +90,7 @@
     assert(bulb);
     assert(bulb->gw);
 
-    LIST_REMOVE(bulb, link);
+    RB_REMOVE(lifxd_bulb_map, &lifxd_bulbs_table, bulb);
     lifxd_info(
         "closed bulb \"%.*s\" on [%s]:%hu",
         sizeof(bulb->status.label),
@@ -117,3 +100,20 @@
     );
     free(bulb);
 }
+
+void
+lifxd_bulb_set_light_status(struct lifxd_bulb *bulb,
+                            const struct lifxd_light_status *status)
+{
+    assert(bulb);
+    assert(status);
+    memcpy(&bulb->status, status, sizeof(bulb->status));
+}
+
+
+void
+lifxd_bulb_set_power_state(struct lifxd_bulb *bulb, uint16_t power)
+{
+    assert(bulb);
+    bulb->status.power = power;
+}
diff --git a/core/bulb.h b/core/bulb.h
--- a/core/bulb.h
+++ b/core/bulb.h
@@ -45,14 +45,24 @@
 #pragma pack(pop)
 
 struct lifxd_bulb {
-    LIST_ENTRY(lifxd_bulb)      link;
+    RB_ENTRY(lifxd_bulb)        link;
+    SLIST_ENTRY(lifxd_bulb)     link_by_gw;
     struct lifxd_gateway        *gw;
     uint8_t                     addr[LIFXD_ADDR_LENGTH];
     struct lifxd_light_status   status;
 };
-LIST_HEAD(lifxd_bulb_list, lifxd_bulb);
+RB_HEAD(lifxd_bulb_map, lifxd_bulb);
+SLIST_HEAD(lifxd_bulb_list, lifxd_bulb);
+
+static inline int
+lifxd_bulb_cmp(const struct lifxd_bulb *a, const struct lifxd_bulb *b)
+{
+    return memcmp(a->addr, b->addr, sizeof(a->addr));
+}
 
 struct lifxd_bulb *lifxd_bulb_get(struct lifxd_gateway *, const uint8_t *);
 struct lifxd_bulb *lifxd_bulb_open(struct lifxd_gateway *, const uint8_t *);
-struct lifxd_bulb *lifxd_bulb_get_or_open(struct lifxd_gateway *, const uint8_t *);
 void lifxd_bulb_close(struct lifxd_bulb *);
+
+void lifxd_bulb_set_light_status(struct lifxd_bulb *, const struct lifxd_light_status *);
+void lifxd_bulb_set_power_state(struct lifxd_bulb *, uint16_t);
diff --git a/core/gateway.c b/core/gateway.c
--- a/core/gateway.c
+++ b/core/gateway.c
@@ -57,18 +57,20 @@
 {
     assert(gw);
 
+    event_del(gw->refresh_ev);
     event_del(gw->write_ev);
     if (gw->socket != -1) {
         evutil_closesocket(gw->socket);
         LIST_REMOVE(gw, link);
     }
+    event_free(gw->refresh_ev);
     event_free(gw->write_ev);
     evbuffer_free(gw->write_buf);
-    for (struct lifxd_bulb *bulb = lifxd_bulb_get(gw, NULL);
-         bulb;
-         bulb = lifxd_bulb_get(gw, NULL)) {
+    struct lifxd_bulb *bulb, *next_bulb;
+    SLIST_FOREACH_SAFE(bulb, &gw->bulbs, link_by_gw, next_bulb) {
         lifxd_bulb_close(bulb);
     }
+
     lifxd_info(
         "connection with gateway bulb [%s]:%hu closed", gw->ip_addr, gw->port
     );
@@ -76,26 +78,7 @@
 }
 
 static void
-lifxd_gateway_handle_write(struct lifxd_gateway *gw)
-{
-    assert(gw);
-
-    if (evbuffer_write(gw->write_buf, gw->socket) == -1 && errno != EAGAIN) {
-        lifxd_warn("can't write to [%s]:%hu", gw->ip_addr, gw->port);
-        lifxd_gateway_close(gw);
-        if (!lifxd_broadcast_discovery()) {
-            lifxd_err(1, "can't start auto discovery");
-        }
-        return;
-    }
-
-    if (!evbuffer_get_length(gw->write_buf)) {
-        event_del(gw->write_ev);
-    }
-}
-
-static void
-lifxd_gateway_event_callback(evutil_socket_t socket, short events, void *ctx)
+lifxd_gateway_write_callback(evutil_socket_t socket, short events, void *ctx)
 {
     (void)socket;
 
@@ -113,19 +96,72 @@
         return;
     }
     if (events & EV_WRITE) {
-        lifxd_gateway_handle_write(gw);
+        if (evbuffer_write(gw->write_buf, gw->socket) == -1 && errno != EAGAIN) {
+            lifxd_warn("can't write to [%s]:%hu", gw->ip_addr, gw->port);
+            lifxd_gateway_close(gw);
+            if (!lifxd_broadcast_discovery()) {
+                lifxd_err(1, "can't start auto discovery");
+            }
+            return;
+        }
+        if (!evbuffer_get_length(gw->write_buf)) {
+            event_del(gw->write_ev);
+        }
     }
 }
 
+static void
+lifxd_gateway_refresh_callback(evutil_socket_t socket, short events, void *ctx)
+{
+    (void)socket;
+    (void)events;
+
+    assert(ctx);
+
+    struct lifxd_gateway *gw = (struct lifxd_gateway *)ctx;
+
+    int buflen = evbuffer_get_length(gw->write_buf);
+    if (buflen < LIFXD_GATEWAY_WRITE_HIGH_WATERMARK) {
+        struct lifxd_bulb *bulb;
+        SLIST_FOREACH(bulb, &gw->bulbs, link_by_gw) {
+            lifxd_gateway_get_light_status(gw, bulb);
+        }
+        return;
+    }
+    lifxd_info(
+        "refresh skipped on gateway [%s]:%hu, (buflen=%d)",
+        gw->ip_addr, gw->port, buflen
+    );
+}
+
+static struct lifxd_bulb *
+lifxd_gateway_get_or_open_bulb(struct lifxd_gateway *gw, const uint8_t *bulb_addr)
+{
+    assert(gw);
+    assert(bulb_addr);
+
+    struct lifxd_bulb *bulb = lifxd_bulb_get(gw, bulb_addr);
+    if (!bulb) {
+        bulb = lifxd_bulb_open(gw, bulb_addr);
+        if (bulb) {
+            SLIST_INSERT_HEAD(&gw->bulbs, bulb, link_by_gw);
+            lifxd_info(
+                "bulb %s on [%s]:%hu",
+                lifxd_addrtoa(bulb_addr), gw->ip_addr, gw->port
+            );
+        }
+    }
+    return bulb;
+}
+
 struct lifxd_gateway *
-lifxd_gateway_open(const struct sockaddr_storage *peer, const uint8_t *site)
+lifxd_gateway_open(const struct sockaddr_storage *peer,
+                   const uint8_t *site,
+                   const uint8_t *addr)
 {
     assert(peer);
-
-    if (!site) {
-        lifxd_warnx("connecting directly to a bulb isn't supported yet");
-        return NULL;
-    }
+    assert(site);
+    assert(addr);
 
     struct lifxd_gateway *gw = calloc(1, sizeof(*gw));
     if (!gw) {
@@ -146,33 +182,53 @@
         lifxd_ev_base,
         gw->socket,
         EV_WRITE|EV_PERSIST,
-        lifxd_gateway_event_callback,
+        lifxd_gateway_write_callback,
         gw
     );
     gw->write_buf = evbuffer_new();
+    gw->refresh_ev = event_new(
+        lifxd_ev_base,
+        -1,
+        EV_PERSIST,
+        lifxd_gateway_refresh_callback,
+        gw
+    );
     lifxd_sockaddrtoa(peer, gw->ip_addr, sizeof(gw->ip_addr));
     gw->port = lifxd_sockaddrport(peer);
     memcpy(gw->addr, site, sizeof(gw->addr));
 
-    if (gw->write_ev && gw->write_buf) {
-        lifxd_info(
-            "gateway %s at [%s]:%hu",
-            lifxd_addrtoa(gw->addr),
-            gw->ip_addr,
-            gw->port
-        );
-        LIST_INSERT_HEAD(&lifxd_gateways, gw, link);
-        return gw;
+    struct timeval refresh_interval = {
+        .tv_usec = LIFXD_GATEWAY_REFRESH_INTERVAL_MSEC * 1000
+    };
+
+    // The gateway is also a bulb:
+    struct lifxd_bulb *bulb = lifxd_gateway_get_or_open_bulb(gw, addr);
+
+    if (!gw->write_ev || !gw->write_buf || !gw->refresh_ev || !bulb
+        || event_add(gw->refresh_ev, &refresh_interval) != 0) {
+        lifxd_warn("can't allocate a new gateway bulb");
+        goto error_allocate;
     }
 
-    lifxd_warn("can't allocate a new gateway bulb");
+    lifxd_info(
+        "gateway %s at [%s]:%hu",
+        lifxd_addrtoa(gw->addr),
+        gw->ip_addr,
+        gw->port
+    );
+    LIST_INSERT_HEAD(&lifxd_gateways, gw, link);
+    return gw;
 
+error_allocate:
     if (gw->write_ev) {
         event_free(gw->write_ev);
     }
     if (gw->write_buf) {
         evbuffer_free(gw->write_buf);
     }
+    if (gw->refresh_ev) {
+        event_free(gw->refresh_ev);
+    }
 error_connect:
     close(gw->socket);
 error_socket:
@@ -205,22 +261,6 @@
 }
 
 void
-lifxd_gateway_get_pan_gateway(struct lifxd_gateway *gw)
-{
-    assert(gw);
-
-    struct lifxd_packet_header hdr = {
-        .size = LIFXD_PACKET_HEADER_SIZE,
-        .protocol = LIFXD_PROTOCOL_VERSION,
-        .packet_type = LIFXD_GET_PAN_GATEWAY
-    };
-    lifxd_wire_encode_header(&hdr);
-    lifxd_debug("GET_PAN_GATEWAY → [%s]:%hu", gw->ip_addr, gw->port);
-    evbuffer_add(gw->write_buf, &hdr, sizeof(hdr));
-    event_add(gw->write_ev, NULL);
-}
-
-void
 lifxd_gateway_handle_pan_gateway(struct lifxd_gateway *gw,
                                  const struct lifxd_packet_header *hdr,
                                  const struct lifxd_packet_pan_gateway *pkt)
@@ -228,7 +268,7 @@
     assert(gw && hdr && pkt);
 
     lifxd_debug(
-        "SET_PAN_GATEWAY ← [%s]:%hu - %s gw_addr=%s",
+        "SET_PAN_GATEWAY <-- [%s]:%hu - %s gw_addr=%s",
         gw->ip_addr, gw->port,
         lifxd_addrtoa(hdr->bulb_addr),
         lifxd_addrtoa(hdr->gw_addr)
@@ -237,17 +277,21 @@
 }
 
 void
-lifxd_gateway_get_light_status(struct lifxd_gateway *gw)
+lifxd_gateway_get_light_status(struct lifxd_gateway *gw,
+                               const struct lifxd_bulb *bulb)
 {
     assert(gw);
+    assert(bulb);
 
     struct lifxd_packet_header hdr = {
         .size = LIFXD_PACKET_HEADER_SIZE,
-        .protocol = LIFXD_PROTOCOL_VERSION,
+        .protocol = LIFXD_PROTOCOL_VERSION_WITH_ADDR,
         .packet_type = LIFXD_GET_LIGHT_STATE
     };
+    memcpy(hdr.gw_addr, gw->addr, sizeof(hdr.gw_addr));
+    memcpy(hdr.bulb_addr, bulb->addr, sizeof(hdr.bulb_addr));
     lifxd_wire_encode_header(&hdr);
-    lifxd_debug("GET_LIGHT_STATE → [%s]:%hu", gw->ip_addr, gw->port);
+    lifxd_debug("GET_LIGHT_STATE --> [%s]:%hu", gw->ip_addr, gw->port);
     evbuffer_add(gw->write_buf, &hdr, sizeof(hdr));
     event_add(gw->write_ev, NULL);
 }
@@ -260,7 +304,7 @@
     assert(gw && hdr && pkt);
 
     lifxd_debug(
-        "SET_LIGHT_STATUS ← [%s]:%hu - %s "
+        "SET_LIGHT_STATUS <-- [%s]:%hu - %s "
         "hue=%#hx, saturation=%#hx, brightness=%#hx, "
         "kelvin=%#hx, dim=%#hx, power=%#hx, label=%.*s, tags=%lx",
         gw->ip_addr, gw->port, lifxd_addrtoa(hdr->bulb_addr),
@@ -268,11 +312,13 @@
         pkt->dim, pkt->power, sizeof(pkt->label), pkt->label, pkt->tags
     );
 
-    struct lifxd_bulb *bulb = lifxd_bulb_get_or_open(gw, hdr->bulb_addr);
-    if (bulb) {
-        assert(sizeof(*pkt) == sizeof(bulb->status));
-        memcpy(&bulb->status, pkt, sizeof(*pkt));
+    struct lifxd_bulb *b = lifxd_gateway_get_or_open_bulb(gw, hdr->bulb_addr);
+    if (!b) {
+        return;
     }
+
+    assert(sizeof(*pkt) == sizeof(b->status));
+    lifxd_bulb_set_light_status(b, (const struct lifxd_light_status *)pkt);
 }
 
 void
@@ -283,12 +329,14 @@
     assert(gw && hdr && pkt);
 
     lifxd_debug(
-        "SET_POWER_STATE ← [%s]:%hu - %s power=%#hx",
+        "SET_POWER_STATE <-- [%s]:%hu - %s power=%#hx",
         gw->ip_addr, gw->port, lifxd_addrtoa(hdr->bulb_addr), pkt->power
     );
 
-    struct lifxd_bulb *bulb = lifxd_bulb_get_or_open(gw, hdr->bulb_addr);
-    if (bulb) {
-        bulb->status.power = pkt->power;
+    struct lifxd_bulb *b = lifxd_gateway_get_or_open_bulb(gw, hdr->bulb_addr);
+    if (!b) {
+        return;
     }
+
+    lifxd_bulb_set_power_state(b, pkt->power);
 }
diff --git a/core/gateway.h b/core/gateway.h
--- a/core/gateway.h
+++ b/core/gateway.h
@@ -29,27 +29,38 @@
 
 #pragma once
 
+// Let's start with something simple for now, in the future this will need to
+// account for each gateway response time and it would be interesting to see if
+// aggressively querying the bulbs raises their power consumption:
+enum { LIFXD_GATEWAY_REFRESH_INTERVAL_MSEC = 70 };
+
+// In the meantime skip a refresh if we have too many bytes in our write buffer:
+enum { LIFXD_GATEWAY_WRITE_HIGH_WATERMARK = 1024 };
+
 struct lifxd_gateway {
     LIST_ENTRY(lifxd_gateway)   link;
+    struct lifxd_bulb_list      bulbs;
     char                        ip_addr[INET6_ADDRSTRLEN];
     uint16_t                    port;
     uint8_t                     addr[LIFXD_ADDR_LENGTH];
     evutil_socket_t             socket;
     struct event                *write_ev;
     struct evbuffer             *write_buf;
+    struct event                *refresh_ev;
 };
 LIST_HEAD(lifxd_gateway_list, lifxd_gateway);
 
 struct lifxd_gateway *lifxd_gateway_get(const uint8_t *);
 struct lifxd_gateway *lifxd_gateway_open(const struct sockaddr_storage *,
+                                         const uint8_t *,
                                          const uint8_t *);
 void lifxd_gateway_close_all(void);
 
-void lifxd_gateway_get_pan_gateway(struct lifxd_gateway *);
 void lifxd_gateway_handle_pan_gateway(struct lifxd_gateway *,
                                       const struct lifxd_packet_header *,
                                       const struct lifxd_packet_pan_gateway *);
-void lifxd_gateway_get_light_status(struct lifxd_gateway *);
+
+void lifxd_gateway_get_light_status(struct lifxd_gateway *, const struct lifxd_bulb *);
 void lifxd_gateway_handle_light_status(struct lifxd_gateway *,
                                        const struct lifxd_packet_header *,
                                        const struct lifxd_packet_light_status *);
diff --git a/core/wire_proto.h b/core/wire_proto.h
--- a/core/wire_proto.h
+++ b/core/wire_proto.h
@@ -55,6 +55,7 @@
 
 enum { LIFXD_PACKET_HEADER_SIZE = sizeof(struct lifxd_packet_header) };
 enum { LIFXD_PROTOCOL_VERSION = 0x54 };
+enum { LIFXD_PROTOCOL_VERSION_WITH_ADDR = 0x34 };
 
 // Let's define a maximum packet size just in case somebody sends us weird
 // headers:
