# HG changeset patch
# Parent  ff6ef9ea893d2ebfde7de10b57fea4f238721d93
Send only one LIFX packet per UDP datagram

Turns out the bulbs can't do that...

This changeset also fixes rate limiting, status refresh and improve the
latency measurement a bit.

This is necessary to support tagging.

diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -83,6 +83,7 @@
     assert(ctx);
 
     struct lgtd_lifx_gateway *gw = (struct lgtd_lifx_gateway *)ctx;
+
     if (events & EV_TIMEOUT) {  // Not sure how that could happen in UDP but eh.
         lgtd_warn(
             "lost connection with gateway bulb [%s]:%hu", gw->ip_addr, gw->port
@@ -93,8 +94,13 @@
         }
         return;
     }
+
     if (events & EV_WRITE) {
-        int nbytes = evbuffer_write(gw->write_buf, gw->socket);
+        assert(gw->pkt_ring_tail >= 0);
+        assert(gw->pkt_ring_tail < (int)LGTD_ARRAY_SIZE(gw->pkt_ring));
+
+        int to_write = gw->pkt_ring[gw->pkt_ring_tail].size;
+        int nbytes = evbuffer_write_atmost(gw->write_buf, gw->socket, to_write);
         if (nbytes == -1 && errno != EAGAIN) {
             lgtd_warn("can't write to [%s]:%hu", gw->ip_addr, gw->port);
             lgtd_lifx_gateway_close(gw);
@@ -103,16 +109,33 @@
             }
             return;
         }
+
         // Callbacks are called in any order, so we keep two timers to make
         // sure we can get the latency right, otherwise we could be compute the
         // latency with last_pkt_at < last_req_at, which isn't true since the
         // pkt will be for an answer to the previous write:
         gw->last_req_at = gw->next_req_at;
         gw->next_req_at = lgtd_time_monotonic_msecs();
-        // XXX this isn't perfect because we don't know what we just sent, I
-        // just assume that everything pending will alway be transmitted in a
-        // single call:
-        gw->pending_refresh_req = false;
+
+        gw->pkt_ring[gw->pkt_ring_tail].size -= nbytes;
+        if (gw->pkt_ring[gw->pkt_ring_tail].size == 0) {
+            enum lgtd_lifx_packet_type type;
+            type = gw->pkt_ring[gw->pkt_ring_tail].type;
+            if (type == LGTD_LIFX_GET_TAG_LABELS) {
+                gw->pending_refresh_req = false;
+            }
+            if (lgtd_opts.verbosity <= LGTD_DEBUG) {
+                const struct lgtd_lifx_packet_infos *pkt_infos =
+                    lgtd_lifx_wire_get_packet_infos(type);
+                lgtd_debug(
+                    "%s --> [%s]:%hu", pkt_infos->name, gw->ip_addr, gw->port
+                );
+            }
+            gw->pkt_ring[gw->pkt_ring_tail].type = 0;
+            LGTD_LIFX_GATEWAY_INC_MESSAGE_RING_INDEX(gw->pkt_ring_tail);
+            gw->pkt_ring_full = false;
+        }
+
         if (!evbuffer_get_length(gw->write_buf)) {
             event_del(gw->write_ev);
         }
@@ -134,8 +157,10 @@
         gw->site.as_array,
         LGTD_LIFX_GET_LIGHT_STATE
     );
-    lgtd_debug("GET_LIGHT_STATE --> [%s]:%hu", gw->ip_addr, gw->port);
-    lgtd_lifx_gateway_send_packet(gw, &hdr, NULL, 0);
+    lgtd_lifx_gateway_enqueue_packet(
+        gw, &hdr, LGTD_LIFX_GET_LIGHT_STATE, NULL, 0
+    );
+
     gw->pending_refresh_req = true;
 }
 
@@ -286,21 +311,39 @@
 }
 
 void
-lgtd_lifx_gateway_send_packet(struct lgtd_lifx_gateway *gw,
-                              const struct lgtd_lifx_packet_header *hdr,
-                              const void *pkt,
-                              int pkt_size)
+lgtd_lifx_gateway_enqueue_packet(struct lgtd_lifx_gateway *gw,
+                                 const struct lgtd_lifx_packet_header *hdr,
+                                 enum lgtd_lifx_packet_type pkt_type,
+                                 const void *pkt,
+                                 int pkt_size)
 {
     assert(gw);
     assert(hdr);
     assert(pkt_size >= 0 && pkt_size < LGTD_LIFX_MAX_PACKET_SIZE);
     assert(!memcmp(hdr->site, gw->site.as_array, LGTD_LIFX_ADDR_LENGTH));
+    assert(gw->pkt_ring_head >= 0);
+    assert(gw->pkt_ring_head < (int)LGTD_ARRAY_SIZE(gw->pkt_ring));
+
+    if (gw->pkt_ring_full) {
+        lgtd_warnx(
+            "dropping packet type %s: packet queue on [%s]:%hu is full",
+            lgtd_lifx_wire_get_packet_infos(pkt_type)->name,
+            gw->ip_addr, gw->port
+        );
+        return;
+    }
 
     evbuffer_add(gw->write_buf, hdr, sizeof(*hdr));
     if (pkt) {
         assert((unsigned)pkt_size == le16toh(hdr->size) - sizeof(*hdr));
         evbuffer_add(gw->write_buf, pkt, pkt_size);
     }
+    gw->pkt_ring[gw->pkt_ring_head].size = sizeof(*hdr) + pkt_size;
+    gw->pkt_ring[gw->pkt_ring_head].type = pkt_type;
+    LGTD_LIFX_GATEWAY_INC_MESSAGE_RING_INDEX(gw->pkt_ring_head);
+    if (gw->pkt_ring_head == gw->pkt_ring_tail) {
+        gw->pkt_ring_full = true;
+    }
     event_add(gw->write_ev, NULL);
 }
 
@@ -352,10 +395,10 @@
         && b->last_light_state_at > b->dirty_at
         && b->gw->last_pkt_at - b->dirty_at > 400) {
         if (b->expected_power_on == b->state.power) {
-            lgtd_warnx("clearing dirty_at on %s", b->state.label);
+            lgtd_debug("clearing dirty_at on %s", b->state.label);
             b->dirty_at = 0;
         } else {
-            lgtd_warnx(
+            lgtd_info(
                 "retransmiting power %s to %s",
                 b->expected_power_on ? "on" : "off", b->state.label
             );
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -23,6 +23,14 @@
 // still draw about 2W in ZigBee and about 3W in WiFi).
 enum { LGTD_LIFX_GATEWAY_MIN_REFRESH_INTERVAL_MSECS = 200 };
 
+// You can't send more than one lifx packet per UDP datagram.
+enum { LGTD_LIFX_GATEWAY_PACKET_RING_SIZE = 16 };
+
+struct lgtd_lifx_message {
+    enum lgtd_lifx_packet_type  type;
+    int                         size;
+};
+
 struct lgtd_lifx_gateway {
     LIST_ENTRY(lgtd_lifx_gateway)   link;
     struct lgtd_lifx_bulb_list      bulbs;
@@ -47,6 +55,14 @@
     lgtd_time_mono_t                last_req_at;
     lgtd_time_mono_t                next_req_at;
     lgtd_time_mono_t                last_pkt_at;
+    struct lgtd_lifx_message        pkt_ring[LGTD_LIFX_GATEWAY_PACKET_RING_SIZE];
+#define LGTD_LIFX_GATEWAY_INC_MESSAGE_RING_INDEX(idx)  do { \
+    (idx) += 1;                                             \
+    (idx) %= LGTD_LIFX_GATEWAY_PACKET_RING_SIZE;            \
+} while(0)
+    int                             pkt_ring_head;
+    int                             pkt_ring_tail;
+    bool                            pkt_ring_full;
     struct event                    *write_ev;
     struct evbuffer                 *write_buf;
     bool                            pending_refresh_req;
@@ -67,10 +83,11 @@
 
 void lgtd_lifx_gateway_force_refresh(struct lgtd_lifx_gateway *);
 
-void lgtd_lifx_gateway_send_packet(struct lgtd_lifx_gateway *,
-                                   const struct lgtd_lifx_packet_header *,
-                                   const void *,
-                                   int);
+void lgtd_lifx_gateway_enqueue_packet(struct lgtd_lifx_gateway *,
+                                      const struct lgtd_lifx_packet_header *,
+                                      enum lgtd_lifx_packet_type,
+                                      const void *,
+                                      int);
 
 void lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *,
                                           const struct lgtd_lifx_packet_header *,
diff --git a/tests/core/router/tests_router_utils.h b/tests/core/router/tests_router_utils.h
--- a/tests/core/router/tests_router_utils.h
+++ b/tests/core/router/tests_router_utils.h
@@ -7,10 +7,11 @@
 } lgtd_tests_gw_pkt_queue[16] = { { NULL, NULL, NULL, 0}, };
 
 void
-lgtd_lifx_gateway_send_packet(struct lgtd_lifx_gateway *gw,
-                              const struct lgtd_lifx_packet_header *hdr,
-                              const void *pkt,
-                              int pkt_size)
+lgtd_lifx_gateway_enqueue_packet(struct lgtd_lifx_gateway *gw,
+                                 const struct lgtd_lifx_packet_header *hdr,
+                                 enum lgtd_lifx_packet_type pkt_type,
+                                 const void *pkt,
+                                 int pkt_size)
 {
     lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].gw = gw;
     // headers are created on the stack so we need to dup them:
diff --git a/tests/lifx/gateway/CMakeLists.txt b/tests/lifx/gateway/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/CMakeLists.txt
@@ -0,0 +1,26 @@
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+ADD_LIBRARY(
+    test_lifx_gateway STATIC
+    ${LIGHTSD_SOURCE_DIR}/core/log.c
+    ${LIGHTSD_SOURCE_DIR}/core/proto.c
+    ${LIGHTSD_SOURCE_DIR}/core/router.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/broadcast.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
+    ${TIME_MONOTONIC_IMPL}
+)
+
+FUNCTION(ADD_GATEWAY_TEST TEST_SOURCE)
+    ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE} test_lifx_gateway)
+ENDFUNCTION()
+
+FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
+FOREACH(TEST ${TESTS})
+    ADD_GATEWAY_TEST(${TEST})
+ENDFOREACH()
diff --git a/tests/lifx/gateway/test_gateway_enqueue_packet.c b/tests/lifx/gateway/test_gateway_enqueue_packet.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_enqueue_packet.c
@@ -0,0 +1,65 @@
+#include "gateway.c"
+
+#include "test_gateway_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+    gw.write_ev = (void *)42;
+
+    struct lgtd_lifx_packet_power_state pkt;
+    pkt.power = LGTD_LIFX_POWER_ON;
+
+    union lgtd_lifx_target target = { .tags = 0 };
+
+    struct lgtd_lifx_packet_header hdr;
+    lgtd_lifx_wire_setup_header(
+        &hdr,
+        LGTD_LIFX_TARGET_ALL_DEVICES,
+        target,
+        gw.site.as_array,
+        LGTD_LIFX_SET_POWER_STATE
+    );
+
+    lgtd_lifx_gateway_enqueue_packet(
+        &gw, &hdr, LGTD_LIFX_SET_POWER_STATE, &pkt, sizeof(pkt)
+    );
+
+    if (memcmp(gw_write_buf, &hdr, sizeof(hdr))) {
+        errx(1, "header incorrectly buffered");
+    }
+
+    if (memcmp(&gw_write_buf[sizeof(hdr)], &pkt, sizeof(pkt))) {
+        errx(1, "pkt incorrectly buffered");
+    }
+
+    if (gw.pkt_ring[0].type != LGTD_LIFX_SET_POWER_STATE) {
+        errx(1, "packet type incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring[0].size != sizeof(pkt) + sizeof(hdr)) {
+        errx(1, "packet size incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring_head != 1) {
+        errx(1, "packet ring head should be on index 1");
+    }
+
+    if (gw.pkt_ring_tail != 0) {
+        errx(1, "packet ring tail should be on index 0");
+    }
+
+    if (gw.pkt_ring_full == true) {
+        errx(1, "packet ring shouldn't be full");
+    }
+
+    if (last_event_passed_to_event_add != gw.write_ev) {
+        errx(1, "event_add should have been called with gw.write_ev");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_enqueue_packet_ring_full.c b/tests/lifx/gateway/test_gateway_enqueue_packet_ring_full.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_enqueue_packet_ring_full.c
@@ -0,0 +1,89 @@
+#include "gateway.c"
+
+#include "test_gateway_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+    gw.write_ev = (void *)42;
+
+    struct lgtd_lifx_packet_power_state pkt;
+    pkt.power = LGTD_LIFX_POWER_ON;
+
+    union lgtd_lifx_target target = { .tags = 0 };
+
+    struct lgtd_lifx_packet_header hdr;
+    lgtd_lifx_wire_setup_header(
+        &hdr,
+        LGTD_LIFX_TARGET_ALL_DEVICES,
+        target,
+        gw.site.as_array,
+        LGTD_LIFX_SET_POWER_STATE
+    );
+
+    // set the head so it catches up the tail:
+    gw.pkt_ring_head = 1;
+    gw.pkt_ring_tail = 2;
+
+    lgtd_lifx_gateway_enqueue_packet(
+        &gw, &hdr, LGTD_LIFX_SET_POWER_STATE, &pkt, sizeof(pkt)
+    );
+
+    if (memcmp(gw_write_buf, &hdr, sizeof(hdr))) {
+        errx(1, "header incorrectly buffered");
+    }
+
+    if (memcmp(&gw_write_buf[sizeof(hdr)], &pkt, sizeof(pkt))) {
+        errx(1, "pkt incorrectly buffered");
+    }
+
+    if (gw.pkt_ring[1].type != LGTD_LIFX_SET_POWER_STATE) {
+        errx(1, "packet type incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring[1].size != sizeof(pkt) + sizeof(hdr)) {
+        errx(1, "packet size incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring_head != 2) {
+        errx(1, "packet ring head should be on index 2");
+    }
+
+    if (gw.pkt_ring_tail != 2) {
+        errx(1, "packet ring tail should be on index 2");
+    }
+
+    if (gw.pkt_ring_full != true) {
+        errx(1, "packet ring should be full");
+    }
+
+    if (last_event_passed_to_event_add != gw.write_ev) {
+        errx(1, "event_add should have been called with gw.write_ev");
+    }
+
+    lgtd_lifx_gateway_enqueue_packet(
+        &gw, &hdr, LGTD_LIFX_SET_POWER_STATE, &pkt, sizeof(pkt)
+    );
+
+    if (gw_write_buf_idx != sizeof(pkt) + sizeof(hdr)) {
+        errx(1, "nothing should have been buffered");
+    }
+
+    if (gw.pkt_ring_head != 2) {
+        errx(1, "packet ring head should be on index 2");
+    }
+
+    if (gw.pkt_ring_tail != 2) {
+        errx(1, "packet ring tail should be on index 2");
+    }
+
+    if (gw.pkt_ring_full != true) {
+        errx(1, "packet ring should be full");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_enqueue_packet_ring_wraparound.c b/tests/lifx/gateway/test_gateway_enqueue_packet_ring_wraparound.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_enqueue_packet_ring_wraparound.c
@@ -0,0 +1,71 @@
+#include "gateway.c"
+
+#include "test_gateway_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+    gw.write_ev = (void *)42;
+
+    struct lgtd_lifx_packet_power_state pkt;
+    pkt.power = LGTD_LIFX_POWER_ON;
+
+    union lgtd_lifx_target target = { .tags = 0 };
+
+    struct lgtd_lifx_packet_header hdr;
+    lgtd_lifx_wire_setup_header(
+        &hdr,
+        LGTD_LIFX_TARGET_ALL_DEVICES,
+        target,
+        gw.site.as_array,
+        LGTD_LIFX_SET_POWER_STATE
+    );
+
+    int pkt_ring_last_idx = LGTD_ARRAY_SIZE(gw.pkt_ring) - 1;
+
+    // set the head so it has to wrap-around and set the tail somewhere:
+    gw.pkt_ring_head = pkt_ring_last_idx;
+    gw.pkt_ring_tail = 2;
+
+    lgtd_lifx_gateway_enqueue_packet(
+        &gw, &hdr, LGTD_LIFX_SET_POWER_STATE, &pkt, sizeof(pkt)
+    );
+
+    if (memcmp(gw_write_buf, &hdr, sizeof(hdr))) {
+        errx(1, "header incorrectly buffered");
+    }
+
+    if (memcmp(&gw_write_buf[sizeof(hdr)], &pkt, sizeof(pkt))) {
+        errx(1, "pkt incorrectly buffered");
+    }
+
+    if (gw.pkt_ring[pkt_ring_last_idx].type != LGTD_LIFX_SET_POWER_STATE) {
+        errx(1, "packet type incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring[pkt_ring_last_idx].size != sizeof(pkt) + sizeof(hdr)) {
+        errx(1, "packet size incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring_head != 0) {
+        errx(1, "packet ring head should have wrapped around to index 0");
+    }
+
+    if (gw.pkt_ring_tail != 2) {
+        errx(1, "packet ring tail should be on index 2");
+    }
+
+    if (gw.pkt_ring_full == true) {
+        errx(1, "packet ring shouldn't be full");
+    }
+
+    if (last_event_passed_to_event_add != gw.write_ev) {
+        errx(1, "event_add should have been called with gw.write_ev");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_utils.h b/tests/lifx/gateway/test_gateway_utils.h
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_utils.h
@@ -0,0 +1,162 @@
+#pragma once
+
+static char gw_write_buf[4096] = { 0 };
+static int gw_write_buf_idx = 0;
+
+static inline void
+reset_gw_write_buf(void)
+{
+    memset(gw_write_buf, 0, sizeof(gw_write_buf));
+    gw_write_buf_idx = 0;
+}
+
+int
+evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen)
+{
+    (void)buf;
+    int to_write = LGTD_MIN(
+        datlen, sizeof(gw_write_buf) - gw_write_buf_idx
+    );
+    memcpy(&gw_write_buf[gw_write_buf_idx], data, to_write);
+    gw_write_buf_idx += to_write;
+    return 0;
+}
+
+struct lgtd_lifx_tag_list lgtd_lifx_tags = LIST_HEAD_INITIALIZER(&lgtd_lifx_tags);
+
+#ifndef MOCKED_EVBUFFER_GET_LENGTH
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    (void)buf;
+    return gw_write_buf_idx + 1;
+}
+#endif
+
+#ifndef MOCKED_EVBUFFER_WRITE_ATMOST
+int
+evbuffer_write_atmost(struct evbuffer *buf,
+                      evutil_socket_t fd,
+                      ev_ssize_t howmuch)
+{
+    (void)buf;
+    (void)fd;
+    (void)howmuch;
+    return howmuch;
+}
+#endif
+
+#ifndef MOCKED_LIFX_TAGGING_INCREF
+struct lgtd_lifx_tag *
+lgtd_lifx_tagging_incref(const char *label, const struct lgtd_lifx_gateway *gw)
+{
+    struct lgtd_lifx_tag *tag = calloc(1, sizeof(*tag));
+    strcpy(tag->label, label);
+    LIST_INSERT_HEAD(&lgtd_lifx_tags, tag, link);
+    struct lgtd_lifx_site *site = calloc(1, sizeof(*site));
+    site->gw = gw;
+    LIST_INSERT_HEAD(&tag->sites, site, link);
+    return tag;
+}
+#endif
+
+#ifndef MOCKED_LIFX_TAGGING_DECREF
+void
+lgtd_lifx_tagging_decref(struct lgtd_lifx_tag *tag,
+                         const struct lgtd_lifx_gateway *gw)
+{
+    (void)tag;
+    (void)gw;
+}
+#endif
+
+struct evbuffer *
+evbuffer_new(void)
+{
+    return NULL;
+}
+
+void
+evbuffer_free(struct evbuffer *buf)
+{
+    (void)buf;
+}
+
+
+static struct event *last_event_passed_to_event_add = NULL;
+
+int
+event_add(struct event *ev, const struct timeval *timeout)
+{
+    (void)timeout;
+    last_event_passed_to_event_add = ev;
+    return 0;
+}
+
+static struct event *last_event_passed_to_event_del = NULL;
+
+int
+event_del(struct event *ev)
+{
+    last_event_passed_to_event_del = ev;
+    return 0;
+}
+
+void
+event_active(struct event *ev, int res, short ncalls)
+{
+    (void)ev;
+    (void)res;
+    (void)ncalls;
+}
+
+struct event *
+event_new(struct event_base *evbase,
+          evutil_socket_t sock,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    (void)evbase;
+    (void)sock;
+    (void)events;
+    (void)cb;
+    (void)ctx;
+    return NULL;
+}
+
+void
+event_free(struct event *ev)
+{
+    (void)ev;
+}
+
+int
+event_pending(const struct event *ev, short events, struct timeval *tv)
+{
+    (void)ev;
+    (void)events;
+    (void)tv;
+    return 0;
+}
+
+int
+evutil_closesocket(evutil_socket_t sock)
+{
+    (void)sock;
+    return 0;
+}
+
+int
+evutil_make_socket_nonblocking(evutil_socket_t sock)
+{
+    (void)sock;
+    return 0;
+}
+
+int
+evutil_make_listen_socket_reuseable(evutil_socket_t sock)
+{
+    (void)sock;
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_write_callback.c b/tests/lifx/gateway/test_gateway_write_callback.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_write_callback.c
@@ -0,0 +1,77 @@
+#include "gateway.c"
+
+#define MOCKED_EVBUFFER_WRITE_ATMOST
+#define MOCKED_EVBUFFER_GET_LENGTH
+#include "test_gateway_utils.h"
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)42) {
+        errx(1, "didn't get the expected evbuffer");
+    }
+
+    // fake another packet to write:
+    return sizeof(struct lgtd_lifx_packet_header);
+}
+
+int
+evbuffer_write_atmost(struct evbuffer *buf,
+                      evutil_socket_t fd,
+                      ev_ssize_t howmuch)
+{
+    if (fd != 25) {
+        errx(1, "evbuffer_write_atmost didn't get the expected socket");
+    }
+
+    if (buf != (void *)42) {
+        errx(1, "evbuffer_write_atmost didn't get the expected evbuffer");
+    }
+
+    int expected = sizeof(struct lgtd_lifx_packet_header);
+    expected += sizeof(struct lgtd_lifx_packet_power_state);
+    if (howmuch != expected) {
+        errx(
+            1, "evbuffer_write_atmost expected %d but got %ld",
+            expected, howmuch
+        );
+    }
+
+    return howmuch;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    // fake some values:
+    gw.socket = 25;
+    gw.write_ev = (void *)21;
+    gw.write_buf = (void *)42;
+
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_header);
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_power_state);
+    gw.pkt_ring[0].type = LGTD_LIFX_SET_POWER_STATE;
+    gw.pkt_ring_head++;
+    gw.pkt_ring_head++;
+
+    lgtd_lifx_gateway_write_callback(-1, EV_WRITE, &gw);
+
+    if (gw.pkt_ring[0].size != 0 || gw.pkt_ring[0].type != 0) {
+        errx(1, "the ring entry should have been reset");
+    }
+
+    if (gw.pkt_ring_tail != 1) {
+        errx(1, "the tail shoud have been moved by one");
+    }
+
+    if (last_event_passed_to_event_del != NULL) {
+        errx(1, "event_del shouldn't have ben called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_write_callback_clears_ring_full_flag.c b/tests/lifx/gateway/test_gateway_write_callback_clears_ring_full_flag.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_write_callback_clears_ring_full_flag.c
@@ -0,0 +1,80 @@
+#include "gateway.c"
+
+#define MOCKED_EVBUFFER_WRITE_ATMOST
+#define MOCKED_EVBUFFER_GET_LENGTH
+#include "test_gateway_utils.h"
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)42) {
+        errx(1, "didn't get the expected evbuffer");
+    }
+
+    // fake another packet to write:
+    return sizeof(struct lgtd_lifx_packet_header);
+}
+
+int
+evbuffer_write_atmost(struct evbuffer *buf,
+                      evutil_socket_t fd,
+                      ev_ssize_t howmuch)
+{
+    if (fd != 25) {
+        errx(1, "evbuffer_write_atmost didn't get the expected socket");
+    }
+
+    if (buf != (void *)42) {
+        errx(1, "evbuffer_write_atmost didn't get the expected evbuffer");
+    }
+
+    int expected = sizeof(struct lgtd_lifx_packet_header);
+    expected += sizeof(struct lgtd_lifx_packet_power_state);
+    if (howmuch != expected) {
+        errx(
+            1, "evbuffer_write_atmost expected %d but got %ld",
+            expected, howmuch
+        );
+    }
+
+    return howmuch;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    // fake some values:
+    gw.socket = 25;
+    gw.write_ev = (void *)21;
+    gw.write_buf = (void *)42;
+
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_header);
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_power_state);
+    gw.pkt_ring[0].type = LGTD_LIFX_SET_POWER_STATE;
+    gw.pkt_ring_full = true;
+
+    lgtd_lifx_gateway_write_callback(-1, EV_WRITE, &gw);
+
+    if (gw.pkt_ring[0].size != 0 || gw.pkt_ring[0].type != 0) {
+        errx(1, "the ring entry should have been reset");
+    }
+
+    if (gw.pkt_ring_tail != 1) {
+        errx(1, "the tail shoud have been moved by one");
+    }
+
+    if (last_event_passed_to_event_del != NULL) {
+        errx(1, "event_del shouldn't have ben called");
+    }
+
+    if (gw.pkt_ring_full) {
+        errx(1, "the ring full flag should have been cleared out");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_write_callback_last_packet_on_ring.c b/tests/lifx/gateway/test_gateway_write_callback_last_packet_on_ring.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_write_callback_last_packet_on_ring.c
@@ -0,0 +1,76 @@
+#include "gateway.c"
+
+#define MOCKED_EVBUFFER_WRITE_ATMOST
+#define MOCKED_EVBUFFER_GET_LENGTH
+#include "test_gateway_utils.h"
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)42) {
+        errx(1, "didn't get the expected evbuffer");
+    }
+
+    return 0;
+}
+
+int
+evbuffer_write_atmost(struct evbuffer *buf,
+                      evutil_socket_t fd,
+                      ev_ssize_t howmuch)
+{
+    if (fd != 25) {
+        errx(1, "evbuffer_write_atmost didn't get the expected socket");
+    }
+
+    if (buf != (void *)42) {
+        errx(1, "evbuffer_write_atmost didn't get the expected evbuffer");
+    }
+
+    int expected = sizeof(struct lgtd_lifx_packet_header);
+    expected += sizeof(struct lgtd_lifx_packet_power_state);
+    if (howmuch != expected) {
+        errx(
+            1, "evbuffer_write_atmost expected %d but got %ld",
+            expected, howmuch
+        );
+    }
+
+    return howmuch;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    // fake some values:
+    gw.socket = 25;
+    gw.write_ev = (void *)21;
+    gw.write_buf = (void *)42;
+
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_header);
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_power_state);
+    gw.pkt_ring[0].type = LGTD_LIFX_SET_POWER_STATE;
+    gw.pkt_ring_head++;
+    gw.pkt_ring_head++;
+
+    lgtd_lifx_gateway_write_callback(-1, EV_WRITE, &gw);
+
+    if (gw.pkt_ring[0].size != 0 || gw.pkt_ring[0].type != 0) {
+        errx(1, "the ring entry should have been reset");
+    }
+
+    if (gw.pkt_ring_tail != 1) {
+        errx(1, "the tail shoud have been moved by one");
+    }
+
+    if (last_event_passed_to_event_del != (void *)21) {
+        errx(1, "event_del should have ben called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_write_callback_partial_write.c b/tests/lifx/gateway/test_gateway_write_callback_partial_write.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_write_callback_partial_write.c
@@ -0,0 +1,101 @@
+#include "gateway.c"
+
+#define MOCKED_EVBUFFER_WRITE_ATMOST
+#define MOCKED_EVBUFFER_GET_LENGTH
+#include "test_gateway_utils.h"
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)42) {
+        errx(1, "didn't get the expected evbuffer");
+    }
+
+    // fake another packet to write:
+    return sizeof(struct lgtd_lifx_packet_header);
+}
+
+int
+evbuffer_write_atmost(struct evbuffer *buf,
+                      evutil_socket_t fd,
+                      ev_ssize_t howmuch)
+{
+    if (fd != 25) {
+        errx(1, "evbuffer_write_atmost didn't get the expected socket");
+    }
+
+    if (buf != (void *)42) {
+        errx(1, "evbuffer_write_atmost didn't get the expected evbuffer");
+    }
+
+    static int expected = (
+        sizeof(struct lgtd_lifx_packet_header)
+        + sizeof(struct lgtd_lifx_packet_power_state)
+    );
+    if (howmuch != expected) {
+        errx(
+            1, "evbuffer_write_atmost expected %d but got %ld",
+            expected, howmuch
+        );
+    }
+
+    if (expected != sizeof(struct lgtd_lifx_packet_power_state)) {
+        expected -= sizeof(struct lgtd_lifx_packet_header);
+        return sizeof(struct lgtd_lifx_packet_header);
+    }
+
+    return howmuch;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    // fake some values:
+    gw.socket = 25;
+    gw.write_buf = (void *)42;
+
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_header);
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_power_state);
+    gw.pkt_ring[0].type = LGTD_LIFX_SET_POWER_STATE;
+    gw.pkt_ring_head++;
+    gw.pkt_ring_head++;
+
+    lgtd_lifx_gateway_write_callback(-1, EV_WRITE, &gw);
+
+    if (gw.pkt_ring[0].type != LGTD_LIFX_SET_POWER_STATE) {
+        errx(1, "the ring entry doesn't have the right packet type");
+    }
+
+    if (gw.pkt_ring[0].size != sizeof(struct lgtd_lifx_packet_power_state)) {
+        errx(1, "the ring entry doesn't have the right size value");
+    }
+
+    if (gw.pkt_ring_tail != 0) {
+        errx(1, "the tail shoudn't have been moved by one");
+    }
+
+    if (last_event_passed_to_event_del != NULL) {
+        errx(1, "event_del shouldn't have ben called");
+    }
+
+    lgtd_lifx_gateway_write_callback(-1, EV_WRITE, &gw);
+
+    if (gw.pkt_ring[0].size != 0 || gw.pkt_ring[0].type != 0) {
+        errx(1, "the ring entry should have been reset");
+    }
+
+    if (gw.pkt_ring_tail != 1) {
+        errx(1, "the tail shoud have been moved by one");
+    }
+
+    if (last_event_passed_to_event_del != NULL) {
+        errx(1, "event_del shouldn't have ben called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_write_callback_ring_wraparound.c b/tests/lifx/gateway/test_gateway_write_callback_ring_wraparound.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_write_callback_ring_wraparound.c
@@ -0,0 +1,79 @@
+#include "gateway.c"
+
+#define MOCKED_EVBUFFER_WRITE_ATMOST
+#define MOCKED_EVBUFFER_GET_LENGTH
+#include "test_gateway_utils.h"
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)42) {
+        errx(1, "didn't get the expected evbuffer");
+    }
+
+    // fake another packet to write:
+    return sizeof(struct lgtd_lifx_packet_header);
+}
+
+int
+evbuffer_write_atmost(struct evbuffer *buf,
+                      evutil_socket_t fd,
+                      ev_ssize_t howmuch)
+{
+    if (fd != 25) {
+        errx(1, "evbuffer_write_atmost didn't get the expected socket");
+    }
+
+    if (buf != (void *)42) {
+        errx(1, "evbuffer_write_atmost didn't get the expected evbuffer");
+    }
+
+    int expected = sizeof(struct lgtd_lifx_packet_header);
+    expected += sizeof(struct lgtd_lifx_packet_power_state);
+    if (howmuch != expected) {
+        errx(
+            1, "evbuffer_write_atmost expected %d but got %ld",
+            expected, howmuch
+        );
+    }
+
+    return howmuch;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    // fake some values:
+    gw.socket = 25;
+    gw.write_ev = (void *)21;
+    gw.write_buf = (void *)42;
+
+    int pkt_ring_last_idx = LGTD_ARRAY_SIZE(gw.pkt_ring) - 1;
+    gw.pkt_ring_tail = pkt_ring_last_idx;
+
+    gw.pkt_ring[pkt_ring_last_idx].size += sizeof(struct lgtd_lifx_packet_header);
+    gw.pkt_ring[pkt_ring_last_idx].size += sizeof(struct lgtd_lifx_packet_power_state);
+    gw.pkt_ring[pkt_ring_last_idx].type = LGTD_LIFX_SET_POWER_STATE;
+
+    lgtd_lifx_gateway_write_callback(-1, EV_WRITE, &gw);
+
+    if (gw.pkt_ring[pkt_ring_last_idx].size != 0
+        || gw.pkt_ring[pkt_ring_last_idx].type != 0) {
+        errx(1, "the ring entry should have been reset");
+    }
+
+    if (gw.pkt_ring_tail != 0) {
+        errx(1, "the tail shoud have wrapped around to 0");
+    }
+
+    if (last_event_passed_to_event_del != NULL) {
+        errx(1, "event_del shouldn't have ben called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/tests_shims.c b/tests/lifx/tests_shims.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/tests_shims.c
@@ -0,0 +1,37 @@
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+#include "core/lightsd.h"
+
+struct lgtd_opts lgtd_opts = {
+    .foreground = false,
+    .log_timestamps = false,
+    .verbosity = LGTD_DEBUG
+};
+
+struct event_base *lgtd_ev_base = NULL;
+
+void
+lgtd_cleanup(void)
+{
+}
+
+short
+lgtd_sockaddrport(const struct sockaddr_storage *peer)
+{
+    if (!peer) {
+        return -1;
+    }
+
+    if (peer->ss_family == AF_INET) {
+        const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
+        return ntohs(in_peer->sin_port);
+    } else {
+        const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
+        return ntohs(in6_peer->sin6_port);
+    }
+}
