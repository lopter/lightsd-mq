# HG changeset patch
# Parent f3d6e5762be9d62df241359e696d816c76842f69
# Parent  57d655e5136f2e6ca9a5865691b33e876d103b38
Add the set_waveform command

diff --git a/.hgignore b/.hgignore
--- a/.hgignore
+++ b/.hgignore
@@ -1,3 +1,3 @@
-.*\.sw[p-z]$
+.*\.sw[a-z]$
 .*\.py[co]$
 ^build
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -16,6 +16,7 @@
 // along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <sys/queue.h>
+#include <sys/tree.h>
 #include <arpa/inet.h>
 #include <assert.h>
 #include <ctype.h>
@@ -30,6 +31,7 @@
 #include <event2/bufferevent.h>
 #include <event2/util.h>
 
+#include "lifx/wire_proto.h"
 #include "jsmn.h"
 #include "client.h"
 #include "jsonrpc.h"
@@ -486,7 +488,7 @@
                                                 const struct lgtd_jsonrpc_request *request,
                                                 const char *json)
 {
-    struct lgtd_jsonrpc_set_brightness_args {
+    struct lgtd_jsonrpc_set_light_from_hsbk_args {
         const jsmntok_t *target;
         const jsmntok_t *h;
         const jsmntok_t *s;
@@ -497,37 +499,37 @@
     static const struct lgtd_jsonrpc_node schema[] = {
         LGTD_JSONRPC_NODE(
             "target",
-            offsetof(struct lgtd_jsonrpc_set_brightness_args, target),
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, target),
             lgtd_jsonrpc_type_string,
             false
         ),
         LGTD_JSONRPC_NODE(
             "hue",
-            offsetof(struct lgtd_jsonrpc_set_brightness_args, h),
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, h),
             lgtd_jsonrpc_type_float_between_0_and_360,
             false
         ),
         LGTD_JSONRPC_NODE(
             "saturation",
-            offsetof(struct lgtd_jsonrpc_set_brightness_args, s),
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, s),
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "brightness",
-            offsetof(struct lgtd_jsonrpc_set_brightness_args, b),
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, b),
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "kelvin",
-            offsetof(struct lgtd_jsonrpc_set_brightness_args, k),
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, k),
             lgtd_jsonrpc_type_integer,
             false
         ),
         LGTD_JSONRPC_NODE(
             "transition",
-            offsetof(struct lgtd_jsonrpc_set_brightness_args, t),
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, t),
             lgtd_jsonrpc_type_integer,
             false
         ),
@@ -633,6 +635,183 @@
 }
 
 static void
+lgtd_jsonrpc_check_and_call_set_waveform(struct lgtd_client *client,
+                                         const struct lgtd_jsonrpc_request *request,
+                                         const char *json)
+{
+    struct lgtd_jsonrpc_set_waveform_args {
+        const jsmntok_t *target;
+        const jsmntok_t *waveform;
+        const jsmntok_t *h;
+        const jsmntok_t *s;
+        const jsmntok_t *b;
+        const jsmntok_t *k;
+        const jsmntok_t *period;
+        const jsmntok_t *cycles;
+        const jsmntok_t *skew_ratio;
+        const jsmntok_t *transient;
+    } params = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
+    static const struct lgtd_jsonrpc_node schema[] = {
+        LGTD_JSONRPC_NODE(
+            "target",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, target),
+            lgtd_jsonrpc_type_string,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "waveform",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, waveform),
+            lgtd_jsonrpc_type_string,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "hue",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, h),
+            lgtd_jsonrpc_type_float_between_0_and_360,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "saturation",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, s),
+            lgtd_jsonrpc_type_float_between_0_and_1,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "brightness",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, b),
+            lgtd_jsonrpc_type_float_between_0_and_1,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "kelvin",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, k),
+            lgtd_jsonrpc_type_integer,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "period",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, period),
+            lgtd_jsonrpc_type_integer,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "cycles",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, cycles),
+            lgtd_jsonrpc_type_integer,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "skew_ratio",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, skew_ratio),
+            lgtd_jsonrpc_type_float_between_0_and_1,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "transient",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, transient),
+            lgtd_jsonrpc_type_bool,
+            false
+        ),
+    };
+
+    static const struct {
+        const char  *type;
+        int         len;
+    } waveform_table[] = {
+#define WF(e) { .type = e, .len = sizeof(e) - 1 }
+        WF("SAW"),
+        WF("SINE"),
+        WF("HALF_SINE"),
+        WF("TRIANGLE"),
+        WF("PULSE")
+    };
+
+    bool ok = lgtd_jsonrpc_extract_and_validate_params_against_schema(
+        &params,
+        schema,
+        LGTD_ARRAY_SIZE(schema),
+        request->params,
+        request->params_ntokens,
+        json
+    );
+    if (!ok) {
+        goto error_invalid_params;
+    }
+
+    enum lgtd_lifx_waveform_type waveform;
+    for (int i = 0;; i++) {
+        if (i == LGTD_ARRAY_SIZE(waveform_table)) {
+            goto error_invalid_params;
+        }
+        if (LGTD_JSONRPC_TOKEN_LEN(params.waveform) != waveform_table[i].len) {
+            continue;
+        }
+        bool match = !memcmp(
+            waveform_table[i].type,
+            &json[params.waveform->start],
+            waveform_table[i].len
+        );
+        if (match) {
+            waveform = i;
+            break;
+        }
+    }
+
+    int h = lgtd_jsonrpc_float_range_to_uint16(
+        &json[params.h->start], LGTD_JSONRPC_TOKEN_LEN(params.h), 0, 360
+    );
+    int s = lgtd_jsonrpc_float_range_to_uint16(
+        &json[params.s->start], LGTD_JSONRPC_TOKEN_LEN(params.s), 0, 1
+    );
+    int b = lgtd_jsonrpc_float_range_to_uint16(
+        &json[params.b->start], LGTD_JSONRPC_TOKEN_LEN(params.b), 0, 1
+    );
+    errno = 0;
+    int k = strtol(&json[params.k->start], NULL, 10);
+    if (k < 2500 || k > 9000 || errno == ERANGE) {
+        goto error_invalid_params;
+    }
+    int period = strtol(&json[params.period->start], NULL, 10);
+    if (period <= 0 || errno == ERANGE) {
+        goto error_invalid_params;
+    }
+    int cycles = strtol(&json[params.cycles->start], NULL, 10);
+    if (cycles <= 0 || errno == ERANGE) {
+        goto error_invalid_params;
+    }
+    int skew_ratio = lgtd_jsonrpc_float_range_to_uint16(
+        &json[params.skew_ratio->start],
+        LGTD_JSONRPC_TOKEN_LEN(params.skew_ratio),
+        0, 1
+    );
+    skew_ratio -= UINT16_MAX / 2;
+    bool transient = json[params.transient->start] == 't';
+
+
+    char *target;
+    target = lgtd_jsonrpc_dup_target(client, request, json, params.target);
+    if (!target) {
+        return;
+    }
+
+    lgtd_proto_set_waveform(
+        target, waveform, h, s, b, k, period, cycles, skew_ratio, transient
+    );
+
+    free(target);
+    if (ok) {
+        lgtd_jsonrpc_send_response(client, request, json, "true");
+        return;
+    }
+
+error_invalid_params:
+    lgtd_jsonrpc_send_error(
+        client, request, json, LGTD_JSONRPC_INVALID_PARAMS,
+        "Invalid parameters"
+    );
+}
+
+static void
 lgtd_jsonrpc_check_and_call_power_off(struct lgtd_client *client,
                                       const struct lgtd_jsonrpc_request *request,
                                       const char *json)
@@ -674,6 +853,11 @@
             "set_light_from_hsbk", 6, // t, h, s, b, k, t
             lgtd_jsonrpc_check_and_call_set_light_from_hsbk
         ),
+        LGTD_JSONRPC_METHOD(
+            // t, waveform, h, s, b, k, period, cycles, skew_ratio, transient
+            "set_waveform", 10,
+            lgtd_jsonrpc_check_and_call_set_waveform
+        ),
     };
 
     assert(client);
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -74,3 +74,37 @@
     lgtd_lifx_wire_encode_light_color(&pkt);
     return lgtd_router_send(target, LGTD_LIFX_SET_LIGHT_COLOR, &pkt);
 }
+
+bool lgtd_proto_set_waveform(const char *target,
+                             enum lgtd_lifx_waveform_type waveform,
+                             int hue, int saturation,
+                             int brightness, int kelvin,
+                             int period, float cycles,
+                             int skew_ratio, bool transient)
+{
+    assert(target);
+    assert(hue >= 0 && hue <= UINT16_MAX);
+    assert(saturation >= 0 && saturation <= UINT16_MAX);
+    assert(brightness >= 0 && brightness <= UINT16_MAX);
+    assert(kelvin >= 2500 && kelvin <= 9000);
+    assert(waveform <= LGTD_LIFX_WAVEFORM_PULSE);
+    assert(skew_ratio >= -32767 && skew_ratio <= 32768);
+    assert(period >= 0);
+    assert(cycles >= 0);
+
+    struct lgtd_lifx_packet_waveform pkt = {
+        .stream = 0,
+        .transient = transient,
+        .hue = hue,
+        .saturation = saturation,
+        .brightness = brightness,
+        .kelvin = kelvin,
+        .period = period,
+        .cycles = cycles,
+        .skew_ratio = skew_ratio,
+        .waveform = waveform
+    };
+
+    lgtd_lifx_wire_encode_waveform(&pkt);
+    return lgtd_router_send(target, LGTD_LIFX_SET_WAVEFORM, &pkt);
+}
diff --git a/core/proto.h b/core/proto.h
--- a/core/proto.h
+++ b/core/proto.h
@@ -18,5 +18,9 @@
 #pragma once
 
 bool lgtd_proto_set_light_from_hsbk(const char *, int, int, int, int, int);
+bool lgtd_proto_set_waveform(const char *,
+                             enum lgtd_lifx_waveform_type,
+                             int, int, int, int,
+                             int, float, int, bool);
 bool lgtd_proto_power_on(const char *);
 bool lgtd_proto_power_off(const char *);
diff --git a/docs/protocol.rst b/docs/protocol.rst
--- a/docs/protocol.rst
+++ b/docs/protocol.rst
@@ -11,15 +11,18 @@
 Commands that manipulate bulbs will take a *target* argument to define on which
 bulb(s) the operation should apply:
 
-+-----------------------------+--------------------------------------------+
-| ``\*``                      | targets all bulbs                          |
-+-----------------------------+--------------------------------------------+
-| ``#TagName``                | targets bulbs tagged with *TagName*        |
-+-----------------------------+--------------------------------------------+
-| ``124f31a5``                | directly target the bulb with the given id |
-+-----------------------------+--------------------------------------------+
-| ``[\*, #Kitchen, 123456]``  | compose different targets together         |
-+-----------------------------+--------------------------------------------+
++-----------------------------+-----------------------------------------------+
+| ``\*``                      | targets all bulbs                             |
++-----------------------------+-----------------------------------------------+
+| ``#TagName``                | targets bulbs tagged with *TagName*           |
++-----------------------------+-----------------------------------------------+
+| ``124f31a5``                | directly target the bulb with the given id    |
++-----------------------------+-----------------------------------------------+
+| ``label``                   | directly target the bulb with the given label |
++-----------------------------+-----------------------------------------------+
+
+You can use JSON-RPC's batch feature to send a command to multiple targets at
+the same time.
 
 Available methods
 -----------------
@@ -40,5 +43,19 @@
    :param int k: Temperature in Kelvin from 2500 to 9000.
    :param int t: Transition duration to this color in ms.
 
+.. function:: set_waveform(target, waveform, h, s, b, k, period, cycles, skew_ratio, transient)
+
+   :param string waveform: One of ``SAW``, ``SINE``, ``HALF_SINE``,
+                           ``TRIANGLE``, ``PULSE``.
+   :param float h: Hue from 0 to 360.
+   :param float s: Saturation from 0 to 1.
+   :param float b: Brightness from 0 to 1.
+   :param int k: Temperature in Kelvin from 2500 to 9000.
+   :param int period: milliseconds per cycle.
+   :param int cycles: number of cycles.
+   :param float skew_ratio: from 0 to 1.
+   :param bool transient: if true the target will keep the color it has at the
+                          end of the waveform, otherwise it will revert back to
+                          its original state.
 
 .. vim: set tw=80 spelllang=en spell:
diff --git a/lifx/wire_proto.c b/lifx/wire_proto.c
--- a/lifx/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -129,6 +129,13 @@
             .type = LGTD_LIFX_SET_LIGHT_COLOR,
             .size = sizeof(struct lgtd_lifx_packet_light_color),
             .encode = ENCODER(lgtd_lifx_wire_encode_light_color)
+        },
+        {
+            REQUEST_ONLY,
+            .name = "SET_WAVEFORM",
+            .type = LGTD_LIFX_SET_WAVEFORM,
+            .size = sizeof(struct lgtd_lifx_packet_waveform),
+            .encode = ENCODER(lgtd_lifx_wire_encode_waveform)
         }
     };
 
@@ -177,6 +184,8 @@
     const struct lgtd_lifx_packet_infos *pkt_infos =
         lgtd_lifx_wire_get_packet_infos(packet_type);
 
+    assert(pkt_infos);
+
     memset(hdr, 0, sizeof(*hdr));
     hdr->size = pkt_infos->size + sizeof(*hdr);
     hdr->protocol.version = LGTD_LIFX_PROTOCOL_V1;
@@ -270,3 +279,16 @@
     pkt->kelvin = htole16(pkt->kelvin);
     pkt->transition = htole32(pkt->transition);
 }
+
+void
+lgtd_lifx_wire_encode_waveform(struct lgtd_lifx_packet_waveform *pkt)
+{
+    assert(pkt);
+
+    pkt->hue = htole16(pkt->hue);
+    pkt->saturation = htole16(pkt->saturation);
+    pkt->brightness = htole16(pkt->brightness);
+    pkt->kelvin = htole16(pkt->kelvin);
+    pkt->period = htole16(pkt->period);
+    pkt->skew_ratio = htole16(pkt->skew_ratio);
+}
diff --git a/lifx/wire_proto.h b/lifx/wire_proto.h
--- a/lifx/wire_proto.h
+++ b/lifx/wire_proto.h
@@ -173,6 +173,27 @@
     uint32le_t  transition; // transition time to the color in msecs
 };
 
+enum lgtd_lifx_waveform_type {
+    LGTD_LIFX_WAVEFORM_SAW = 0,
+    LGTD_LIFX_WAVEFORM_SINE = 1,
+    LGTD_LIFX_WAVEFORM_HALF_SINE = 2,
+    LGTD_LIFX_WAVEFORM_TRIANGLE = 3,
+    LGTD_LIFX_WAVEFORM_PULSE = 4,
+};
+
+struct lgtd_lifx_packet_waveform {
+    uint8_t     stream;
+    uint8_t     transient;
+    uint16le_t  hue;
+    uint16le_t  saturation;
+    uint16le_t  brightness;
+    uint16le_t  kelvin;
+    uint32le_t  period; // milliseconds
+    float       cycles; // yes, this value is really encoded as a float.
+    uint16le_t  skew_ratio;
+    uint8_t     waveform; // see enum lgtd_lifx_waveform_type
+};
+
 #pragma pack(pop)
 
 struct lgtd_lifx_gateway;
@@ -222,3 +243,4 @@
 void lgtd_lifx_wire_decode_power_state(struct lgtd_lifx_packet_power_state *);
 
 void lgtd_lifx_wire_encode_light_color(struct lgtd_lifx_packet_light_color *);
+void lgtd_lifx_wire_encode_waveform(struct lgtd_lifx_packet_waveform *pkt);
diff --git a/tests/core/jsonrpc/test_jsonrpc_utils.h b/tests/core/jsonrpc/test_jsonrpc_utils.h
--- a/tests/core/jsonrpc/test_jsonrpc_utils.h
+++ b/tests/core/jsonrpc/test_jsonrpc_utils.h
@@ -66,3 +66,25 @@
     return true;
 }
 #endif
+
+#ifndef LGTD_TESTING_SET_WAVEFORM
+bool lgtd_proto_set_waveform(const char *target,
+                             enum lgtd_lifx_waveform_type waveform,
+                             int hue, int saturation,
+                             int brightness, int kelvin,
+                             int period, float cycles,
+                             int skew_ratio, bool transient)
+{
+    (void)target;
+    (void)waveform;
+    (void)hue;
+    (void)saturation;
+    (void)brightness;
+    (void)kelvin;
+    (void)period;
+    (void)cycles;
+    (void)skew_ratio;
+    (void)transient;
+    return true;
+}
+#endif
diff --git a/tests/lightsc b/tests/lightsc
--- a/tests/lightsc
+++ b/tests/lightsc
@@ -2,8 +2,11 @@
 
 import json
 import socket
+import sys
 import time
 
+from IPython.terminal.embed import InteractiveShellEmbed
+
 
 def jsonrpc_call(socket, id, method, params):
     payload = {
@@ -24,6 +27,34 @@
     ])
 
 
+def set_waveform(socket, id, target, waveform,
+                 h, s, b, k,
+                 period, cycles, skew_ratio, transient):
+    jsonrpc_call(socket, id, "set_waveform", [
+        target, waveform, h, s, b, k, period, cycles, skew_ratio, transient
+    ])
+
+
+def saw(socket, id, target, h, s, b, k, period, cycles, transient=True):
+    set_waveform(
+        socket, id, target, "SAW", h, s, b, k,
+        cycles=cycles,
+        period=period,
+        skew_ratio=0.5,
+        transient=transient
+    )
+
+
+def sine(socket, id, target, h, s, b, k, period, cycles, peak=0.5, transient=True):
+    set_waveform(
+        socket, id, target, "SINE", h, s, b, k,
+        cycles=cycles,
+        period=period,
+        skew_ratio=peak,
+        transient=transient
+    )
+
+
 def power_on(socket, id, target):
     jsonrpc_call(socket, id, "power_on", {"target": target})
 
@@ -40,12 +71,16 @@
     neko = "d073d5018fb6"
     target = "*"
     try:
+        if len(sys.argv) == 2 and sys.argv[1] == "shell":
+            ipshell = InteractiveShellEmbed()
+            ipshell()
+            sys.exit(0)
         power_on(s, id, target)
         while True:
             h = (h + 5) % 360
             id += 1
             set_light_from_hsbk(s, id, target, h, 0.8, 0.1, 2500, 450)
             time.sleep(0.5)
+        power_off(s, id, target)
     finally:
-        power_off(s, id, target)
         s.close()
