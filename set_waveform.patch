# HG changeset patch
# Parent 18915e2158cd3c6becf972848d936503cad55ac3
# Parent  57d655e5136f2e6ca9a5865691b33e876d103b38
Add the set_waveform command

diff --git a/.hgignore b/.hgignore
--- a/.hgignore
+++ b/.hgignore
@@ -1,3 +1,3 @@
-.*\.sw[p-z]$
+.*\.sw[a-z]$
 .*\.py[co]$
 ^build
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -16,6 +16,7 @@
 // along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <sys/queue.h>
+#include <sys/tree.h>
 #include <arpa/inet.h>
 #include <assert.h>
 #include <ctype.h>
@@ -30,6 +31,7 @@
 #include <event2/bufferevent.h>
 #include <event2/util.h>
 
+#include "lifx/wire_proto.h"
 #include "jsmn.h"
 #include "client.h"
 #include "jsonrpc.h"
@@ -486,7 +488,7 @@
                                                 const struct lgtd_jsonrpc_request *request,
                                                 const char *json)
 {
-    struct lgtd_jsonrpc_set_brightness_args {
+    struct lgtd_jsonrpc_set_light_from_hsbk_args {
         const jsmntok_t *target;
         const jsmntok_t *h;
         const jsmntok_t *s;
@@ -497,37 +499,37 @@
     static const struct lgtd_jsonrpc_node schema[] = {
         LGTD_JSONRPC_NODE(
             "target",
-            offsetof(struct lgtd_jsonrpc_set_brightness_args, target),
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, target),
             lgtd_jsonrpc_type_string,
             false
         ),
         LGTD_JSONRPC_NODE(
             "hue",
-            offsetof(struct lgtd_jsonrpc_set_brightness_args, h),
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, h),
             lgtd_jsonrpc_type_float_between_0_and_360,
             false
         ),
         LGTD_JSONRPC_NODE(
             "saturation",
-            offsetof(struct lgtd_jsonrpc_set_brightness_args, s),
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, s),
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "brightness",
-            offsetof(struct lgtd_jsonrpc_set_brightness_args, b),
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, b),
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "kelvin",
-            offsetof(struct lgtd_jsonrpc_set_brightness_args, k),
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, k),
             lgtd_jsonrpc_type_integer,
             false
         ),
         LGTD_JSONRPC_NODE(
             "transition",
-            offsetof(struct lgtd_jsonrpc_set_brightness_args, t),
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, t),
             lgtd_jsonrpc_type_integer,
             false
         ),
@@ -633,6 +635,160 @@
 }
 
 static void
+lgtd_jsonrpc_check_and_call_set_waveform(struct lgtd_client *client,
+                                         const struct lgtd_jsonrpc_request *request,
+                                         const char *json)
+{
+    struct lgtd_jsonrpc_set_waveform_args {
+        const jsmntok_t *target;
+        const jsmntok_t *waveform;
+        const jsmntok_t *h;
+        const jsmntok_t *s;
+        const jsmntok_t *b;
+        const jsmntok_t *k;
+        const jsmntok_t *period;
+        const jsmntok_t *cycles;
+        const jsmntok_t *skew_ratio;
+        const jsmntok_t *transient;
+    } params = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
+    static const struct lgtd_jsonrpc_node schema[] = {
+        LGTD_JSONRPC_NODE(
+            "target",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, target),
+            lgtd_jsonrpc_type_string,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "waveform",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, waveform),
+            lgtd_jsonrpc_type_string,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "hue",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, h),
+            lgtd_jsonrpc_type_float_between_0_and_360,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "saturation",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, s),
+            lgtd_jsonrpc_type_float_between_0_and_1,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "brightness",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, b),
+            lgtd_jsonrpc_type_float_between_0_and_1,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "kelvin",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, k),
+            lgtd_jsonrpc_type_integer,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "period",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, period),
+            lgtd_jsonrpc_type_integer,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "cycles",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, cycles),
+            lgtd_jsonrpc_type_integer,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "skew_ratio",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, skew_ratio),
+            lgtd_jsonrpc_type_float_between_0_and_1,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "transient",
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, transient),
+            lgtd_jsonrpc_type_bool,
+            false
+        ),
+    };
+
+    bool ok = lgtd_jsonrpc_extract_and_validate_params_against_schema(
+        &params,
+        schema,
+        LGTD_ARRAY_SIZE(schema),
+        request->params,
+        request->params_ntokens,
+        json
+    );
+    if (!ok) {
+        goto error_invalid_params;
+    }
+
+    enum lgtd_lifx_waveform_type waveform;
+    waveform = lgtd_lifx_wire_waveform_string_id_to_type(
+        &json[params.waveform->start], LGTD_JSONRPC_TOKEN_LEN(params.waveform)
+    );
+    if (waveform == LGTD_LIFX_WAVEFORM_INVALID) {
+        goto error_invalid_params;
+    }
+
+    int h = lgtd_jsonrpc_float_range_to_uint16(
+        &json[params.h->start], LGTD_JSONRPC_TOKEN_LEN(params.h), 0, 360
+    );
+    int s = lgtd_jsonrpc_float_range_to_uint16(
+        &json[params.s->start], LGTD_JSONRPC_TOKEN_LEN(params.s), 0, 1
+    );
+    int b = lgtd_jsonrpc_float_range_to_uint16(
+        &json[params.b->start], LGTD_JSONRPC_TOKEN_LEN(params.b), 0, 1
+    );
+    errno = 0;
+    int k = strtol(&json[params.k->start], NULL, 10);
+    if (k < 2500 || k > 9000 || errno == ERANGE) {
+        goto error_invalid_params;
+    }
+    int period = strtol(&json[params.period->start], NULL, 10);
+    if (period <= 0 || errno == ERANGE) {
+        goto error_invalid_params;
+    }
+    int cycles = strtol(&json[params.cycles->start], NULL, 10);
+    if (cycles <= 0 || errno == ERANGE) {
+        goto error_invalid_params;
+    }
+    int skew_ratio = lgtd_jsonrpc_float_range_to_uint16(
+        &json[params.skew_ratio->start],
+        LGTD_JSONRPC_TOKEN_LEN(params.skew_ratio),
+        0, 1
+    );
+    skew_ratio -= UINT16_MAX / 2;
+    bool transient = json[params.transient->start] == 't';
+
+
+    char *target;
+    target = lgtd_jsonrpc_dup_target(client, request, json, params.target);
+    if (!target) {
+        return;
+    }
+
+    lgtd_proto_set_waveform(
+        target, waveform, h, s, b, k, period, cycles, skew_ratio, transient
+    );
+
+    free(target);
+    if (ok) {
+        lgtd_jsonrpc_send_response(client, request, json, "true");
+        return;
+    }
+
+error_invalid_params:
+    lgtd_jsonrpc_send_error(
+        client, request, json, LGTD_JSONRPC_INVALID_PARAMS,
+        "Invalid parameters"
+    );
+}
+
+static void
 lgtd_jsonrpc_check_and_call_power_off(struct lgtd_client *client,
                                       const struct lgtd_jsonrpc_request *request,
                                       const char *json)
@@ -674,6 +830,11 @@
             "set_light_from_hsbk", 6, // t, h, s, b, k, t
             lgtd_jsonrpc_check_and_call_set_light_from_hsbk
         ),
+        LGTD_JSONRPC_METHOD(
+            // t, waveform, h, s, b, k, period, cycles, skew_ratio, transient
+            "set_waveform", 10,
+            lgtd_jsonrpc_check_and_call_set_waveform
+        ),
     };
 
     assert(client);
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -74,3 +74,37 @@
     lgtd_lifx_wire_encode_light_color(&pkt);
     return lgtd_router_send(target, LGTD_LIFX_SET_LIGHT_COLOR, &pkt);
 }
+
+bool lgtd_proto_set_waveform(const char *target,
+                             enum lgtd_lifx_waveform_type waveform,
+                             int hue, int saturation,
+                             int brightness, int kelvin,
+                             int period, float cycles,
+                             int skew_ratio, bool transient)
+{
+    assert(target);
+    assert(hue >= 0 && hue <= UINT16_MAX);
+    assert(saturation >= 0 && saturation <= UINT16_MAX);
+    assert(brightness >= 0 && brightness <= UINT16_MAX);
+    assert(kelvin >= 2500 && kelvin <= 9000);
+    assert(waveform <= LGTD_LIFX_WAVEFORM_PULSE);
+    assert(skew_ratio >= -32767 && skew_ratio <= 32768);
+    assert(period >= 0);
+    assert(cycles >= 0);
+
+    struct lgtd_lifx_packet_waveform pkt = {
+        .stream = 0,
+        .transient = transient,
+        .hue = hue,
+        .saturation = saturation,
+        .brightness = brightness,
+        .kelvin = kelvin,
+        .period = period,
+        .cycles = cycles,
+        .skew_ratio = skew_ratio,
+        .waveform = waveform
+    };
+
+    lgtd_lifx_wire_encode_waveform(&pkt);
+    return lgtd_router_send(target, LGTD_LIFX_SET_WAVEFORM, &pkt);
+}
diff --git a/core/proto.h b/core/proto.h
--- a/core/proto.h
+++ b/core/proto.h
@@ -18,5 +18,9 @@
 #pragma once
 
 bool lgtd_proto_set_light_from_hsbk(const char *, int, int, int, int, int);
+bool lgtd_proto_set_waveform(const char *,
+                             enum lgtd_lifx_waveform_type,
+                             int, int, int, int,
+                             int, float, int, bool);
 bool lgtd_proto_power_on(const char *);
 bool lgtd_proto_power_off(const char *);
diff --git a/docs/protocol.rst b/docs/protocol.rst
--- a/docs/protocol.rst
+++ b/docs/protocol.rst
@@ -11,15 +11,18 @@
 Commands that manipulate bulbs will take a *target* argument to define on which
 bulb(s) the operation should apply:
 
-+-----------------------------+--------------------------------------------+
-| ``\*``                      | targets all bulbs                          |
-+-----------------------------+--------------------------------------------+
-| ``#TagName``                | targets bulbs tagged with *TagName*        |
-+-----------------------------+--------------------------------------------+
-| ``124f31a5``                | directly target the bulb with the given id |
-+-----------------------------+--------------------------------------------+
-| ``[\*, #Kitchen, 123456]``  | compose different targets together         |
-+-----------------------------+--------------------------------------------+
++-----------------------------+-----------------------------------------------+
+| ``\*``                      | targets all bulbs                             |
++-----------------------------+-----------------------------------------------+
+| ``#TagName``                | targets bulbs tagged with *TagName*           |
++-----------------------------+-----------------------------------------------+
+| ``124f31a5``                | directly target the bulb with the given id    |
++-----------------------------+-----------------------------------------------+
+| ``label``                   | directly target the bulb with the given label |
++-----------------------------+-----------------------------------------------+
+
+You can use JSON-RPC's batch feature to send a command to multiple targets at
+the same time.
 
 Available methods
 -----------------
@@ -40,5 +43,19 @@
    :param int k: Temperature in Kelvin from 2500 to 9000.
    :param int t: Transition duration to this color in ms.
 
+.. function:: set_waveform(target, waveform, h, s, b, k, period, cycles, skew_ratio, transient)
+
+   :param string waveform: One of ``SAW``, ``SINE``, ``HALF_SINE``,
+                           ``TRIANGLE``, ``PULSE``.
+   :param float h: Hue from 0 to 360.
+   :param float s: Saturation from 0 to 1.
+   :param float b: Brightness from 0 to 1.
+   :param int k: Temperature in Kelvin from 2500 to 9000.
+   :param int period: milliseconds per cycle.
+   :param int cycles: number of cycles.
+   :param float skew_ratio: from 0 to 1.
+   :param bool transient: if true the target will keep the color it has at the
+                          end of the waveform, otherwise it will revert back to
+                          its original state.
 
 .. vim: set tw=80 spelllang=en spell:
diff --git a/lifx/wire_proto.c b/lifx/wire_proto.c
--- a/lifx/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -129,6 +129,13 @@
             .type = LGTD_LIFX_SET_LIGHT_COLOR,
             .size = sizeof(struct lgtd_lifx_packet_light_color),
             .encode = ENCODER(lgtd_lifx_wire_encode_light_color)
+        },
+        {
+            REQUEST_ONLY,
+            .name = "SET_WAVEFORM",
+            .type = LGTD_LIFX_SET_WAVEFORM,
+            .size = sizeof(struct lgtd_lifx_packet_waveform),
+            .encode = ENCODER(lgtd_lifx_wire_encode_waveform)
         }
     };
 
@@ -148,6 +155,34 @@
     return RB_FIND(lgtd_lifx_packet_infos_map, &lgtd_lifx_packet_infos, &pkt_infos);
 }
 
+
+#define WAVEFORM_ENTRY(e) { .str = e, .len = sizeof(e) - 1 }
+const struct lgtd_lifx_waveform_string_id lgtd_lifx_waveform_table[] = {
+    WAVEFORM_ENTRY("SAW"),
+    WAVEFORM_ENTRY("SINE"),
+    WAVEFORM_ENTRY("HALF_SINE"),
+    WAVEFORM_ENTRY("TRIANGLE"),
+    WAVEFORM_ENTRY("PULSE"),
+    WAVEFORM_ENTRY("INVALID")
+};
+
+enum lgtd_lifx_waveform_type
+lgtd_lifx_wire_waveform_string_id_to_type(const char *s, int len)
+{
+    assert(s);
+    assert(len >= 0);
+
+    for (int i = 0; i != LGTD_ARRAY_SIZE(lgtd_lifx_waveform_table); i++) {
+        const struct lgtd_lifx_waveform_string_id *entry;
+        entry = &lgtd_lifx_waveform_table[i];
+        if (entry->len == len && !memcmp(entry->str, s, len)) {
+            return i;
+        }
+    }
+
+    return LGTD_LIFX_WAVEFORM_INVALID;
+}
+
 // Convert all the fields in the header to the host endianness.
 //
 // \return The payload size or -1 if the header is invalid.
@@ -177,6 +212,8 @@
     const struct lgtd_lifx_packet_infos *pkt_infos =
         lgtd_lifx_wire_get_packet_infos(packet_type);
 
+    assert(pkt_infos);
+
     memset(hdr, 0, sizeof(*hdr));
     hdr->size = pkt_infos->size + sizeof(*hdr);
     hdr->protocol.version = LGTD_LIFX_PROTOCOL_V1;
@@ -270,3 +307,16 @@
     pkt->kelvin = htole16(pkt->kelvin);
     pkt->transition = htole32(pkt->transition);
 }
+
+void
+lgtd_lifx_wire_encode_waveform(struct lgtd_lifx_packet_waveform *pkt)
+{
+    assert(pkt);
+
+    pkt->hue = htole16(pkt->hue);
+    pkt->saturation = htole16(pkt->saturation);
+    pkt->brightness = htole16(pkt->brightness);
+    pkt->kelvin = htole16(pkt->kelvin);
+    pkt->period = htole16(pkt->period);
+    pkt->skew_ratio = htole16(pkt->skew_ratio);
+}
diff --git a/lifx/wire_proto.h b/lifx/wire_proto.h
--- a/lifx/wire_proto.h
+++ b/lifx/wire_proto.h
@@ -173,8 +173,38 @@
     uint32le_t  transition; // transition time to the color in msecs
 };
 
+// note: those can be used as indexes for lgtd_lifx_waveform_table
+enum lgtd_lifx_waveform_type {
+    LGTD_LIFX_WAVEFORM_SAW = 0,
+    LGTD_LIFX_WAVEFORM_SINE = 1,
+    LGTD_LIFX_WAVEFORM_HALF_SINE = 2,
+    LGTD_LIFX_WAVEFORM_TRIANGLE = 3,
+    LGTD_LIFX_WAVEFORM_PULSE = 4,
+    LGTD_LIFX_WAVEFORM_INVALID = 5,
+};
+
+struct lgtd_lifx_packet_waveform {
+    uint8_t     stream;
+    uint8_t     transient;
+    uint16le_t  hue;
+    uint16le_t  saturation;
+    uint16le_t  brightness;
+    uint16le_t  kelvin;
+    uint32le_t  period; // milliseconds
+    float       cycles; // yes, this value is really encoded as a float.
+    uint16le_t  skew_ratio;
+    uint8_t     waveform; // see enum lgtd_lifx_waveform_type
+};
+
 #pragma pack(pop)
 
+struct lgtd_lifx_waveform_string_id {
+    const char  *str;
+    int         len;
+};
+
+extern const struct lgtd_lifx_waveform_string_id lgtd_lifx_waveform_table[];
+
 struct lgtd_lifx_gateway;
 
 struct lgtd_lifx_packet_infos {
@@ -204,6 +234,8 @@
 
 extern union lgtd_lifx_target LGTD_LIFX_UNSPEC_TARGET;
 
+enum lgtd_lifx_waveform_type lgtd_lifx_wire_waveform_string_id_to_type(const char *, int);
+
 const struct lgtd_lifx_packet_infos *lgtd_lifx_wire_get_packet_infos(enum lgtd_lifx_packet_type);
 void lgtd_lifx_wire_load_packet_infos_map(void);
 
@@ -222,3 +254,4 @@
 void lgtd_lifx_wire_decode_power_state(struct lgtd_lifx_packet_power_state *);
 
 void lgtd_lifx_wire_encode_light_color(struct lgtd_lifx_packet_light_color *);
+void lgtd_lifx_wire_encode_waveform(struct lgtd_lifx_packet_waveform *pkt);
diff --git a/tests/core/jsonrpc/CMakeLists.txt b/tests/core/jsonrpc/CMakeLists.txt
--- a/tests/core/jsonrpc/CMakeLists.txt
+++ b/tests/core/jsonrpc/CMakeLists.txt
@@ -7,6 +7,7 @@
     test_core_jsonrpc STATIC
     ${LIGHTSD_SOURCE_DIR}/core/jsmn.c
     ${LIGHTSD_SOURCE_DIR}/core/log.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_utils.c
 )
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c
@@ -0,0 +1,120 @@
+#include "jsonrpc.c"
+
+#define LGTD_TESTING_SET_WAVEFORM
+#include "test_jsonrpc_utils.h"
+
+static bool set_waveform_called = false;
+
+bool
+lgtd_proto_set_waveform(const char *target,
+                        enum lgtd_lifx_waveform_type waveform,
+                        int hue, int saturation,
+                        int brightness, int kelvin,
+                        int period, float cycles,
+                        int skew_ratio, bool transient)
+{
+    if (strcmp(target, "*")) {
+        errx(1, "Invalid target [%s] (expected=[*])", target);
+    }
+    int expected_hue = lgtd_jsonrpc_float_range_to_uint16(
+        "324.2341", strlen("324.2341"), 0, 360
+    );
+    if (hue != expected_hue) {
+        errx(1, "Invalid hue: %d, expected: %d", hue, expected_hue);
+    }
+    int expected_saturation = lgtd_jsonrpc_float_range_to_uint16(
+        "0.234", strlen("0.234"), 0, 1
+    );
+    if (saturation != expected_saturation) {
+        errx(
+            1, "Invalid saturation: %d, expected: %d",
+            saturation, expected_saturation
+        );
+    }
+    if (brightness != UINT16_MAX) {
+        errx(
+            1, "Invalid brightness: %d, expected: %d",
+            brightness, UINT16_MAX
+        );
+    }
+    if (kelvin != 4200) {
+        errx(
+            1, "Invalid temperature: %d, expected: 4200", kelvin
+        );
+    }
+    if (period != 1000) {
+        errx(1, "Invalid period: %d, expected: 1000", period);
+    }
+    if (cycles != 10) {
+        errx(1, "Invalid cycles: %d, expected: 10", (int)cycles);
+    }
+    if (skew_ratio != 0) {
+        errx(1, "Invalid skew_ratio: %d, expected: 0", skew_ratio);
+    }
+    if (!transient) {
+        errx(1, "transient is false instead of true");
+    }
+    if (waveform != LGTD_LIFX_WAVEFORM_SAW) {
+        errx(
+            1, "Invalid waveform %d: expected: %d",
+            waveform, LGTD_LIFX_WAVEFORM_SAW
+        );
+    }
+    set_waveform_called = true;
+    return true;
+}
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_waveform\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 324.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": 4200,"
+            "\"cycles\": 10,"
+            "\"period\": 1000,"
+            "\"skew_ratio\": 0.5,"
+            "\"transient\": true,"
+            "\"waveform\": \"SAW\""
+        "},"
+        "\"id\": \"42\""
+    "}");
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    bool ok;
+    struct lgtd_client client = { .io = NULL };
+    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
+    ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
+    if (!ok) {
+        errx(1, "can't parse request");
+    }
+
+    lgtd_jsonrpc_check_and_call_set_waveform(&client, &req, json);
+
+    const char response[] = ("{"
+        "\"jsonrpc\": \"2.0\", "
+        "\"id\": \"42\", "
+        "\"result\": true"
+    "}");
+
+    if (strcmp(client_write_buf, response)) {
+        errx(
+            1, "invalid response: %s (expected: %s)",
+            client_write_buf, response
+        );
+    }
+
+    if (!set_waveform_called) {
+        errx(1, "lgtd_proto_set_waveform wasn't called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform_invalid_params.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform_invalid_params.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform_invalid_params.c
@@ -0,0 +1,251 @@
+#include "jsonrpc.c"
+
+#define LGTD_TESTING_SET_WAVEFORM
+#include "test_jsonrpc_utils.h"
+
+static bool set_waveform_called = false;
+
+bool
+lgtd_proto_set_waveform(const char *target,
+                        enum lgtd_lifx_waveform_type waveform,
+                        int hue, int saturation,
+                        int brightness, int kelvin,
+                        int period, float cycles,
+                        int skew_ratio, bool transient)
+{
+    (void)target;
+    (void)waveform;
+    (void)hue;
+    (void)saturation;
+    (void)brightness;
+    (void)kelvin;
+    (void)period;
+    (void)cycles;
+    (void)skew_ratio;
+    (void)transient;
+    set_waveform_called = true;
+    return true;
+}
+
+static void
+test_request(const char *json)
+{
+    jsmntok_t tokens[32];
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json)
+    );
+
+    bool ok;
+    struct lgtd_client client = { .io = NULL };
+    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
+    ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
+    if (!ok) {
+        errx(1, "can't parse request");
+    }
+
+    lgtd_jsonrpc_check_and_call_set_waveform(&client, &req, json);
+
+    if (!strstr(client_write_buf, "-32602")) {
+        errx(1, "no error returned, client_write_buf=[%s]", client_write_buf);
+    }
+
+    if (set_waveform_called) {
+        errx(1, "lgtd_proto_power_off was called");
+    }
+
+    reset_client_write_buf();
+}
+
+int
+main(void)
+{
+    // invalid temperature:
+    test_request("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_waveform\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 324.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": -4200,"
+            "\"cycles\": 10,"
+            "\"period\": 1000,"
+            "\"skew_ratio\": 0.5,"
+            "\"transient\": true,"
+            "\"waveform\": \"SAW\""
+        "},"
+        "\"id\": \"42\""
+    "}");
+
+    // saturation to big
+    test_request("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_waveform\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 324.2341514, "
+            "\"saturation\": 3.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": 4200,"
+            "\"cycles\": 10,"
+            "\"period\": 1000,"
+            "\"skew_ratio\": 0.5,"
+            "\"transient\": true,"
+            "\"waveform\": \"SAW\""
+        "},"
+        "\"id\": \"42\""
+    "}");
+
+    // hue too big
+    test_request("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_waveform\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 424.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": 4200,"
+            "\"cycles\": 10,"
+            "\"period\": 1000,"
+            "\"skew_ratio\": 0.5,"
+            "\"transient\": true,"
+            "\"waveform\": \"SAW\""
+        "},"
+        "\"id\": \"42\""
+    "}");
+
+    // brightness too small
+    test_request("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_waveform\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 224.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": -1.0, "
+            "\"kelvin\": 4200,"
+            "\"cycles\": 10,"
+            "\"period\": 1000,"
+            "\"skew_ratio\": 0.5,"
+            "\"transient\": true,"
+            "\"waveform\": \"SAW\""
+        "},"
+        "\"id\": \"42\""
+    "}");
+
+    // cycles must be > 0
+    test_request("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_waveform\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 224.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": 4200,"
+            "\"cycles\": 0,"
+            "\"period\": 1000,"
+            "\"skew_ratio\": 0.5,"
+            "\"transient\": true,"
+            "\"waveform\": \"SAW\""
+        "},"
+        "\"id\": \"42\""
+    "}");
+
+    // skew ratio too big
+    test_request("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_waveform\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 224.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": 4200,"
+            "\"cycles\": 10,"
+            "\"period\": 1000,"
+            "\"skew_ratio\": 1.5,"
+            "\"transient\": true,"
+            "\"waveform\": \"SAW\""
+        "},"
+        "\"id\": \"42\""
+    "}");
+
+    // skew ratio too small
+    test_request("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_waveform\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 224.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": 4200,"
+            "\"cycles\": 10,"
+            "\"period\": 1000,"
+            "\"skew_ratio\": -1.5,"
+            "\"transient\": true,"
+            "\"waveform\": \"SAW\""
+        "},"
+        "\"id\": \"42\""
+    "}");
+
+    // invalid waveform
+    test_request("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_waveform\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 224.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": 4200,"
+            "\"cycles\": 10,"
+            "\"period\": 1000,"
+            "\"skew_ratio\": 0.5,"
+            "\"transient\": true,"
+            "\"waveform\": \"TEST\""
+        "},"
+        "\"id\": \"42\""
+    "}");
+
+    // invalid transient
+    test_request("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_waveform\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 224.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": 4200,"
+            "\"cycles\": 10,"
+            "\"period\": 1000,"
+            "\"skew_ratio\": 0.5,"
+            "\"transient\": 42,"
+            "\"waveform\": \"SAW\""
+        "},"
+        "\"id\": \"42\""
+    "}");
+
+    // period must be > 0
+    test_request("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_waveform\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 224.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": 4200,"
+            "\"cycles\": 10,"
+            "\"period\": 0,"
+            "\"skew_ratio\": 0.5,"
+            "\"transient\": true,"
+            "\"waveform\": \"SAW\""
+        "},"
+        "\"id\": \"42\""
+    "}");
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_utils.h b/tests/core/jsonrpc/test_jsonrpc_utils.h
--- a/tests/core/jsonrpc/test_jsonrpc_utils.h
+++ b/tests/core/jsonrpc/test_jsonrpc_utils.h
@@ -66,3 +66,25 @@
     return true;
 }
 #endif
+
+#ifndef LGTD_TESTING_SET_WAVEFORM
+bool lgtd_proto_set_waveform(const char *target,
+                             enum lgtd_lifx_waveform_type waveform,
+                             int hue, int saturation,
+                             int brightness, int kelvin,
+                             int period, float cycles,
+                             int skew_ratio, bool transient)
+{
+    (void)target;
+    (void)waveform;
+    (void)hue;
+    (void)saturation;
+    (void)brightness;
+    (void)kelvin;
+    (void)period;
+    (void)cycles;
+    (void)skew_ratio;
+    (void)transient;
+    return true;
+}
+#endif
diff --git a/tests/core/tests_utils.h b/tests/core/tests_utils.h
--- a/tests/core/tests_utils.h
+++ b/tests/core/tests_utils.h
@@ -1,2 +1,4 @@
+#pragma once
+
 struct lgtd_lifx_gateway *lgtd_tests_insert_mock_gateway(int);
 struct lgtd_lifx_bulb *lgtd_tests_insert_mock_bulb(struct lgtd_lifx_gateway *, uint64_t);
diff --git a/tests/lifx/CMakeLists.txt b/tests/lifx/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/lifx/CMakeLists.txt
@@ -0,0 +1,10 @@
+INCLUDE_DIRECTORIES(
+    ${LIGHTSD_SOURCE_DIR}
+    ${LIGHTSD_SOURCE_DIR}/lifx/
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${LIGHTSD_BINARY_DIR}
+    ${LIGHTSD_BINARY_DIR}/lifx/
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+ADD_ALL_SUBDIRECTORIES()
diff --git a/tests/lifx/wire_proto/CMakeLists.txt b/tests/lifx/wire_proto/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/lifx/wire_proto/CMakeLists.txt
@@ -0,0 +1,13 @@
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+FUNCTION(ADD_WIRE_PROTO_TEST TEST_SOURCE)
+    ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE} FALSE)
+ENDFUNCTION()
+
+FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
+FOREACH(TEST ${TESTS})
+    ADD_WIRE_PROTO_TEST(${TEST})
+ENDFOREACH()
diff --git a/tests/lifx/wire_proto/test_wire_proto_utils.h b/tests/lifx/wire_proto/test_wire_proto_utils.h
new file mode 100644
--- /dev/null
+++ b/tests/lifx/wire_proto/test_wire_proto_utils.h
@@ -0,0 +1,28 @@
+#pragma once
+
+void lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *gw,
+                                          const struct lgtd_lifx_packet_header *hdr,
+                                          const struct lgtd_lifx_packet_pan_gateway *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+
+void lgtd_lifx_gateway_handle_light_status(struct lgtd_lifx_gateway *gw,
+                                           const struct lgtd_lifx_packet_header *hdr,
+                                           const struct lgtd_lifx_packet_light_status *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+
+void lgtd_lifx_gateway_handle_power_state(struct lgtd_lifx_gateway *gw,
+                                          const struct lgtd_lifx_packet_header *hdr,
+                                          const struct lgtd_lifx_packet_power_state *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
diff --git a/tests/lifx/wire_proto/test_wire_proto_waveform_table.c b/tests/lifx/wire_proto/test_wire_proto_waveform_table.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/wire_proto/test_wire_proto_waveform_table.c
@@ -0,0 +1,57 @@
+#include "wire_proto.c"
+
+#include "test_wire_proto_utils.h"
+
+int
+main(void)
+{
+    enum lgtd_lifx_waveform_type rv = LGTD_LIFX_WAVEFORM_INVALID;
+
+    rv = lgtd_lifx_wire_waveform_string_id_to_type("SAW", 3);
+    if (rv != LGTD_LIFX_WAVEFORM_SAW) {
+        errx(1, "Expected WAVEFORM_SAW");
+    }
+
+    rv = lgtd_lifx_wire_waveform_string_id_to_type("SINE", 4);
+    if (rv != LGTD_LIFX_WAVEFORM_SINE) {
+        errx(1, "Expected WAVEFORM_SINE");
+    }
+
+    rv = lgtd_lifx_wire_waveform_string_id_to_type("HALF_SINE", 9);
+    if (rv != LGTD_LIFX_WAVEFORM_HALF_SINE) {
+        errx(1, "Expected WAVEFORM_HALF_SINE");
+    }
+
+    rv = lgtd_lifx_wire_waveform_string_id_to_type("TRIANGLE", 8);
+    if (rv != LGTD_LIFX_WAVEFORM_TRIANGLE) {
+        errx(1, "Expected WAVEFORM_TRIANGLE");
+    }
+
+    rv = lgtd_lifx_wire_waveform_string_id_to_type("PULSE", 5);
+    if (rv != LGTD_LIFX_WAVEFORM_PULSE) {
+        errx(1, "Expected WAVEFORM_PULSE");
+    }
+
+    rv = lgtd_lifx_wire_waveform_string_id_to_type("TEST", 4);
+    if (rv != LGTD_LIFX_WAVEFORM_INVALID) {
+        errx(1, "Expected WAVEFORM_INVALID");
+    }
+
+    rv = lgtd_lifx_wire_waveform_string_id_to_type("", 0);
+    if (rv != LGTD_LIFX_WAVEFORM_INVALID) {
+        errx(1, "Expected WAVEFORM_INVALID");
+    }
+
+    int cmp = strcmp(
+        lgtd_lifx_waveform_table[LGTD_LIFX_WAVEFORM_INVALID].str,
+        "INVALID"
+    );
+    if (cmp) {
+        errx(
+            1, "Expected INVALID got %s",
+            lgtd_lifx_waveform_table[LGTD_LIFX_WAVEFORM_INVALID].str
+        );
+    }
+
+    return 0;
+}
diff --git a/tests/lightsc b/tests/lightsc
--- a/tests/lightsc
+++ b/tests/lightsc
@@ -2,8 +2,11 @@
 
 import json
 import socket
+import sys
 import time
 
+from IPython.terminal.embed import InteractiveShellEmbed
+
 
 def jsonrpc_call(socket, id, method, params):
     payload = {
@@ -24,6 +27,34 @@
     ])
 
 
+def set_waveform(socket, id, target, waveform,
+                 h, s, b, k,
+                 period, cycles, skew_ratio, transient):
+    jsonrpc_call(socket, id, "set_waveform", [
+        target, waveform, h, s, b, k, period, cycles, skew_ratio, transient
+    ])
+
+
+def saw(socket, id, target, h, s, b, k, period, cycles, transient=True):
+    set_waveform(
+        socket, id, target, "SAW", h, s, b, k,
+        cycles=cycles,
+        period=period,
+        skew_ratio=0.5,
+        transient=transient
+    )
+
+
+def sine(socket, id, target, h, s, b, k, period, cycles, peak=0.5, transient=True):
+    set_waveform(
+        socket, id, target, "SINE", h, s, b, k,
+        cycles=cycles,
+        period=period,
+        skew_ratio=peak,
+        transient=transient
+    )
+
+
 def power_on(socket, id, target):
     jsonrpc_call(socket, id, "power_on", {"target": target})
 
@@ -40,12 +71,16 @@
     neko = "d073d5018fb6"
     target = "*"
     try:
+        if len(sys.argv) == 2 and sys.argv[1] == "shell":
+            ipshell = InteractiveShellEmbed()
+            ipshell()
+            sys.exit(0)
         power_on(s, id, target)
         while True:
             h = (h + 5) % 360
             id += 1
             set_light_from_hsbk(s, id, target, h, 0.8, 0.1, 2500, 450)
             time.sleep(0.5)
+        power_off(s, id, target)
     finally:
-        power_off(s, id, target)
         s.close()
