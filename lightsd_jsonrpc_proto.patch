# HG changeset patch
# Parent 4bcb4a2cbc3080bcba1c70a5a431ed72be7140ed
# Parent  4bcb4a2cbc3080bcba1c70a5a431ed72be7140ed
Add a TCP/JSON-RPC API

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -16,6 +16,8 @@
 
 SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${LIGHTSD_SOURCE_DIR}/CMakeScripts)
 
+ENABLE_TESTING()
+
 ### Platform checks ############################################################
 
 # TODO: we need at least 2.0.19-stable because of the logging defines
@@ -29,6 +31,9 @@
 
 ### Global definitions #########################################################
 
+INCLUDE(AddAllSubdirectories)
+INCLUDE(AddTestFromSources)
+
 SET(CMAKE_C_FLAGS "-pipe -Wextra -Wall -Wstrict-prototypes -std=c99")
 
 # Only relevant for the GNU libc:
@@ -49,3 +54,4 @@
 
 ADD_SUBDIRECTORY(core)
 ADD_SUBDIRECTORY(lifx)
+ADD_SUBDIRECTORY(tests)
diff --git a/CMakeScripts/AddAllSubdirectories.cmake b/CMakeScripts/AddAllSubdirectories.cmake
new file mode 100644
--- /dev/null
+++ b/CMakeScripts/AddAllSubdirectories.cmake
@@ -0,0 +1,8 @@
+FUNCTION(ADD_ALL_SUBDIRECTORIES)
+    FILE(GLOB SUBDIRECTORIES "*")
+    FOREACH (ENTRY ${SUBDIRECTORIES})
+        IF (IS_DIRECTORY ${ENTRY})
+            ADD_SUBDIRECTORY(${ENTRY})
+        ENDIF ()
+    ENDFOREACH ()
+ENDFUNCTION()
diff --git a/CMakeScripts/AddTestFromSources.cmake b/CMakeScripts/AddTestFromSources.cmake
new file mode 100644
--- /dev/null
+++ b/CMakeScripts/AddTestFromSources.cmake
@@ -0,0 +1,8 @@
+FUNCTION(ADD_TEST_FROM_C_SOURCES)
+    STRING(LENGTH ${ARGV0} TEST_NAME_LEN)
+    STRING(LENGTH "test_" PREFIX_LEN)
+    MATH(EXPR TEST_NAME_LEN "${TEST_NAME_LEN} - 2 - ${PREFIX_LEN}")
+    STRING(SUBSTRING ${ARGV0} ${PREFIX_LEN} ${TEST_NAME_LEN} TEST_NAME)
+    ADD_EXECUTABLE(${TEST_NAME} ${ARGV})
+    ADD_TEST(test_${TEST_NAME} ${TEST_NAME})
+ENDFUNCTION()
diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -10,10 +10,18 @@
 
 CONFIGURE_FILE(version.h.in ${CMAKE_CURRENT_BINARY_DIR}/version.h)
 
+ADD_DEFINITIONS("-DJSMN_STRICT=1")
+
 ADD_EXECUTABLE(
     lightsd
+    client.c
+    jsmn.c
+    jsonrpc.c
+    listen.c
     lightsd.c
     log.c
+    proto.c
+    router.c
     ${TIME_MONOTONIC_IMPL}
 )
 
diff --git a/core/client.c b/core/client.c
new file mode 100644
--- /dev/null
+++ b/core/client.c
@@ -0,0 +1,177 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <sys/queue.h>
+#include <assert.h>
+#include <err.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include <event2/buffer.h>
+#include <event2/bufferevent.h>
+#include <event2/event.h>
+
+#include "jsmn.h"
+#include "client.h"
+#include "jsonrpc.h"
+#include "lightsd.h"
+
+struct lgtd_client_list lgtd_clients = LIST_HEAD_INITIALIZER(&lgtd_clients);
+
+static void
+lgtd_client_close(struct lgtd_client *client)
+{
+    assert(client);
+    assert(client->io);
+
+    LIST_REMOVE(client, link);
+    bufferevent_free(client->io);
+    free(client);
+}
+
+void
+lgtd_client_close_all(void)
+{
+    struct lgtd_client *client, *next_client;
+    LIST_FOREACH_SAFE(client, &lgtd_clients, link, next_client) {
+        lgtd_client_close(client);
+    }
+}
+
+static void
+lgtd_client_read_callback(struct bufferevent *bev, void *ctx)
+{
+    assert(ctx);
+
+    struct lgtd_client *client = ctx;
+
+    struct evbuffer *input = bufferevent_get_input(bev);
+    size_t bufsz = evbuffer_get_contiguous_space(input);
+    // Get the actual pointer to the beginning of the evbuf:
+    const char *buf = (char *)evbuffer_pullup(input, bufsz);
+    jsmnerr_t rv;
+
+retry_after_pullup:
+    rv = jsmn_parse(
+        &client->jsmn_ctx,
+        buf,
+        bufsz,
+        client->jsmn_tokens,
+        LGTD_ARRAY_SIZE(client->jsmn_tokens)
+    );
+    switch (rv) {
+    case JSMN_ERROR_NOMEM:
+        lgtd_warnx(
+            "dropping client [%s]:%hu: request too big, not "
+            "enough parser tokens", client->ip_addr, client->port
+        );
+        lgtd_client_close(client);
+        break;
+    case JSMN_ERROR_INVAL:
+        lgtd_warnx(
+            "dropping client [%s]:%hu: invalid json",
+            client->ip_addr, client->port
+        );
+        // TODO: consume remaining data and send a proper error instead of
+        // closing the connection:
+        lgtd_client_close(client);
+        break;
+    case JSMN_ERROR_PART:
+        if (evbuffer_get_length(input) > LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) {
+            lgtd_warnx(
+                "dropping client [%s]:%hu: request too big",
+                client->ip_addr, client->port
+            );
+            lgtd_client_close(client);
+            break;
+        } else if (bufsz >= evbuffer_get_length(input)) {
+            break; // We pulled up everything already, wait for more data
+        }
+        // pullup and resume parsing:
+        buf = (char *)evbuffer_pullup(input, -1);
+        bufsz = evbuffer_get_length(input);
+        goto retry_after_pullup;
+    default:
+        lgtd_jsonrpc_dispatch_request(client, buf, rv);
+        evbuffer_drain(input, bufsz);
+        jsmn_init(&client->jsmn_ctx);
+        break;
+    }
+}
+
+static void
+lgtd_client_event_callback(struct bufferevent *bev, short events, void *ctx)
+{
+    (void)bev;
+    assert(ctx);
+
+    struct lgtd_client *client = ctx;
+
+    if (events & (BEV_EVENT_ERROR|BEV_EVENT_EOF)) {
+        lgtd_info(
+            "lost connection with client [%s]:%hu",
+            client->ip_addr, client->port
+        );
+        lgtd_client_close(client);
+    }
+}
+
+struct lgtd_client *
+lgtd_client_open(evutil_socket_t peer, const struct sockaddr_storage *peer_addr)
+{
+    assert(peer != -1);
+    assert(peer_addr);
+
+    struct lgtd_client *client = calloc(1, sizeof(*client));
+    if (!client) {
+        return NULL;
+    }
+    client->io = bufferevent_socket_new(
+        lgtd_ev_base, peer, BEV_OPT_CLOSE_ON_FREE
+    );
+    if (!client->io) {
+        return NULL;
+    }
+    bufferevent_setcb(
+        client->io,
+        lgtd_client_read_callback,
+        NULL,
+        lgtd_client_event_callback,
+        client
+    );
+    lgtd_sockaddrtoa(peer_addr, client->ip_addr, sizeof(client->ip_addr));
+    client->port = lgtd_sockaddrport(peer_addr);
+    jsmn_init(&client->jsmn_ctx);
+    bufferevent_enable(client->io, EV_READ|EV_WRITE|EV_TIMEOUT);
+
+    LIST_INSERT_HEAD(&lgtd_clients, client, link);
+
+    return client;
+}
diff --git a/core/client.h b/core/client.h
new file mode 100644
--- /dev/null
+++ b/core/client.h
@@ -0,0 +1,50 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+enum { LGTD_CLIENT_JSMN_TOKENS_NUM = 48 };
+enum { LGTD_CLIENT_MAX_REQUEST_BUF_SIZE = 2048 };
+
+struct lgtd_client {
+    LIST_ENTRY(lgtd_client)  link;
+    struct bufferevent      *io;
+    char                    ip_addr[INET6_ADDRSTRLEN];
+    uint16_t                port;
+    jsmn_parser             jsmn_ctx;
+    jsmntok_t               jsmn_tokens[LGTD_CLIENT_JSMN_TOKENS_NUM];
+};
+LIST_HEAD(lgtd_client_list, lgtd_client);
+
+#define LGTD_CLIENT_WRITE_STRING(client, s) do {        \
+    bufferevent_write((client)->io, s, strlen((s)));    \
+} while(0)
+
+struct lgtd_client *lgtd_client_open(evutil_socket_t, const struct sockaddr_storage *);
+void lgtd_client_close_all(void);
diff --git a/core/jsmn.c b/core/jsmn.c
new file mode 100644
--- /dev/null
+++ b/core/jsmn.c
@@ -0,0 +1,333 @@
+/*
+ * Copyright (c) 2010 Serge A. Zaitsev
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+
+#include "jsmn.h"
+
+/**
+ * Allocates a fresh unused token from the token pull.
+ */
+static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser,
+		jsmntok_t *tokens, size_t num_tokens) {
+	jsmntok_t *tok;
+	if (parser->toknext >= num_tokens) {
+		return NULL;
+	}
+	tok = &tokens[parser->toknext++];
+	tok->start = tok->end = -1;
+	tok->size = 0;
+#ifdef JSMN_PARENT_LINKS
+	tok->parent = -1;
+#endif
+	return tok;
+}
+
+/**
+ * Fills token type and boundaries.
+ */
+static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type,
+                            int start, int end) {
+	token->type = type;
+	token->start = start;
+	token->end = end;
+	token->size = 0;
+}
+
+/**
+ * Fills next available token with JSON primitive.
+ */
+static jsmnerr_t jsmn_parse_primitive(jsmn_parser *parser, const char *js,
+		size_t len, jsmntok_t *tokens, size_t num_tokens) {
+	jsmntok_t *token;
+	int start;
+
+	start = parser->pos;
+
+	for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+		switch (js[parser->pos]) {
+#ifndef JSMN_STRICT
+			/* In strict mode primitive must be followed by "," or "}" or "]" */
+			case ':':
+#endif
+			case '\t' : case '\r' : case '\n' : case ' ' :
+			case ','  : case ']'  : case '}' :
+				goto found;
+		}
+		if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
+			parser->pos = start;
+			return JSMN_ERROR_INVAL;
+		}
+	}
+#ifdef JSMN_STRICT
+	/* In strict mode primitive must be followed by a comma/object/array */
+	parser->pos = start;
+	return JSMN_ERROR_PART;
+#endif
+
+found:
+	if (tokens == NULL) {
+		parser->pos--;
+		return 0;
+	}
+	token = jsmn_alloc_token(parser, tokens, num_tokens);
+	if (token == NULL) {
+		parser->pos = start;
+		return JSMN_ERROR_NOMEM;
+	}
+	jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
+#ifdef JSMN_PARENT_LINKS
+	token->parent = parser->toksuper;
+#endif
+	parser->pos--;
+	return 0;
+}
+
+/**
+ * Filsl next token with JSON string.
+ */
+static jsmnerr_t jsmn_parse_string(jsmn_parser *parser, const char *js,
+		size_t len, jsmntok_t *tokens, size_t num_tokens) {
+	jsmntok_t *token;
+
+	int start = parser->pos;
+
+	parser->pos++;
+
+	/* Skip starting quote */
+	for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+		char c = js[parser->pos];
+
+		/* Quote: end of string */
+		if (c == '\"') {
+			if (tokens == NULL) {
+				return 0;
+			}
+			token = jsmn_alloc_token(parser, tokens, num_tokens);
+			if (token == NULL) {
+				parser->pos = start;
+				return JSMN_ERROR_NOMEM;
+			}
+			jsmn_fill_token(token, JSMN_STRING, start+1, parser->pos);
+#ifdef JSMN_PARENT_LINKS
+			token->parent = parser->toksuper;
+#endif
+			return 0;
+		}
+
+		/* Backslash: Quoted symbol expected */
+		if (c == '\\' && parser->pos + 1 < len) {
+			int i;
+			parser->pos++;
+			switch (js[parser->pos]) {
+				/* Allowed escaped symbols */
+				case '\"': case '/' : case '\\' : case 'b' :
+				case 'f' : case 'r' : case 'n'  : case 't' :
+					break;
+				/* Allows escaped symbol \uXXXX */
+				case 'u':
+					parser->pos++;
+					for(i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0'; i++) {
+						/* If it isn't a hex character we have an error */
+						if(!((js[parser->pos] >= 48 && js[parser->pos] <= 57) || /* 0-9 */
+									(js[parser->pos] >= 65 && js[parser->pos] <= 70) || /* A-F */
+									(js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */
+							parser->pos = start;
+							return JSMN_ERROR_INVAL;
+						}
+						parser->pos++;
+					}
+					parser->pos--;
+					break;
+				/* Unexpected symbol */
+				default:
+					parser->pos = start;
+					return JSMN_ERROR_INVAL;
+			}
+		}
+	}
+	parser->pos = start;
+	return JSMN_ERROR_PART;
+}
+
+/**
+ * Parse JSON string and fill tokens.
+ */
+jsmnerr_t jsmn_parse(jsmn_parser *parser, const char *js, size_t len,
+		jsmntok_t *tokens, unsigned int num_tokens) {
+	jsmnerr_t r;
+	int i;
+	jsmntok_t *token;
+	int count = 0;
+
+	for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
+		char c;
+		jsmntype_t type;
+
+		c = js[parser->pos];
+		switch (c) {
+			case '{': case '[':
+				count++;
+				if (tokens == NULL) {
+					break;
+				}
+				token = jsmn_alloc_token(parser, tokens, num_tokens);
+				if (token == NULL)
+					return JSMN_ERROR_NOMEM;
+				if (parser->toksuper != -1) {
+					tokens[parser->toksuper].size++;
+#ifdef JSMN_PARENT_LINKS
+					token->parent = parser->toksuper;
+#endif
+				}
+				token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
+				token->start = parser->pos;
+				parser->toksuper = parser->toknext - 1;
+				break;
+			case '}': case ']':
+				if (tokens == NULL)
+					break;
+				type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
+#ifdef JSMN_PARENT_LINKS
+				if (parser->toknext < 1) {
+					return JSMN_ERROR_INVAL;
+				}
+				token = &tokens[parser->toknext - 1];
+				for (;;) {
+					if (token->start != -1 && token->end == -1) {
+						if (token->type != type) {
+							return JSMN_ERROR_INVAL;
+						}
+						token->end = parser->pos + 1;
+						parser->toksuper = token->parent;
+						break;
+					}
+					if (token->parent == -1) {
+						break;
+					}
+					token = &tokens[token->parent];
+				}
+#else
+				for (i = parser->toknext - 1; i >= 0; i--) {
+					token = &tokens[i];
+					if (token->start != -1 && token->end == -1) {
+						if (token->type != type) {
+							return JSMN_ERROR_INVAL;
+						}
+						parser->toksuper = -1;
+						token->end = parser->pos + 1;
+						break;
+					}
+				}
+				/* Error if unmatched closing bracket */
+				if (i == -1) return JSMN_ERROR_INVAL;
+				for (; i >= 0; i--) {
+					token = &tokens[i];
+					if (token->start != -1 && token->end == -1) {
+						parser->toksuper = i;
+						break;
+					}
+				}
+#endif
+				break;
+			case '\"':
+				r = jsmn_parse_string(parser, js, len, tokens, num_tokens);
+				if (r < 0) return r;
+				count++;
+				if (parser->toksuper != -1 && tokens != NULL)
+					tokens[parser->toksuper].size++;
+				break;
+			case '\t' : case '\r' : case '\n' : case ' ':
+				break;
+			case ':':
+				parser->toksuper = parser->toknext - 1;
+				break;
+			case ',':
+				if (tokens != NULL &&
+						tokens[parser->toksuper].type != JSMN_ARRAY &&
+						tokens[parser->toksuper].type != JSMN_OBJECT) {
+#ifdef JSMN_PARENT_LINKS
+					parser->toksuper = tokens[parser->toksuper].parent;
+#else
+					for (i = parser->toknext - 1; i >= 0; i--) {
+						if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
+							if (tokens[i].start != -1 && tokens[i].end == -1) {
+								parser->toksuper = i;
+								break;
+							}
+						}
+					}
+#endif
+				}
+				break;
+#ifdef JSMN_STRICT
+			/* In strict mode primitives are: numbers and booleans */
+			case '-': case '0': case '1' : case '2': case '3' : case '4':
+			case '5': case '6': case '7' : case '8': case '9':
+			case 't': case 'f': case 'n' :
+				/* And they must not be keys of the object */
+				if (tokens != NULL) {
+					jsmntok_t *t = &tokens[parser->toksuper];
+					if (t->type == JSMN_OBJECT ||
+							(t->type == JSMN_STRING && t->size != 0)) {
+						return JSMN_ERROR_INVAL;
+					}
+				}
+#else
+			/* In non-strict mode every unquoted value is a primitive */
+			default:
+#endif
+				r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);
+				if (r < 0) return r;
+				count++;
+				if (parser->toksuper != -1 && tokens != NULL)
+					tokens[parser->toksuper].size++;
+				break;
+
+#ifdef JSMN_STRICT
+			/* Unexpected char in strict mode */
+			default:
+				return JSMN_ERROR_INVAL;
+#endif
+		}
+	}
+
+	for (i = parser->toknext - 1; i >= 0; i--) {
+		/* Unmatched opened object or array */
+		if (tokens[i].start != -1 && tokens[i].end == -1) {
+			return JSMN_ERROR_PART;
+		}
+	}
+
+	return count;
+}
+
+/**
+ * Creates a new parser based over a given  buffer with an array of tokens
+ * available.
+ */
+void jsmn_init(jsmn_parser *parser) {
+	parser->pos = 0;
+	parser->toknext = 0;
+	parser->toksuper = -1;
+}
+
diff --git a/core/jsmn.h b/core/jsmn.h
new file mode 100644
--- /dev/null
+++ b/core/jsmn.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2010 Serge A. Zaitsev
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef __JSMN_H_
+#define __JSMN_H_
+
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * JSON type identifier. Basic types are:
+ * 	o Object
+ * 	o Array
+ * 	o String
+ * 	o Other primitive: number, boolean (true/false) or null
+ */
+typedef enum {
+	JSMN_PRIMITIVE = 0,
+	JSMN_OBJECT = 1,
+	JSMN_ARRAY = 2,
+	JSMN_STRING = 3
+} jsmntype_t;
+
+typedef enum {
+	/* Not enough tokens were provided */
+	JSMN_ERROR_NOMEM = -1,
+	/* Invalid character inside JSON string */
+	JSMN_ERROR_INVAL = -2,
+	/* The string is not a full JSON packet, more bytes expected */
+	JSMN_ERROR_PART = -3
+} jsmnerr_t;
+
+/**
+ * JSON token description.
+ * @param		type	type (object, array, string etc.)
+ * @param		start	start position in JSON data string
+ * @param		end		end position in JSON data string
+ */
+typedef struct {
+	jsmntype_t type;
+	int start;
+	int end;
+	int size;
+#ifdef JSMN_PARENT_LINKS
+	int parent;
+#endif
+} jsmntok_t;
+
+/**
+ * JSON parser. Contains an array of token blocks available. Also stores
+ * the string being parsed now and current position in that string
+ */
+typedef struct {
+	unsigned int pos; /* offset in the JSON string */
+	unsigned int toknext; /* next token to allocate */
+	int toksuper; /* superior token node, e.g parent object or array */
+} jsmn_parser;
+
+/**
+ * Create JSON parser over an array of tokens
+ */
+void jsmn_init(jsmn_parser *parser);
+
+/**
+ * Run JSON parser. It parses a JSON data string into and array of tokens, each describing
+ * a single JSON object.
+ */
+jsmnerr_t jsmn_parse(jsmn_parser *parser, const char *js, size_t len,
+		jsmntok_t *tokens, unsigned int num_tokens);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __JSMN_H_ */
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
new file mode 100644
--- /dev/null
+++ b/core/jsonrpc.c
@@ -0,0 +1,653 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <sys/queue.h>
+#include <arpa/inet.h>
+#include <assert.h>
+#include <ctype.h>
+#include <err.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <event2/bufferevent.h>
+#include <event2/util.h>
+
+#include "jsmn.h"
+#include "client.h"
+#include "jsonrpc.h"
+#include "proto.h"
+#include "lightsd.h"
+
+static bool
+lgtd_jsonrpc_type_integer(const jsmntok_t *t, const char *json)
+{
+    if (t->type != JSMN_PRIMITIVE) {
+        return false;
+    }
+
+    const char *endptr = NULL;
+    errno = 0;
+    strtol(&json[t->start], (char **)&endptr, 10);
+    return endptr == json + t->end && errno != ERANGE;
+}
+
+static bool
+lgtd_jsonrpc_type_float_between_0_and_1(const jsmntok_t *t,
+                                        const char *json)
+{
+    if (t->type != JSMN_PRIMITIVE) {
+        return false;
+    }
+
+    int i = t->start;
+    bool dot_seen = false;
+    bool first_digit_is_one = false;
+    for (; i < t->end; i++) {
+        if (json[i] == '.') {
+            if (dot_seen) {
+                return false;
+            }
+            dot_seen = true;
+        } else if (dot_seen) {
+            if (json[i] < '0' || json[i] > '9') {
+                return false;
+            } if (first_digit_is_one && json[i] != '0') {
+                return false;
+            }
+        } else {
+            if (first_digit_is_one) {
+                return false;
+            } else if (json[i] == '1') {
+                first_digit_is_one = true;
+            } else if (json[i] != '0') {
+                return false;
+            }
+        }
+    }
+
+    return true;
+}
+
+static bool
+lgtd_jsonrpc_type_float_between_0_and_360(const jsmntok_t *t,
+                                          const char *json)
+{
+    if (t->type != JSMN_PRIMITIVE) {
+        return false;
+    }
+
+    char c = json[t->start];
+    if (c != '-' && (c > '9' || c < '0')) {
+        return false;
+    }
+
+    const char *endptr = NULL;
+    errno = 0;
+    long intpart = strtol(&json[t->start], (char **)&endptr, 10);
+    if ((endptr != json + t->end && *endptr != '.')
+        || errno == ERANGE || intpart < 0 || intpart > 360
+        || (intpart == 0 && c == '-')) {
+        return false;
+    }
+    if (endptr == json + t->end) {
+        return true;
+    }
+    long fracpart = strtol(++endptr, (char **)&endptr, 10);
+    return endptr == json + t->end && errno != ERANGE
+        && fracpart >= 0 && (intpart < 360 || fracpart == 0);
+}
+
+static bool
+lgtd_jsonrpc_type_number(const jsmntok_t *t, const char *json)
+{
+    if (t->type != JSMN_PRIMITIVE) {
+        return false;
+    }
+
+    char c = json[t->start];
+    return c == '-' || (c >= '0' && c <= '9');
+}
+
+static bool __attribute__((unused))
+lgtd_jsonrpc_type_bool(const jsmntok_t *t, const char *json)
+{
+    if (t->type != JSMN_PRIMITIVE) {
+        return false;
+    }
+
+    char c = json[t->start];
+    return c == 't' || c == 'f';
+}
+
+static bool
+lgtd_jsonrpc_type_null(const jsmntok_t *t, const char *json)
+{
+    return memcmp(
+        &json[t->start], "null", LGTD_MIN(t->size, (int)sizeof("null"))
+    );
+}
+
+static bool
+lgtd_jsonrpc_type_string(const jsmntok_t *t, const char *json)
+{
+    (void)json;
+    return t->type == JSMN_STRING;
+}
+
+static bool
+lgtd_jsonrpc_type_object_or_array(const jsmntok_t *t, const char *json)
+{
+    (void)json;
+    return t->type == JSMN_OBJECT || t->type == JSMN_ARRAY;
+}
+
+static bool
+lgtd_jsonrpc_type_string_number_or_null(const jsmntok_t *t,
+                                        const char *json)
+{
+    return lgtd_jsonrpc_type_number(t, json)
+        || lgtd_jsonrpc_type_null(t, json)
+        || t->type == JSMN_STRING;
+}
+
+static int
+lgtd_jsonrpc_consume_object_or_array(const jsmntok_t *tokens,
+                                     int ti,
+                                     int parsed,
+                                     const char *json)
+{
+    assert(tokens[ti].type == JSMN_OBJECT || tokens[ti].type == JSMN_ARRAY);
+    assert(ti < parsed);
+
+    int obj_size = tokens[ti++].size;
+    while (obj_size-- && ti < parsed) {
+        if (tokens[ti].type == JSMN_OBJECT || tokens[ti].type == JSMN_ARRAY) {
+            ti = lgtd_jsonrpc_consume_object_or_array(tokens, ti, parsed, json);
+        } else {
+            ti += tokens[ti].size + 1;
+        }
+    }
+    return ti;
+}
+
+static int
+lgtd_jsonrpc_float_range_to_uint16(const char *s, int len, int start, int stop)
+{
+    assert(s);
+    assert(len > 0);
+    assert(start < stop);
+
+    int range = stop * 10E5 - start * 10E5;
+    const char *dot = NULL;
+    long fracpart = 0;
+    long intpart = strtol(s, (char **)&dot, 10) * 10E5;
+    if (dot - s != len && *dot == '.') {
+        for (int i = dot - s + 1, multiplier = 10E4;
+             i != len && multiplier != 0;
+             i++, multiplier /= 10) {
+            fracpart += (s[i] - '0') * multiplier;
+        }
+    }
+    return ((intpart + fracpart) * UINT16_MAX) / range;
+}
+
+static bool
+lgtd_jsonrpc_extract_values_from_schema_and_dict(void *output,
+                                                 const struct lgtd_jsonrpc_node *schema,
+                                                 int schema_size,
+                                                 const jsmntok_t *tokens,
+                                                 int ntokens,
+                                                 const char *json)
+{
+    if (tokens[0].type != JSMN_OBJECT) {
+        return false;
+    }
+
+    for (int ti = 1; ti < ntokens;) {
+        // make sure it's a key:
+        if (tokens[ti].type != JSMN_STRING) {
+            return false;
+        }
+
+        for (int si = 0; si != schema_size; si++) {
+            int tokenlen = LGTD_JSONRPC_TOKEN_LEN(&tokens[ti]);
+            if (schema[si].keylen != tokenlen) {
+                continue;
+            }
+            int diff = memcmp(
+                schema[si].key, &json[tokens[ti].start], tokenlen
+            );
+            if (!diff) {
+                ti++; // keys looks good, move to the value
+                if (!schema[si].type_cmp(&tokens[ti], json)) {
+                    lgtd_debug(
+                        "jsonrpc client sent an invalid value for %s",
+                        schema[si].key
+                    );
+                    return false;
+                }
+                if (schema[si].value_offset != -1) {
+                    const jsmntok_t *seen = LGTD_JSONRPC_GET_JSMNTOK(
+                        output, schema[si].value_offset
+                    );
+                    if (seen) { // duplicate key
+                        lgtd_debug(
+                            "jsonrpc client sent duplicate parameter %s",
+                            schema[si].key
+                        );
+                        return false;
+                    }
+                    LGTD_JSONRPC_SET_JSMNTOK(
+                        output, schema[si].value_offset, &tokens[ti]
+                    );
+                }
+                break;
+            }
+        }
+
+        if (tokens[ti].type == JSMN_OBJECT || tokens[ti].type == JSMN_ARRAY) {
+            // if it's an object or an array we need to skip everything in it:
+            ti = lgtd_jsonrpc_consume_object_or_array(
+                tokens, ti, ntokens, json
+            );
+        } else {
+            ti++;
+        }
+    }
+
+    for (int si = 0; si != LGTD_ARRAY_SIZE(schema); si++) {
+        if (!schema[si].optional) {
+            const jsmntok_t *seen = LGTD_JSONRPC_GET_JSMNTOK(
+                output, schema[si].value_offset
+            );
+            if (!seen) {
+                lgtd_debug("missing jsonrpc parameter %s", schema[si].key);
+                return false;
+            }
+            lgtd_debug("got jsonrpc parameter %s", schema[si].key);
+        }
+    }
+
+    return true;
+}
+
+static void
+lgtd_jsonrpc_write_id(struct lgtd_client *client,
+                      const struct lgtd_jsonrpc_request *request,
+                      const char *json)
+{
+    int start, stop;
+    if (request->id->type == JSMN_STRING) { // get the quotes
+        start = request->id->start - 1;
+        stop = request->id->end + 1;
+    } else {
+        start = request->id->start;
+        stop = request->id->end;
+    }
+    bufferevent_write(client->io, &json[start], stop - start);
+}
+
+void
+lgtd_jsonrpc_send_error(struct lgtd_client *client,
+                        const struct lgtd_jsonrpc_request *request,
+                        const char *json,
+                        enum lgtd_jsonrpc_error_code code,
+                        const char *message)
+{
+    LGTD_CLIENT_WRITE_STRING(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
+    lgtd_jsonrpc_write_id(client, request, json);
+    LGTD_CLIENT_WRITE_STRING(client, ", \"error\": {\"code\": ");
+    char str_code[8] = { 0 };
+    snprintf(str_code, sizeof(str_code), "%d", code);
+    LGTD_CLIENT_WRITE_STRING(client, str_code);
+    LGTD_CLIENT_WRITE_STRING(client, ", \"message\": \"");
+    LGTD_CLIENT_WRITE_STRING(client, message);
+    LGTD_CLIENT_WRITE_STRING(client, "\"}}");
+}
+
+void
+lgtd_jsonrpc_send_response(struct lgtd_client *client,
+                           const struct lgtd_jsonrpc_request *request,
+                           const char *json,
+                           const char *result)
+{
+    LGTD_CLIENT_WRITE_STRING(client, "{\"jsonrpc\": \"2.0\", \"id\": ");
+    lgtd_jsonrpc_write_id(client, request, json);
+    LGTD_CLIENT_WRITE_STRING(client, ", \"result\": \"");
+    LGTD_CLIENT_WRITE_STRING(client, result);
+    LGTD_CLIENT_WRITE_STRING(client, "\"}");
+}
+
+static bool
+lgtd_jsonrpc_check_and_extract_request(struct lgtd_jsonrpc_request *request,
+                                       const jsmntok_t *tokens,
+                                       int ntokens,
+                                       const char *json)
+{
+    static const struct lgtd_jsonrpc_node request_schema[] = {
+        LGTD_JSONRPC_NODE(
+            "jsonrpc", -1, lgtd_jsonrpc_type_string, false
+        ),
+        LGTD_JSONRPC_NODE(
+            "method",
+            offsetof(struct lgtd_jsonrpc_request, method),
+            lgtd_jsonrpc_type_string,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "params",
+            offsetof(struct lgtd_jsonrpc_request, params),
+            lgtd_jsonrpc_type_object_or_array,
+            true
+        ),
+        LGTD_JSONRPC_NODE(
+            "id",
+            offsetof(struct lgtd_jsonrpc_request, id),
+            lgtd_jsonrpc_type_string_number_or_null,
+            true
+        )
+    };
+
+    bool ok = lgtd_jsonrpc_extract_values_from_schema_and_dict(
+        request,
+        request_schema,
+        LGTD_ARRAY_SIZE(request_schema),
+        tokens,
+        ntokens,
+        json
+    );
+    if (ok) {
+        if (request->params) {
+            while (request->params[request->params_ntokens++].start
+                   < request->params->end);
+        }
+        return true;
+    }
+
+    return false;
+}
+
+static char *
+lgtd_jsonrpc_dup_target(struct lgtd_client *client,
+                        const struct lgtd_jsonrpc_request *request,
+                        const char *json,
+                        const jsmntok_t *t)
+{
+    char *target = strndup(
+        &json[t->start], LGTD_JSONRPC_TOKEN_LEN(t)
+    );
+    if (!target) {
+        lgtd_jsonrpc_send_error(
+            client, request, json, LGTD_JSONRPC_INTERNAL_ERROR,
+            "Shit's on fire, yo"
+        );
+    }
+    return target;
+}
+
+static void
+lgtd_jsonrpc_check_and_call_set_light_from_hsbk(struct lgtd_client *client,
+                                                const struct lgtd_jsonrpc_request *request,
+                                                const char *json)
+{
+    struct lgtd_jsonrpc_set_brightness_args {
+        const jsmntok_t *target;
+        const jsmntok_t *h;
+        const jsmntok_t *s;
+        const jsmntok_t *b;
+        const jsmntok_t *k;
+    } params = { NULL, NULL, NULL, NULL, NULL };
+    static const struct lgtd_jsonrpc_node schema[] = {
+        LGTD_JSONRPC_NODE(
+            "target",
+            offsetof(struct lgtd_jsonrpc_set_brightness_args, target),
+            lgtd_jsonrpc_type_string,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "hue",
+            offsetof(struct lgtd_jsonrpc_set_brightness_args, h),
+            lgtd_jsonrpc_type_float_between_0_and_360,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "saturation",
+            offsetof(struct lgtd_jsonrpc_set_brightness_args, s),
+            lgtd_jsonrpc_type_float_between_0_and_1,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "brightness",
+            offsetof(struct lgtd_jsonrpc_set_brightness_args, b),
+            lgtd_jsonrpc_type_float_between_0_and_1,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "kelvin",
+            offsetof(struct lgtd_jsonrpc_set_brightness_args, k),
+            lgtd_jsonrpc_type_integer,
+            false
+        ),
+    };
+
+    bool ok = lgtd_jsonrpc_extract_values_from_schema_and_dict(
+        &params,
+        schema,
+        LGTD_ARRAY_SIZE(schema),
+        request->params,
+        request->params_ntokens,
+        json
+    );
+    if (!ok) {
+        goto error_invalid_params;
+    }
+
+    int h = lgtd_jsonrpc_float_range_to_uint16(
+        &json[params.h->start], LGTD_JSONRPC_TOKEN_LEN(params.h), 0, 360
+    );
+    int s = lgtd_jsonrpc_float_range_to_uint16(
+        &json[params.s->start], LGTD_JSONRPC_TOKEN_LEN(params.s), 0, 1
+    );
+    int b = lgtd_jsonrpc_float_range_to_uint16(
+        &json[params.b->start], LGTD_JSONRPC_TOKEN_LEN(params.b), 0, 1
+    );
+    errno = 0;
+    int k = strtol(&json[params.k->start], NULL, 10);
+    if (k < 2500 || k > 9000 || errno == ERANGE) {
+        goto error_invalid_params;
+    }
+
+    char *t = lgtd_jsonrpc_dup_target(client, request, json, params.target);
+    if (!t) {
+        return;
+    }
+
+    ok = lgtd_proto_set_light_from_hsbk(t, h, s, b, k, 0);
+    free(t);
+    if (ok) {
+        lgtd_jsonrpc_send_response(client, request, json, "true");
+        return;
+    }
+
+error_invalid_params:
+    lgtd_jsonrpc_send_error(
+        client, request, json, LGTD_JSONRPC_INVALID_PARAMS,
+        "Invalid parameters"
+    );
+}
+
+static char *
+lgtd_jsonrpc_extract_target_only(struct lgtd_client *client,
+                                 const struct lgtd_jsonrpc_request *request,
+                                 const char *json)
+{
+    const jsmntok_t *target;
+    static const struct lgtd_jsonrpc_node schema[] = {
+        LGTD_JSONRPC_NODE("target", 0, lgtd_jsonrpc_type_string, false)
+    };
+
+    bool ok = lgtd_jsonrpc_extract_values_from_schema_and_dict(
+        &target, schema, 1, request->params, request->params_ntokens, json
+    );
+    if (!ok) {
+        lgtd_jsonrpc_send_error(
+            client, request, json, LGTD_JSONRPC_INVALID_PARAMS,
+            "Invalid parameters"
+        );
+        return NULL;
+    }
+
+    return lgtd_jsonrpc_dup_target(client, request, json, target);
+}
+
+static void
+lgtd_jsonrpc_check_and_call_power_on(struct lgtd_client *client,
+                                     const struct lgtd_jsonrpc_request *request,
+                                     const char *json)
+{
+
+    char *target = lgtd_jsonrpc_extract_target_only(client, request, json);
+    if (!target) {
+        return;
+    }
+
+    bool ok = lgtd_proto_power_on(target);
+    free(target);
+    if (ok) {
+        lgtd_jsonrpc_send_response(client, request, json, "true");
+        return;
+    }
+
+    lgtd_jsonrpc_send_error(
+        client, request, json, LGTD_JSONRPC_INVALID_PARAMS,
+        "Invalid parameters"
+    );
+}
+
+static void
+lgtd_jsonrpc_check_and_call_power_off(struct lgtd_client *client,
+                                      const struct lgtd_jsonrpc_request *request,
+                                      const char *json)
+{
+
+    char *target = lgtd_jsonrpc_extract_target_only(client, request, json);
+    if (!target) {
+        return;
+    }
+
+    bool ok = lgtd_proto_power_off(target);
+    free(target);
+    if (ok) {
+        lgtd_jsonrpc_send_response(client, request, json, "true");
+        return;
+    }
+
+    lgtd_jsonrpc_send_error(
+        client, request, json, LGTD_JSONRPC_INVALID_PARAMS,
+        "Invalid parameters"
+    );
+}
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client,
+                              const char *json,
+                              int parsed)
+{
+    static const struct lgtd_jsonrpc_method methods[] = {
+        LGTD_JSONRPC_METHOD(
+            "power_on", 1, // t
+            lgtd_jsonrpc_check_and_call_power_on
+        ),
+        LGTD_JSONRPC_METHOD(
+            "power_off", 1, // t
+            lgtd_jsonrpc_check_and_call_power_off
+        ),
+        LGTD_JSONRPC_METHOD(
+            "set_light_from_hsbk", 5, // t, h, s, b, k
+            lgtd_jsonrpc_check_and_call_set_light_from_hsbk
+        ),
+    };
+
+    assert(client);
+    assert(parsed > 0);
+
+    const jsmntok_t *tokens = client->jsmn_tokens;
+
+    // TODO: batch requests
+
+    struct lgtd_jsonrpc_request request;
+    memset(&request, 0, sizeof(request));
+    bool ok = lgtd_jsonrpc_check_and_extract_request(
+        &request,
+        tokens,
+        parsed,
+        json
+    );
+    if (!ok) {
+        lgtd_jsonrpc_send_error(
+            client, &request, json, LGTD_JSONRPC_INVALID_REQUEST,
+            "Invalid request"
+        );
+        return;
+    }
+
+    assert(request.method);
+    assert(request.id);
+
+    for (int i = 0; i != LGTD_ARRAY_SIZE(methods); i++) {
+        int parsed_method_namelen = LGTD_JSONRPC_TOKEN_LEN(request.method);
+        if (parsed_method_namelen != methods[i].namelen) {
+            continue;
+        }
+        int diff = memcmp(
+            methods[i].name, &json[request.method->start], methods[i].namelen
+        );
+        if (!diff) {
+            int params_count = request.params->size;
+            if (params_count != methods[i].params_count) {
+                lgtd_jsonrpc_send_error(
+                    client, &request, json, LGTD_JSONRPC_INVALID_PARAMS,
+                    "Invalid number of parameters"
+                );
+                return;
+            }
+            methods[i].method(client, &request, json);
+            return;
+        }
+    }
+
+    lgtd_jsonrpc_send_error(
+        client, &request, json, LGTD_JSONRPC_METHOD_NOT_FOUND,
+        "Method not found"
+    );
+}
diff --git a/core/jsonrpc.h b/core/jsonrpc.h
new file mode 100644
--- /dev/null
+++ b/core/jsonrpc.h
@@ -0,0 +1,100 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+struct lgtd_jsonrpc_request {
+    const jsmntok_t *method;
+    const jsmntok_t *params;
+    int             params_ntokens;
+    const jsmntok_t *id;
+};
+
+struct lgtd_jsonrpc_node {
+    const char      *key;
+    int             keylen;
+    int             value_offset;
+    bool            (*type_cmp)(const jsmntok_t *, const char *);
+    bool            optional;
+};
+
+#define LGTD_JSONRPC_SET_JSMNTOK(object, value_offset, value) do {          \
+    *(const jsmntok_t **)(&(((char *)(object))[value_offset])) = (value);   \
+} while (0)
+
+#define LGTD_JSONRPC_GET_JSMNTOK(object, value_offset)          \
+    *(const jsmntok_t **)(&((char *)(object))[value_offset]);   \
+
+#define LGTD_JSONRPC_NODE(key_, value_offset_, fn_type_cmp, optional_)   { \
+    .key = (key_),                                                          \
+    .keylen = sizeof((key_)) - 1,                                           \
+    .value_offset = (value_offset_),                                        \
+    .type_cmp = (fn_type_cmp),                                              \
+    .optional = (optional_)                                                 \
+}
+
+#define LGTD_JSONRPC_TOKEN_LEN(t) ((t)->end - (t)->start)
+
+struct lgtd_jsonrpc_method {
+    const char  *name;
+    int         namelen;
+    int         params_count;
+    void        (*method)(struct lgtd_client *,
+                          const struct lgtd_jsonrpc_request *,
+                          const char *);
+};
+
+#define LGTD_JSONRPC_METHOD(name_, params_count_, method_) {    \
+    .name = (name_),                                            \
+    .namelen = sizeof((name_)) -1,                              \
+    .params_count = (params_count_),                            \
+    .method = (method_)                                         \
+}
+
+enum lgtd_jsonrpc_error_code {
+    LGTD_JSONRPC_SUCCESS = 0,
+    LGTD_JSONRPC_PARSE_ERROR = -32700,
+    LGTD_JSONRPC_INVALID_REQUEST = -32600,
+    LGTD_JSONRPC_METHOD_NOT_FOUND = -32601,
+    LGTD_JSONRPC_INVALID_PARAMS = -32602,
+    LGTD_JSONRPC_INTERNAL_ERROR = -32603,
+    LGTD_JSONRPC_SERVER_ERROR = -32000 // (to -32099)
+};
+
+void lgtd_jsonrpc_dispatch_request(struct lgtd_client *, const char *, int);
+
+void lgtd_jsonrpc_send_error(struct lgtd_client *,
+                             const struct lgtd_jsonrpc_request *,
+                             const char *,
+                             enum lgtd_jsonrpc_error_code,
+                             const char *);
+void lgtd_jsonrpc_send_response(struct lgtd_client *,
+                                const struct lgtd_jsonrpc_request *,
+                                const char *,
+                                const char *);
diff --git a/core/lightsd.c b/core/lightsd.c
--- a/core/lightsd.c
+++ b/core/lightsd.c
@@ -51,8 +51,11 @@
 #include "lifx/bulb.h"
 #include "lifx/gateway.h"
 #include "lifx/broadcast.h"
+#include "lifx/timer.h"
 #include "version.h"
-#include "lifx/timer.h"
+#include "jsmn.h"
+#include "client.h"
+#include "listen.h"
 #include "lightsd.h"
 
 struct lgtd_opts lgtd_opts = {
@@ -66,6 +69,8 @@
 void
 lgtd_cleanup(void)
 {
+    lgtd_listen_close_all();
+    lgtd_client_close_all();
     lgtd_lifx_timer_close();
     lgtd_lifx_broadcast_close();
     lgtd_lifx_gateway_close_all();
@@ -131,7 +136,8 @@
 lgtd_usage(const char *progname)
 {
     printf(
-        "Usage: %s [-v debug|info|warning|error] [-f] [-t] [-h] [-V]\n",
+        "Usage: %s -l addr:port [-l ...] [-f] [-t] [-h] [-V] "
+        "[-v debug|info|warning|error]\n",
         progname
     );
     exit(0);
@@ -140,7 +146,11 @@
 int
 main(int argc, char *argv[])
 {
+    lgtd_configure_libevent();
+    lgtd_configure_signal_handling();
+
     static const struct option long_opts[] = {
+        {"listen",          required_argument, NULL, 'l'},
         {"foreground",      no_argument,       NULL, 'f'},
         {"no-timestamps",   no_argument,       NULL, 't'},
         {"help",            no_argument,       NULL, 'h'},
@@ -148,12 +158,22 @@
         {"version",         no_argument,       NULL, 'V'},
         {NULL,              0,                 NULL, 0}
     };
-    const char short_opts[] = "fthv:V";
+    const char short_opts[] = "l:fthv:V";
 
     for (int rv = getopt_long(argc, argv, short_opts, long_opts, NULL);
          rv != -1;
          rv = getopt_long(argc, argv, short_opts, long_opts, NULL)) {
         switch (rv) {
+        case 'l':
+            (void)0;
+            char *sep = strrchr(optarg, ':');
+            if (!sep || !sep[1]) {
+                lgtd_usage(argv[0]);
+            }
+            *sep = '\0';
+            if (!lgtd_listen_open(optarg, sep + 1)) {
+                exit(1);
+            }
         case 'f':
             lgtd_opts.foreground = true;
             break;
@@ -187,12 +207,9 @@
     argc -= optind;
     argv += optind;
 
-    lgtd_configure_libevent();
-    lgtd_configure_signal_handling();
-
     lgtd_lifx_wire_load_packet_infos_map();
     if (!lgtd_lifx_timer_setup() || !lgtd_lifx_broadcast_setup()) {
-        lgtd_err(1, "can't setup lgtd_lifx");
+        lgtd_err(1, "can't setup lightsd");
     }
 
     lgtd_lifx_timer_start_discovery();
diff --git a/core/lightsd.h b/core/lightsd.h
--- a/core/lightsd.h
+++ b/core/lightsd.h
@@ -34,6 +34,7 @@
 #endif
 
 #define LGTD_ABS(v) ((v) >= 0 ? (v) : (v) * -1)
+#define LGTD_MIN(a, b) ((a) < (b) ? (a) : (b))
 #define LGTD_ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
 #define LGTD_MSECS_TO_TIMEVAL(v) { \
     .tv_sec = (v) / 1000,           \
@@ -50,9 +51,9 @@
 enum { LGTD_ERROR_MSG_BUFSIZE = 2048 };
 
 struct lgtd_opts {
-    bool                    foreground;
-    bool                    log_timestamps;
-    enum lgtd_verbosity    verbosity;
+    bool                foreground;
+    bool                log_timestamps;
+    enum lgtd_verbosity verbosity;
 };
 
 extern struct lgtd_opts lgtd_opts;
diff --git a/core/listen.c b/core/listen.c
new file mode 100644
--- /dev/null
+++ b/core/listen.c
@@ -0,0 +1,147 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <sys/queue.h>
+#include <assert.h>
+#include <err.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <event2/listener.h>
+#include <event2/util.h>
+
+#include "jsmn.h"
+#include "client.h"
+#include "listen.h"
+#include "lightsd.h"
+
+struct lgtd_listen_list lgtd_listeners =
+    SLIST_HEAD_INITIALIZER(&lgtd_listeners);
+
+static void
+lgtd_listen_accept_new_client(struct evconnlistener *evlistener,
+                              evutil_socket_t peer,
+                              struct sockaddr *peer_addr,
+                              int addrlen,
+                              void *ctx)
+{
+    (void)evlistener;
+    (void)addrlen;
+
+    struct lgtd_listen *listener = ctx;
+    struct lgtd_client *client = lgtd_client_open(
+        peer, (struct sockaddr_storage *)peer_addr
+    );
+    if (client) {
+        lgtd_info(
+            "accepted new client [%s]:%hu", client->ip_addr, client->port
+        );
+        return;
+    }
+    lgtd_warn(
+        "can't accept new client on %s:%s", listener->addr, listener->port
+    );
+}
+
+void
+lgtd_listen_close_all(void)
+{
+    while (!SLIST_EMPTY(&lgtd_listeners)) {
+        struct lgtd_listen *listener = SLIST_FIRST(&lgtd_listeners);
+        SLIST_REMOVE_HEAD(&lgtd_listeners, link);
+        evconnlistener_free(listener->evlistener);
+        free(listener);
+    }
+}
+
+bool
+lgtd_listen_open(const char *addr, const char *port)
+{
+    assert(addr);
+    assert(port);
+
+    struct evutil_addrinfo *res = NULL, hints = {
+        .ai_family = AF_UNSPEC,
+        .ai_socktype = SOCK_STREAM,
+        .ai_protocol = IPPROTO_TCP,
+        .ai_flags = EVUTIL_AI_NUMERICSERV|EVUTIL_AI_PASSIVE
+    };
+
+    int err = evutil_getaddrinfo(addr, port, &hints, &res);
+    if (err) {
+        lgtd_warnx(
+            "can't listen on %s:%s: %s", addr, port, evutil_gai_strerror(err)
+        );
+        return false;
+    }
+
+    struct lgtd_listen *listener;
+    struct evconnlistener *evlistener;
+    for (struct evutil_addrinfo *it = res; it; it = it->ai_next) {
+        evlistener = NULL;
+        listener = calloc(1, sizeof(*listener));
+        if (!listener) {
+            goto error;
+        }
+        evlistener = evconnlistener_new_bind(
+            lgtd_ev_base,
+            lgtd_listen_accept_new_client,
+            listener,
+            LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE,
+            -1,
+            it->ai_addr,
+            it->ai_addrlen
+        );
+        if (!evlistener) {
+            goto error;
+        }
+        listener->evlistener = evlistener;
+        listener->addr = addr;
+        listener->port = port;
+        SLIST_INSERT_HEAD(&lgtd_listeners, listener, link);
+        lgtd_info(
+            "listening on %s:%s (%s)",
+            addr, port, it->ai_family == AF_INET ? "IPv4" : "IPv6"
+        );
+    }
+
+    evutil_freeaddrinfo(res);
+
+    return true;
+
+error:
+    lgtd_warn("can't listen on %s:%s", addr, port);
+    if (evlistener) {
+        evconnlistener_free(evlistener);
+    }
+    free(listener);
+    evutil_freeaddrinfo(res);
+    return false;
+}
diff --git a/core/listen.h b/core/listen.h
new file mode 100644
--- /dev/null
+++ b/core/listen.h
@@ -0,0 +1,41 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+struct lgtd_listen {
+    SLIST_ENTRY(lgtd_listen)    link;
+    const char                  *addr;
+    const char                  *port;
+    struct evconnlistener       *evlistener;
+};
+SLIST_HEAD(lgtd_listen_list, lgtd_listen);
+
+bool lgtd_listen_open(const char *, const char *);
+void lgtd_listen_close_all(void);
diff --git a/core/log.c b/core/log.c
--- a/core/log.c
+++ b/core/log.c
@@ -83,11 +83,11 @@
         lgtd_isotime_now(timestr, sizeof(timestr));
         fprintf(
             stderr, "[%s] [%s] %s",
-            timestr, loglvl, showprogname ? "lightsd " : ""
+            timestr, loglvl, showprogname ? "lightsd: " : ""
         );
         return;
     }
-    fprintf(stderr, "[%s] %s", loglvl, showprogname ? "lightsd " : "");
+    fprintf(stderr, "[%s] %s", loglvl, showprogname ? "lightsd: " : "");
 }
 
 const char *
diff --git a/core/proto.c b/core/proto.c
new file mode 100644
--- /dev/null
+++ b/core/proto.c
@@ -0,0 +1,88 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <arpa/inet.h>
+#include <assert.h>
+#include <err.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include "lifx/wire_proto.h"
+#include "router.h"
+#include "lightsd.h"
+
+bool
+lgtd_proto_power_on(const char *target)
+{
+    assert(target);
+
+    struct lgtd_lifx_packet_power_state pkt = { .power = LGTD_LIFX_POWER_ON };
+    return lgtd_router_send(target, LGTD_LIFX_SET_POWER_STATE, &pkt);
+}
+
+bool
+lgtd_proto_power_off(const char *target)
+{
+    assert(target);
+
+    struct lgtd_lifx_packet_power_state pkt = { .power = LGTD_LIFX_POWER_OFF };
+    return lgtd_router_send(target, LGTD_LIFX_SET_POWER_STATE, &pkt);
+}
+
+bool
+lgtd_proto_set_light_from_hsbk(const char *target,
+                               int hue,
+                               int saturation,
+                               int brightness,
+                               int kelvin,
+                               int transition_msecs)
+{
+    assert(target);
+    assert(hue >= 0 && hue <= UINT16_MAX);
+    assert(saturation >= 0 && saturation <= UINT16_MAX);
+    assert(brightness >= 0 && brightness <= UINT16_MAX);
+    assert(kelvin >= 2500 && kelvin <= 9000);
+    assert(transition_msecs >= 0);
+
+    struct lgtd_lifx_packet_light_color pkt = {
+        .stream = 0,
+        .hue = hue,
+        .saturation = saturation,
+        .brightness = brightness,
+        .kelvin = kelvin,
+        .transition = transition_msecs
+    };
+    lgtd_lifx_wire_encode_light_color(&pkt);
+    return lgtd_router_send(target, LGTD_LIFX_SET_LIGHT_COLOR, &pkt);
+}
diff --git a/core/proto.h b/core/proto.h
new file mode 100644
--- /dev/null
+++ b/core/proto.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+bool lgtd_proto_set_light_from_hsbk(const char *, int, int, int, int, int);
+bool lgtd_proto_power_on(const char *);
+bool lgtd_proto_power_off(const char *);
diff --git a/core/router.c b/core/router.c
new file mode 100644
--- /dev/null
+++ b/core/router.c
@@ -0,0 +1,83 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <arpa/inet.h>
+#include <assert.h>
+#include <err.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <event2/util.h>
+
+#include "lifx/wire_proto.h"
+#include "time_monotonic.h"
+#include "lifx/bulb.h"
+#include "lifx/gateway.h"
+#include "lightsd.h"
+
+static void
+lgtd_router_broadcast(enum lgtd_lifx_packet_type pkt_type, void *pkt)
+{
+    struct lgtd_lifx_packet_header hdr;
+    union lgtd_lifx_target target = { .tags = 0 };
+
+    const struct lgtd_lifx_packet_infos *pkt_infos = NULL;
+    struct lgtd_lifx_gateway *gw;
+    LIST_FOREACH(gw, &lgtd_lifx_gateways, link) {
+        pkt_infos = lgtd_lifx_wire_setup_header(
+            &hdr, LGTD_LIFX_TARGET_ALL_DEVICES, target, gw->site, pkt_type
+        );
+        assert(pkt_infos);
+        lgtd_lifx_gateway_send_packet(gw, &hdr, pkt, pkt_infos->size);
+    }
+
+    if (pkt_infos) {
+        lgtd_debug("broadcasting %s", pkt_infos->name);
+    }
+}
+
+bool
+lgtd_router_send(const char *target,
+                 enum lgtd_lifx_packet_type pkt_type,
+                 void *pkt)
+{
+    assert(target);
+
+    if (!strcmp(target, "*")) {
+        lgtd_router_broadcast(pkt_type, pkt);
+        return true;
+    }
+
+    return false;
+}
diff --git a/core/router.h b/core/router.h
new file mode 100644
--- /dev/null
+++ b/core/router.h
@@ -0,0 +1,32 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+// 1. Redistributions of source code must retain the above copyright notice,
+//    this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright notice,
+//    this list of conditions and the following disclaimer in the documentation
+//    and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the copyright holder nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+bool lgtd_router_send(const char *, enum lgtd_lifx_packet_type, void *);
diff --git a/docs/conf.py b/docs/conf.py
new file mode 100644
--- /dev/null
+++ b/docs/conf.py
@@ -0,0 +1,259 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+#
+# lightsd documentation build configuration file, created by
+# sphinx-quickstart on Wed Jan 28 00:04:24 2015.
+#
+# This file is execfile()d with the current directory set to its
+# containing dir.
+#
+# Note that not all possible configuration values are present in this
+# autogenerated file.
+#
+# All configuration values have a default; values that are commented out
+# serve to show the default.
+
+import sys
+import os
+
+# If extensions (or modules to document with autodoc) are in another directory,
+# add these directories to sys.path here. If the directory is relative to the
+# documentation root, use os.path.abspath to make it absolute, like shown here.
+#sys.path.insert(0, os.path.abspath('.'))
+
+# -- General configuration ------------------------------------------------
+
+# If your documentation needs a minimal Sphinx version, state it here.
+#needs_sphinx = '1.0'
+
+# Add any Sphinx extension module names here, as strings. They can be
+# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
+# ones.
+extensions = []
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = ['_templates']
+
+# The suffix of source filenames.
+source_suffix = '.rst'
+
+# The encoding of source files.
+#source_encoding = 'utf-8-sig'
+
+# The master toctree document.
+master_doc = 'index'
+
+# General information about the project.
+project = 'lightsd'
+copyright = '2015, Louis Opter'
+
+# The version info for the project you're documenting, acts as replacement for
+# |version| and |release|, also used in various other places throughout the
+# built documents.
+#
+# The short X.Y version.
+version = '0.0.1'
+# The full version, including alpha/beta/rc tags.
+release = '0.0.1'
+
+# The language for content autogenerated by Sphinx. Refer to documentation
+# for a list of supported languages.
+#language = None
+
+# There are two options for replacing |today|: either, you set today to some
+# non-false value, then it is used:
+#today = ''
+# Else, today_fmt is used as the format for a strftime call.
+#today_fmt = '%B %d, %Y'
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+exclude_patterns = ['_build']
+
+# The reST default role (used for this markup: `text`) to use for all
+# documents.
+#default_role = None
+
+# If true, '()' will be appended to :func: etc. cross-reference text.
+#add_function_parentheses = True
+
+# If true, the current module name will be prepended to all description
+# unit titles (such as .. function::).
+#add_module_names = True
+
+# If true, sectionauthor and moduleauthor directives will be shown in the
+# output. They are ignored by default.
+#show_authors = False
+
+# The name of the Pygments (syntax highlighting) style to use.
+pygments_style = 'sphinx'
+
+# A list of ignored prefixes for module index sorting.
+#modindex_common_prefix = []
+
+# If true, keep warnings as "system message" paragraphs in the built documents.
+#keep_warnings = False
+
+
+# -- Options for HTML output ----------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+html_theme = 'nature'
+
+# Theme options are theme-specific and customize the look and feel of a theme
+# further.  For a list of options available for each theme, see the
+# documentation.
+#html_theme_options = {}
+
+# Add any paths that contain custom themes here, relative to this directory.
+#html_theme_path = []
+
+# The name for this set of Sphinx documents.  If None, it defaults to
+# "<project> v<release> documentation".
+#html_title = None
+
+# A shorter title for the navigation bar.  Default is the same as html_title.
+#html_short_title = None
+
+# The name of an image file (relative to this directory) to place at the top
+# of the sidebar.
+#html_logo = None
+
+# The name of an image file (within the static path) to use as favicon of the
+# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
+# pixels large.
+#html_favicon = None
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+html_static_path = ['_static']
+
+# Add any extra paths that contain custom files (such as robots.txt or
+# .htaccess) here, relative to this directory. These files are copied
+# directly to the root of the documentation.
+#html_extra_path = []
+
+# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
+# using the given strftime format.
+#html_last_updated_fmt = '%b %d, %Y'
+
+# If true, SmartyPants will be used to convert quotes and dashes to
+# typographically correct entities.
+#html_use_smartypants = True
+
+# Custom sidebar templates, maps document names to template names.
+#html_sidebars = {}
+
+# Additional templates that should be rendered to pages, maps page names to
+# template names.
+#html_additional_pages = {}
+
+# If false, no module index is generated.
+#html_domain_indices = True
+
+# If false, no index is generated.
+#html_use_index = True
+
+# If true, the index is split into individual pages for each letter.
+#html_split_index = False
+
+# If true, links to the reST sources are added to the pages.
+#html_show_sourcelink = True
+
+# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
+#html_show_sphinx = True
+
+# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
+#html_show_copyright = True
+
+# If true, an OpenSearch description file will be output, and all pages will
+# contain a <link> tag referring to it.  The value of this option must be the
+# base URL from which the finished HTML is served.
+#html_use_opensearch = ''
+
+# This is the file name suffix for HTML files (e.g. ".xhtml").
+#html_file_suffix = None
+
+# Output file base name for HTML help builder.
+htmlhelp_basename = 'lightsddoc'
+
+
+# -- Options for LaTeX output ---------------------------------------------
+
+latex_elements = {
+# The paper size ('letterpaper' or 'a4paper').
+#'papersize': 'letterpaper',
+
+# The font size ('10pt', '11pt' or '12pt').
+#'pointsize': '10pt',
+
+# Additional stuff for the LaTeX preamble.
+#'preamble': '',
+}
+
+# Grouping the document tree into LaTeX files. List of tuples
+# (source start file, target name, title,
+#  author, documentclass [howto, manual, or own class]).
+latex_documents = [
+  ('index', 'lightsd.tex', 'lightsd Documentation',
+   'Louis Opter', 'manual'),
+]
+
+# The name of an image file (relative to this directory) to place at the top of
+# the title page.
+#latex_logo = None
+
+# For "manual" documents, if this is true, then toplevel headings are parts,
+# not chapters.
+#latex_use_parts = False
+
+# If true, show page references after internal links.
+#latex_show_pagerefs = False
+
+# If true, show URL addresses after external links.
+#latex_show_urls = False
+
+# Documents to append as an appendix to all manuals.
+#latex_appendices = []
+
+# If false, no module index is generated.
+#latex_domain_indices = True
+
+
+# -- Options for manual page output ---------------------------------------
+
+# One entry per manual page. List of tuples
+# (source start file, name, description, authors, manual section).
+man_pages = [
+    ('index', 'lightsd', 'lightsd Documentation',
+     ['Louis Opter'], 1)
+]
+
+# If true, show URL addresses after external links.
+#man_show_urls = False
+
+
+# -- Options for Texinfo output -------------------------------------------
+
+# Grouping the document tree into Texinfo files. List of tuples
+# (source start file, target name, title, author,
+#  dir menu entry, description, category)
+texinfo_documents = [
+  ('index', 'lightsd', 'lightsd Documentation',
+   'Louis Opter', 'lightsd', 'One line description of project.',
+   'Miscellaneous'),
+]
+
+# Documents to append as an appendix to all manuals.
+#texinfo_appendices = []
+
+# If false, no module index is generated.
+#texinfo_domain_indices = True
+
+# How to display URL addresses: 'footnote', 'no', or 'inline'.
+#texinfo_show_urls = 'footnote'
+
+# If true, do not generate a @detailmenu in the "Top" node's menu.
+#texinfo_no_detailmenu = False
diff --git a/docs/index.rst b/docs/index.rst
new file mode 100644
--- /dev/null
+++ b/docs/index.rst
@@ -0,0 +1,16 @@
+The lights daemon documentation
+===============================
+
+Contents:
+
+.. toctree::
+   :maxdepth: 2
+
+   protocol
+
+Indices and tables
+==================
+
+* :ref:`genindex`
+* :ref:`modindex`
+* :ref:`search`
diff --git a/docs/internal-apis.rst b/docs/internal-apis.rst
new file mode 100644
--- /dev/null
+++ b/docs/internal-apis.rst
@@ -0,0 +1,15 @@
+lightds internal APIs
+=====================
+
+lgtd_proto_*
+------------
+
+.. function:: lgtd_proto_set_light_from_hsbk(target, h, s, b, k)
+
+   :param string target: targeted bulbs;
+   :param int h: Hue from 0 (0°) to 65535 (360°);
+   :param int s: Saturation from 0 to 65535;
+   :param int b: Brightness from 0 to 65535;
+   :param int k: Temperature in Kelvin (max 9000K).
+
+.. vim: set tw=80 spelllang=en spell:
diff --git a/docs/protocol.rst b/docs/protocol.rst
new file mode 100644
--- /dev/null
+++ b/docs/protocol.rst
@@ -0,0 +1,55 @@
+The lights daemon protocol
+==========================
+
+The lightsd protocol is implemented on top of `JSON-RPC 2.0`_.
+
+Targeting bulbs
+---------------
+
+Commands that manipulate bulbs will take a *target* argument to define on which
+bulb(s) the operation should apply:
+
++-----------------------------+--------------------------------------------+
+| ``\*``                      | targets all bulbs                          |
++-----------------------------+--------------------------------------------+
+| ``#TagName``                | targets bulbs tagged with *TagName*        |
++-----------------------------+--------------------------------------------+
+| ``124f31a5``                | directly target the bulb with the given id |
++-----------------------------+--------------------------------------------+
+| ``[\*, #Kitchen, 123456]``  | compose different targets together         |
++-----------------------------+--------------------------------------------+
+
+Available methods
+-----------------
+
+.. function:: get_light(target)
+
+   Foo.
+
+.. function:: power_off(target)
+
+   Power off the given bulb(s).
+
+.. function:: power_on(target)
+
+   Power on the given bulb(s).
+
+.. function:: set_light_from_hsbk(target, h, s, b, k)
+
+   :param float h: Hue from 0 to 360.
+   :param float s: Saturation from 0 to 1.
+   :param float b: Brightness from 0 to 1.
+   :param int k: Temperature (in Kelvin) from 2500 to 9000.
+
+.. function:: idle()
+
+   Bar.
+
+Notifications
+-------------
+
+lightsd will push a notification whenever the status of a bulb changes.
+
+.. _JSON-RPC 2.0: http://www.jsonrpc.org/specification
+
+.. vim: set tw=80 spelllang=en spell:
diff --git a/lifx/broadcast.c b/lifx/broadcast.c
--- a/lifx/broadcast.c
+++ b/lifx/broadcast.c
@@ -286,6 +286,12 @@
     if (err) {
         goto error;
     }
+    err = evutil_make_listen_socket_reuseable(
+        lgtd_lifx_broadcast_endpoint.socket
+    );
+    if (err) {
+        goto error;
+    }
 
     err = evutil_make_socket_nonblocking(lgtd_lifx_broadcast_endpoint.socket);
     if (err == -1) {
diff --git a/lifx/wire_proto.c b/lifx/wire_proto.c
--- a/lifx/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -84,14 +84,18 @@
     ((void (*)(struct lgtd_lifx_gateway *,              \
                const struct lgtd_lifx_packet_header *,  \
                const void *))(x))
-#define REQUEST_ONLY                                    \
+#define NO_PAYLOAD                                          \
+    .encode = lgtd_lifx_wire_null_packet_encoder_decoder
+#define RESPONSE_ONLY                                       \
+    .encode = lgtd_lifx_wire_null_packet_encoder_decoder
+#define REQUEST_ONLY                                        \
     .decode = lgtd_lifx_wire_null_packet_encoder_decoder,   \
-    .encode = lgtd_lifx_wire_null_packet_encoder_decoder,   \
     .handle = lgtd_lifx_wire_null_packet_handler
 
     static struct lgtd_lifx_packet_infos packet_table[] = {
         {
             REQUEST_ONLY,
+            NO_PAYLOAD,
             .name = "GET_PAN_GATEWAY",
             .type = LGTD_LIFX_GET_PAN_GATEWAY
         },
@@ -105,23 +109,38 @@
         },
         {
             REQUEST_ONLY,
+            NO_PAYLOAD,
             .name = "GET_LIGHT_STATUS",
             .type = LGTD_LIFX_GET_LIGHT_STATE
         },
         {
+            RESPONSE_ONLY,
             .name = "LIGHT_STATUS",
             .type = LGTD_LIFX_LIGHT_STATUS,
             .size = sizeof(struct lgtd_lifx_packet_light_status),
             .decode = DECODER(lgtd_lifx_wire_decode_light_status),
-            .encode = ENCODER(lgtd_lifx_wire_encode_light_status),
             .handle = HANDLER(lgtd_lifx_gateway_handle_light_status)
         },
         {
+            REQUEST_ONLY,
+            NO_PAYLOAD, // well it has a payload, but it's just 0 or 1...
+            .size = sizeof(struct lgtd_lifx_packet_power_state),
+            .name = "SET_POWER_STATE",
+            .type = LGTD_LIFX_SET_POWER_STATE,
+        },
+        {
             .name = "POWER_STATE",
             .type = LGTD_LIFX_POWER_STATE,
             .size = sizeof(struct lgtd_lifx_packet_power_state),
             .decode = DECODER(lgtd_lifx_wire_decode_power_state),
             .handle = HANDLER(lgtd_lifx_gateway_handle_power_state)
+        },
+        {
+            REQUEST_ONLY,
+            .name = "SET_LIGHT_COLOR",
+            .type = LGTD_LIFX_SET_LIGHT_COLOR,
+            .size = sizeof(struct lgtd_lifx_packet_light_color),
+            .encode = ENCODER(lgtd_lifx_wire_encode_light_color)
         }
     };
 
@@ -247,7 +266,13 @@
 }
 
 void
-lgtd_lifx_wire_encode_light_status(struct lgtd_lifx_packet_light_status *pkt)
+lgtd_lifx_wire_decode_power_state(struct lgtd_lifx_packet_power_state *pkt)
+{
+    assert(pkt);
+}
+
+void
+lgtd_lifx_wire_encode_light_color(struct lgtd_lifx_packet_light_color *pkt)
 {
     assert(pkt);
 
@@ -255,13 +280,5 @@
     pkt->saturation = htole16(pkt->saturation);
     pkt->brightness = htole16(pkt->brightness);
     pkt->kelvin = htole16(pkt->kelvin);
-    pkt->dim = htole16(pkt->dim);
-    pkt->power = htole16(pkt->power);
-    pkt->tags = htole64(pkt->tags);
+    pkt->transition = htole32(pkt->transition);
 }
-
-void
-lgtd_lifx_wire_decode_power_state(struct lgtd_lifx_packet_power_state *pkt)
-{
-    assert(pkt);
-}
diff --git a/lifx/wire_proto.h b/lifx/wire_proto.h
--- a/lifx/wire_proto.h
+++ b/lifx/wire_proto.h
@@ -124,7 +124,7 @@
     LGTD_LIFX_SET_FACTORY_TEST_MODE = 0x27,
     LGTD_LIFX_DISABLE_FACTORY_TEST_MODE = 0x28,
     LGTD_LIFX_GET_LIGHT_STATE = 0x65,
-    LGTD_LIFX_SET_LIGHT_COLOUR = 0x66,
+    LGTD_LIFX_SET_LIGHT_COLOR = 0x66,
     LGTD_LIFX_SET_WAVEFORM = 0x67,
     LGTD_LIFX_SET_DIM_ABSOLUTE = 0x68,
     LGTD_LIFX_SET_DIM_RELATIVE = 0x69,
@@ -176,6 +176,15 @@
     LGTD_LIFX_TARGET_ALL_DEVICES
 };
 
+struct lgtd_lifx_packet_light_color {
+    uint8_t     stream; // should be 0
+    uint16le_t  hue;
+    uint16le_t  saturation;
+    uint16le_t  brightness;
+    uint16le_t  kelvin;
+    uint32le_t  transition; // transition time to the color in msecs
+};
+
 #pragma pack(pop)
 
 struct lgtd_lifx_gateway;
@@ -195,7 +204,7 @@
 
 static inline int
 lgtd_lifx_packet_infos_cmp(struct lgtd_lifx_packet_infos *a,
-                       struct lgtd_lifx_packet_infos *b)
+                           struct lgtd_lifx_packet_infos *b)
 {
     return a->type - b->type;
 }
@@ -223,3 +232,5 @@
 void lgtd_lifx_wire_decode_light_status(struct lgtd_lifx_packet_light_status *);
 void lgtd_lifx_wire_encode_light_status(struct lgtd_lifx_packet_light_status *);
 void lgtd_lifx_wire_decode_power_state(struct lgtd_lifx_packet_power_state *);
+
+void lgtd_lifx_wire_encode_light_color(struct lgtd_lifx_packet_light_color *);
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/CMakeLists.txt
@@ -0,0 +1,1 @@
+ADD_ALL_SUBDIRECTORIES()
diff --git a/tests/core/CMakeLists.txt b/tests/core/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/core/CMakeLists.txt
@@ -0,0 +1,1 @@
+ADD_ALL_SUBDIRECTORIES()
diff --git a/tests/core/jsonrpc/CMakeLists.txt b/tests/core/jsonrpc/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/CMakeLists.txt
@@ -0,0 +1,20 @@
+INCLUDE_DIRECTORIES(
+    ${LIGHTSD_SOURCE_DIR}
+    ${LIGHTSD_SOURCE_DIR}/core/
+    ${LIGHTSD_BINARY_DIR}
+    ${LIGHTSD_BINARY_DIR}/core/
+)
+
+FUNCTION(ADD_JSONRPC_TEST TEST_SOURCE)
+    ADD_TEST_FROM_C_SOURCES(
+        ${TEST_SOURCE}
+        ${LIGHTSD_SOURCE_DIR}/core/jsmn.c
+        ${LIGHTSD_SOURCE_DIR}/core/log.c
+        ${CMAKE_CURRENT_SOURCE_DIR}/../utils.c
+    )
+ENDFUNCTION()
+
+FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
+FOREACH(TEST ${TESTS})
+    ADD_JSONRPC_TEST(${TEST})
+ENDFOREACH()
diff --git a/tests/core/jsonrpc/test_jsonrpc_extract_request_no_params.c b/tests/core/jsonrpc/test_jsonrpc_extract_request_no_params.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_extract_request_no_params.c
@@ -0,0 +1,48 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"hello\","
+        "\"id\": \"42\""
+    "}");
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
+    bool ok = lgtd_jsonrpc_check_and_extract_request(
+        &req, tokens, parsed, json
+    );
+
+    if (!ok) {
+        errx(1, "return value should be true");
+    }
+
+    if (!req.method) {
+        errx(1, "missing method");
+    }
+    if (req.method->end - req.method->start != sizeof("hello") - 1
+        || memcmp(&json[req.method->start], "hello", sizeof("hello") - 1)) {
+        errx(1, "wrong method name");
+    }
+
+    if (req.params) {
+        errx(1, "params should be null");
+    }
+
+    if (!req.id) {
+        errx(1, "missing id");
+    }
+    if (req.id->end - req.id->start != 2
+        || memcmp(&json[req.id->start], "42", 2)) {
+        errx(1, "wrong id");
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_extract_request_notification_no_params.c b/tests/core/jsonrpc/test_jsonrpc_extract_request_notification_no_params.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_extract_request_notification_no_params.c
@@ -0,0 +1,43 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"hello\""
+    "}");
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
+    bool ok = lgtd_jsonrpc_check_and_extract_request(
+        &req, tokens, parsed, json
+    );
+
+    if (!ok) {
+        errx(1, "return value should be true");
+    }
+
+    if (!req.method) {
+        errx(1, "missing method");
+    }
+    if (req.method->end - req.method->start != sizeof("hello") - 1
+        || memcmp(&json[req.method->start], "hello", sizeof("hello") - 1)) {
+        errx(1, "wrong method name");
+    }
+
+    if (req.params) {
+        errx(1, "params should be null");
+    }
+
+    if (req.id) {
+        errx(1, "id should be null");
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_extract_request_params_array.c b/tests/core/jsonrpc/test_jsonrpc_extract_request_params_array.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_extract_request_params_array.c
@@ -0,0 +1,54 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"hello\","
+        "\"params\": [\"on\", 12345, null, {\"lol\": \"wut\"}],"
+        "\"id\": \"42\""
+    "}");
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
+    bool ok = lgtd_jsonrpc_check_and_extract_request(
+        &req, tokens, parsed, json
+    );
+
+    if (!ok) {
+        errx(1, "return value should be true");
+    }
+
+    if (!req.method) {
+        errx(1, "missing method");
+    }
+    if (req.method->end - req.method->start != sizeof("hello") - 1
+        || memcmp(&json[req.method->start], "hello", sizeof("hello") - 1)) {
+        errx(1, "wrong method name");
+    }
+
+    if (!req.params) {
+        errx(1, "missing params");
+    }
+    const char params[] = "[\"on\", 12345, null, {\"lol\": \"wut\"}]"; 
+    if (req.params->end - req.params->start != sizeof(params) - 1
+        || memcmp(&json[req.params->start], params, req.params->size)) {
+        errx(1, "wrong params");
+    }
+
+    if (!req.id) {
+        errx(1, "missing id");
+    }
+    if (req.id->end - req.id->start != 2
+        || memcmp(&json[req.id->start], "42", 2)) {
+        errx(1, "wrong id");
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_extract_request_params_obj.c b/tests/core/jsonrpc/test_jsonrpc_extract_request_params_obj.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_extract_request_params_obj.c
@@ -0,0 +1,54 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"hello\","
+        "\"params\": {\"on\": true},"
+        "\"id\": \"42\""
+    "}");
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
+    bool ok = lgtd_jsonrpc_check_and_extract_request(
+        &req, tokens, parsed, json
+    );
+
+    if (!ok) {
+        errx(1, "return value should be true");
+    }
+
+    if (!req.method) {
+        errx(1, "missing method");
+    }
+    if (req.method->end - req.method->start != sizeof("hello") - 1
+        || memcmp(&json[req.method->start], "hello", sizeof("hello") - 1)) {
+        errx(1, "wrong method name");
+    }
+
+    if (!req.params) {
+        errx(1, "missing params");
+    }
+    const char params[] = "{\"on\": true}";
+    if (req.params->end - req.params->start != sizeof(params) - 1
+        || memcmp(&json[req.params->start], params, req.params->size)) {
+        errx(1, "wrong params");
+    }
+
+    if (!req.id) {
+        errx(1, "missing id");
+    }
+    if (req.id->end - req.id->start != 2
+        || memcmp(&json[req.id->start], "42", 2)) {
+        errx(1, "wrong id");
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_extract_request_valid_notification.c b/tests/core/jsonrpc/test_jsonrpc_extract_request_valid_notification.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_extract_request_valid_notification.c
@@ -0,0 +1,49 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"hello\","
+        "\"params\": {\"on\": true}"
+    "}");
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
+    bool ok = lgtd_jsonrpc_check_and_extract_request(
+        &req, tokens, parsed, json
+    );
+
+    if (!ok) {
+        errx(1, "return value should be true");
+    }
+
+    if (!req.method) {
+        errx(1, "missing method");
+    }
+    if (req.method->end - req.method->start != sizeof("hello") - 1
+        || memcmp(&json[req.method->start], "hello", sizeof("hello") - 1)) {
+        errx(1, "wrong method name");
+    }
+
+    if (!req.params) {
+        errx(1, "missing params");
+    }
+    const char params[] = "{\"on\": true}";
+    if (req.params->end - req.params->start != sizeof(params) - 1
+        || memcmp(&json[req.params->start], params, req.params->size)) {
+        errx(1, "wrong params");
+    }
+
+    if (req.id) {
+        errx(1, "id should be NULL");
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_send_error.c b/tests/core/jsonrpc/test_jsonrpc_send_error.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_send_error.c
@@ -0,0 +1,32 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+int
+main(void)
+{
+    struct lgtd_client client = { .io = NULL };
+    jsmntok_t token = { .start = 1, .end = 3, .type = JSMN_STRING };
+    struct lgtd_jsonrpc_request req = { .id = &token };
+
+    lgtd_jsonrpc_send_error(
+        &client, &req, "\"42\"",LGTD_JSONRPC_INVALID_REQUEST, "Invalid Request"
+    );
+
+    const char *expected = (
+        "{"
+        "\"jsonrpc\": \"2.0\", "
+        "\"id\": \"42\", "
+        "\"error\": {\"code\": -32600, \"message\": \"Invalid Request\"}"
+        "}"
+    );
+
+    int diff = memcmp(client_write_buf, expected, strlen(expected));
+    if (diff) {
+        printf("expected: %s\n", expected);
+        printf("received: %s\n", client_write_buf);
+        return 1;
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_invalid.c b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_invalid.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_invalid.c
@@ -0,0 +1,26 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+static void
+test_float(const char *json)
+{
+    jsmntok_t tokens[8];
+    parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
+    if (lgtd_jsonrpc_type_float_between_0_and_1(tokens, json)) {
+        errx(1, "%s was considered as a valid float >= 0 and <= 1", json);
+    }
+}
+
+int
+main(void)
+{
+    test_float("1.1234");
+    test_float("-0.1234");
+    test_float("1.00000001");
+    test_float("2.0000");
+    test_float("10");
+    test_float("0.0.1");
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_valid.c b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_valid.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_valid.c
@@ -0,0 +1,25 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+static void
+test_float(const char *json)
+{
+    jsmntok_t tokens[8];
+    parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
+    if (!lgtd_jsonrpc_type_float_between_0_and_1(tokens, json)) {
+        errx(1, "%s wasn't considered as a valid float >= 0 and <= 1", json);
+    }
+}
+
+int
+main(void)
+{
+    test_float("0.1234");
+    test_float("1.0000000");
+    test_float("0.9999");
+    test_float("0.01");
+    test_float("000.01");
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_invalid.c b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_invalid.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_invalid.c
@@ -0,0 +1,26 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+static void
+test_float(const char *json)
+{
+    jsmntok_t tokens[8];
+    parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
+    if (lgtd_jsonrpc_type_float_between_0_and_360(tokens, json)) {
+        errx(1, "%s was considered as a valid float >= 0 and <= 360", json);
+    }
+}
+
+int
+main(void)
+{
+    test_float("-1.1234");
+    test_float("-0.1234");
+    test_float("0.1.234");
+    test_float("0.1a234");
+    test_float("360a");
+    test_float("360.1");
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_valid.c b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_valid.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_valid.c
@@ -0,0 +1,29 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+static void
+test_float(const char *json)
+{
+    jsmntok_t tokens[8];
+    parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
+    if (!lgtd_jsonrpc_type_float_between_0_and_360(tokens, json)) {
+        errx(1, "%s wasn't considered as a valid float >= 0 and <= 360", json);
+    }
+}
+
+int
+main(void)
+{
+    test_float("1.1234");
+    test_float("1.00000001");
+    test_float("2.0000");
+    test_float("10");
+    test_float("0.1");
+    test_float("0");
+    test_float("231.");
+    test_float("359.1");
+    test_float("360");
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_integer.c b/tests/core/jsonrpc/test_jsonrpc_type_integer.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_type_integer.c
@@ -0,0 +1,20 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+int
+main(void)
+{
+    const char *json = "1234";
+    jsmntok_t tokens[8];
+
+    parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json));
+
+    bool ok = lgtd_jsonrpc_type_integer(tokens, json);
+
+    if (!ok) {
+        errx(1, "%s wasn't considered as a valid integer", json);
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_integer_invalid_characters.c b/tests/core/jsonrpc/test_jsonrpc_type_integer_invalid_characters.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_type_integer_invalid_characters.c
@@ -0,0 +1,20 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+int
+main(void)
+{
+    const char *json = "-1a";
+    jsmntok_t tokens[8];
+
+    parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json));
+
+    bool ok = lgtd_jsonrpc_type_integer(tokens, json);
+
+    if (ok) {
+        errx(1, "%s wasn't considered invalid", json);
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_integer_too_big.c b/tests/core/jsonrpc/test_jsonrpc_type_integer_too_big.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_type_integer_too_big.c
@@ -0,0 +1,20 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+int
+main(void)
+{
+    const char *json = "9999999999";
+    jsmntok_t tokens[8];
+
+    parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json));
+
+    bool ok = lgtd_jsonrpc_type_integer(tokens, json);
+
+    if (ok) {
+        errx(1, "%s wasn't considered invalid", json);
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_integer_too_small.c b/tests/core/jsonrpc/test_jsonrpc_type_integer_too_small.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_type_integer_too_small.c
@@ -0,0 +1,20 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+int
+main(void)
+{
+    const char *json = "-9999999999";
+    jsmntok_t tokens[8];
+
+    parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json));
+
+    bool ok = lgtd_jsonrpc_type_integer(tokens, json);
+
+    if (ok) {
+        errx(1, "%s wasn't considered invalid", json);
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_utils.h b/tests/core/jsonrpc/test_jsonrpc_utils.h
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_utils.h
@@ -0,0 +1,73 @@
+#pragma once
+
+#define TEST_REQUEST_INITIALIZER { NULL, NULL, 0, NULL }
+
+static inline int
+parse_json(jsmntok_t *tokens, size_t capacity, const char *json , size_t len)
+{
+    jsmn_parser ctx;
+    jsmn_init(&ctx);
+    return jsmn_parse(&ctx, json, len, tokens, capacity);
+}
+
+static char client_write_buf[4096] = { 0 };
+static int client_write_buf_idx = 0;
+
+int
+bufferevent_write(struct bufferevent *bev, const void *data, size_t nbytes)
+{
+    (void)bev;
+    int to_write = LGTD_MIN(nbytes, sizeof(client_write_buf));
+    memcpy(&client_write_buf[client_write_buf_idx], data, to_write);
+    client_write_buf_idx += to_write;
+    return 0;
+}
+
+#ifndef LGTD_TESTING_SET_LIGHT_FROM_HSBK
+bool
+lgtd_proto_set_light_from_hsbk(const char *target,
+                               int hue,
+                               int saturation,
+                               int brightness,
+                               int kelvin,
+                               int transition_msecs)
+{
+    if (!target) {
+        errx(1, "target is missing");
+    }
+    if (hue < 0 || hue > UINT16_MAX) {
+        errx(1, "Invalid hue: %d", hue);
+    }
+    if (saturation < 0 || saturation > UINT16_MAX) {
+        errx(1, "Invalid saturation: %d", saturation);
+    }
+    if (brightness < 0 || brightness > UINT16_MAX) {
+        errx(1, "Invalid brightness: %d", brightness);
+    }
+    if (kelvin < 2500 || kelvin > 9000) {
+        errx(1, "Invalid temperature: %d", kelvin);
+    }
+    if (transition_msecs < 0) {
+        errx(1, "Invalid transition duration: %d", transition_msecs);
+    }
+    return true;
+}
+#endif
+
+bool
+lgtd_proto_power_on(const char *target)
+{
+    if (!target) {
+        errx(1, "target is missing");
+    }
+    return true;
+}
+
+bool
+lgtd_proto_power_off(const char *target)
+{
+    if (!target) {
+        errx(1, "target is missing");
+    }
+    return true;
+}
diff --git a/tests/core/utils.c b/tests/core/utils.c
new file mode 100644
--- /dev/null
+++ b/tests/core/utils.c
@@ -0,0 +1,18 @@
+#include <stdbool.h>
+
+#include <event2/event.h>
+
+#include "lightsd.h"
+
+struct lgtd_opts lgtd_opts = {
+    .foreground = false,
+    .log_timestamps = false,
+    .verbosity = LGTD_DEBUG
+}; 
+
+struct event_base *lgtd_ev_base = NULL;
+
+void
+lgtd_cleanup(void)
+{
+}
diff --git a/tests/lightsc b/tests/lightsc
new file mode 100755
--- /dev/null
+++ b/tests/lightsc
@@ -0,0 +1,36 @@
+#!/usr/bin/env python
+
+import json
+import socket
+import time
+
+
+def set_light_from_hsbk(socket, h, s, b, k):
+    # Example echo method
+    payload = {
+        "method": "set_light_from_hsbk",
+        "params": {
+            "target": "*",
+            "hue": h,
+            "saturation": s,
+            "brightness": b,
+            "kelvin": k
+        },
+        "jsonrpc": "2.0",
+        "id": 0,
+    }
+    socket.send(json.dumps(payload).encode("utf-8"))
+    response = socket.recv(2048)
+    response = json.loads(response)
+    print(response)
+
+if __name__ == "__main__":
+    s = socket.create_connection(("localhost", 1234))
+    h = 0
+    try:
+        while True:
+            h = (h + 5) % 360
+            set_light_from_hsbk(s, h, 0.7, 0.1, 6000)
+            time.sleep(0.05)
+    finally:
+        s.close()
