# HG changeset patch
# Parent  f53fd0ef32c475da14c00890cf0b2d0f65bc1e9a
Correctly support optional arguments in the JSON-RPC API

Passing too many arguments as an array also properly fails now.

While we are at it, put the correct argument names in the documentation
so that it works for people passing argument by name.

diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -459,7 +459,7 @@
         }
     }
 
-    return si == schema_size;
+    return !objsize || (si < schema_size && schema[si].optional);
 }
 
 static bool
@@ -470,6 +470,17 @@
                                                         int ntokens,
                                                         const char *json)
 {
+    if (!ntokens) {
+        // "params" were omitted, make sure no args were required or that they
+        // are all optional:
+        while (schema_size--) {
+            if (!schema[schema_size].optional) {
+                return false;
+            }
+        }
+        return true;
+    }
+
     switch (tokens[0].type) {
     case JSMN_OBJECT:
         return lgtd_jsonrpc_extract_values_from_schema_and_dict(
@@ -716,7 +727,7 @@
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, t),
             -1,
             lgtd_jsonrpc_type_integer,
-            false
+            true
         ),
     };
 
@@ -746,9 +757,12 @@
     if (k < 2500 || k > 9000 || errno == ERANGE) {
         goto error_invalid_params;
     }
-    int t = strtol(&client->json[params.t->start], NULL, 10);
-    if (t < 0 || errno == ERANGE) {
-        goto error_invalid_params;
+    int t = 0;
+    if (params.t) {
+        t = strtol(&client->json[params.t->start], NULL, 10);
+        if (t < 0 || errno == ERANGE) {
+            goto error_invalid_params;
+        }
     }
 
     struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
@@ -854,7 +868,7 @@
             offsetof(struct lgtd_jsonrpc_set_waveform_args, transient),
             -1,
             lgtd_jsonrpc_type_bool,
-            false
+            true
         ),
     };
 
@@ -906,7 +920,8 @@
         0, 1
     );
     skew_ratio -= UINT16_MAX / 2;
-    bool transient = client->json[params.transient->start] == 't';
+    bool transient = params.transient ?
+        client->json[params.transient->start] == 't' : true;
 
     struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
     ok = lgtd_jsonrpc_build_target_list(
@@ -1102,43 +1117,24 @@
                           int *batch_sent)
 {
     static const struct lgtd_jsonrpc_method methods[] = {
+        LGTD_JSONRPC_METHOD("power_on", lgtd_jsonrpc_check_and_call_power_on),
+        LGTD_JSONRPC_METHOD("power_off", lgtd_jsonrpc_check_and_call_power_off),
         LGTD_JSONRPC_METHOD(
-            "power_on", 1, // t
-            lgtd_jsonrpc_check_and_call_power_on
+            "power_toggle", lgtd_jsonrpc_check_and_call_power_toggle
         ),
         LGTD_JSONRPC_METHOD(
-            "power_off", 1, // t
-            lgtd_jsonrpc_check_and_call_power_off
-        ),
-        LGTD_JSONRPC_METHOD(
-            "power_toggle", 1, // t
-            lgtd_jsonrpc_check_and_call_power_toggle
-        ),
-        LGTD_JSONRPC_METHOD(
-            "set_light_from_hsbk", 6, // t, h, s, b, k, t
+            "set_light_from_hsbk",
             lgtd_jsonrpc_check_and_call_set_light_from_hsbk
         ),
         LGTD_JSONRPC_METHOD(
-            // t, waveform, h, s, b, k, period, cycles, skew_ratio, transient
-            "set_waveform", 10,
-            lgtd_jsonrpc_check_and_call_set_waveform
+            "set_waveform", lgtd_jsonrpc_check_and_call_set_waveform
         ),
         LGTD_JSONRPC_METHOD(
-            "get_light_state", 1, // t
-            lgtd_jsonrpc_check_and_call_get_light_state
+            "get_light_state", lgtd_jsonrpc_check_and_call_get_light_state
         ),
-        LGTD_JSONRPC_METHOD(
-            "tag", 2, // t, tag
-            lgtd_jsonrpc_check_and_call_tag
-        ),
-        LGTD_JSONRPC_METHOD(
-            "untag", 2, // t, tag
-            lgtd_jsonrpc_check_and_call_untag
-        ),
-        LGTD_JSONRPC_METHOD(
-            "set_label", 2, // t, label
-            lgtd_jsonrpc_check_and_call_set_label
-        )
+        LGTD_JSONRPC_METHOD("tag", lgtd_jsonrpc_check_and_call_tag),
+        LGTD_JSONRPC_METHOD("untag", lgtd_jsonrpc_check_and_call_untag),
+        LGTD_JSONRPC_METHOD("set_label", lgtd_jsonrpc_check_and_call_set_label)
     };
 
     if (batch_sent) {
@@ -1172,15 +1168,11 @@
             continue;
         }
         int diff = memcmp(
-            methods[i].name, &client->json[request.method->start], methods[i].namelen
+            methods[i].name,
+            &client->json[request.method->start],
+            methods[i].namelen
         );
         if (!diff) {
-            int params_count = request.params ? request.params->size : 0;
-            if (params_count != methods[i].params_count) {
-                error_code = LGTD_JSONRPC_INVALID_PARAMS;
-                error_msg = "Invalid number of parameters";
-                goto error;
-            }
             struct bufferevent *client_io = NULL; // keep compilers happy...
             if (!request.id) {
                 // Ugly hack to behave correctly on jsonrpc notifications, it's
diff --git a/core/jsonrpc.h b/core/jsonrpc.h
--- a/core/jsonrpc.h
+++ b/core/jsonrpc.h
@@ -63,15 +63,13 @@
 struct lgtd_jsonrpc_method {
     const char  *name;
     int         namelen;
-    int         params_count;
     void        (*method)(struct lgtd_client *);
 };
 
-#define LGTD_JSONRPC_METHOD(name_, params_count_, method_) {    \
-    .name = (name_),                                            \
-    .namelen = sizeof((name_)) -1,                              \
-    .params_count = (params_count_),                            \
-    .method = (method_)                                         \
+#define LGTD_JSONRPC_METHOD(name_, method_) {   \
+    .name = (name_),                            \
+    .namelen = sizeof((name_)) -1,              \
+    .method = (method_)                         \
 }
 
 enum lgtd_jsonrpc_error_code {
diff --git a/docs/protocol.rst b/docs/protocol.rst
--- a/docs/protocol.rst
+++ b/docs/protocol.rst
@@ -32,9 +32,7 @@
 +-----------------------------+------------------------------------------------+
 
 The mac address (id) of each bulb can be found with get_light_state_ under the
-``_lifx`` map, e.g:
-
-::
+``_lifx`` map, e.g::
 
    "_lifx": {
        "addr": "d0:73:d5:02:e5:30",
@@ -65,28 +63,30 @@
 
    Power on (if they are off) or power off (if they are on) the given bulb(s).
 
-.. function:: set_light_from_hsbk(target, h, s, b, k, t)
+.. function:: set_light_from_hsbk(target, hue, saturation, brightness, kelvin[, transition])
 
-   :param float h: Hue from 0 to 360.
-   :param float s: Saturation from 0 to 1.
-   :param float b: Brightness from 0 to 1.
-   :param int k: Temperature in Kelvin from 2500 to 9000.
-   :param int t: Transition duration to this color in ms.
+   :param float hue: From 0 to 360.
+   :param float saturation: From 0 to 1.
+   :param float brightness: From 0 to 1.
+   :param int kelvin: Temperature in Kelvin from 2500 to 9000.
+   :param int transition: Optional time in ms it will take for the bulb to turn
+                          to this color.
 
-.. function:: set_waveform(target, waveform, h, s, b, k, period, cycles, skew_ratio, transient)
+.. function:: set_waveform(target, waveform, hue, saturation, brightness, kelvin, period, cycles, skew_ratio[, transient])
 
    :param string waveform: One of ``SAW``, ``SINE``, ``HALF_SINE``,
                            ``TRIANGLE``, ``SQUARE``.
-   :param float h: Hue from 0 to 360.
-   :param float s: Saturation from 0 to 1.
-   :param float b: Brightness from 0 to 1.
-   :param int k: Temperature in Kelvin from 2500 to 9000.
-   :param int period: milliseconds per cycle.
-   :param int cycles: number of cycles.
-   :param float skew_ratio: from 0 to 1.
-   :param bool transient: if true the target will keep the color it has at the
+   :param float hue: From 0 to 360.
+   :param float saturation: From 0 to 1.
+   :param float brightness: From 0 to 1.
+   :param int kelvin: Temperature in Kelvin from 2500 to 9000.
+   :param int period: Milliseconds per cycle.
+   :param int cycles: Number of cycles.
+   :param float skew_ratio: From 0 to 1, see table below.
+   :param bool transient: If true the target will keep the color it has at the
                           end of the waveform, otherwise it will revert back to
-                          its original state.
+                          its original state. This argument is optional and
+                          defaults to true.
 
    The meaning of the ``skew_ratio`` argument depends on the type of waveform:
 
@@ -129,9 +129,7 @@
    Tag (group) the given target bulb(s) with the given label (group name), then
    label can be used as a target by prefixing it with ``#``.
 
-   To add a device to an existing "group" simply do:
-
-   ::
+   To add a device to an existing "group" simply do::
 
       tag(["#myexistingtag", "bulbtoadd"], "myexistingtag")
 
@@ -143,9 +141,7 @@
 .. function:: untag(target, label)
 
    Remove the given tag from the given target bulb(s). To completely delete a
-   tag (group), simple do:
-
-   ::
+   tag (group), simply do::
 
       untag("#myexistingtag", "myexistingtag")
 
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk.c
@@ -8,7 +8,7 @@
 
 #include "test_jsonrpc_utils.h"
 
-static bool set_light_called = false;
+static int set_light_call_count = false;
 
 void
 lgtd_proto_set_light_from_hsbk(struct lgtd_client *client,
@@ -55,19 +55,38 @@
             1, "Invalid temperature: %d, expected: 4200", kelvin
         );
     }
-    if (transition_msecs != 60) {
-        errx(
-            1, "Invalid transition duration: %d, expected: 60", transition_msecs
-        );
+    switch (set_light_call_count++) {
+    case 0:
+        if (transition_msecs != 600) {
+            errx(
+                1, "Invalid transition duration: %d, expected: 600",
+                transition_msecs
+            );
+        }
+        break;
+    case 1:
+        if (transition_msecs != 0) {
+            errx(
+                1, "Invalid transition duration: %d, expected: 0",
+                transition_msecs
+            );
+        }
+        break;
+    default:
+        errx(1, "set_light_from_hsbk called too many times");
     }
-    set_light_called = true;
 }
 
 int
 main(void)
 {
     jsmntok_t tokens[32];
-    const char json[] = ("{"
+    int parsed;
+    bool ok;
+    struct lgtd_jsonrpc_request req;
+    struct lgtd_client client = { .io = NULL, .current_request = &req };
+
+    const char *json = ("{"
         "\"jsonrpc\": \"2.0\","
         "\"method\": \"set_light_from_hsbk\","
         "\"params\": {"
@@ -76,27 +95,44 @@
             "\"saturation\": 0.234, "
             "\"brightness\": 1.0, "
             "\"kelvin\": 4200,"
-            "\"transition\": 60"
+            "\"transition\": 600"
         "},"
         "\"id\": \"42\""
     "}");
-    int parsed = parse_json(
-        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
-    );
-
-    bool ok;
-    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
-    struct lgtd_client client = {
-        .io = NULL, .current_request = &req, .json = json
-    };
+    client.json = json;
+    parsed = parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
+    memset(&req, 0, sizeof(req));
     ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
     if (!ok) {
         errx(1, "can't parse request");
     }
+    lgtd_jsonrpc_check_and_call_set_light_from_hsbk(&client);
+    if (set_light_call_count != 1) {
+        errx(1, "lgtd_proto_set_light_from_hsbk wasn't called");
+    }
 
+    // optional transition argument
+    json = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_light_from_hsbk\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 324.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": 4200"
+        "},"
+        "\"id\": \"42\""
+    "}");
+    client.json = json;
+    parsed = parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
+    memset(&req, 0, sizeof(req));
+    ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
+    if (!ok) {
+        errx(1, "can't parse request");
+    }
     lgtd_jsonrpc_check_and_call_set_light_from_hsbk(&client);
-
-    if (!set_light_called) {
+    if (set_light_call_count != 2) {
         errx(1, "lgtd_proto_set_light_from_hsbk wasn't called");
     }
 
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_from_array.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_from_array.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_from_array.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_from_array.c
@@ -8,7 +8,7 @@
 
 #include "test_jsonrpc_utils.h"
 
-static bool set_light_called = false;
+static int set_light_call_count = 0;
 
 void
 lgtd_proto_set_light_from_hsbk(struct lgtd_client *client,
@@ -55,43 +55,73 @@
             1, "Invalid temperature: %d, expected: 4200", kelvin
         );
     }
-    if (transition_msecs != 0) {
-        errx(
-            1, "Invalid transition duration: %d, expected: 0", transition_msecs
-        );
+    switch (set_light_call_count++) {
+    case 0:
+        if (transition_msecs != 600) {
+            errx(
+                1, "Invalid transition duration: %d, expected: 600",
+                transition_msecs
+            );
+        }
+        break;
+    case 1:
+        if (transition_msecs != 0) {
+            errx(
+                1, "Invalid transition duration: %d, expected: 0",
+                transition_msecs
+            );
+        }
+        break;
+    default:
+        errx(1, "set_light_from_hsbk called too many times");
     }
-    set_light_called = true;
 }
 
 int
 main(void)
 {
     jsmntok_t tokens[32];
-    const char json[] = ("{"
+    int parsed;
+    bool ok;
+    struct lgtd_jsonrpc_request req;
+    struct lgtd_client client = {
+        .io = NULL, .current_request = &req,
+    };
+
+    const char *json = ("{"
         "\"jsonrpc\": \"2.0\","
         "\"method\": \"set_light_from_hsbk\","
-        "\"params\": ["
-            "\"*\", 324.2341514, 0.234, 1.0, 4200, 0"
-        "],"
+        "\"params\": [\"*\", 324.2341514, 0.234, 1.0, 4200, 600],"
         "\"id\": \"42\""
     "}");
-    int parsed = parse_json(
-        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
-    );
-
-    bool ok;
-    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
-    struct lgtd_client client = {
-        .io = NULL, .current_request = &req, .json = json
-    };
+    client.json = json;
+    parsed = parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
+    memset(&req, 0, sizeof(req));
     ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
     if (!ok) {
         errx(1, "can't parse request");
     }
+    lgtd_jsonrpc_check_and_call_set_light_from_hsbk(&client);
+    if (set_light_call_count != 1) {
+        errx(1, "lgtd_proto_set_light_from_hsbk wasn't called");
+    }
 
+    // optional transition
+    json = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_light_from_hsbk\","
+        "\"params\": [\"*\", 324.2341514, 0.234, 1.0, 4200],"
+        "\"id\": \"42\""
+    "}");
+    client.json = json;
+    parsed = parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
+    memset(&req, 0, sizeof(req));
+    ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
+    if (!ok) {
+        errx(1, "can't parse request");
+    }
     lgtd_jsonrpc_check_and_call_set_light_from_hsbk(&client);
-
-    if (!set_light_called) {
+    if (set_light_call_count != 2) {
         errx(1, "lgtd_proto_set_light_from_hsbk wasn't called");
     }
 
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_invalid_params.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_invalid_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_invalid_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_invalid_params.c
@@ -133,5 +133,29 @@
         "},"
         "\"id\": \"42\""
     "}");
+
+    // invalid temperature:
+    test_request("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_light_from_hsbk\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 324.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": -4200,"
+            "\"transition\": 42"
+        "},"
+        "\"id\": \"42\""
+    "}");
+
+    // too many params
+    test_request("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_light_from_hsbk\","
+        "\"params\": [\"*\", 324.2341514, 0.234, 1.0, 4200, 600, \"extraarg\"],"
+        "\"id\": \"42\""
+    "}");
+
     return 0;
 }
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c
@@ -23,7 +23,7 @@
     return LGTD_LIFX_WAVEFORM_SAW;
 }
 
-static bool set_waveform_called = false;
+static int set_waveform_call_count = 0;
 
 void
 lgtd_proto_set_waveform(struct lgtd_client *client,
@@ -79,23 +79,38 @@
     if (skew_ratio != 0) {
         errx(1, "Invalid skew_ratio: %d, expected: 0", skew_ratio);
     }
-    if (!transient) {
-        errx(1, "transient is false instead of true");
-    }
     if (waveform != LGTD_LIFX_WAVEFORM_SAW) {
         errx(
             1, "Invalid waveform %d: expected: %d",
             waveform, LGTD_LIFX_WAVEFORM_SAW
         );
     }
-    set_waveform_called = true;
+    switch (set_waveform_call_count++) {
+    case 0:
+        if (transient) {
+            errx(1, "Invalid transient: true (expected false)");
+        }
+        break;
+    case 1:
+        if (!transient) {
+            errx(1, "Invalid transient: false (expected true)");
+        }
+        break;
+    default:
+        errx(1, "set_waveform called too many times");
+    }
 }
 
 int
 main(void)
 {
     jsmntok_t tokens[32];
-    const char json[] = ("{"
+    int parsed;
+    bool ok;
+    struct lgtd_jsonrpc_request req;
+    struct lgtd_client client = { .io = NULL, .current_request = &req };
+
+    const char *json = ("{"
         "\"jsonrpc\": \"2.0\","
         "\"method\": \"set_waveform\","
         "\"params\": {"
@@ -107,28 +122,49 @@
             "\"cycles\": 10,"
             "\"period\": 1000,"
             "\"skew_ratio\": 0.5,"
-            "\"transient\": true,"
+            "\"transient\": false,"
             "\"waveform\": \"SAW\""
         "},"
         "\"id\": \"42\""
     "}");
-    int parsed = parse_json(
-        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
-    );
-
-    bool ok;
-    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
-    struct lgtd_client client = {
-        .io = NULL, .current_request = &req, .json = json
-    };
+    client.json = json;
+    parsed = parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
+    memset(&req, 0, sizeof(req));
     ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
     if (!ok) {
         errx(1, "can't parse request");
     }
+    lgtd_jsonrpc_check_and_call_set_waveform(&client);
+    if (set_waveform_call_count != 1) {
+        errx(1, "lgtd_proto_set_waveform wasn't called");
+    }
 
+    // optional transient argument
+    json = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"set_waveform\","
+        "\"params\": {"
+            "\"target\": \"*\", "
+            "\"hue\": 324.2341514, "
+            "\"saturation\": 0.234, "
+            "\"brightness\": 1.0, "
+            "\"kelvin\": 4200,"
+            "\"cycles\": 10,"
+            "\"period\": 1000,"
+            "\"skew_ratio\": 0.5,"
+            "\"waveform\": \"SAW\""
+        "},"
+        "\"id\": \"42\""
+    "}");
+    client.json = json;
+    parsed = parse_json(tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json));
+    memset(&req, 0, sizeof(req));
+    ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
+    if (!ok) {
+        errx(1, "can't parse request");
+    }
     lgtd_jsonrpc_check_and_call_set_waveform(&client);
-
-    if (!set_waveform_called) {
+    if (set_waveform_call_count != 2) {
         errx(1, "lgtd_proto_set_waveform wasn't called");
     }
 
diff --git a/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c b/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c
@@ -40,7 +40,7 @@
         "\"error\": {"
             "\"code\": -32602, "
             "\"message\": "
-            "\"Invalid number of parameters\""
+            "\"Invalid parameters\""
         "}"
     "}");
 
