# HG changeset patch
# Parent fc8907e9d27f2882bf6c77fabdc90ac86eceb663
# Parent  f9aa8a3fd77288a69e0be23f0623ce31868bab19
Add the ability to target a specific device via its address

diff --git a/core/router.c b/core/router.c
--- a/core/router.c
+++ b/core/router.c
@@ -67,6 +67,33 @@
     }
 }
 
+static void
+lgtd_router_device(struct lgtd_lifx_bulb *bulb,
+                   enum lgtd_lifx_packet_type pkt_type,
+                   void *pkt)
+{
+    assert(bulb);
+
+    struct lgtd_lifx_packet_header hdr;
+    union lgtd_lifx_target target = { .addr = bulb->addr };
+
+    const struct lgtd_lifx_packet_infos *pkt_infos;
+    pkt_infos = lgtd_lifx_wire_setup_header(
+        &hdr, LGTD_LIFX_TARGET_DEVICE, target, bulb->gw->site, pkt_type
+    );
+    assert(pkt_infos);
+
+    lgtd_lifx_gateway_send_packet(bulb->gw, &hdr, pkt, pkt_infos->size);
+
+    if (pkt_type == LGTD_LIFX_SET_POWER_STATE) {
+        bulb->dirty_at = lgtd_time_monotonic_msecs();
+        struct lgtd_lifx_packet_power_state *payload = pkt;
+        bulb->expected_power_on = payload->power;
+    }
+
+    lgtd_debug("sending %s to %s", pkt_infos->name, lgtd_addrtoa(bulb->addr));
+}
+
 bool
 lgtd_router_send(const char *target,
                  enum lgtd_lifx_packet_type pkt_type,
@@ -79,5 +106,25 @@
         return true;
     }
 
+    if (isxdigit(target[0])) {
+        const char *endptr = NULL;
+        errno = 0;
+        long long device = strtoll(target, (char **)&endptr, 16);
+        if (*endptr || errno == ERANGE) {
+            lgtd_debug("invalid target device %s", target);
+            return false;
+        }
+        device = htobe64(device);
+        struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_get(
+            (uint8_t *)&device + sizeof(device) - LGTD_LIFX_ADDR_LENGTH
+        );
+        if (!bulb) {
+            lgtd_debug("target device %#llx not found", device);
+            return false;
+        }
+        lgtd_router_device(bulb, pkt_type, pkt);
+        return true;
+    }
+
     return false;
 }
diff --git a/lifx/bulb.c b/lifx/bulb.c
--- a/lifx/bulb.c
+++ b/lifx/bulb.c
@@ -37,9 +37,8 @@
     RB_INITIALIZER(&lgtd_lifx_bulbs_table);
 
 struct lgtd_lifx_bulb *
-lgtd_lifx_bulb_get(struct lgtd_lifx_gateway *gw, const uint8_t *addr)
+lgtd_lifx_bulb_get(const uint8_t *addr)
 {
-    assert(gw);
     assert(addr);
 
     struct lgtd_lifx_bulb bulb;
@@ -77,9 +76,10 @@
     RB_REMOVE(lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table, bulb);
     SLIST_REMOVE(&bulb->gw->bulbs, bulb, lgtd_lifx_bulb, link_by_gw);
     lgtd_info(
-        "closed bulb \"%.*s\" on [%s]:%hu",
+        "closed bulb \"%.*s\" (%s) on [%s]:%hu",
         LGTD_LIFX_LABEL_SIZE,
         bulb->state.label,
+        lgtd_addrtoa(bulb->addr),
         bulb->gw->ip_addr,
         bulb->gw->port
     );
diff --git a/lifx/bulb.h b/lifx/bulb.h
--- a/lifx/bulb.h
+++ b/lifx/bulb.h
@@ -60,7 +60,7 @@
     lgtd_lifx_bulb_cmp
 );
 
-struct lgtd_lifx_bulb *lgtd_lifx_bulb_get(struct lgtd_lifx_gateway *, const uint8_t *);
+struct lgtd_lifx_bulb *lgtd_lifx_bulb_get(const uint8_t *);
 struct lgtd_lifx_bulb *lgtd_lifx_bulb_open(struct lgtd_lifx_gateway *, const uint8_t *);
 void lgtd_lifx_bulb_close(struct lgtd_lifx_bulb *);
 
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -154,7 +154,7 @@
     assert(gw);
     assert(bulb_addr);
 
-    struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_get(gw, bulb_addr);
+    struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_get(bulb_addr);
     if (!bulb) {
         bulb = lgtd_lifx_bulb_open(gw, bulb_addr);
         if (bulb) {
diff --git a/lifx/wire_proto.c b/lifx/wire_proto.c
--- a/lifx/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -196,7 +196,7 @@
         hdr->target.tags = target.tags;
         break;
     case LGTD_LIFX_TARGET_DEVICE:
-        hdr->protocol.addressable = false;
+        hdr->protocol.addressable = true;
         memcpy(hdr->target.device_addr, target.addr, LGTD_LIFX_ADDR_LENGTH);
         break;
     case LGTD_LIFX_TARGET_ALL_DEVICES:
diff --git a/tests/core/jsonrpc/CMakeLists.txt b/tests/core/jsonrpc/CMakeLists.txt
--- a/tests/core/jsonrpc/CMakeLists.txt
+++ b/tests/core/jsonrpc/CMakeLists.txt
@@ -1,7 +1,9 @@
 INCLUDE_DIRECTORIES(
     ${LIGHTSD_SOURCE_DIR}
+    ${LIGHTSD_SOURCE_DIR}/../
     ${LIGHTSD_SOURCE_DIR}/core/
     ${LIGHTSD_BINARY_DIR}
+    ${LIGHTSD_BINARY_DIR}/../
     ${LIGHTSD_BINARY_DIR}/core/
 )
 
@@ -9,7 +11,8 @@
     test_core_jsonrpc STATIC
     ${LIGHTSD_SOURCE_DIR}/core/jsmn.c
     ${LIGHTSD_SOURCE_DIR}/core/log.c
-    ${CMAKE_CURRENT_SOURCE_DIR}/../utils.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_utils.c
 )
 
 FUNCTION(ADD_JSONRPC_TEST TEST_SOURCE)
diff --git a/tests/core/router/CMakeLists.txt b/tests/core/router/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/core/router/CMakeLists.txt
@@ -0,0 +1,33 @@
+INCLUDE_DIRECTORIES(
+    ${LIGHTSD_SOURCE_DIR}
+    ${LIGHTSD_SOURCE_DIR}/../
+    ${LIGHTSD_SOURCE_DIR}/core/
+    ${LIGHTSD_SOURCE_DIR}/tests/core/
+    ${LIGHTSD_BINARY_DIR}
+    ${LIGHTSD_BINARY_DIR}/../
+    ${LIGHTSD_BINARY_DIR}/core/
+    ${LIGHTSD_BINARY_DIR}/tests/core/
+)
+
+ADD_LIBRARY(
+    test_core_router STATIC
+    ${LIGHTSD_SOURCE_DIR}/core/log.c
+    ${LIGHTSD_SOURCE_DIR}/core/proto.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_utils.c
+    ${TIME_MONOTONIC_IMPL}
+)
+
+TARGET_LINK_LIBRARIES(test_core_router ${EVENT2_CORE_LIBRARY})
+
+FUNCTION(ADD_ROUTER_TEST TEST_SOURCE)
+    ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE} test_core_router)
+ENDFUNCTION()
+
+FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
+FOREACH(TEST ${TESTS})
+    ADD_ROUTER_TEST(${TEST})
+ENDFOREACH()
diff --git a/tests/core/router/test_router_broadcast.c b/tests/core/router/test_router_broadcast.c
new file mode 100644
--- /dev/null
+++ b/tests/core/router/test_router_broadcast.c
@@ -0,0 +1,54 @@
+#include "router.c"
+
+#include "tests_utils.h"
+#include "tests_router_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    lgtd_tests_insert_mock_gateway(2);
+    lgtd_tests_insert_mock_gateway(1);
+
+    struct lgtd_lifx_packet_power_state payload = {
+        .power = LGTD_LIFX_POWER_ON
+    };
+    lgtd_router_send("*", LGTD_LIFX_SET_POWER_STATE, &payload);
+
+    if (lgtd_tests_gw_pkt_queue_size != 2) {
+        lgtd_errx(1, "2 packets should have been sent");
+    }
+
+    for (int i = lgtd_tests_gw_pkt_queue_size; i--;) {
+        struct lgtd_lifx_gateway *gw = lgtd_tests_gw_pkt_queue[i].gw;
+        if (gw->socket != i + 1) {
+            lgtd_errx(
+                1, "packet was sent to wrong gateway (expected %d, got %d)",
+                i + 1, gw->socket
+            );
+        }
+        const struct lgtd_lifx_packet_header *hdr;
+        hdr = lgtd_tests_gw_pkt_queue[i].hdr;
+        if (!hdr->protocol.tagged || hdr->protocol.addressable) {
+            lgtd_errx(1, "packet header doesn't have the right bits set");
+        }
+        if (hdr->target.tags != 0) {
+            lgtd_errx(1, "tags should be 0 for broadcast");
+        }
+        if (memcmp(gw->site, hdr->site, sizeof(hdr->site))) {
+            lgtd_errx(1, "sites don't match");
+        }
+        if (lgtd_tests_gw_pkt_queue[i].pkt != &payload) {
+            lgtd_errx(1, "the payload has been improperly set");
+        }
+        if (lgtd_tests_gw_pkt_queue[i].pkt_size != sizeof(payload)) {
+            lgtd_errx(
+                1, "unexpected pkt size %d (expected %ld)",
+                lgtd_tests_gw_pkt_queue[i].pkt_size, sizeof(payload)
+            );
+        }
+    }
+
+    return 0;
+}
diff --git a/tests/core/router/test_router_device.c b/tests/core/router/test_router_device.c
new file mode 100644
--- /dev/null
+++ b/tests/core/router/test_router_device.c
@@ -0,0 +1,58 @@
+#include "router.c"
+
+#include "tests_utils.h"
+#include "tests_router_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway *gw_1 = lgtd_tests_insert_mock_gateway(1);
+    struct lgtd_lifx_bulb *bulb_1 = lgtd_tests_insert_mock_bulb(gw_1, 1);
+    struct lgtd_lifx_gateway *gw_2 = lgtd_tests_insert_mock_gateway(2);
+    lgtd_tests_insert_mock_bulb(gw_2, 2);
+
+    struct lgtd_lifx_packet_power_state payload = {
+        .power = LGTD_LIFX_POWER_ON
+    };
+    lgtd_router_send("1", LGTD_LIFX_SET_POWER_STATE, &payload);
+
+    if (lgtd_tests_gw_pkt_queue_size != 1) {
+        lgtd_errx(1, "1 packet should have been sent");
+    }
+
+    struct lgtd_lifx_gateway *recpt_gw = lgtd_tests_gw_pkt_queue[0].gw;
+    struct lgtd_lifx_packet_header *hdr_queued = lgtd_tests_gw_pkt_queue[0].hdr;
+    const void *pkt_queued = lgtd_tests_gw_pkt_queue[0].pkt;
+    int pkt_size = lgtd_tests_gw_pkt_queue[0].pkt_size;
+
+    if (recpt_gw != gw_1) {
+        lgtd_errx(1, "the packet has been sent to the wrong gateway");
+    }
+
+    if (!hdr_queued->protocol.addressable || hdr_queued->protocol.tagged) {
+        lgtd_errx(1, "the packet header doesn't have the right protocol flags");
+    }
+
+    if (memcmp(hdr_queued->target.device_addr, bulb_1->addr, sizeof(bulb_1->addr))) {
+        lgtd_errx(1, "the packet header doesn't have the right target address");
+    }
+
+    if (memcmp(gw_1->site, hdr_queued->site, sizeof(hdr_queued->site))) {
+        lgtd_errx(1, "incorrect site in the headers");
+    }
+
+    if (pkt_queued != &payload) {
+        lgtd_errx(1, "invalid payload");
+    }
+
+    if (pkt_size != sizeof(payload)) {
+        lgtd_errx(
+            1, "unexpected pkt size %d (expected %ld)",
+            pkt_size, sizeof(payload)
+        );
+    }
+
+    return 0;
+}
diff --git a/tests/core/router/test_router_invalid_targets.c b/tests/core/router/test_router_invalid_targets.c
new file mode 100644
--- /dev/null
+++ b/tests/core/router/test_router_invalid_targets.c
@@ -0,0 +1,39 @@
+#include "router.c"
+
+#include "tests_utils.h"
+#include "tests_router_utils.h"
+
+void
+test_target(const char *target)
+{
+    struct lgtd_lifx_packet_power_state payload = {
+        .power = LGTD_LIFX_POWER_ON
+    };
+    bool ok = lgtd_router_send(target, LGTD_LIFX_SET_POWER_STATE, &payload);
+    if (ok) {
+        lgtd_errx(1, "router_send didn't return false for an unknown device");
+    }
+    if (lgtd_tests_gw_pkt_queue_size) {
+        lgtd_errx(1, "no packets should have been sent");
+    }
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway *gw_1 = lgtd_tests_insert_mock_gateway(1);
+    lgtd_tests_insert_mock_bulb(gw_1, 1);
+    struct lgtd_lifx_gateway *gw_2 = lgtd_tests_insert_mock_gateway(2);
+    lgtd_tests_insert_mock_bulb(gw_2, 2);
+
+    test_target("4");
+    test_target("-1");
+    test_target("blabla");
+    test_target("**");
+    test_target("ffffffffffffffffffffffffff");
+    test_target("");
+
+    return 0;
+}
diff --git a/tests/core/router/tests_router_utils.h b/tests/core/router/tests_router_utils.h
new file mode 100644
--- /dev/null
+++ b/tests/core/router/tests_router_utils.h
@@ -0,0 +1,45 @@
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <event2/util.h>
+
+#include "lifx/wire_proto.h"
+#include "core/time_monotonic.h"
+#include "lifx/bulb.h"
+#include "lifx/gateway.h"
+#include "tests_utils.h"
+
+int lgtd_tests_gw_pkt_queue_size = 0;
+struct {
+    struct lgtd_lifx_gateway        *gw;
+    struct lgtd_lifx_packet_header  *hdr;
+    const void                      *pkt;
+    int                             pkt_size;
+} lgtd_tests_gw_pkt_queue[16] = { { NULL, NULL, NULL, 0}, };
+
+void
+lgtd_lifx_gateway_send_packet(struct lgtd_lifx_gateway *gw,
+                              const struct lgtd_lifx_packet_header *hdr,
+                              const void *pkt,
+                              int pkt_size)
+{
+    lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].gw = gw;
+    // headers are created on the stack so we need to dup them:
+    lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].hdr = malloc(
+        sizeof(*hdr)
+    );
+    memcpy(
+        lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].hdr,
+        hdr,
+        sizeof(*hdr)
+    );
+    lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].pkt = pkt;
+    lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].pkt_size = pkt_size;
+    lgtd_tests_gw_pkt_queue_size++;
+}
diff --git a/tests/core/tests_shims.c b/tests/core/tests_shims.c
new file mode 100644
--- /dev/null
+++ b/tests/core/tests_shims.c
@@ -0,0 +1,58 @@
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <event2/event.h>
+#include <event2/util.h>
+
+#include "lifx/wire_proto.h"
+#include "core/time_monotonic.h"
+#include "lifx/bulb.h"
+#include "lifx/gateway.h"
+#include "lightsd.h"
+
+struct lgtd_opts lgtd_opts = {
+    .foreground = false,
+    .log_timestamps = false,
+    .verbosity = LGTD_DEBUG
+};
+
+struct event_base *lgtd_ev_base = NULL;
+
+void
+lgtd_cleanup(void)
+{
+}
+
+
+void lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *gw,
+                                          const struct lgtd_lifx_packet_header *hdr,
+                                          const struct lgtd_lifx_packet_pan_gateway *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+
+void lgtd_lifx_gateway_handle_light_status(struct lgtd_lifx_gateway *gw,
+                                           const struct lgtd_lifx_packet_header *hdr,
+                                           const struct lgtd_lifx_packet_light_status *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+
+void lgtd_lifx_gateway_handle_power_state(struct lgtd_lifx_gateway *gw,
+                                          const struct lgtd_lifx_packet_header *hdr,
+                                          const struct lgtd_lifx_packet_power_state *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
diff --git a/tests/core/utils.c b/tests/core/tests_utils.c
rename from tests/core/utils.c
rename to tests/core/tests_utils.c
--- a/tests/core/utils.c
+++ b/tests/core/tests_utils.c
@@ -1,18 +1,47 @@
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <sys/socket.h>
+#include <assert.h>
+#include <endian.h>
+#include <netinet/in.h>
 #include <stdbool.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
 
-#include <event2/event.h>
+#include <event2/util.h>
 
-#include "lightsd.h"
+#include "lifx/wire_proto.h"
+#include "core/time_monotonic.h"
+#include "lifx/bulb.h"
+#include "lifx/gateway.h"
+#include "tests_utils.h"
 
-struct lgtd_opts lgtd_opts = {
-    .foreground = false,
-    .log_timestamps = false,
-    .verbosity = LGTD_DEBUG
-}; 
+struct lgtd_lifx_gateway_list lgtd_lifx_gateways =
+    LIST_HEAD_INITIALIZER(&lgtd_lifx_gateways);
 
-struct event_base *lgtd_ev_base = NULL;
+struct lgtd_lifx_gateway *
+lgtd_tests_insert_mock_gateway(int id)
+{
+    struct lgtd_lifx_gateway *gw = calloc(1, sizeof(*gw));
 
-void
-lgtd_cleanup(void)
+    gw->socket = id;
+    gw->site[0] = id;
+
+    LIST_INSERT_HEAD(&lgtd_lifx_gateways, gw, link);
+
+    return gw;
+}
+
+struct lgtd_lifx_bulb *
+lgtd_tests_insert_mock_bulb(struct lgtd_lifx_gateway *gw, uint64_t addr)
 {
+    assert(gw);
+
+    union {
+        uint8_t     as_array[LGTD_LIFX_ADDR_LENGTH];
+        uint64_t    as_scalar;
+    } bulb_addr = { .as_scalar = htobe64(addr) >> 16 };
+
+    return lgtd_lifx_bulb_open(gw, bulb_addr.as_array);
 }
diff --git a/tests/core/tests_utils.h b/tests/core/tests_utils.h
new file mode 100644
--- /dev/null
+++ b/tests/core/tests_utils.h
@@ -0,0 +1,2 @@
+struct lgtd_lifx_gateway *lgtd_tests_insert_mock_gateway(int);
+struct lgtd_lifx_bulb *lgtd_tests_insert_mock_bulb(struct lgtd_lifx_gateway *, uint64_t);
diff --git a/tests/lightsc b/tests/lightsc
--- a/tests/lightsc
+++ b/tests/lightsc
@@ -18,30 +18,34 @@
     print(response)
 
 
-def set_light_from_hsbk(socket, id, h, s, b, k):
+def set_light_from_hsbk(socket, id, target, h, s, b, k):
     jsonrpc_call(socket, id, "set_light_from_hsbk", [
-        "*", h, s, b, k
+        target, h, s, b, k
     ])
 
 
-def power_on(socket, id):
-    jsonrpc_call(socket, id, "power_on", {"target": "*"})
+def power_on(socket, id, target):
+    jsonrpc_call(socket, id, "power_on", {"target": target})
 
 
-def power_off(socket, id):
-    jsonrpc_call(socket, id, "power_off", {"target": "*"})
+def power_off(socket, id, target):
+    jsonrpc_call(socket, id, "power_off", {"target": target})
 
 if __name__ == "__main__":
     s = socket.create_connection(("localhost", 1234))
     h = 0
     id = 0
+    nb = "d073d501a0d5"
+    fugu = "d073d500603b"
+    neko = "d073d5018fb6"
+    target = "*"
     try:
-        power_on(s, id)
+        power_on(s, id, target)
         while True:
             h = (h + 1) % 360
             id += 1
-            set_light_from_hsbk(s, id, h, 0.7, 0.02, 2500)
+            set_light_from_hsbk(s, id, target, h, 0.7, 0.02, 2500)
             time.sleep(0.1)
     finally:
-        power_off(s, id)
+        power_off(s, id, target)
         s.close()
