# HG changeset patch
# Parent  97da5a287d16500aff148dcb4b81fe9da5e84d77
Send one lifx packet per UDP datagram with a queue

The firmware doesn't seem to support one more than one packet per
datagram.

diff --git a/core/client.h b/core/client.h
--- a/core/client.h
+++ b/core/client.h
@@ -31,7 +31,7 @@
 };
 
 struct lgtd_client {
-    LIST_ENTRY(lgtd_client)      link;
+    LIST_ENTRY(lgtd_client)     link;
     struct bufferevent          *io;
     char                        ip_addr[INET6_ADDRSTRLEN];
     uint16_t                    port;
diff --git a/core/router.c b/core/router.c
--- a/core/router.c
+++ b/core/router.c
@@ -55,7 +55,9 @@
             &hdr, LGTD_LIFX_TARGET_ALL_DEVICES, target, gw->site, pkt_type
         );
         assert(pkt_infos);
-        lgtd_lifx_gateway_send_packet(gw, &hdr, pkt, pkt_infos->size);
+        lgtd_lifx_gateway_enqueue_packet(
+            gw, &hdr, pkt_type, pkt, pkt_infos->size
+        );
         struct lgtd_lifx_bulb *bulb;
         lgtd_time_mono_t now = lgtd_time_monotonic_msecs();
         SLIST_FOREACH(bulb, &gw->bulbs, link_by_gw) {
@@ -88,7 +90,9 @@
     );
     assert(pkt_infos);
 
-    lgtd_lifx_gateway_send_packet(bulb->gw, &hdr, pkt, pkt_infos->size);
+    lgtd_lifx_gateway_enqueue_packet(
+        bulb->gw, &hdr, pkt_type, pkt, pkt_infos->size
+    );
 
     if (pkt_type == LGTD_LIFX_SET_POWER_STATE) {
         bulb->dirty_at = lgtd_time_monotonic_msecs();
diff --git a/core/router.h b/core/router.h
--- a/core/router.h
+++ b/core/router.h
@@ -17,6 +17,12 @@
 
 #pragma once
 
+// TODO: return that from the functions in there and handle it:
+enum lgtd_router_error {
+    LGTD_ROUTER_INVALID_TARGET_ERROR,
+    LGTD_ROUTER_CANNOT_ENQUEUE_PACKET_ERROR
+};
+
 bool lgtd_router_send(const struct lgtd_proto_target_list *, enum lgtd_lifx_packet_type, void *);
 void lgtd_router_send_to_device(struct lgtd_lifx_bulb *, enum lgtd_lifx_packet_type, void *);
 void lgtd_router_broadcast(enum lgtd_lifx_packet_type, void *);
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -93,6 +93,7 @@
     assert(ctx);
 
     struct lgtd_lifx_gateway *gw = (struct lgtd_lifx_gateway *)ctx;
+
     if (events & EV_TIMEOUT) {  // Not sure how that could happen in UDP but eh.
         lgtd_warn(
             "lost connection with gateway bulb [%s]:%hu", gw->ip_addr, gw->port
@@ -103,8 +104,13 @@
         }
         return;
     }
+
     if (events & EV_WRITE) {
-        int nbytes = evbuffer_write(gw->write_buf, gw->socket);
+        assert(gw->pkt_ring_tail >= 0);
+        assert(gw->pkt_ring_tail < (int)LGTD_ARRAY_SIZE(gw->pkt_ring));
+
+        int to_write = gw->pkt_ring[gw->pkt_ring_tail].size;
+        int nbytes = evbuffer_write_atmost(gw->write_buf, gw->socket, to_write);
         if (nbytes == -1 && errno != EAGAIN) {
             lgtd_warn("can't write to [%s]:%hu", gw->ip_addr, gw->port);
             lgtd_lifx_gateway_close(gw);
@@ -113,16 +119,32 @@
             }
             return;
         }
+
         // Callbacks are called in any order, so we keep two timers to make
         // sure we can get the latency right, otherwise we could be compute the
         // latency with last_pkt_at < last_req_at, which isn't true since the
         // pkt will be for an answer to the previous write:
         gw->last_req_at = gw->next_req_at;
         gw->next_req_at = lgtd_time_monotonic_msecs();
-        // XXX this isn't perfect because we don't know what we just sent, I
-        // just assume that everything pending will alway be transmitted in a
-        // single call:
-        gw->pending_refresh_req = false;
+
+        gw->pkt_ring[gw->pkt_ring_tail].size -= nbytes;
+        if (gw->pkt_ring[gw->pkt_ring_tail].size == 0) {
+            enum lgtd_lifx_packet_type type;
+            type = gw->pkt_ring[gw->pkt_ring_tail].type;
+            if (type == LGTD_LIFX_GET_TAG_LABELS) {
+                gw->pending_refresh_req = false;
+            }
+            if (lgtd_opts.verbosity <= LGTD_DEBUG) {
+                const struct lgtd_lifx_packet_infos *pkt_infos =
+                    lgtd_lifx_wire_get_packet_infos(type);
+                lgtd_debug(
+                    "%s --> [%s]:%hu", pkt_infos->name, gw->ip_addr, gw->port
+                );
+            }
+            LGTD_LIFX_GATEWAY_INC_MESSAGE_RING_INDEX(gw->pkt_ring_tail);
+            gw->pkt_ring_full = false;
+        }
+
         if (!evbuffer_get_length(gw->write_buf)) {
             event_del(gw->write_ev);
         }
@@ -136,20 +158,21 @@
 
     struct lgtd_lifx_packet_header hdr;
     union lgtd_lifx_target target = { .addr = gw->site };
-    lgtd_debug(
-        "GET_LIGHT_STATE+GET_TAG_LABELS --> [%s]:%hu", gw->ip_addr, gw->port
-    );
 
     lgtd_lifx_wire_setup_header(
         &hdr, LGTD_LIFX_TARGET_SITE, target, gw->site, LGTD_LIFX_GET_LIGHT_STATE
     );
-    lgtd_lifx_gateway_send_packet(gw, &hdr, NULL, 0);
+    lgtd_lifx_gateway_enqueue_packet(
+        gw, &hdr, LGTD_LIFX_GET_LIGHT_STATE, NULL, 0
+    );
 
     struct lgtd_lifx_packet_get_tag_labels pkt = { .tags = LGTD_LIFX_ALL_TAGS };
     lgtd_lifx_wire_setup_header(
         &hdr, LGTD_LIFX_TARGET_SITE, target, gw->site, LGTD_LIFX_GET_TAG_LABELS
     );
-    lgtd_lifx_gateway_send_packet(gw, &hdr, &pkt, sizeof(pkt));
+    lgtd_lifx_gateway_enqueue_packet(
+        gw, &hdr, LGTD_LIFX_GET_TAG_LABELS, &pkt, sizeof(pkt)
+    );
 
     gw->pending_refresh_req = true;
 }
@@ -308,21 +331,37 @@
 }
 
 void
-lgtd_lifx_gateway_send_packet(struct lgtd_lifx_gateway *gw,
-                              const struct lgtd_lifx_packet_header *hdr,
-                              const void *pkt,
-                              int pkt_size)
+lgtd_lifx_gateway_enqueue_packet(struct lgtd_lifx_gateway *gw,
+                                 const struct lgtd_lifx_packet_header *hdr,
+                                 enum lgtd_lifx_packet_type pkt_type,
+                                 const void *pkt,
+                                 int pkt_size)
 {
     assert(gw);
     assert(hdr);
     assert(pkt_size >= 0 && pkt_size < LGTD_LIFX_MAX_PACKET_SIZE);
     assert(!memcmp(hdr->site, gw->site, LGTD_LIFX_ADDR_LENGTH));
+    assert(gw->pkt_ring_head >= 0);
+    assert(gw->pkt_ring_head < (int)LGTD_ARRAY_SIZE(gw->pkt_ring));
+
+    if (gw->pkt_ring_full) {
+        lgtd_warnx(
+            "dropping packet type %#x: packet queue is full", hdr->packet_type
+        );
+        return;
+    }
 
     evbuffer_add(gw->write_buf, hdr, sizeof(*hdr));
     if (pkt) {
         assert((unsigned)pkt_size == le16toh(hdr->size) - sizeof(*hdr));
         evbuffer_add(gw->write_buf, pkt, pkt_size);
     }
+    gw->pkt_ring[gw->pkt_ring_head].size = sizeof(*hdr) + pkt_size;
+    gw->pkt_ring[gw->pkt_ring_head].type = pkt_type;
+    LGTD_LIFX_GATEWAY_INC_MESSAGE_RING_INDEX(gw->pkt_ring_head);
+    if (gw->pkt_ring_head == gw->pkt_ring_tail) {
+        gw->pkt_ring_full = true;
+    }
     event_add(gw->write_ev, NULL);
 }
 
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -23,6 +23,14 @@
 // still draw about 2W in ZigBee and about 3W in WiFi).
 enum { LGTD_LIFX_GATEWAY_MIN_REFRESH_INTERVAL_MSECS = 200 };
 
+// You can't send more than one lifx packet per UDP datagram.
+enum { LGTD_LIFX_GATEWAY_PACKET_RING_SIZE = 16 };
+
+struct lgtd_lifx_message {
+    enum lgtd_lifx_packet_type  type;
+    int                         size;
+};
+
 struct lgtd_lifx_gateway {
     LIST_ENTRY(lgtd_lifx_gateway)   link;
     struct lgtd_lifx_bulb_list      bulbs;
@@ -43,6 +51,14 @@
     lgtd_time_mono_t                last_req_at;
     lgtd_time_mono_t                next_req_at;
     lgtd_time_mono_t                last_pkt_at;
+    struct lgtd_lifx_message        pkt_ring[LGTD_LIFX_GATEWAY_PACKET_RING_SIZE];
+#define LGTD_LIFX_GATEWAY_INC_MESSAGE_RING_INDEX(idx)  do { \
+    (idx) += 1;                                             \
+    (idx) %= LGTD_LIFX_GATEWAY_PACKET_RING_SIZE;            \
+} while(0)
+    int                             pkt_ring_head;
+    int                             pkt_ring_tail;
+    bool                            pkt_ring_full;
     struct event                    *write_ev;
     struct evbuffer                 *write_buf;
     bool                            pending_refresh_req;
@@ -63,10 +79,11 @@
 
 void lgtd_lifx_gateway_force_refresh(struct lgtd_lifx_gateway *);
 
-void lgtd_lifx_gateway_send_packet(struct lgtd_lifx_gateway *,
-                                   const struct lgtd_lifx_packet_header *,
-                                   const void *,
-                                   int);
+void lgtd_lifx_gateway_enqueue_packet(struct lgtd_lifx_gateway *,
+                                      const struct lgtd_lifx_packet_header *,
+                                      enum lgtd_lifx_packet_type,
+                                      const void *,
+                                      int);
 
 void lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *,
                                           const struct lgtd_lifx_packet_header *,
diff --git a/tests/core/jsonrpc/test_jsonrpc_utils.h b/tests/core/jsonrpc/test_jsonrpc_utils.h
--- a/tests/core/jsonrpc/test_jsonrpc_utils.h
+++ b/tests/core/jsonrpc/test_jsonrpc_utils.h
@@ -24,7 +24,9 @@
 bufferevent_write(struct bufferevent *bev, const void *data, size_t nbytes)
 {
     (void)bev;
-    int to_write = LGTD_MIN(nbytes, sizeof(client_write_buf));
+    int to_write = LGTD_MIN(
+        nbytes, sizeof(client_write_buf) - client_write_buf_idx
+    );
     memcpy(&client_write_buf[client_write_buf_idx], data, to_write);
     client_write_buf_idx += to_write;
     return 0;
diff --git a/tests/core/router/test_router_broadcast.c b/tests/core/router/test_router_broadcast.c
--- a/tests/core/router/test_router_broadcast.c
+++ b/tests/core/router/test_router_broadcast.c
@@ -18,12 +18,12 @@
     targets = lgtd_tests_build_target_list("*", NULL);
     lgtd_router_send(targets, LGTD_LIFX_SET_POWER_STATE, &payload);
 
-    if (lgtd_tests_gw_pkt_queue_size != 2) {
+    if (lgtd_tests_gw_pkt_ring_size != 2) {
         lgtd_errx(1, "2 packets should have been sent");
     }
 
-    for (int i = lgtd_tests_gw_pkt_queue_size; i--;) {
-        struct lgtd_lifx_gateway *gw = lgtd_tests_gw_pkt_queue[i].gw;
+    for (int i = lgtd_tests_gw_pkt_ring_size; i--;) {
+        struct lgtd_lifx_gateway *gw = lgtd_tests_gw_pkt_ring[i].gw;
         if (gw->socket != i + 1) {
             lgtd_errx(
                 1, "packet was sent to wrong gateway (expected %d, got %d)",
@@ -31,7 +31,7 @@
             );
         }
         const struct lgtd_lifx_packet_header *hdr;
-        hdr = lgtd_tests_gw_pkt_queue[i].hdr;
+        hdr = lgtd_tests_gw_pkt_ring[i].hdr;
         if (!hdr->protocol.tagged || hdr->protocol.addressable) {
             lgtd_errx(1, "packet header doesn't have the right bits set");
         }
@@ -41,13 +41,13 @@
         if (memcmp(gw->site, hdr->site, sizeof(hdr->site))) {
             lgtd_errx(1, "sites don't match");
         }
-        if (lgtd_tests_gw_pkt_queue[i].pkt != &payload) {
+        if (lgtd_tests_gw_pkt_ring[i].pkt != &payload) {
             lgtd_errx(1, "the payload has been improperly set");
         }
-        if (lgtd_tests_gw_pkt_queue[i].pkt_size != sizeof(payload)) {
+        if (lgtd_tests_gw_pkt_ring[i].pkt_size != sizeof(payload)) {
             lgtd_errx(
                 1, "unexpected pkt size %d (expected %ld)",
-                lgtd_tests_gw_pkt_queue[i].pkt_size, sizeof(payload)
+                lgtd_tests_gw_pkt_ring[i].pkt_size, sizeof(payload)
             );
         }
     }
diff --git a/tests/core/router/test_router_device.c b/tests/core/router/test_router_device.c
--- a/tests/core/router/test_router_device.c
+++ b/tests/core/router/test_router_device.c
@@ -20,14 +20,14 @@
     targets = lgtd_tests_build_target_list("1", NULL);
     lgtd_router_send(targets, LGTD_LIFX_SET_POWER_STATE, &payload);
 
-    if (lgtd_tests_gw_pkt_queue_size != 1) {
+    if (lgtd_tests_gw_pkt_ring_size != 1) {
         lgtd_errx(1, "1 packet should have been sent");
     }
 
-    struct lgtd_lifx_gateway *recpt_gw = lgtd_tests_gw_pkt_queue[0].gw;
-    struct lgtd_lifx_packet_header *hdr_queued = lgtd_tests_gw_pkt_queue[0].hdr;
-    const void *pkt_queued = lgtd_tests_gw_pkt_queue[0].pkt;
-    int pkt_size = lgtd_tests_gw_pkt_queue[0].pkt_size;
+    struct lgtd_lifx_gateway *recpt_gw = lgtd_tests_gw_pkt_ring[0].gw;
+    struct lgtd_lifx_packet_header *hdr_queued = lgtd_tests_gw_pkt_ring[0].hdr;
+    const void *pkt_ringd = lgtd_tests_gw_pkt_ring[0].pkt;
+    int pkt_size = lgtd_tests_gw_pkt_ring[0].pkt_size;
 
     if (recpt_gw != gw_1) {
         lgtd_errx(1, "the packet has been sent to the wrong gateway");
@@ -45,7 +45,7 @@
         lgtd_errx(1, "incorrect site in the headers");
     }
 
-    if (pkt_queued != &payload) {
+    if (pkt_ringd != &payload) {
         lgtd_errx(1, "invalid payload");
     }
 
diff --git a/tests/core/router/test_router_invalid_targets.c b/tests/core/router/test_router_invalid_targets.c
--- a/tests/core/router/test_router_invalid_targets.c
+++ b/tests/core/router/test_router_invalid_targets.c
@@ -15,7 +15,7 @@
     if (ok) {
         lgtd_errx(1, "router_send didn't return false for an unknown device");
     }
-    if (lgtd_tests_gw_pkt_queue_size) {
+    if (lgtd_tests_gw_pkt_ring_size) {
         lgtd_errx(1, "no packets should have been sent");
     }
 }
diff --git a/tests/core/router/tests_router_utils.h b/tests/core/router/tests_router_utils.h
--- a/tests/core/router/tests_router_utils.h
+++ b/tests/core/router/tests_router_utils.h
@@ -1,10 +1,10 @@
-int lgtd_tests_gw_pkt_queue_size = 0;
+int lgtd_tests_gw_pkt_ring_size = 0;
 struct {
     struct lgtd_lifx_gateway        *gw;
     struct lgtd_lifx_packet_header  *hdr;
     const void                      *pkt;
     int                             pkt_size;
-} lgtd_tests_gw_pkt_queue[16] = { { NULL, NULL, NULL, 0}, };
+} lgtd_tests_gw_pkt_ring[16] = { { NULL, NULL, NULL, 0}, };
 
 void
 lgtd_lifx_gateway_send_packet(struct lgtd_lifx_gateway *gw,
@@ -12,17 +12,17 @@
                               const void *pkt,
                               int pkt_size)
 {
-    lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].gw = gw;
+    lgtd_tests_gw_pkt_ring[lgtd_tests_gw_pkt_ring_size].gw = gw;
     // headers are created on the stack so we need to dup them:
-    lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].hdr = malloc(
+    lgtd_tests_gw_pkt_ring[lgtd_tests_gw_pkt_ring_size].hdr = malloc(
         sizeof(*hdr)
     );
     memcpy(
-        lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].hdr,
+        lgtd_tests_gw_pkt_ring[lgtd_tests_gw_pkt_ring_size].hdr,
         hdr,
         sizeof(*hdr)
     );
-    lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].pkt = pkt;
-    lgtd_tests_gw_pkt_queue[lgtd_tests_gw_pkt_queue_size].pkt_size = pkt_size;
-    lgtd_tests_gw_pkt_queue_size++;
+    lgtd_tests_gw_pkt_ring[lgtd_tests_gw_pkt_ring_size].pkt = pkt;
+    lgtd_tests_gw_pkt_ring[lgtd_tests_gw_pkt_ring_size].pkt_size = pkt_size;
+    lgtd_tests_gw_pkt_ring_size++;
 }
diff --git a/tests/lifx/gateway/CMakeLists.txt b/tests/lifx/gateway/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/CMakeLists.txt
@@ -0,0 +1,27 @@
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+ADD_LIBRARY(
+    test_lifx_gateway STATIC
+    ${LIGHTSD_SOURCE_DIR}/core/log.c
+    ${LIGHTSD_SOURCE_DIR}/core/proto.c
+    ${LIGHTSD_SOURCE_DIR}/core/router.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/broadcast.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/tagging.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
+    ${TIME_MONOTONIC_IMPL}
+)
+
+FUNCTION(ADD_GATEWAY_TEST TEST_SOURCE)
+    ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE} test_lifx_gateway)
+ENDFUNCTION()
+
+FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
+FOREACH(TEST ${TESTS})
+    ADD_GATEWAY_TEST(${TEST})
+ENDFOREACH()
diff --git a/tests/lifx/gateway/test_gateway_enqueue_packet.c b/tests/lifx/gateway/test_gateway_enqueue_packet.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_enqueue_packet.c
@@ -0,0 +1,65 @@
+#include "gateway.c"
+
+#include "test_gateway_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+    gw.write_ev = (void *)42;
+
+    struct lgtd_lifx_packet_power_state pkt;
+    pkt.power = LGTD_LIFX_POWER_ON;
+
+    union lgtd_lifx_target target = { .tags = 0 };
+
+    struct lgtd_lifx_packet_header hdr;
+    lgtd_lifx_wire_setup_header(
+        &hdr,
+        LGTD_LIFX_TARGET_ALL_DEVICES,
+        target,
+        gw.site,
+        LGTD_LIFX_SET_POWER_STATE
+    );
+
+    lgtd_lifx_gateway_enqueue_packet(
+        &gw, &hdr, LGTD_LIFX_SET_POWER_STATE, &pkt, sizeof(pkt)
+    );
+
+    if (memcmp(gw_write_buf, &hdr, sizeof(hdr))) {
+        errx(1, "header incorrectly buffered");
+    }
+
+    if (memcmp(&gw_write_buf[sizeof(hdr)], &pkt, sizeof(pkt))) {
+        errx(1, "pkt incorrectly buffered");
+    }
+
+    if (gw.pkt_ring[0].type != LGTD_LIFX_SET_POWER_STATE) {
+        errx(1, "packet type incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring[0].size != sizeof(pkt) + sizeof(hdr)) {
+        errx(1, "packet size incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring_head != 1) {
+        errx(1, "packet ring head should be on index 1");
+    }
+
+    if (gw.pkt_ring_tail != 0) {
+        errx(1, "packet ring tail should be on index 0");
+    }
+
+    if (gw.pkt_ring_full == true) {
+        errx(1, "packet ring shouldn't be full");
+    }
+
+    if (last_event_passed_to_event_add != gw.write_ev) {
+        errx(1, "event_add should have been called with gw.write_ev");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_utils.h b/tests/lifx/gateway/test_gateway_utils.h
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_utils.h
@@ -0,0 +1,130 @@
+#pragma once
+
+static char gw_write_buf[4096] = { 0 };
+static int gw_write_buf_idx = 0;
+
+static inline void
+reset_gw_write_buf(void)
+{
+    memset(gw_write_buf, 0, sizeof(gw_write_buf));
+    gw_write_buf_idx = 0;
+}
+
+int
+evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen)
+{
+    (void)buf;
+    int to_write = LGTD_MIN(
+        datlen, sizeof(gw_write_buf) - gw_write_buf_idx
+    );
+    memcpy(&gw_write_buf[gw_write_buf_idx], data, to_write);
+    gw_write_buf_idx += to_write;
+    return 0;
+}
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    (void)buf;
+    return gw_write_buf_idx + 1;
+}
+
+int
+evbuffer_write_atmost(struct evbuffer *buf,
+                      evutil_socket_t fd,
+                      ev_ssize_t howmuch)
+{
+    (void)buf;
+    (void)fd;
+    (void)howmuch;
+    return howmuch;
+}
+
+struct evbuffer *
+evbuffer_new(void)
+{
+    return NULL;
+}
+
+void
+evbuffer_free(struct evbuffer *buf)
+{
+    (void)buf;
+}
+
+
+static struct event *last_event_passed_to_event_add = NULL;
+
+int
+event_add(struct event *ev, const struct timeval *timeout)
+{
+    (void)timeout;
+    last_event_passed_to_event_add = ev;
+    return 0;
+}
+
+int
+event_del(struct event *ev)
+{
+    (void)ev;
+    return 0;
+}
+
+void
+event_active(struct event *ev, int res, short ncalls)
+{
+    (void)ev;
+    (void)res;
+    (void)ncalls;
+}
+
+struct event *
+event_new(struct event_base *evbase,
+          evutil_socket_t sock,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    (void)evbase;
+    (void)sock;
+    (void)events;
+    (void)cb;
+    (void)ctx;
+    return NULL;
+}
+
+void
+event_free(struct event *ev)
+{
+    (void)ev;
+}
+
+int
+event_pending(const struct event *ev, short events, struct timeval *tv)
+{
+    (void)ev;
+    (void)events;
+    (void)tv;
+    return 0;
+}
+
+int
+evutil_closesocket(evutil_socket_t sock)
+{
+    (void)sock;
+    return 0;
+}
+
+int
+evutil_make_socket_nonblocking(evutil_socket_t sock)
+{
+    (void)sock;
+    return 0;
+}
+
+int
+evutil_make_listen_socket_reuseable(evutil_socket_t sock)
+{
+    (void)sock;
+    return 0;
+}
diff --git a/tests/lifx/tests_shims.c b/tests/lifx/tests_shims.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/tests_shims.c
@@ -0,0 +1,37 @@
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+#include "core/lightsd.h"
+
+struct lgtd_opts lgtd_opts = {
+    .foreground = false,
+    .log_timestamps = false,
+    .verbosity = LGTD_DEBUG
+};
+
+struct event_base *lgtd_ev_base = NULL;
+
+void
+lgtd_cleanup(void)
+{
+}
+
+short
+lgtd_sockaddrport(const struct sockaddr_storage *peer)
+{
+    if (!peer) {
+        return -1;
+    }
+
+    if (peer->ss_family == AF_INET) {
+        const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
+        return ntohs(in_peer->sin_port);
+    } else {
+        const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
+        return ntohs(in6_peer->sin6_port);
+    }
+}
diff --git a/tests/lifx/wire_proto/test_wire_proto_utils.h b/tests/lifx/wire_proto/test_wire_proto_utils.h
--- a/tests/lifx/wire_proto/test_wire_proto_utils.h
+++ b/tests/lifx/wire_proto/test_wire_proto_utils.h
@@ -26,3 +26,12 @@
     (void)hdr;
     (void)pkt;
 }
+
+void lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *gw,
+                                         const struct lgtd_lifx_packet_header *hdr,
+                                         const struct lgtd_lifx_packet_tag_labels *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
