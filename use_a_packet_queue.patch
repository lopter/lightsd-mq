# HG changeset patch
# Parent  0110fc76a59b42fe5dca91ef4bc60707af6b6a34
Send one lifx packet per UDP datagram with a queue

The firmware doesn't seem to support one more than one packet per
datagram.

diff --git a/core/router.c b/core/router.c
--- a/core/router.c
+++ b/core/router.c
@@ -55,7 +55,9 @@
             &hdr, LGTD_LIFX_TARGET_ALL_DEVICES, target, gw->site, pkt_type
         );
         assert(pkt_infos);
-        lgtd_lifx_gateway_send_packet(gw, &hdr, pkt, pkt_infos->size);
+        lgtd_lifx_gateway_enqueue_packet(
+            gw, &hdr, pkt_type, pkt, pkt_infos->size
+        );
         struct lgtd_lifx_bulb *bulb;
         lgtd_time_mono_t now = lgtd_time_monotonic_msecs();
         SLIST_FOREACH(bulb, &gw->bulbs, link_by_gw) {
@@ -88,7 +90,9 @@
     );
     assert(pkt_infos);
 
-    lgtd_lifx_gateway_send_packet(bulb->gw, &hdr, pkt, pkt_infos->size);
+    lgtd_lifx_gateway_enqueue_packet(
+        bulb->gw, &hdr, pkt_type, pkt, pkt_infos->size
+    );
 
     if (pkt_type == LGTD_LIFX_SET_POWER_STATE) {
         bulb->dirty_at = lgtd_time_monotonic_msecs();
diff --git a/core/router.h b/core/router.h
--- a/core/router.h
+++ b/core/router.h
@@ -17,6 +17,12 @@
 
 #pragma once
 
+// TODO: return that from the functions in there and handle it:
+enum lgtd_router_error {
+    LGTD_ROUTER_INVALID_TARGET_ERROR,
+    LGTD_ROUTER_CANNOT_ENQUEUE_PACKET_ERROR
+};
+
 bool lgtd_router_send(const struct lgtd_proto_target_list *, enum lgtd_lifx_packet_type, void *);
 void lgtd_router_send_to_device(struct lgtd_lifx_bulb *, enum lgtd_lifx_packet_type, void *);
 void lgtd_router_broadcast(enum lgtd_lifx_packet_type, void *);
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -93,6 +93,7 @@
     assert(ctx);
 
     struct lgtd_lifx_gateway *gw = (struct lgtd_lifx_gateway *)ctx;
+
     if (events & EV_TIMEOUT) {  // Not sure how that could happen in UDP but eh.
         lgtd_warn(
             "lost connection with gateway bulb [%s]:%hu", gw->ip_addr, gw->port
@@ -103,8 +104,13 @@
         }
         return;
     }
+
     if (events & EV_WRITE) {
-        int nbytes = evbuffer_write(gw->write_buf, gw->socket);
+        assert(gw->pkt_queue_tail >= 0);
+        assert(gw->pkt_queue_tail < LGTD_LIFX_ARRAY_SIZE(gw->pkt_queue));
+
+        int to_write = gw->pkt_queue[gw->pkt_queue_tail].size;
+        int nbytes = evbuffer_write_atmost(gw->write_buf, gw->socket, to_write);
         if (nbytes == -1 && errno != EAGAIN) {
             lgtd_warn("can't write to [%s]:%hu", gw->ip_addr, gw->port);
             lgtd_lifx_gateway_close(gw);
@@ -113,16 +119,32 @@
             }
             return;
         }
+
         // Callbacks are called in any order, so we keep two timers to make
         // sure we can get the latency right, otherwise we could be compute the
         // latency with last_pkt_at < last_req_at, which isn't true since the
         // pkt will be for an answer to the previous write:
         gw->last_req_at = gw->next_req_at;
         gw->next_req_at = lgtd_time_monotonic_msecs();
-        // XXX this isn't perfect because we don't know what we just sent, I
-        // just assume that everything pending will alway be transmitted in a
-        // single call:
-        gw->pending_refresh_req = false;
+
+        gw->pkt_queue[gw->pkt_queue_tail].size -= nbytes;
+        if (gw->pkt_queue[gw->pkt_queue_tail].size == 0) {
+            enum lgtd_lifx_packet_type type;
+            type = gw->pkt_queue[gw->pkt_queue_tail].type;
+            if (type == LGTD_LIFX_GET_TAG_LABELS) {
+                gw->pending_refresh_req = false;
+            }
+            if (lgtd_opts.verbosity <= LGTD_DEBUG) {
+                const struct lgtd_lifx_packet_infos *pkt_infos =
+                    lgtd_lifx_wire_get_packet_infos(type);
+                lgtd_debug(
+                    "%s --> [%s]:%hu", pkt_infos->name, gw->ip_addr, gw->port
+                );
+            }
+            LGTD_LIFX_GATEWAY_INC_MESSAGE_QUEUE_INDEX(gw->pkt_queue_tail);
+            gw->pkt_queue_full = false;
+        }
+
         if (!evbuffer_get_length(gw->write_buf)) {
             event_del(gw->write_ev);
         }
@@ -136,20 +158,21 @@
 
     struct lgtd_lifx_packet_header hdr;
     union lgtd_lifx_target target = { .addr = gw->site };
-    lgtd_debug(
-        "GET_LIGHT_STATE+GET_TAG_LABELS --> [%s]:%hu", gw->ip_addr, gw->port
-    );
 
     lgtd_lifx_wire_setup_header(
         &hdr, LGTD_LIFX_TARGET_SITE, target, gw->site, LGTD_LIFX_GET_LIGHT_STATE
     );
-    lgtd_lifx_gateway_send_packet(gw, &hdr, NULL, 0);
+    lgtd_lifx_gateway_enqueue_packet(
+        gw, &hdr, LGTD_LIFX_GET_LIGHT_STATE, NULL, 0
+    );
 
     struct lgtd_lifx_packet_get_tag_labels pkt = { .tags = LGTD_LIFX_ALL_TAGS };
     lgtd_lifx_wire_setup_header(
         &hdr, LGTD_LIFX_TARGET_SITE, target, gw->site, LGTD_LIFX_GET_TAG_LABELS
     );
-    lgtd_lifx_gateway_send_packet(gw, &hdr, &pkt, sizeof(pkt));
+    lgtd_lifx_gateway_enqueue_packet(
+        gw, &hdr, LGTD_LIFX_GET_TAG_LABELS, &pkt, sizeof(pkt)
+    );
 
     gw->pending_refresh_req = true;
 }
@@ -308,21 +331,37 @@
 }
 
 void
-lgtd_lifx_gateway_send_packet(struct lgtd_lifx_gateway *gw,
-                              const struct lgtd_lifx_packet_header *hdr,
-                              const void *pkt,
-                              int pkt_size)
+lgtd_lifx_gateway_enqueue_packet(struct lgtd_lifx_gateway *gw,
+                                 const struct lgtd_lifx_packet_header *hdr,
+                                 enum lgtd_lifx_packet_type pkt_type,
+                                 const void *pkt,
+                                 int pkt_size)
 {
     assert(gw);
     assert(hdr);
     assert(pkt_size >= 0 && pkt_size < LGTD_LIFX_MAX_PACKET_SIZE);
     assert(!memcmp(hdr->site, gw->site, LGTD_LIFX_ADDR_LENGTH));
+    assert(gw->pkt_queue_head >= 0);
+    assert(gw->pkt_queue_head < LGTD_LIFX_ARRAY_SIZE(gw->pkt_queue));
+
+    if (gw->pkt_queue_full) {
+        lgtd_warnx(
+            "dropping packet type %#x: packet queue is full", hdr->packet_type
+        );
+        return;
+    }
 
     evbuffer_add(gw->write_buf, hdr, sizeof(*hdr));
     if (pkt) {
         assert((unsigned)pkt_size == le16toh(hdr->size) - sizeof(*hdr));
         evbuffer_add(gw->write_buf, pkt, pkt_size);
     }
+    gw->pkt_queue[gw->pkt_queue_head].size = sizeof(*hdr) + pkt_size;
+    gw->pkt_queue[gw->pkt_queue_head].type = pkt_type;
+    LGTD_LIFX_GATEWAY_INC_MESSAGE_QUEUE_INDEX(gw->pkt_queue_head);
+    if (gw->pkt_queue_head == gw->pkt_queue_tail) {
+        gw->pkt_queue_full = true;
+    }
     event_add(gw->write_ev, NULL);
 }
 
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -23,6 +23,14 @@
 // still draw about 2W in ZigBee and about 3W in WiFi).
 enum { LGTD_LIFX_GATEWAY_MIN_REFRESH_INTERVAL_MSECS = 200 };
 
+// You can't send more than one lifx packet per UDP datagram.
+enum { LGTD_LIFX_GATEWAY_PACKET_QUEUE_SIZE = 50 };
+
+struct lgtd_lifx_message {
+    enum lgtd_lifx_packet_type  type;
+    int                         size;
+};
+
 struct lgtd_lifx_gateway {
     LIST_ENTRY(lgtd_lifx_gateway)   link;
     struct lgtd_lifx_bulb_list      bulbs;
@@ -43,6 +51,13 @@
     lgtd_time_mono_t                last_req_at;
     lgtd_time_mono_t                next_req_at;
     lgtd_time_mono_t                last_pkt_at;
+    struct lgtd_lifx_message        pkt_queue[LGTD_LIFX_GATEWAY_PACKET_QUEUE_SIZE];
+#define LGTD_LIFX_INC_MESSAGE_QUEUE_INDEX(idx)  do {    \
+    (idx) += 1;                                         \
+    (idx) %= LGTD_LIFX_GATEWAY_PACKET_QUEUE_SIZE;       \
+} while(0)
+    int                             pkt_queue_head;
+    int                             pkt_queue_tail;
     struct event                    *write_ev;
     struct evbuffer                 *write_buf;
     bool                            pending_refresh_req;
@@ -63,10 +78,11 @@
 
 void lgtd_lifx_gateway_force_refresh(struct lgtd_lifx_gateway *);
 
-void lgtd_lifx_gateway_send_packet(struct lgtd_lifx_gateway *,
-                                   const struct lgtd_lifx_packet_header *,
-                                   const void *,
-                                   int);
+void lgtd_lifx_gateway_enqueue_packet(struct lgtd_lifx_gateway *,
+                                      const struct lgtd_lifx_packet_header *,
+                                      enum lgtd_lifx_packet_type,
+                                      const void *,
+                                      int);
 
 void lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *,
                                           const struct lgtd_lifx_packet_header *,
