# HG changeset patch
# Parent 4417dc7761b7cefed8dc2f5c82061dac10914d0a
Re-transmit GET_LIGHT_STATUS instead of waiting for the gateway to timeout

diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -145,6 +145,14 @@
     lgtd_lifx_gateway_send_get_all_light_state((struct lgtd_lifx_gateway *)ctx);
 }
 
+void
+lgtd_lifx_gateway_force_refresh(struct lgtd_lifx_gateway *gw)
+{
+    assert(gw);
+
+    event_active(gw->refresh_ev, 0, 0);
+}
+
 static struct lgtd_lifx_bulb *
 lgtd_lifx_gateway_get_or_open_bulb(struct lgtd_lifx_gateway *gw,
                                    const uint8_t *bulb_addr)
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -72,6 +72,8 @@
 void lgtd_lifx_gateway_close(struct lgtd_lifx_gateway *);
 void lgtd_lifx_gateway_close_all(void);
 
+void lgtd_lifx_gateway_force_refresh(struct lgtd_lifx_gateway *);
+
 void lgtd_lifx_gateway_send_packet(struct lgtd_lifx_gateway *,
                                    const struct lgtd_lifx_packet_header *,
                                    const void *,
diff --git a/lifx/timer.c b/lifx/timer.c
--- a/lifx/timer.c
+++ b/lifx/timer.c
@@ -126,6 +126,12 @@
             );
             lgtd_lifx_gateway_close(gw);
             start_discovery = true;
+        } else if (gw_lag >= LGTD_LIFX_TIMER_DEVICE_FORCE_REFRESH_MSECS) {
+            lgtd_info(
+                "no update on bulb gateway [%s]:%hu for %dms, forcing refresh",
+                gw->ip_addr, gw->port, gw_lag
+            );
+            lgtd_lifx_gateway_force_refresh(gw);
         }
     }
 
diff --git a/lifx/timer.h b/lifx/timer.h
--- a/lifx/timer.h
+++ b/lifx/timer.h
@@ -33,6 +33,7 @@
 enum { LGTD_LIFX_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS = 2000 };
 enum { LGTD_LIFX_TIMER_PASSIVE_DISCOVERY_INTERVAL_MSECS = 10000 };
 enum { LGTD_LIFX_TIMER_DEVICE_TIMEOUT_MSECS = 2000 };
+enum { LGTD_LIFX_TIMER_DEVICE_FORCE_REFRESH_MSECS = 600 };
 
 bool lgtd_lifx_timer_setup(void);
 void lgtd_lifx_timer_close(void);
