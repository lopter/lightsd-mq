# HG changeset patch
# Parent  2ae975b26d16104b7fd10a3bd49d4095ddc80a29
Add support for JSON-RPC batch requests/responses

diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -163,6 +163,13 @@
 }
 
 static bool
+lgtd_jsonrpc_type_object(const jsmntok_t *t, const char *json)
+{
+    (void)json;
+    return t->type == JSMN_OBJECT;
+}
+
+static bool
 lgtd_jsonrpc_type_object_or_array(const jsmntok_t *t, const char *json)
 {
     (void)json;
@@ -327,9 +334,9 @@
     }
 
     for (int ti = 1; ti < ntokens;) {
-        // make sure it's a key:
+        // make sure it's a key, otherwise we reached the end of the object:
         if (tokens[ti].type != JSMN_STRING) {
-            return false;
+            break;
         }
 
         int si = 0;
@@ -578,7 +585,7 @@
         )
     };
 
-    return lgtd_jsonrpc_extract_values_from_schema_and_dict(
+    bool ok = lgtd_jsonrpc_extract_values_from_schema_and_dict(
         request,
         request_schema,
         LGTD_ARRAY_SIZE(request_schema),
@@ -586,6 +593,19 @@
         ntokens,
         json
     );
+    if (!ok) {
+        return false;
+    }
+
+    request->request_ntokens = 1 + 2 + 2; // dict itself + jsonrpc + method
+    if (request->params) {
+        request->request_ntokens += 1 + request->params_ntokens;
+    }
+    if (request->id) {
+        request->request_ntokens += 2;
+    }
+
+    return true;
 }
 
 static bool
@@ -1055,8 +1075,10 @@
     );
 }
 
-void
-lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+static void
+lgtd_jsonrpc_dispatch_one(struct lgtd_client *client,
+                          const jsmntok_t *tokens,
+                          int ntokens)
 {
     static const struct lgtd_jsonrpc_method methods[] = {
         LGTD_JSONRPC_METHOD(
@@ -1098,18 +1120,10 @@
         )
     };
 
-    assert(client);
-    assert(parsed >= 0);
-
-    // TODO: batch requests
-
     struct lgtd_jsonrpc_request request;
     memset(&request, 0, sizeof(request));
     bool ok = lgtd_jsonrpc_check_and_extract_request(
-        &request,
-        client->jsmn_tokens,
-        parsed,
-        client->json
+        &request, tokens, ntokens, client->json
     );
     client->current_request = &request;
     if (!ok) {
@@ -1150,3 +1164,47 @@
 error:
     client->current_request = NULL;
 }
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    assert(client);
+    assert(parsed >= 0);
+
+    if (!parsed || !client->jsmn_tokens[0].size) {
+        lgtd_jsonrpc_send_error(
+            client, LGTD_JSONRPC_INVALID_REQUEST, "Invalid request"
+        );
+        return;
+    }
+
+    if (!lgtd_jsonrpc_type_array(client->jsmn_tokens, client->json)) {
+        lgtd_jsonrpc_dispatch_one(client, client->jsmn_tokens, parsed);
+        return;
+    }
+
+    bool comma = false;
+    for (int ti = 1; ti < parsed;) {
+        const jsmntok_t *tok = &client->jsmn_tokens[ti];
+
+        lgtd_client_write_string(client, comma ? "," : "[");
+        comma = true;
+
+        if (lgtd_jsonrpc_type_object(tok, client->json)) {
+            lgtd_jsonrpc_dispatch_one(client, tok, parsed - ti);
+        } else {
+            lgtd_jsonrpc_send_error(
+                client, LGTD_JSONRPC_INVALID_REQUEST, "Invalid request"
+            );
+        }
+
+        if (lgtd_jsonrpc_type_object_or_array(tok, client->json)) {
+            ti = lgtd_jsonrpc_consume_object_or_array(
+                client->jsmn_tokens, ti, parsed, client->json
+            );
+        } else {
+            ti++;
+        }
+    }
+    lgtd_client_write_string(client, "]");
+}
diff --git a/core/jsonrpc.h b/core/jsonrpc.h
--- a/core/jsonrpc.h
+++ b/core/jsonrpc.h
@@ -26,6 +26,7 @@
     const jsmntok_t *params;
     int             params_ntokens;
     const jsmntok_t *id;
+    int             request_ntokens;
 };
 
 struct lgtd_jsonrpc_node {
@@ -45,7 +46,7 @@
     *(const jsmntok_t **)(&((char *)(object))[value_offset]);
 
 #define LGTD_JSONRPC_SET_NTOKENS(object, ntokens_offset, ntokens) do {  \
-    *(int *)(&(((char *)(object))[ntokens_offset])) = (ntokens);          \
+    *(int *)(&(((char *)(object))[ntokens_offset])) = (ntokens);        \
 } while (0)
 
 #define LGTD_JSONRPC_NODE(key_, value_offset_, ntokens_offset_, fn_type_cmp, optional_)   { \
diff --git a/examples/lightsc.py b/examples/lightsc.py
--- a/examples/lightsc.py
+++ b/examples/lightsc.py
@@ -1,154 +1,183 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
+# Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice,
+#    this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice,
+#    this list of conditions and the following disclaimer in the documentation
+#    and/or other materials provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors
+#    may be used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
 
+import contextlib
 import json
 import socket
 import sys
-import time
 import uuid
 
 from IPython.terminal.embed import InteractiveShellEmbed
 
 
-def jsonrpc_call(socket, method, params):
-    payload = {
-        "method": method,
-        "params": params,
-        "jsonrpc": "2.0",
-        "id": str(uuid.uuid4()),
-    }
-    socket.send(json.dumps(payload).encode("utf-8"))
-    response = socket.recv(8192).decode("utf-8")
-    try:
-        response = json.loads(response)
-    except ValueError:
-        print("received invalid json: {}".format(response))
-        return None
-    return response
+class LightsClient:
 
+    def __init__(self, host, port):
+        self._socket = socket.create_connection((host, port))
+        self._pipeline = []
+        self._batch = False
 
-def set_light_from_hsbk(socket, target, h, s, b, k, t):
-    return jsonrpc_call(socket, "set_light_from_hsbk", [
-        target, h, s, b, k, t
-    ])
+    @classmethod
+    def _make_payload(cls, method, params):
+        return {
+            "method": method,
+            "params": params,
+            "jsonrpc": "2.0",
+            "id": str(uuid.uuid4()),
+        }
 
+    def _execute_payload(self, payload):
+        self._socket.send(json.dumps(payload).encode("utf-8"))
+        response = self._socket.recv(8192).decode("utf-8")
+        try:
+            response = json.loads(response)
+        except Exception:
+            print("received invalid json: {}".format(response))
 
-def set_waveform(socket, target, waveform,
-                 h, s, b, k,
-                 period, cycles, skew_ratio, transient):
-    return jsonrpc_call(socket, "set_waveform", [
-        target, waveform, h, s, b, k, period, cycles, skew_ratio, transient
-    ])
+        return response
 
+    def _jsonrpc_call(self, method, params):
+        payload = self._make_payload(method, params)
+        if self._batch:
+            self._pipeline.append(payload)
+            return
+        return self._execute_payload(payload)
 
-def saw(socket, target, h, s, b, k, period, cycles, transient=True):
-    return set_waveform(
-        socket, target, "SAW", h, s, b, k,
-        cycles=cycles,
-        period=period,
-        skew_ratio=0.5,
-        transient=transient
-    )
+    @contextlib.contextmanager
+    def batch(self):
+        self._batch = True
+        response = []
+        yield response
+        self._batch = False
+        result = self._execute_payload(self._pipeline)
+        if isinstance(result, list):
+            response.extend(result)
+        else:
+            response.append(result)
+        self._pipeline = []
 
+    def set_light_from_hsbk(self, target, h, s, b, k, t):
+        return self._jsonrpc_call("set_light_from_hsbk", [
+            target, h, s, b, k, t
+        ])
 
-def sine(socket, target, h, s, b, k, period, cycles, peak=0.5, transient=True):
-    return set_waveform(
-        socket, target, "SINE", h, s, b, k,
-        cycles=cycles,
-        period=period,
-        skew_ratio=peak,
-        transient=transient
-    )
+    def set_waveform(self, target, waveform,
+                     h, s, b, k,
+                     period, cycles, skew_ratio, transient):
+        return self._jsonrpc_call("set_waveform", [
+            target, waveform, h, s, b, k, period, cycles, skew_ratio, transient
+        ])
 
+    def saw(self, target, h, s, b, k, period, cycles, transient=True):
+        return self.set_waveform(
+            target, "SAW", h, s, b, k,
+            cycles=cycles,
+            period=period,
+            skew_ratio=0.5,
+            transient=transient
+        )
 
-def half_sine(socket, target, h, s, b, k, period, cycles, transient=True):
-    return set_waveform(
-        socket, target, "HALF_SINE", h, s, b, k,
-        cycles=cycles,
-        period=period,
-        skew_ratio=0.5,
-        transient=transient
-    )
+    def sine(self, target, h, s, b, k,
+             period, cycles, peak=0.5, transient=True):
+        return self.set_waveform(
+            target, "SINE", h, s, b, k,
+            cycles=cycles,
+            period=period,
+            skew_ratio=peak,
+            transient=transient
+        )
 
+    def half_sine(self, target, h, s, b, k, period, cycles, transient=True):
+        return self.set_waveform(
+            target, "HALF_SINE", h, s, b, k,
+            cycles=cycles,
+            period=period,
+            skew_ratio=0.5,
+            transient=transient
+        )
 
-def triangle(socket, target, h, s, b, k,
-             period, cycles, peak=0.5, transient=True):
-    return set_waveform(
-        socket, target, "TRIANGLE", h, s, b, k,
-        cycles=cycles,
-        period=period,
-        skew_ratio=peak,
-        transient=transient
-    )
+    def triangle(self, target, h, s, b, k,
+                 period, cycles, peak=0.5, transient=True):
+        return self.set_waveform(
+            target, "TRIANGLE", h, s, b, k,
+            cycles=cycles,
+            period=period,
+            skew_ratio=peak,
+            transient=transient
+        )
 
+    def square(self, target, h, s, b, k, period, cycles,
+               duty_cycle=0.5, transient=True):
+        return self.set_waveform(
+            target, "SQUARE", h, s, b, k,
+            cycles=cycles,
+            period=period,
+            skew_ratio=duty_cycle,
+            transient=transient
+        )
 
-def square(socket, target, h, s, b, k, period, cycles,
-           duty_cycle=0.5, transient=True):
-    return set_waveform(
-        socket, target, "SQUARE", h, s, b, k,
-        cycles=cycles,
-        period=period,
-        skew_ratio=duty_cycle,
-        transient=transient
-    )
+    def power_on(self, target):
+        return self._jsonrpc_call("power_on", {"target": target})
 
+    def power_off(self, target):
+        return self._jsonrpc_call("power_off", {"target": target})
 
-def power_on(socket, target):
-    return jsonrpc_call(socket, "power_on", {"target": target})
+    def power_toggle(self, target):
+        return self._jsonrpc_call("power_toggle", {"target": target})
 
+    def get_light_state(self, target):
+        return self._jsonrpc_call("get_light_state", [target])
 
-def power_off(socket, target):
-    return jsonrpc_call(socket, "power_off", {"target": target})
+    def tag(self, target, tag):
+        return self._jsonrpc_call("tag", [target, tag])
 
+    def untag(self, target, tag):
+        return self._jsonrpc_call("untag", [target, tag])
 
-def power_toggle(socket, target):
-    return jsonrpc_call(socket, "power_toggle", {"target": target})
+    def set_label(self, target, label):
+        return self._jsonrpc_call("set_label", [target, label])
 
-
-def get_light_state(socket, target):
-    return jsonrpc_call(socket, "get_light_state", [target])
-
-
-def tag(socket, target, tag):
-    return jsonrpc_call(socket, "tag", [target, tag])
-
-
-def untag(socket, target, tag):
-    return jsonrpc_call(socket, "untag", [target, tag])
-
-
-def set_label(socket, target, label):
-    return jsonrpc_call(socket, "set_label", [target, label])
-
-
-def adjust_brightness(socket, target, adjustment):
-    bulbs = get_light_state(socket, target)["result"]
-    for bulb in bulbs:
-        h, s, b, k = bulb["hsbk"]
-        b += adjustment
-        b = max(min(b, 1.0), 0.0)
-        set_light_from_hsbk(socket, bulb["label"], h, s, b, k, 500)
-
+    def adjust_brightness(self, target, adjustment):
+        bulbs = self.get_light_state(target)["result"]
+        for bulb in bulbs:
+            h, s, b, k = bulb["hsbk"]
+            b += adjustment
+            b = max(min(b, 1.0), 0.0)
+            self.set_light_from_hsbk(bulb["label"], h, s, b, k, 500)
 
 if __name__ == "__main__":
-    s = socket.create_connection(("localhost", 1234))
-    h = 0
-    id = 0
+    c = LightsClient("localhost", 1234)
     nb = "d073d501a0d5"
     fugu = "d073d500603b"
     neko = "d073d5018fb6"
     middle = "d073d502e530"
-    target = "*"
-    try:
-        if len(sys.argv) == 2 and sys.argv[1] == "shell":
-            ipshell = InteractiveShellEmbed()
-            ipshell()
-            sys.exit(0)
-        power_on(s, target)
-        while True:
-            h = (h + 5) % 360
-            id += 1
-            set_light_from_hsbk(s, target, h, 0.8, 0.1, 2500, 450)
-            time.sleep(0.5)
-        power_off(s, target)
-    finally:
-        s.close()
+    ipshell = InteractiveShellEmbed()
+    ipshell()
+    sys.exit(0)
