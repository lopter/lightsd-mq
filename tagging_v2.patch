# HG changeset patch
# Parent  e4365dbb8d548bf60e1ec4bb9069f7a5cbd69d4f

diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -155,15 +155,11 @@
     lgtd_client_start_send_response(client);
 
     LGTD_CLIENT_WRITE_STRING(client, "[");
-    struct lgtd_lifx_label_sites_tags *label;
-    LIST_FOREACH(label, &lgtd_lifx_labels, link) {
+    struct lgtd_lifx_tag *tag;
+    LIST_FOREACH(tag, &lgtd_lifx_tags, link) {
         LGTD_CLIENT_WRITE_STRING(client, "\"");
-        LGTD_CLIENT_WRITE_STRING(client, label->label);
-        if (LIST_NEXT(label, link) != LIST_END(lgtd_lifx_labels)) {
-            LGTD_CLIENT_WRITE_STRING(client, "\",");
-        } else {
-            LGTD_CLIENT_WRITE_STRING(client, "\"");
-        }
+        LGTD_CLIENT_WRITE_STRING(client, tag->label);
+        LGTD_CLIENT_WRITE_STRING(client, LIST_NEXT(tag, link) ? "\", " : "\"");
     }
     LGTD_CLIENT_WRITE_STRING(client, "]");
 
diff --git a/core/router.c b/core/router.c
--- a/core/router.c
+++ b/core/router.c
@@ -52,7 +52,11 @@
     struct lgtd_lifx_gateway *gw;
     LIST_FOREACH(gw, &lgtd_lifx_gateways, link) {
         pkt_infos = lgtd_lifx_wire_setup_header(
-            &hdr, LGTD_LIFX_TARGET_ALL_DEVICES, target, gw->site, pkt_type
+            &hdr,
+            LGTD_LIFX_TARGET_ALL_DEVICES,
+            target,
+            gw->site.as_array,
+            pkt_type
         );
         assert(pkt_infos);
         lgtd_lifx_gateway_enqueue_packet(
@@ -86,7 +90,11 @@
 
     const struct lgtd_lifx_packet_infos *pkt_infos;
     pkt_infos = lgtd_lifx_wire_setup_header(
-        &hdr, LGTD_LIFX_TARGET_DEVICE, target, bulb->gw->site, pkt_type
+        &hdr,
+        LGTD_LIFX_TARGET_DEVICE,
+        target,
+        bulb->gw->site.as_array,
+        pkt_type
     );
     assert(pkt_infos);
 
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -49,6 +49,26 @@
 struct lgtd_lifx_gateway_list lgtd_lifx_gateways =
     LIST_HEAD_INITIALIZER(&lgtd_lifx_gateways);
 
+// Kim Walisch (2012)
+// http://chessprogramming.wikispaces.com/BitScan#DeBruijnMultiplation
+static inline int
+lgtd_lifx_bitscan64_forward(uint64_t n)
+{
+    enum { DEBRUIJN_NUMBER = 0x03f79d71b4cb0a89 };
+    static const int DEBRUIJN_SEQUENCE[64] = {
+        0, 47,  1, 56, 48, 27,  2, 60,
+       57, 49, 41, 37, 28, 16,  3, 61,
+       54, 58, 35, 52, 50, 42, 21, 44,
+       38, 32, 29, 23, 17, 11,  4, 62,
+       46, 55, 26, 59, 40, 36, 15, 53,
+       34, 51, 20, 43, 31, 22, 10, 45,
+       25, 39, 14, 33, 19, 30,  9, 24,
+       13, 18,  8, 12,  7,  6,  5, 63
+    };
+
+    return n ? DEBRUIJN_SEQUENCE[((n ^ (n - 1)) * DEBRUIJN_NUMBER) >> 58] : -1;
+}
+
 void
 lgtd_lifx_gateway_close(struct lgtd_lifx_gateway *gw)
 {
@@ -63,23 +83,19 @@
     event_free(gw->refresh_ev);
     event_free(gw->write_ev);
     evbuffer_free(gw->write_buf);
+    for (int i = 0; i != LGTD_LIFX_GATEWAY_MAX_TAGS; i++) {
+        if (gw->tags[i]) {
+            lgtd_lifx_tagging_decref(gw->tags[i], gw);
+        }
+    }
     struct lgtd_lifx_bulb *bulb, *next_bulb;
     SLIST_FOREACH_SAFE(bulb, &gw->bulbs, link_by_gw, next_bulb) {
         lgtd_lifx_bulb_close(bulb);
     }
 
-    struct lgtd_lifx_gateway *it;
-    LIST_FOREACH(it, &lgtd_lifx_gateways, link) {
-        if (!memcmp(it->site, gw->site, sizeof(it->site))) {
-            break;
-        }
-    }
-    if (it == LIST_END(&lgtd_lifx_gateways)) {
-        lgtd_lifx_tagging_remove_site(gw->site);
-    }
-
     lgtd_info(
-        "connection with gateway bulb [%s]:%hu closed", gw->ip_addr, gw->port
+        "connection with gateway bulb [%s]:%hu (site %s) closed",
+        gw->ip_addr, gw->port, lgtd_addrtoa(gw->site.as_array)
     );
     free(gw);
 }
@@ -158,10 +174,14 @@
     assert(gw);
 
     struct lgtd_lifx_packet_header hdr;
-    union lgtd_lifx_target target = { .addr = gw->site };
+    union lgtd_lifx_target target = { .addr = gw->site.as_array };
 
     lgtd_lifx_wire_setup_header(
-        &hdr, LGTD_LIFX_TARGET_SITE, target, gw->site, LGTD_LIFX_GET_LIGHT_STATE
+        &hdr,
+        LGTD_LIFX_TARGET_SITE,
+        target,
+        gw->site.as_array,
+        LGTD_LIFX_GET_LIGHT_STATE
     );
     lgtd_lifx_gateway_enqueue_packet(
         gw, &hdr, LGTD_LIFX_GET_LIGHT_STATE, NULL, 0
@@ -169,7 +189,11 @@
 
     struct lgtd_lifx_packet_get_tag_labels pkt = { .tags = LGTD_LIFX_ALL_TAGS };
     lgtd_lifx_wire_setup_header(
-        &hdr, LGTD_LIFX_TARGET_SITE, target, gw->site, LGTD_LIFX_GET_TAG_LABELS
+        &hdr,
+        LGTD_LIFX_TARGET_SITE,
+        target,
+        gw->site.as_array,
+        LGTD_LIFX_GET_TAG_LABELS
     );
     lgtd_lifx_gateway_enqueue_packet(
         gw, &hdr, LGTD_LIFX_GET_TAG_LABELS, &pkt, sizeof(pkt)
@@ -255,7 +279,7 @@
     memcpy(&gw->peer, peer, sizeof(gw->peer));
     lgtd_sockaddrtoa(peer, gw->ip_addr, sizeof(gw->ip_addr));
     gw->port = lgtd_sockaddrport(peer);
-    memcpy(gw->site, site, sizeof(gw->site));
+    memcpy(gw->site.as_array, site, sizeof(gw->site.as_array));
     gw->last_req_at = received_at;
     gw->next_req_at = received_at;
     gw->last_pkt_at = received_at;
@@ -270,16 +294,9 @@
         goto error_allocate;
     }
 
-    if (!lgtd_lifx_tagging_add_site(gw->site)) {
-        lgtd_warn(
-            "can't allocate a new tag table for site %s", lgtd_addrtoa(gw->site)
-        );
-        goto error_allocate;
-    }
-
     lgtd_info(
         "gateway for site %s at [%s]:%hu",
-        lgtd_addrtoa(gw->site), gw->ip_addr, gw->port
+        lgtd_addrtoa(gw->site.as_array), gw->ip_addr, gw->port
     );
     LIST_INSERT_HEAD(&lgtd_lifx_gateways, gw, link);
 
@@ -341,7 +358,7 @@
     assert(gw);
     assert(hdr);
     assert(pkt_size >= 0 && pkt_size < LGTD_LIFX_MAX_PACKET_SIZE);
-    assert(!memcmp(hdr->site, gw->site, LGTD_LIFX_ADDR_LENGTH));
+    assert(!memcmp(hdr->site, gw->site.as_array, LGTD_LIFX_ADDR_LENGTH));
     assert(gw->pkt_ring_head >= 0);
     assert(gw->pkt_ring_head < (int)LGTD_ARRAY_SIZE(gw->pkt_ring));
 
@@ -480,9 +497,65 @@
     lgtd_lifx_bulb_set_power_state(b, pkt->power);
 }
 
-void lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *gw,
-                                         const struct lgtd_lifx_packet_header *hdr,
-                                         const struct lgtd_lifx_packet_tag_labels *pkt)
+#define TAG_ID_TO_VALUE(x) (1 << (x))
+
+int
+lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *gw,
+                                  int tag_id,
+                                  const char *tag_label)
+{
+    assert(gw);
+    assert(tag_label);
+    // allocating a new tag_id (tag_id == -1) isn't supported yet:
+    assert(tag_id >= 0);
+    assert(tag_id < LGTD_LIFX_GATEWAY_MAX_TAGS);
+
+    if (!(gw->tag_ids & TAG_ID_TO_VALUE(tag_id))) {
+        struct lgtd_lifx_tag *tag;
+        tag = lgtd_lifx_tagging_incref(tag_label, gw);
+        if (!tag) {
+            lgtd_warn(
+                "couldn't allocate a new reference to tag [%s] (site %s)",
+                tag_label, lgtd_addrtoa(gw->site.as_array)
+            );
+            return -1;
+        }
+        lgtd_debug(
+            "tag_id %d allocated for tag [%s] on gw [%s]:%hu (site %s)",
+            tag_id, tag_label, gw->ip_addr, gw->port,
+            lgtd_addrtoa(gw->site.as_array)
+        );
+        gw->tag_ids |= TAG_ID_TO_VALUE(tag_id);
+        gw->tags[tag_id] = tag;
+    }
+
+    return tag_id;
+}
+
+void
+lgtd_lifx_gateway_deallocate_tag_id(struct lgtd_lifx_gateway *gw, int tag_id)
+{
+    assert(gw);
+    assert(tag_id >= 0);
+    assert(tag_id < LGTD_LIFX_GATEWAY_MAX_TAGS);
+
+    if (gw->tag_ids & TAG_ID_TO_VALUE(tag_id)) {
+        lgtd_debug(
+            "tag_id %d deallocated for tag [%s] on gw [%s]:%hu (site %s)",
+            tag_id, gw->tags[tag_id]->label,
+            gw->ip_addr, gw->port,
+            lgtd_addrtoa(gw->site.as_array)
+        );
+        lgtd_lifx_tagging_decref(gw->tags[tag_id], gw);
+        gw->tag_ids &= ~TAG_ID_TO_VALUE(tag_id);
+        gw->tags[tag_id] = NULL;
+    }
+}
+
+void
+lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *gw,
+                                    const struct lgtd_lifx_packet_header *hdr,
+                                    const struct lgtd_lifx_packet_tag_labels *pkt)
 {
     assert(gw && hdr && pkt);
 
@@ -492,5 +565,17 @@
         pkt->label, (uintmax_t)pkt->tags
     );
 
-    lgtd_lifx_tagging_update(gw->site, pkt->label, pkt->tags);
+    uint64_t tags = pkt->tags;
+    while (true) {
+        int tag_id = lgtd_lifx_bitscan64_forward(tags);
+        if (tag_id == -1) {
+            break;
+        }
+        if (pkt->label[0]) {
+            lgtd_lifx_gateway_allocate_tag_id(gw, tag_id, pkt->label);
+        } else if (gw->tags[tag_id]) {
+            lgtd_lifx_gateway_deallocate_tag_id(gw, tag_id);
+        }
+        tags &= ~TAG_ID_TO_VALUE(tag_id);
+    }
 }
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -26,6 +26,8 @@
 // You can't send more than one lifx packet per UDP datagram.
 enum { LGTD_LIFX_GATEWAY_PACKET_RING_SIZE = 16 };
 
+enum { LGTD_LIFX_GATEWAY_MAX_TAGS = 64 };
+
 struct lgtd_lifx_message {
     enum lgtd_lifx_packet_type  type;
     int                         size;
@@ -42,7 +44,13 @@
     struct sockaddr_storage         peer;
     char                            ip_addr[INET6_ADDRSTRLEN];
     uint16_t                        port;
-    uint8_t                         site[LGTD_LIFX_ADDR_LENGTH];
+    // TODO: just use an integer and rename it to site_id:
+    union {
+        uint8_t                     as_array[LGTD_LIFX_ADDR_LENGTH];
+        uint64_t                    as_integer;
+    }                               site;
+    uint64_t                        tag_ids;
+    struct lgtd_lifx_tag            *tags[LGTD_LIFX_GATEWAY_MAX_TAGS];
     evutil_socket_t                 socket;
     // Those three timers let us measure the latency of the gateway. If we
     // aren't the only client on the network then this won't be accurate since
@@ -85,6 +93,9 @@
                                       const void *,
                                       int);
 
+int lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *, int, const char *);
+void lgtd_lifx_gateway_deallocate_tag_id(struct lgtd_lifx_gateway *, int);
+
 void lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *,
                                           const struct lgtd_lifx_packet_header *,
                                           const struct lgtd_lifx_packet_pan_gateway *);
diff --git a/lifx/tagging.c b/lifx/tagging.c
--- a/lifx/tagging.c
+++ b/lifx/tagging.c
@@ -21,6 +21,7 @@
 #include <assert.h>
 #include <endian.h>
 #include <err.h>
+#include <errno.h>
 #include <stdarg.h>
 #include <stdbool.h>
 #include <stdint.h>
@@ -30,183 +31,105 @@
 #include <event2/util.h>
 
 #include "wire_proto.h"
+#include "core/time_monotonic.h"
+#include "bulb.h"
+#include "gateway.h"
 #include "tagging.h"
 #include "core/lightsd.h"
 
-static struct lgtd_lifx_site_tags_list lgtd_lifx_site_tags_map =
-    LIST_HEAD_INITIALIZER(&lgtd_lifx_site_tags_map);
-struct lgtd_lifx_label_sites_tags_list lgtd_lifx_labels =
-    LIST_HEAD_INITIALIZER(&lgtd_lifx_labels);
+struct lgtd_lifx_tag_list lgtd_lifx_tags =
+    LIST_HEAD_INITIALIZER(&lgtd_lifx_tags);
 
-// Kim Walisch (2012)
-// http://chessprogramming.wikispaces.com/BitScan#DeBruijnMultiplation
-static inline int
-lgtd_lifx_tagging_bitscan64_forward(uint64_t n)
+static struct lgtd_lifx_tag *
+lgtd_lifx_tagging_find_tag(const char *tag_label)
 {
-    enum { DEBRUIJN_NUMBER = 0x03f79d71b4cb0a89 };
-    static const int DEBRUIJN_SEQUENCE[64] = {
-        0, 47,  1, 56, 48, 27,  2, 60,
-       57, 49, 41, 37, 28, 16,  3, 61,
-       54, 58, 35, 52, 50, 42, 21, 44,
-       38, 32, 29, 23, 17, 11,  4, 62,
-       46, 55, 26, 59, 40, 36, 15, 53,
-       34, 51, 20, 43, 31, 22, 10, 45,
-       25, 39, 14, 33, 19, 30,  9, 24,
-       13, 18,  8, 12,  7,  6,  5, 63
-    };
-
-    return n ? DEBRUIJN_SEQUENCE[((n ^ (n - 1)) * DEBRUIJN_NUMBER) >> 58] : -1;
+    struct lgtd_lifx_tag *tag = NULL;
+    LIST_FOREACH(tag, &lgtd_lifx_tags, link) {
+        if (!strcmp(tag->label, tag_label)) {
+            break;
+        }
+    }
+    return tag;
 }
 
-bool
-lgtd_lifx_tagging_add_site(const uint8_t *site)
+static struct lgtd_lifx_site *
+lgtd_lifx_tagging_find_site(struct lgtd_lifx_site_list *sites,
+                            const struct lgtd_lifx_gateway *gw)
 {
-    assert(site);
-
-    struct lgtd_lifx_site_tags *site_tags;
-    LIST_FOREACH(site_tags, &lgtd_lifx_site_tags_map, link) {
-        if (!memcmp(site_tags->site_id.as_array, site, LGTD_LIFX_ADDR_LENGTH)) {
-            return true; // site already exists
+    struct lgtd_lifx_site *site = NULL;
+    LIST_FOREACH(site, sites, link) {
+        if (site->gw == gw) {
+            break;
         }
     }
+    return site;
+}
 
-    site_tags = calloc(1, sizeof(*site_tags));
-    memcpy(site_tags->site_id.as_array, site, LGTD_LIFX_ADDR_LENGTH);
-    LIST_INSERT_HEAD(&lgtd_lifx_site_tags_map, site_tags, link);
+struct lgtd_lifx_tag *
+lgtd_lifx_tagging_incref(const char *tag_label,
+                         const struct lgtd_lifx_gateway *gw)
+{
+    assert(strlen(tag_label) < LGTD_LIFX_LABEL_SIZE);
+    assert(gw);
 
-    return true;
+    bool dealloc_tag = false;
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(tag_label);
+    if (!tag) {
+        tag = calloc(1, sizeof(*tag));
+        if (!tag) {
+            return NULL;
+        }
+        strncpy(tag->label, tag_label, sizeof(tag->label) - 1);
+        LIST_INSERT_HEAD(&lgtd_lifx_tags, tag, link);
+        dealloc_tag = true;
+    }
+
+    struct lgtd_lifx_site *site = lgtd_lifx_tagging_find_site(&tag->sites, gw);
+    if (!site) {
+        site = calloc(1, sizeof(*site));
+        if (!site) {
+            if (dealloc_tag) {
+                LIST_REMOVE(tag, link);
+                free(tag);
+            }
+            errno = ENOMEM;
+            return NULL;
+        }
+        if (dealloc_tag) {
+            lgtd_info("discovered tag [%s]", tag_label);
+        }
+        lgtd_debug(
+            "tag [%s] added to gw [%s]:%hu (site %s)",
+            tag_label, gw->ip_addr, gw->port, lgtd_addrtoa(gw->site.as_array)
+        );
+        site->gw = gw;
+        LIST_INSERT_HEAD(&tag->sites, site, link);
+    }
+
+    return tag;
 }
 
 void
-lgtd_lifx_tagging_remove_site(const uint8_t *site)
+lgtd_lifx_tagging_decref(struct lgtd_lifx_tag *tag,
+                         const struct lgtd_lifx_gateway *gw)
 {
-    assert(site);
+    assert(tag);
+    assert(gw);
 
-    struct lgtd_lifx_site_tags *site_tags, *next_site_tags;
-    LIST_FOREACH_SAFE(site_tags, &lgtd_lifx_site_tags_map, link, next_site_tags) {
-        if (!memcmp(site_tags->site_id.as_array, site, LGTD_LIFX_ADDR_LENGTH)) {
-            LIST_REMOVE(site_tags, link);
-            free(site_tags);
-            return;
-        }
+    struct lgtd_lifx_site *site;
+    site = lgtd_lifx_tagging_find_site(&tag->sites, gw);
+    if (site) {
+        lgtd_debug(
+            "tag [%s] removed from gw [%s]:%hu (site %s)",
+            tag->label, gw->ip_addr, gw->port,
+            lgtd_addrtoa(gw->site.as_array)
+        );
+        LIST_REMOVE(site, link);
+        free(site);
     }
-
-#ifndef NDEBUG
-    assert(site_tags != LIST_END(&lgtd_lifx_site_tags_map));
-#else
-    lgtd_warnx(
-        "tried to remove unknown site %s from the tags list", lgtd_addrtoa(site)
-    );
-#endif
-}
-
-static struct lgtd_lifx_label_sites_tags *
-lgtd_lifx_tagging_labels_list_find(const char *label)
-{
-    struct lgtd_lifx_label_sites_tags *label_sites_tags = NULL;
-    LIST_FOREACH(label_sites_tags, &lgtd_lifx_labels, link) {
-        if (!strcmp(label_sites_tags->label, label)) {
-            break;
-        }
-    }
-    return label_sites_tags;
-}
-
-static bool
-lgtd_lifx_tagging_labels_list_add(const char *label,
-                                  struct lgtd_lifx_site_tags *site_tags)
-{
-    struct lgtd_lifx_label_sites_tags *label_sites_tags =
-        lgtd_lifx_tagging_labels_list_find(label);
-
-    if (!label_sites_tags) {
-        label_sites_tags = calloc(1, sizeof(*label_sites_tags));
-        if (!label_sites_tags) {
-            return false;
-        }
-        label_sites_tags->label_len = strlen(label);
-        memcpy(label_sites_tags->label, label, label_sites_tags->label_len);
-        LIST_INSERT_HEAD(&lgtd_lifx_labels, label_sites_tags, link);
-    }
-
-#ifndef NDEBUG
-    const struct lgtd_lifx_site_tags *it;
-    LIST_FOREACH(it, &label_sites_tags->sites_tags, link_by_label) {
-        assert(it != site_tags);
-    }
-#endif
-
-    LIST_INSERT_HEAD(&label_sites_tags->sites_tags, site_tags, link_by_label);
-    return true;
-}
-
-static void
-lgtd_lifx_tagging_labels_list_remove(const char *label,
-                                     struct lgtd_lifx_site_tags *site_tags)
-{
-    assert(lgtd_lifx_tagging_labels_list_find(label));
-    LIST_REMOVE(site_tags, link_by_label);
-}
-
-void
-lgtd_lifx_tagging_update(const uint8_t *site, const char *label, uint64_t tags)
-{
-    assert(site);
-    assert(label);
-    assert(label[LGTD_LIFX_LABEL_SIZE - 1] == '\0');
-
-    struct lgtd_lifx_site_tags *site_tags;
-    LIST_FOREACH(site_tags, &lgtd_lifx_site_tags_map, link) {
-        if (!memcmp(site_tags->site_id.as_array, site, LGTD_LIFX_ADDR_LENGTH)) {
-            break;
-        }
-    }
-
-#ifndef NDEBUG
-    assert(site_tags != LIST_END(&lgtd_lifx_site_tags_map));
-#else
-    if (site_tags == LIST_END(&lgtd_lifx_site_tags_map)) {
-        lgtd_warnx(
-            "tried to add tag %s on unknown site %s", label, lgtd_addrtoa(site)
-        );
-        return;
-    }
-#endif
-
-    while (true) {
-        int i = lgtd_lifx_tagging_bitscan64_forward(tags);
-        if (i == -1) {
-            break;
-        }
-        int len = strlen(label); // len ? adding a label : removing a label
-        if (len) {
-            if (!site_tags->labels[i][0]) {
-                if (lgtd_lifx_tagging_labels_list_add(label, site_tags)) {
-                    lgtd_info(
-                        "adding tag %s (id %d) on site %s",
-                        label, i, lgtd_addrtoa(site)
-                    );
-                    memcpy(site_tags->labels[i], label, len);
-                } else {
-                    lgtd_warn(
-                        "can't add tag %s (id %d) on site %s",
-                        label, i, lgtd_addrtoa(site)
-                    );
-                }
-            } else if (!memcmp(site_tags->labels[i], label, len)) {
-                lgtd_warnx(
-                    "tried to overwrite tag %s (id %d) on site %s with tag %s",
-                    site_tags->labels[i], i, lgtd_addrtoa(site), label
-                );
-            }
-        } else if (site_tags->labels[i][0]) {
-            lgtd_info(
-                "removing tag %s (id %d) on site %s",
-                site_tags->labels[i], i, lgtd_addrtoa(site)
-            );
-            lgtd_lifx_tagging_labels_list_remove(label, site_tags);
-            memset(site_tags->labels[i], 0, sizeof(site_tags->labels[i]));
-        }
-        tags &= ~(1 << i);
+    if (LIST_EMPTY(&tag->sites)) {
+        LIST_REMOVE(tag, link);
+        lgtd_info("forgetting unused tag [%s]", tag->label);
+        free(tag);
     }
 }
diff --git a/lifx/tagging.h b/lifx/tagging.h
--- a/lifx/tagging.h
+++ b/lifx/tagging.h
@@ -17,29 +17,21 @@
 
 #pragma once
 
-struct lgtd_lifx_site_tags {
-    LIST_ENTRY(lgtd_lifx_site_tags) link;
-    LIST_ENTRY(lgtd_lifx_site_tags) link_by_label;
-    union {
-        uint8_t                     as_array[LGTD_LIFX_ADDR_LENGTH];
-        uint64_t                    as_integer;
-    }                               site_id;
-    // TODO?: uint64_t              tag_ids;
-    char                            labels[64][LGTD_LIFX_LABEL_SIZE];
+extern struct lgtd_lifx_tag_list lgtd_lifx_tags;
+
+struct lgtd_lifx_site {
+    LIST_ENTRY(lgtd_lifx_site)      link;
+    const struct lgtd_lifx_gateway  *gw;
 };
-LIST_HEAD(lgtd_lifx_site_tags_list, lgtd_lifx_site_tags);
+LIST_HEAD(lgtd_lifx_site_list, lgtd_lifx_site);
 
-struct lgtd_lifx_label_sites_tags {
-    LIST_ENTRY(lgtd_lifx_label_sites_tags)  link;
-    char                                    label[LGTD_LIFX_LABEL_SIZE];
-    int                                     label_len;
-    struct lgtd_lifx_site_tags_list         sites_tags;
+struct lgtd_lifx_tag {
+    LIST_ENTRY(lgtd_lifx_tag)   link;
+    char                        label[LGTD_LIFX_LABEL_SIZE];
+    struct lgtd_lifx_site_list  sites;
 };
-LIST_HEAD(lgtd_lifx_label_sites_tags_list, lgtd_lifx_label_sites_tags);
+LIST_HEAD(lgtd_lifx_tag_list, lgtd_lifx_tag);
 
-extern struct lgtd_lifx_label_sites_tags_list lgtd_lifx_labels;
-
-bool lgtd_lifx_tagging_add_site(const uint8_t *site);
-void lgtd_lifx_tagging_remove_site(const uint8_t *site);
-
-void lgtd_lifx_tagging_update(const uint8_t *, const char *, uint64_t);
+struct lgtd_lifx_tag *lgtd_lifx_tagging_incref(const char *,
+                                               const struct lgtd_lifx_gateway *);
+void lgtd_lifx_tagging_decref(struct lgtd_lifx_tag *, const struct lgtd_lifx_gateway *);
diff --git a/tests/core/tests_utils.c b/tests/core/tests_utils.c
--- a/tests/core/tests_utils.c
+++ b/tests/core/tests_utils.c
@@ -26,16 +26,13 @@
 struct lgtd_lifx_gateway_list lgtd_lifx_gateways =
     LIST_HEAD_INITIALIZER(&lgtd_lifx_gateways);
 
-struct lgtd_lifx_label_sites_tags_list lgtd_lifx_labels =
-    LIST_HEAD_INITIALIZER(&lgtd_lifx_labels);
-
 struct lgtd_lifx_gateway *
 lgtd_tests_insert_mock_gateway(int id)
 {
     struct lgtd_lifx_gateway *gw = calloc(1, sizeof(*gw));
 
     gw->socket = id;
-    gw->site[0] = id;
+    gw->site.as_array[0] = id;
 
     LIST_INSERT_HEAD(&lgtd_lifx_gateways, gw, link);
 
