# HG changeset patch
# Parent  c1ff9bbf4bbafdf0758a840bc4961240707120e8
Add an interface to start and stop standalone timers

And rename lifx/timer to lifx/watchdog.

diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -25,6 +25,7 @@
     proto.c
     router.c
     stats.c
+    timer.c
 )
 
 TARGET_LINK_LIBRARIES(
diff --git a/core/lightsd.c b/core/lightsd.c
--- a/core/lightsd.c
+++ b/core/lightsd.c
@@ -41,12 +41,13 @@
 #include "lifx/bulb.h"
 #include "lifx/gateway.h"
 #include "lifx/broadcast.h"
-#include "lifx/timer.h"
+#include "lifx/watchdog.h"
 #include "version.h"
 #include "jsmn.h"
 #include "jsonrpc.h"
 #include "client.h"
 #include "pipe.h"
+#include "timer.h"
 #include "listen.h"
 #include "daemon.h"
 #include "lightsd.h"
@@ -65,9 +66,9 @@
     lgtd_listen_close_all();
     lgtd_command_pipe_close_all();
     lgtd_client_close_all();
-    lgtd_lifx_timer_close();
     lgtd_lifx_broadcast_close();
     lgtd_lifx_gateway_close_all();
+    lgtd_timer_stop_all();
     event_base_free(lgtd_ev_base);
 #if LIBEVENT_VERSION_NUMBER >= 0x02010100
     libevent_global_shutdown();
@@ -227,7 +228,7 @@
     argv += optind;
 
     lgtd_lifx_wire_load_packet_info_map();
-    if (!lgtd_lifx_timer_setup() || !lgtd_lifx_broadcast_setup()) {
+    if (!lgtd_lifx_watchdog_setup() || !lgtd_lifx_broadcast_setup()) {
         lgtd_err(1, "can't setup lightsd");
     }
 
@@ -235,7 +236,7 @@
         lgtd_err(1, "can't fork to the background");
     }
 
-    lgtd_lifx_timer_start_discovery();
+    lgtd_lifx_watchdog_start_discovery();
 
     event_base_dispatch(lgtd_ev_base);
 
diff --git a/core/timer.c b/core/timer.c
new file mode 100644
--- /dev/null
+++ b/core/timer.c
@@ -0,0 +1,104 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <sys/queue.h>
+#include <assert.h>
+#include <err.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+#include <event2/event.h>
+#include <event2/util.h>
+
+#include "timer.h"
+#include "lightsd.h"
+
+static struct lgtd_timer_list lgtd_timers = LIST_HEAD_INITIALIZER(&lgtd_timers);
+
+static void
+lgtd_timer_callback(evutil_socket_t socket, short events, void *ctx)
+{
+    assert(ctx);
+
+    (void)socket;
+    (void)events;
+
+    struct lgtd_timer *timer = ctx;
+    timer->callback(timer, timer->ctx);
+}
+
+struct lgtd_timer *
+lgtd_timer_start(int flags,
+                 int ms,
+                 void (*cb)(struct lgtd_timer *,
+                            union lgtd_timer_ctx),
+                 union lgtd_timer_ctx ctx)
+{
+    assert(ms > 0);
+    assert(cb);
+
+    struct lgtd_timer *timer = calloc(1, sizeof(*timer));
+    if (!timer) {
+        return false;
+    }
+    timer->callback = cb;
+    timer->ctx = ctx;
+    LIST_INSERT_HEAD(&lgtd_timers, timer, link);
+
+    struct timeval tv = LGTD_MSECS_TO_TIMEVAL(ms);
+    timer->event = event_new(
+        lgtd_ev_base,
+        -1,
+        flags & LGTD_TIMER_PERSISTENT ? EV_PERSIST : 0,
+        lgtd_timer_callback,
+        timer
+    );
+    if (!timer->event || evtimer_add(timer->event, &tv)) {
+        LIST_REMOVE(timer, link);
+        if (timer->event) {
+            event_free(timer->event);
+        }
+        free(timer);
+        return NULL;
+    }
+
+    if (flags & LGTD_TIMER_ACTIVATE_NOW) {
+        lgtd_timer_activate(timer);
+    }
+    return timer;
+}
+
+void
+lgtd_timer_stop(struct lgtd_timer *timer)
+{
+    assert(timer);
+
+    LIST_REMOVE(timer, link);
+    event_del(timer->event);
+    event_free(timer->event);
+    free(timer);
+}
+
+void
+lgtd_timer_stop_all(void)
+{
+    struct lgtd_timer *timer, *next_timer;
+    LIST_FOREACH_SAFE(timer, &lgtd_timers, link, next_timer) {
+        lgtd_timer_stop(timer);
+    }
+}
diff --git a/core/timer.h b/core/timer.h
new file mode 100644
--- /dev/null
+++ b/core/timer.h
@@ -0,0 +1,77 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#pragma once
+
+struct timeval;
+
+union lgtd_timer_ctx {
+    uint64_t    as_uint;
+    void        *as_ptr;
+};
+
+struct lgtd_timer {
+    LIST_ENTRY(lgtd_timer) link;
+    void                   (*callback)(struct lgtd_timer *,
+                                       union lgtd_timer_ctx);
+    union lgtd_timer_ctx   ctx;
+    struct event           *event;
+};
+LIST_HEAD(lgtd_timer_list, lgtd_timer);
+
+enum lgtd_timer_flags {
+    LGTD_TIMER_DEFAULT_FLAGS = 0,
+    LGTD_TIMER_ACTIVATE_NOW  = 1,
+    LGTD_TIMER_PERSISTENT    = 1 << 1,
+};
+
+// Activate the timer now, in other words make the callback pending:
+static inline void
+lgtd_timer_activate(struct lgtd_timer *timer)
+{
+    assert(timer);
+
+    event_active(timer->event, 0, 0);
+}
+
+// Re-schedule a non-persistent timer with the given timeout:
+static inline bool
+lgtd_timer_reschedule(struct lgtd_timer *timer, const struct timeval *tv)
+{
+    assert(timer);
+    assert(tv);
+
+    return !evtimer_add(timer->event, tv);
+}
+
+static inline bool
+lgtd_timer_ispending(const struct lgtd_timer *timer)
+{
+    assert(timer);
+
+    return evtimer_pending(timer->event, NULL);
+}
+
+void lgtd_timer_stop(struct lgtd_timer *);
+void lgtd_timer_stop_all(void);
+// NOTE: if you start a persistent timer and don't keep track of it, make sure
+//       you don't end up in a callback using a context that has been freed.
+struct lgtd_timer *lgtd_timer_start(int,
+                                    int, // ms
+                                    void (*)(struct lgtd_timer *,
+                                             union lgtd_timer_ctx),
+                                    union lgtd_timer_ctx);
diff --git a/lifx/CMakeLists.txt b/lifx/CMakeLists.txt
--- a/lifx/CMakeLists.txt
+++ b/lifx/CMakeLists.txt
@@ -11,6 +11,6 @@
     bulb.c
     gateway.c
     tagging.c
-    timer.c
+    watchdog.c
     wire_proto.c
 )
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -36,8 +36,8 @@
 #include "core/time_monotonic.h"
 #include "bulb.h"
 #include "gateway.h"
+#include "watchdog.h"
 #include "broadcast.h"
-#include "timer.h"
 #include "tagging.h"
 #include "core/jsmn.h"
 #include "core/jsonrpc.h"
@@ -342,7 +342,7 @@
 
     // In case this is the first bulb (re-)discovered, start the watchdog, it
     // will stop by itself:
-    lgtd_lifx_timer_start_watchdog();
+    lgtd_lifx_watchdog_start();
 
     LGTD_STATS_ADD_AND_UPDATE_PROCTITLE(gateways, 1);
 
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -53,7 +53,7 @@
     struct lgtd_lifx_tag            *tags[LGTD_LIFX_GATEWAY_MAX_TAGS];
     uint8_t                         tag_refcounts[LGTD_LIFX_GATEWAY_MAX_TAGS];
     evutil_socket_t                 socket;
-    // Those three timers let us measure the latency of the gateway. If we
+    // Those three timestamps let us measure the latency of the gateway. If we
     // aren't the only client on the network then this won't be accurate since
     // we will get pushed packets we didn't ask for, but good enough for our
     // purpose of rate limiting our requests to the gateway:
diff --git a/lifx/timer.c b/lifx/watchdog.c
rename from lifx/timer.c
rename to lifx/watchdog.c
--- a/lifx/timer.c
+++ b/lifx/watchdog.c
@@ -22,6 +22,7 @@
 #include <err.h>
 #include <errno.h>
 #include <stdbool.h>
+#include <stdlib.h>
 #include <string.h>
 
 #include <event2/event.h>
@@ -32,48 +33,48 @@
 #include "broadcast.h"
 #include "bulb.h"
 #include "gateway.h"
-#include "timer.h"
+#include "watchdog.h"
 #include "core/lightsd.h"
 
 static struct {
     struct event *watchdog_interval_ev;
     struct event *discovery_timeout_ev;
-} lgtd_lifx_timer_context = {
+} lgtd_lifx_watchdog_context = {
     .watchdog_interval_ev = NULL,
     .discovery_timeout_ev = NULL
 };
 
 static void
-lgtd_lifx_timer_discovery_timeout_event_callback(evutil_socket_t socket,
-                                                 short events,
-                                                 void *ctx)
+lgtd_lifx_watchdog_discovery_timeout_event_callback(evutil_socket_t socket,
+                                                    short events,
+                                                    void *ctx)
 {
     (void)socket;
     (void)events;
     (void)ctx;
 
-    int timeout = LGTD_LIFX_TIMER_PASSIVE_DISCOVERY_INTERVAL_MSECS;
+    int timeout = LGTD_LIFX_WATCHDOG_PASSIVE_DISCOVERY_INTERVAL_MSECS;
     if (LIST_EMPTY(&lgtd_lifx_gateways)) {
         lgtd_debug(
             "discovery didn't returned anything in %dms, restarting it",
-            LGTD_LIFX_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS
+            LGTD_LIFX_WATCHDOG_ACTIVE_DISCOVERY_INTERVAL_MSECS
         );
-        timeout = LGTD_LIFX_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS;
+        timeout = LGTD_LIFX_WATCHDOG_ACTIVE_DISCOVERY_INTERVAL_MSECS;
     } else {
         lgtd_debug("sending periodic discovery packet");
     }
 
     struct timeval tv = LGTD_MSECS_TO_TIMEVAL(timeout);
-    if (event_add(lgtd_lifx_timer_context.discovery_timeout_ev, &tv)
+    if (event_add(lgtd_lifx_watchdog_context.discovery_timeout_ev, &tv)
         || !lgtd_lifx_broadcast_discovery()) {
         lgtd_err(1, "can't start discovery");
     }
 }
 
 static void
-lgtd_lifx_timer_watchdog_timeout_event_callback(evutil_socket_t socket,
-                                                short events,
-                                                void *ctx)
+lgtd_lifx_watchdog_timeout_event_callback(evutil_socket_t socket,
+                                          short events,
+                                          void *ctx)
 {
     (void)socket;
     (void)events;
@@ -90,7 +91,7 @@
         next_bulb
     ) {
         int light_state_lag = now - bulb->last_light_state_at;
-        if (light_state_lag >= LGTD_LIFX_TIMER_DEVICE_TIMEOUT_MSECS) {
+        if (light_state_lag >= LGTD_LIFX_WATCHDOG_DEVICE_TIMEOUT_MSECS) {
             lgtd_info(
                 "closing bulb \"%.*s\" that hasn't been updated for %dms",
                 LGTD_LIFX_LABEL_SIZE, bulb->state.label, light_state_lag
@@ -107,7 +108,7 @@
     struct lgtd_lifx_gateway *gw, *next_gw;
     LIST_FOREACH_SAFE(gw, &lgtd_lifx_gateways, link, next_gw) {
         int gw_lag = now - gw->last_pkt_at;
-        if (gw_lag >= LGTD_LIFX_TIMER_DEVICE_TIMEOUT_MSECS) {
+        if (gw_lag >= LGTD_LIFX_WATCHDOG_DEVICE_TIMEOUT_MSECS) {
             lgtd_info(
                 "closing bulb gateway [%s]:%hu that "
                 "hasn't received traffic for %dms",
@@ -116,7 +117,7 @@
             );
             lgtd_lifx_gateway_close(gw);
             start_discovery = true;
-        } else if (gw_lag >= LGTD_LIFX_TIMER_DEVICE_FORCE_REFRESH_MSECS) {
+        } else if (gw_lag >= LGTD_LIFX_WATCHDOG_DEVICE_FORCE_REFRESH_MSECS) {
             lgtd_info(
                 "no update on bulb gateway [%s]:%hu for %dms, forcing refresh",
                 gw->ip_addr, gw->port, gw_lag
@@ -133,64 +134,67 @@
 }
 
 bool
-lgtd_lifx_timer_setup(void)
+lgtd_lifx_watchdog_setup(void)
 {
-    assert(!lgtd_lifx_timer_context.watchdog_interval_ev);
-    assert(!lgtd_lifx_timer_context.discovery_timeout_ev);
+    assert(!lgtd_lifx_watchdog_context.watchdog_interval_ev);
+    assert(!lgtd_lifx_watchdog_context.discovery_timeout_ev);
 
-    lgtd_lifx_timer_context.discovery_timeout_ev = event_new(
+    lgtd_lifx_watchdog_context.discovery_timeout_ev = event_new(
         lgtd_ev_base,
         -1,
         0,
-        lgtd_lifx_timer_discovery_timeout_event_callback,
+        lgtd_lifx_watchdog_discovery_timeout_event_callback,
         NULL
     );
-    lgtd_lifx_timer_context.watchdog_interval_ev = event_new(
+    lgtd_lifx_watchdog_context.watchdog_interval_ev = event_new(
         lgtd_ev_base,
         -1,
         EV_PERSIST,
-        lgtd_lifx_timer_watchdog_timeout_event_callback,
+        lgtd_lifx_watchdog_timeout_event_callback,
         NULL
     );
 
-    if (lgtd_lifx_timer_context.discovery_timeout_ev
-        && lgtd_lifx_timer_context.watchdog_interval_ev) {
+    if (lgtd_lifx_watchdog_context.discovery_timeout_ev
+        && lgtd_lifx_watchdog_context.watchdog_interval_ev) {
         return true;
     }
 
     int errsave = errno;
-    lgtd_lifx_timer_close();
+    lgtd_lifx_watchdog_close();
     errno = errsave;
     return false;
 }
 
 void
-lgtd_lifx_timer_close(void)
+lgtd_lifx_watchdog_close(void)
 {
-    if (lgtd_lifx_timer_context.discovery_timeout_ev) {
-        event_del(lgtd_lifx_timer_context.discovery_timeout_ev);
-        event_free(lgtd_lifx_timer_context.discovery_timeout_ev);
-        lgtd_lifx_timer_context.discovery_timeout_ev = NULL;
+    if (lgtd_lifx_watchdog_context.discovery_timeout_ev) {
+        event_del(lgtd_lifx_watchdog_context.discovery_timeout_ev);
+        event_free(lgtd_lifx_watchdog_context.discovery_timeout_ev);
+        lgtd_lifx_watchdog_context.discovery_timeout_ev = NULL;
     }
-    if (lgtd_lifx_timer_context.watchdog_interval_ev) {
-        event_del(lgtd_lifx_timer_context.watchdog_interval_ev);
-        event_free(lgtd_lifx_timer_context.watchdog_interval_ev);
-        lgtd_lifx_timer_context.watchdog_interval_ev = NULL;
+    if (lgtd_lifx_watchdog_context.watchdog_interval_ev) {
+        event_del(lgtd_lifx_watchdog_context.watchdog_interval_ev);
+        event_free(lgtd_lifx_watchdog_context.watchdog_interval_ev);
+        lgtd_lifx_watchdog_context.watchdog_interval_ev = NULL;
     }
 }
 
 void
-lgtd_lifx_timer_start_watchdog(void)
+lgtd_lifx_watchdog_start(void)
 {
     assert(
         !RB_EMPTY(&lgtd_lifx_bulbs_table) || !LIST_EMPTY(&lgtd_lifx_gateways)
     );
 
-    if (!evtimer_pending(lgtd_lifx_timer_context.watchdog_interval_ev, NULL)) {
+    bool pending = evtimer_pending(
+        lgtd_lifx_watchdog_context.watchdog_interval_ev, NULL
+    );
+    if (!pending) {
         struct timeval tv = LGTD_MSECS_TO_TIMEVAL(
-            LGTD_LIFX_TIMER_WATCHDOG_INTERVAL_MSECS
+            LGTD_LIFX_WATCHDOG_INTERVAL_MSECS
         );
-        if (event_add(lgtd_lifx_timer_context.watchdog_interval_ev, &tv)) {
+        if (event_add(lgtd_lifx_watchdog_context.watchdog_interval_ev, &tv)) {
             lgtd_err(1, "can't start watchdog");
         }
         lgtd_debug("starting watchdog timer");
@@ -198,12 +202,12 @@
 }
 
 void
-lgtd_lifx_timer_start_discovery(void)
+lgtd_lifx_watchdog_start_discovery(void)
 {
     assert(!evtimer_pending(
-        lgtd_lifx_timer_context.discovery_timeout_ev, NULL
+        lgtd_lifx_watchdog_context.discovery_timeout_ev, NULL
     ));
 
-    lgtd_lifx_timer_discovery_timeout_event_callback(-1, 0, NULL);
+    lgtd_lifx_watchdog_discovery_timeout_event_callback(-1, 0, NULL);
     lgtd_debug("starting discovery timer");
 }
diff --git a/lifx/timer.h b/lifx/watchdog.h
rename from lifx/timer.h
rename to lifx/watchdog.h
--- a/lifx/timer.h
+++ b/lifx/watchdog.h
@@ -17,13 +17,15 @@
 
 #pragma once
 
-enum { LGTD_LIFX_TIMER_WATCHDOG_INTERVAL_MSECS = 500 };
-enum { LGTD_LIFX_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS = 2000 };
-enum { LGTD_LIFX_TIMER_PASSIVE_DISCOVERY_INTERVAL_MSECS = 10000 };
-enum { LGTD_LIFX_TIMER_DEVICE_TIMEOUT_MSECS = 5000 };
-enum { LGTD_LIFX_TIMER_DEVICE_FORCE_REFRESH_MSECS = 2000 };
+enum lgtd_lifx_watchdog_constants {
+    LGTD_LIFX_WATCHDOG_INTERVAL_MSECS = 500,
+    LGTD_LIFX_WATCHDOG_ACTIVE_DISCOVERY_INTERVAL_MSECS = 2000,
+    LGTD_LIFX_WATCHDOG_PASSIVE_DISCOVERY_INTERVAL_MSECS = 10000,
+    LGTD_LIFX_WATCHDOG_DEVICE_TIMEOUT_MSECS = 3000,
+    LGTD_LIFX_WATCHDOG_DEVICE_FORCE_REFRESH_MSECS = 2000
+};
 
-bool lgtd_lifx_timer_setup(void);
-void lgtd_lifx_timer_close(void);
-void lgtd_lifx_timer_start_watchdog(void);
-void lgtd_lifx_timer_start_discovery(void);
+bool lgtd_lifx_watchdog_setup(void);
+void lgtd_lifx_watchdog_start(void);
+void lgtd_lifx_watchdog_close(void);
+void lgtd_lifx_watchdog_start_discovery(void);
diff --git a/tests/core/daemon/test_daemon_update_proctitle.c b/tests/core/daemon/test_daemon_update_proctitle.c
--- a/tests/core/daemon/test_daemon_update_proctitle.c
+++ b/tests/core/daemon/test_daemon_update_proctitle.c
@@ -11,6 +11,8 @@
 
 #include "mock_gateway.h"
 #include "mock_pipe.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 #include "tests_utils.h"
 
diff --git a/tests/core/mock_event2.h b/tests/core/mock_event2.h
--- a/tests/core/mock_event2.h
+++ b/tests/core/mock_event2.h
@@ -1,5 +1,10 @@
 #pragma once
 
+#include <event2/buffer.h>
+#include <event2/event.h>
+
+#define MOCK_EVENT_NEW_EVENT_PTR ((void *)0xdadadada)
+
 #ifndef MOCKED_EVBUFFER_DRAIN
 int
 evbuffer_drain(struct evbuffer *buf, size_t len)
@@ -95,7 +100,28 @@
     (void)events;
     (void)cb;
     (void)ctx;
-    return NULL;
+    return MOCK_EVENT_NEW_EVENT_PTR;
+}
+#endif
+
+#ifndef MOCKED_EVENT_ACTIVE
+void
+event_active(struct event *ev, int res, short ncalls)
+{
+    (void)ev;
+    (void)res;
+    (void)ncalls;
+}
+#endif
+
+#ifndef MOCKED_EVENT_PENDING
+int
+event_pending(const struct event *ev, short events, struct timeval *tv)
+{
+    (void)ev;
+    (void)events;
+    (void)tv;
+    return 0;
 }
 #endif
 
diff --git a/tests/core/mock_router.h b/tests/core/mock_router.h
new file mode 100644
--- /dev/null
+++ b/tests/core/mock_router.h
@@ -0,0 +1,81 @@
+#pragma once
+
+#include "lifx/wire_proto.h"  // enum lgtd_lifx_packet_type
+
+struct lgtd_proto_target_list;
+struct lgtd_router_device_list;
+
+#ifndef MOCKED_LGTD_ROUTER_SEND
+bool
+lgtd_router_send(const struct lgtd_proto_target_list *targets,
+                 enum lgtd_lifx_packet_type pkt_type,
+                 void *pkt)
+{
+    (void)targets;
+    (void)pkt_type;
+    (void)pkt;
+    return true;
+}
+#endif
+
+#ifndef MOCKED_LGTD_ROUTER_SEND_TO_DEVICE
+void
+lgtd_router_send_to_device(struct lgtd_lifx_bulb *bulb,
+                           enum lgtd_lifx_packet_type pkt_type,
+                           void *pkt)
+{
+    (void)bulb;
+    (void)pkt_type;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_ROUTER_SEND_TO_TAG
+void
+lgtd_router_send_to_tag(const struct lgtd_lifx_tag *tag,
+                        enum lgtd_lifx_packet_type pkt_type,
+                        void *pkt)
+{
+    (void)tag;
+    (void)pkt_type;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_ROUTER_SEND_TO_LABEL
+void
+lgtd_router_send_to_label(const char *label,
+                          enum lgtd_lifx_packet_type pkt_type,
+                          void *pkt)
+{
+    (void)label;
+    (void)pkt_type;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_ROUTER_BROADCAST
+void
+lgtd_router_broadcast(enum lgtd_lifx_packet_type pkt_type, void *pkt)
+{
+    (void)pkt_type;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_ROUTER_TARGETS_TO_DEVICES
+struct lgtd_router_device_list *
+lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *targets)
+{
+    (void)targets;
+    return NULL;
+}
+#endif
+
+#ifndef MOCKED_LGTD_ROUTER_DEVICE_LIST_FREE
+void
+lgtd_router_device_list_free(struct lgtd_router_device_list *devices)
+{
+    (void)devices;
+}
+#endif
diff --git a/tests/core/mock_timer.h b/tests/core/mock_timer.h
new file mode 100644
--- /dev/null
+++ b/tests/core/mock_timer.h
@@ -0,0 +1,33 @@
+#pragma once
+
+// we need those two because mock_timer.h is being used where it shouldn't be
+// because it is a dependency for modules (e.g: bulb) that haven't be mocked
+// yet:
+#include <assert.h>
+#include <event2/event.h>
+
+#include "core/timer.h" // to pull the union definition
+
+#ifndef MOCKED_LGTD_TIMER_START
+struct lgtd_timer *
+lgtd_timer_start(int flags,
+                 int ms,
+                 void (*cb)(struct lgtd_timer *,
+                            union lgtd_timer_ctx),
+                 union lgtd_timer_ctx ctx)
+{
+    (void)flags;
+    (void)ms;
+    (void)cb;
+    (void)ctx;
+    return NULL;
+}
+#endif
+
+#ifndef MOCKED_LGTD_TIMER_STOP
+void
+lgtd_timer_stop(struct lgtd_timer *timer)
+{
+    (void)timer;
+}
+#endif
diff --git a/tests/core/pipe/test_pipe_close.c b/tests/core/pipe/test_pipe_close.c
--- a/tests/core/pipe/test_pipe_close.c
+++ b/tests/core/pipe/test_pipe_close.c
@@ -13,6 +13,8 @@
 #define MOCKED_EVENT_FREE
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 #include "tests_utils.h"
 #include "tests_pipe_utils.h"
diff --git a/tests/core/pipe/test_pipe_open.c b/tests/core/pipe/test_pipe_open.c
--- a/tests/core/pipe/test_pipe_open.c
+++ b/tests/core/pipe/test_pipe_open.c
@@ -12,6 +12,8 @@
 #define MOCKED_EVENT_ADD
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 #include "tests_utils.h"
 #define MOCKED_CLIENT_OPEN_FROM_PIPE
diff --git a/tests/core/pipe/test_pipe_open_fifo_already_exists.c b/tests/core/pipe/test_pipe_open_fifo_already_exists.c
--- a/tests/core/pipe/test_pipe_open_fifo_already_exists.c
+++ b/tests/core/pipe/test_pipe_open_fifo_already_exists.c
@@ -12,6 +12,8 @@
 #define MOCKED_EVENT_ADD
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 #include "tests_utils.h"
 #define MOCKED_CLIENT_OPEN_FROM_PIPE
diff --git a/tests/core/pipe/test_pipe_read_callback.c b/tests/core/pipe/test_pipe_read_callback.c
--- a/tests/core/pipe/test_pipe_read_callback.c
+++ b/tests/core/pipe/test_pipe_read_callback.c
@@ -15,6 +15,8 @@
 #define MOCKED_EVBUFFER_DRAIN
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 #include "tests_utils.h"
 #define MOCKED_JSONRPC_DISPATCH_REQUEST
diff --git a/tests/core/pipe/test_pipe_read_callback_extra_data.c b/tests/core/pipe/test_pipe_read_callback_extra_data.c
--- a/tests/core/pipe/test_pipe_read_callback_extra_data.c
+++ b/tests/core/pipe/test_pipe_read_callback_extra_data.c
@@ -14,6 +14,8 @@
 #define MOCKED_EVBUFFER_DRAIN
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 #include "tests_utils.h"
 #define MOCKED_JSONRPC_DISPATCH_REQUEST
diff --git a/tests/core/pipe/test_pipe_read_callback_multiple_requests.c b/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
--- a/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
+++ b/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
@@ -14,6 +14,8 @@
 #define MOCKED_EVBUFFER_DRAIN
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 #include "tests_utils.h"
 #define MOCKED_JSONRPC_DISPATCH_REQUEST
diff --git a/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c b/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c
--- a/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c
+++ b/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c
@@ -14,6 +14,8 @@
 #define MOCKED_EVBUFFER_DRAIN
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 #include "tests_utils.h"
 #define MOCKED_JSONRPC_DISPATCH_REQUEST
diff --git a/tests/core/proto/CMakeLists.txt b/tests/core/proto/CMakeLists.txt
--- a/tests/core/proto/CMakeLists.txt
+++ b/tests/core/proto/CMakeLists.txt
@@ -10,7 +10,6 @@
     ${LIGHTSD_SOURCE_DIR}/core/stats.c
     ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
     ${LIGHTSD_SOURCE_DIR}/lifx/tagging.c
-    ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
     ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_utils.c
diff --git a/tests/core/proto/test_proto_get_light_state.c b/tests/core/proto/test_proto_get_light_state.c
--- a/tests/core/proto/test_proto_get_light_state.c
+++ b/tests/core/proto/test_proto_get_light_state.c
@@ -3,6 +3,8 @@
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
 #include "mock_gateway.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_ROUTER_TARGETS_TO_DEVICES
diff --git a/tests/core/proto/test_proto_get_light_state_empty_device_list.c b/tests/core/proto/test_proto_get_light_state_empty_device_list.c
--- a/tests/core/proto/test_proto_get_light_state_empty_device_list.c
+++ b/tests/core/proto/test_proto_get_light_state_empty_device_list.c
@@ -2,6 +2,8 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_ROUTER_TARGETS_TO_DEVICES
diff --git a/tests/core/proto/test_proto_get_light_state_null_device_list.c b/tests/core/proto/test_proto_get_light_state_null_device_list.c
--- a/tests/core/proto/test_proto_get_light_state_null_device_list.c
+++ b/tests/core/proto/test_proto_get_light_state_null_device_list.c
@@ -2,6 +2,8 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_ROUTER_TARGETS_TO_DEVICES
diff --git a/tests/core/proto/test_proto_get_light_state_unknown_tag_id.c b/tests/core/proto/test_proto_get_light_state_unknown_tag_id.c
--- a/tests/core/proto/test_proto_get_light_state_unknown_tag_id.c
+++ b/tests/core/proto/test_proto_get_light_state_unknown_tag_id.c
@@ -3,6 +3,8 @@
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
 #include "mock_gateway.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_ROUTER_TARGETS_TO_DEVICES
diff --git a/tests/core/proto/test_proto_power_off.c b/tests/core/proto/test_proto_power_off.c
--- a/tests/core/proto/test_proto_power_off.c
+++ b/tests/core/proto/test_proto_power_off.c
@@ -2,6 +2,8 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_power_off_routing_error.c b/tests/core/proto/test_proto_power_off_routing_error.c
--- a/tests/core/proto/test_proto_power_off_routing_error.c
+++ b/tests/core/proto/test_proto_power_off_routing_error.c
@@ -2,6 +2,8 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_power_on.c b/tests/core/proto/test_proto_power_on.c
--- a/tests/core/proto/test_proto_power_on.c
+++ b/tests/core/proto/test_proto_power_on.c
@@ -2,6 +2,8 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_power_on_routing_error.c b/tests/core/proto/test_proto_power_on_routing_error.c
--- a/tests/core/proto/test_proto_power_on_routing_error.c
+++ b/tests/core/proto/test_proto_power_on_routing_error.c
@@ -2,6 +2,8 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_power_toggle.c b/tests/core/proto/test_proto_power_toggle.c
--- a/tests/core/proto/test_proto_power_toggle.c
+++ b/tests/core/proto/test_proto_power_toggle.c
@@ -3,6 +3,8 @@
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
 #include "mock_gateway.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_ROUTER_SEND_TO_DEVICE
diff --git a/tests/core/proto/test_proto_power_toggle_targets_to_device_fails.c b/tests/core/proto/test_proto_power_toggle_targets_to_device_fails.c
--- a/tests/core/proto/test_proto_power_toggle_targets_to_device_fails.c
+++ b/tests/core/proto/test_proto_power_toggle_targets_to_device_fails.c
@@ -3,6 +3,8 @@
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
 #include "mock_gateway.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_ROUTER_SEND_TO_DEVICE
diff --git a/tests/core/proto/test_proto_set_light_from_hsbk.c b/tests/core/proto/test_proto_set_light_from_hsbk.c
--- a/tests/core/proto/test_proto_set_light_from_hsbk.c
+++ b/tests/core/proto/test_proto_set_light_from_hsbk.c
@@ -4,6 +4,8 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_set_light_from_hsbk_on_routing_error.c b/tests/core/proto/test_proto_set_light_from_hsbk_on_routing_error.c
--- a/tests/core/proto/test_proto_set_light_from_hsbk_on_routing_error.c
+++ b/tests/core/proto/test_proto_set_light_from_hsbk_on_routing_error.c
@@ -4,6 +4,8 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_set_waveform.c b/tests/core/proto/test_proto_set_waveform.c
--- a/tests/core/proto/test_proto_set_waveform.c
+++ b/tests/core/proto/test_proto_set_waveform.c
@@ -4,6 +4,8 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_set_waveform_on_routing_error.c b/tests/core/proto/test_proto_set_waveform_on_routing_error.c
--- a/tests/core/proto/test_proto_set_waveform_on_routing_error.c
+++ b/tests/core/proto/test_proto_set_waveform_on_routing_error.c
@@ -4,6 +4,8 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_tag_create.c b/tests/core/proto/test_proto_tag_create.c
--- a/tests/core/proto/test_proto_tag_create.c
+++ b/tests/core/proto/test_proto_tag_create.c
@@ -5,6 +5,8 @@
 #define MOCKED_LIFX_GATEWAY_SEND_TO_SITE
 #define MOCKED_LIFX_GATEWAY_ALLOCATE_TAG_ID
 #include "mock_gateway.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_ROUTER_TARGETS_TO_DEVICES
diff --git a/tests/core/proto/test_proto_tag_create_lifx_gw_tag_ids_full.c b/tests/core/proto/test_proto_tag_create_lifx_gw_tag_ids_full.c
--- a/tests/core/proto/test_proto_tag_create_lifx_gw_tag_ids_full.c
+++ b/tests/core/proto/test_proto_tag_create_lifx_gw_tag_ids_full.c
@@ -5,6 +5,8 @@
 #define MOCKED_LIFX_GATEWAY_SEND_TO_SITE
 #define MOCKED_LIFX_GATEWAY_ALLOCATE_TAG_ID
 #include "mock_gateway.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_ERROR
diff --git a/tests/core/proto/test_proto_tag_update.c b/tests/core/proto/test_proto_tag_update.c
--- a/tests/core/proto/test_proto_tag_update.c
+++ b/tests/core/proto/test_proto_tag_update.c
@@ -5,6 +5,8 @@
 #define MOCKED_LIFX_GATEWAY_SEND_TO_SITE
 #define MOCKED_LIFX_GATEWAY_ALLOCATE_TAG_ID
 #include "mock_gateway.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_ROUTER_TARGETS_TO_DEVICES
diff --git a/tests/core/proto/test_proto_untag.c b/tests/core/proto/test_proto_untag.c
--- a/tests/core/proto/test_proto_untag.c
+++ b/tests/core/proto/test_proto_untag.c
@@ -3,6 +3,8 @@
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
 #include "mock_gateway.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_ROUTER_TARGETS_TO_DEVICES
diff --git a/tests/core/proto/test_proto_untag_tag_does_not_exist.c b/tests/core/proto/test_proto_untag_tag_does_not_exist.c
--- a/tests/core/proto/test_proto_untag_tag_does_not_exist.c
+++ b/tests/core/proto/test_proto_untag_tag_does_not_exist.c
@@ -3,6 +3,8 @@
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
 #include "mock_gateway.h"
+#include "mock_event2.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #define MOCKED_ROUTER_TARGETS_TO_DEVICES
diff --git a/tests/core/router/CMakeLists.txt b/tests/core/router/CMakeLists.txt
--- a/tests/core/router/CMakeLists.txt
+++ b/tests/core/router/CMakeLists.txt
@@ -10,7 +10,6 @@
     ${LIGHTSD_SOURCE_DIR}/core/stats.c
     ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
     ${LIGHTSD_SOURCE_DIR}/lifx/tagging.c
-    ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
     ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_utils.c
diff --git a/tests/core/router/test_router_send_to_broadcast.c b/tests/core/router/test_router_send_to_broadcast.c
--- a/tests/core/router/test_router_send_to_broadcast.c
+++ b/tests/core/router/test_router_send_to_broadcast.c
@@ -1,6 +1,7 @@
 #include "router.c"
 
 #include "mock_daemon.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 
 #include "tests_router_utils.h"
diff --git a/tests/core/router/test_router_send_to_device.c b/tests/core/router/test_router_send_to_device.c
--- a/tests/core/router/test_router_send_to_device.c
+++ b/tests/core/router/test_router_send_to_device.c
@@ -1,6 +1,7 @@
 #include "router.c"
 
 #include "mock_daemon.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 #include "tests_router_utils.h"
 
diff --git a/tests/core/router/test_router_send_to_invalid_targets.c b/tests/core/router/test_router_send_to_invalid_targets.c
--- a/tests/core/router/test_router_send_to_invalid_targets.c
+++ b/tests/core/router/test_router_send_to_invalid_targets.c
@@ -1,6 +1,7 @@
 #include "router.c"
 
 #include "mock_daemon.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 #include "tests_router_utils.h"
 
diff --git a/tests/core/router/test_router_send_to_label.c b/tests/core/router/test_router_send_to_label.c
--- a/tests/core/router/test_router_send_to_label.c
+++ b/tests/core/router/test_router_send_to_label.c
@@ -1,6 +1,7 @@
 #include "router.c"
 
 #include "mock_daemon.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 #include "tests_router_utils.h"
 
diff --git a/tests/core/router/test_router_send_to_tag.c b/tests/core/router/test_router_send_to_tag.c
--- a/tests/core/router/test_router_send_to_tag.c
+++ b/tests/core/router/test_router_send_to_tag.c
@@ -1,6 +1,7 @@
 #include "router.c"
 
 #include "mock_daemon.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 #include "tests_router_utils.h"
 
diff --git a/tests/core/router/test_router_targets_to_devices.c b/tests/core/router/test_router_targets_to_devices.c
--- a/tests/core/router/test_router_targets_to_devices.c
+++ b/tests/core/router/test_router_targets_to_devices.c
@@ -1,6 +1,7 @@
 #include "router.c"
 
 #include "mock_daemon.h"
+#include "mock_timer.h"
 #include "tests_utils.h"
 #include "tests_router_utils.h"
 
diff --git a/tests/core/tests_shims.c b/tests/core/tests_shims.c
--- a/tests/core/tests_shims.c
+++ b/tests/core/tests_shims.c
@@ -24,7 +24,9 @@
     .verbosity = LGTD_DEBUG
 };
 
-struct event_base *lgtd_ev_base = NULL;
+#define MOCK_LGTD_EV_BASE ((void *)2222)
+
+struct event_base *lgtd_ev_base = MOCK_LGTD_EV_BASE;
 
 void
 lgtd_cleanup(void)
diff --git a/tests/core/tests_shims.h b/tests/core/tests_shims.h
--- a/tests/core/tests_shims.h
+++ b/tests/core/tests_shims.h
@@ -6,7 +6,9 @@
     .verbosity = LGTD_DEBUG
 };
 
-struct event_base *lgtd_ev_base = NULL;
+#define MOCK_LGTD_EV_BASE ((void *)2222)
+
+struct event_base *lgtd_ev_base = MOCK_LGTD_EV_BASE;
 
 const char *lgtd_binds = NULL;
 
diff --git a/tests/core/timer/CMakeLists.txt b/tests/core/timer/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/core/timer/CMakeLists.txt
@@ -0,0 +1,13 @@
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+FUNCTION(ADD_TIMER_TEST TEST_SOURCE)
+    ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE})
+ENDFUNCTION()
+
+FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
+FOREACH(TEST ${TESTS})
+    ADD_TIMER_TEST(${TEST})
+ENDFOREACH()
diff --git a/tests/core/timer/test_timer_ispending.c b/tests/core/timer/test_timer_ispending.c
new file mode 100644
--- /dev/null
+++ b/tests/core/timer/test_timer_ispending.c
@@ -0,0 +1,45 @@
+#include <string.h>
+
+#include "core/timer.c"
+
+#define MOCKED_EVENT_PENDING
+#include "mock_event2.h"
+#include "tests_shims.h"
+
+static int event_pending_call_count = 0;
+
+int
+event_pending(const struct event *ev, short events, struct timeval *tv)
+{
+    (void)events;
+
+    if (ev != MOCK_EVENT_NEW_EVENT_PTR) {
+        errx(1, "got event %p (expected %p)", ev, MOCK_EVENT_NEW_EVENT_PTR);
+    }
+
+    if (tv) {
+        errx(1, "got unexpected parameter tv");
+    }
+
+    if (event_pending_call_count++) {
+        errx(1, "event_pending should have been called once");
+    }
+
+    return true;
+}
+
+int
+main(void)
+{
+    struct lgtd_timer timer = { .event = MOCK_EVENT_NEW_EVENT_PTR };
+
+    if (!lgtd_timer_ispending(&timer)) {
+        errx(1, "lgtd_timer_ispending returned false (expected true)");
+    }
+
+    if (!event_pending_call_count) {
+        errx(1, "event_pending wasn't called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/timer/test_timer_reschedule.c b/tests/core/timer/test_timer_reschedule.c
new file mode 100644
--- /dev/null
+++ b/tests/core/timer/test_timer_reschedule.c
@@ -0,0 +1,45 @@
+#include <string.h>
+
+#include "core/timer.c"
+
+#define MOCKED_EVENT_ADD
+#include "mock_event2.h"
+#include "tests_shims.h"
+
+static int event_add_call_count = 0;
+
+int
+event_add(struct event *ev, const struct timeval *tv)
+{
+    if (ev != MOCK_EVENT_NEW_EVENT_PTR) {
+        errx(1, "got event %p (expected %p)", ev, MOCK_EVENT_NEW_EVENT_PTR);
+    }
+
+    struct timeval expected_tv = LGTD_MSECS_TO_TIMEVAL(5);
+    if (memcmp(tv, &expected_tv, sizeof(*tv))) {
+        errx(1, "got unexpected timeout");
+    }
+
+    if (event_add_call_count++) {
+        errx(1, "event_add should have been called once");
+    }
+
+    return 0;
+}
+
+int
+main(void)
+{
+    struct lgtd_timer timer = { .event = MOCK_EVENT_NEW_EVENT_PTR };
+    struct timeval tv = LGTD_MSECS_TO_TIMEVAL(5);
+
+    if (!lgtd_timer_reschedule(&timer, &tv)) {
+        errx(1, "wrong return value");
+    }
+
+    if (!event_add_call_count) {
+        errx(1, "event_add wasn't called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/timer/test_timer_start_activate_now.c b/tests/core/timer/test_timer_start_activate_now.c
new file mode 100644
--- /dev/null
+++ b/tests/core/timer/test_timer_start_activate_now.c
@@ -0,0 +1,145 @@
+#include <string.h>
+
+#include "core/timer.c"
+
+#define MOCKED_EVENT_NEW
+#define MOCKED_EVENT_ADD
+#define MOCKED_EVENT_ACTIVE
+#include "mock_event2.h"
+#include "tests_shims.h"
+
+static void
+my_test_callback(struct lgtd_timer *timer, union lgtd_timer_ctx ctx)
+{
+    (void)timer;
+    (void)ctx;
+}
+
+static int event_active_call_count = 0;
+
+void
+event_active(struct event *ev, int res, short ncalls)
+{
+    if (ev != MOCK_EVENT_NEW_EVENT_PTR) {
+        errx(1, "got event %p (expected %p)", ev, MOCK_EVENT_NEW_EVENT_PTR);
+    }
+
+    if (res) {
+        errx(1, "got res = %d (expected 0)", res);
+    }
+
+    if (ncalls) {
+        errx(1, "got ncalls = %d (expected 0)", ncalls);
+    }
+
+    if (event_active_call_count++) {
+        errx(1, "event_active should be called once");
+    }
+}
+
+static int event_new_call_count = 0;
+
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    if (base != MOCK_LGTD_EV_BASE) {
+        errx(1, "got base %p (expected %p)", base, MOCK_LGTD_EV_BASE);
+    }
+
+    if (fd != -1) {
+        errx(1, "got fd %d (expected -1)", fd);
+    }
+
+    if (events) {
+        errx(1, "got events %#x (expected 0)", events);
+    }
+
+    if (cb != lgtd_timer_callback) {
+        errx(1, "got cb %p (expected %p)", cb, lgtd_timer_callback);
+    }
+
+    if (!ctx) {
+        errx(1, "didn't get any context");
+    }
+
+    if (event_new_call_count++) {
+        errx(1, "event_new should be called once");
+    }
+
+    return MOCK_EVENT_NEW_EVENT_PTR;
+}
+
+static int event_add_call_count = 0;
+
+int
+event_add(struct event *ev, const struct timeval *timeout)
+{
+    if (ev != MOCK_EVENT_NEW_EVENT_PTR) {
+        errx(1, "got ev %p (expected %p)", ev, MOCK_EVENT_NEW_EVENT_PTR);
+    }
+
+    if (!timeout) {
+        errx(1, "a timeout should have been passed in");
+    }
+    // so i don't know wth clang and mac os x are doing but memcmp
+    // gets whacked in -O2 and returns a difference when there isn't,
+    // so we have to do it the painful way:
+    struct timeval expected_tv = LGTD_MSECS_TO_TIMEVAL(5);
+    if (timeout->tv_sec != expected_tv.tv_sec
+        || timeout->tv_usec != expected_tv.tv_usec) {
+        errx(1, "got invalid timeout");
+    }
+
+    if (event_add_call_count++) {
+        errx(1, "event_add should be called once");
+    }
+
+    return 0;
+}
+
+int
+main(void)
+{
+    union lgtd_timer_ctx ctx = { .as_uint = 7614 };
+    struct lgtd_timer *timer = lgtd_timer_start(
+        LGTD_TIMER_ACTIVATE_NOW, 5, my_test_callback, ctx
+    );
+
+    if (timer->event != MOCK_EVENT_NEW_EVENT_PTR) {
+        errx(
+            1, "timer has event %p (expected %p)",
+            timer->event, MOCK_EVENT_NEW_EVENT_PTR
+        );
+    }
+    if (timer->ctx.as_uint != ctx.as_uint) {
+        errx(
+            1, "timer ctx is %ju (expected %ju)",
+            (uintmax_t)timer->ctx.as_uint, (uintmax_t)ctx.as_uint
+        );
+    }
+    if (timer->callback != my_test_callback) {
+        errx(
+            1, "timer callback is %p (expected %p)",
+            timer->callback, my_test_callback
+        );
+    }
+    if (LIST_FIRST(&lgtd_timers) != timer) {
+        errx(1, "the timer wasn't inserted in the timers list");
+    }
+
+    if (!event_new_call_count) {
+        errx(1, "event_new wasn't called");
+    }
+    if (!event_add_call_count) {
+        errx(1, "event_add wasn't called");
+    }
+    if (!event_active_call_count) {
+        errx(1, "the timer wasn't activated");
+    }
+
+    return 0;
+}
diff --git a/tests/core/timer/test_timer_start_persistent.c b/tests/core/timer/test_timer_start_persistent.c
new file mode 100644
--- /dev/null
+++ b/tests/core/timer/test_timer_start_persistent.c
@@ -0,0 +1,129 @@
+#include <string.h>
+
+#include "core/timer.c"
+
+#define MOCKED_EVENT_NEW
+#define MOCKED_EVENT_ADD
+#define MOCKED_EVENT_ACTIVE
+#include "mock_event2.h"
+#include "tests_shims.h"
+
+static void
+my_test_callback(struct lgtd_timer *timer, union lgtd_timer_ctx ctx)
+{
+    (void)timer;
+    (void)ctx;
+}
+
+void
+event_active(struct event *ev, int res, short ncalls)
+{
+    (void)ev;
+    (void)res;
+    (void)ncalls;
+    errx(1, "event_active shouldn't have been called");
+}
+
+static int event_new_call_count = 0;
+
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    if (base != MOCK_LGTD_EV_BASE) {
+        errx(1, "got base %p (expected %p)", base, MOCK_LGTD_EV_BASE);
+    }
+
+    if (fd != -1) {
+        errx(1, "got fd %d (expected -1)", fd);
+    }
+
+    if (events != EV_PERSIST) {
+        errx(1, "got events %#x (expected %#x)", events, EV_PERSIST);
+    }
+
+    if (cb != lgtd_timer_callback) {
+        errx(1, "got cb %p (expected %p)", cb, lgtd_timer_callback);
+    }
+
+    if (!ctx) {
+        errx(1, "didn't get any context");
+    }
+
+    if (event_new_call_count++) {
+        errx(1, "event_new should be called once");
+    }
+
+    return MOCK_EVENT_NEW_EVENT_PTR;
+}
+
+static int event_add_call_count = 0;
+
+int
+event_add(struct event *ev, const struct timeval *timeout)
+{
+    if (ev != MOCK_EVENT_NEW_EVENT_PTR) {
+        errx(1, "got ev %p (expected %p)", ev, MOCK_EVENT_NEW_EVENT_PTR);
+    }
+
+    if (!timeout) {
+        errx(1, "a timeout should have been passed in");
+    }
+    // so i don't know wth clang and mac os x are doing but memcmp
+    // gets whacked in -O2 and returns a difference when there isn't,
+    // so we have to do it the painful way:
+    struct timeval expected_tv = LGTD_MSECS_TO_TIMEVAL(5);
+    if (timeout->tv_sec != expected_tv.tv_sec
+        || timeout->tv_usec != expected_tv.tv_usec) {
+        errx(1, "got invalid timeout");
+    }
+
+    if (event_add_call_count++) {
+        errx(1, "event_add should be called once");
+    }
+
+    return 0;
+}
+
+int
+main(void)
+{
+    union lgtd_timer_ctx ctx = { .as_uint = 7614 };
+    struct lgtd_timer *timer = lgtd_timer_start(
+        LGTD_TIMER_PERSISTENT, 5, my_test_callback, ctx
+    );
+
+    if (timer->event != MOCK_EVENT_NEW_EVENT_PTR) {
+        errx(
+            1, "timer has event %p (expected %p)",
+            timer->event, MOCK_EVENT_NEW_EVENT_PTR
+        );
+    }
+    if (timer->ctx.as_uint != ctx.as_uint) {
+        errx(
+            1, "timer ctx is %ju (expected %ju)",
+            (uintmax_t)timer->ctx.as_uint, (uintmax_t)ctx.as_uint
+        );
+    }
+    if (timer->callback != my_test_callback) {
+        errx(
+            1, "timer callback is %p (expected %p)",
+            timer->callback, my_test_callback
+        );
+    }
+    if (LIST_FIRST(&lgtd_timers) != timer) {
+        errx(1, "the timer wasn't inserted in the timers list");
+    }
+
+    if (!event_new_call_count) {
+        errx(1, "event_new wasn't called");
+    }
+    if (!event_add_call_count) {
+        errx(1, "event_add wasn't called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/CMakeLists.txt b/tests/lifx/CMakeLists.txt
--- a/tests/lifx/CMakeLists.txt
+++ b/tests/lifx/CMakeLists.txt
@@ -2,9 +2,11 @@
     ${LIGHTSD_SOURCE_DIR}
     ${LIGHTSD_SOURCE_DIR}/lifx/
     ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_SOURCE_DIR}/../core
     ${LIGHTSD_BINARY_DIR}
     ${LIGHTSD_BINARY_DIR}/lifx/
     ${CMAKE_CURRENT_BINARY_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}/../core
 )
 
 ADD_ALL_SUBDIRECTORIES()
diff --git a/tests/lifx/bulb/CMakeLists.txt b/tests/lifx/bulb/CMakeLists.txt
--- a/tests/lifx/bulb/CMakeLists.txt
+++ b/tests/lifx/bulb/CMakeLists.txt
@@ -6,7 +6,6 @@
 ADD_CORE_LIBRARY(
     test_lifx_bulb_core STATIC
     ${LIGHTSD_SOURCE_DIR}/core/log.c
-    ${LIGHTSD_SOURCE_DIR}/core/router.c
     ${LIGHTSD_SOURCE_DIR}/core/stats.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
 )
diff --git a/tests/lifx/bulb/test_bulb_close.c b/tests/lifx/bulb/test_bulb_close.c
--- a/tests/lifx/bulb/test_bulb_close.c
+++ b/tests/lifx/bulb/test_bulb_close.c
@@ -1,6 +1,8 @@
 #include "bulb.c"
 
 #include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 int
 main(void)
diff --git a/tests/lifx/bulb/test_bulb_open.c b/tests/lifx/bulb/test_bulb_open.c
--- a/tests/lifx/bulb/test_bulb_open.c
+++ b/tests/lifx/bulb/test_bulb_open.c
@@ -1,6 +1,8 @@
 #include "bulb.c"
 
 #include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 int
 main(void)
diff --git a/tests/lifx/bulb/test_bulb_set_light_state.c b/tests/lifx/bulb/test_bulb_set_light_state.c
--- a/tests/lifx/bulb/test_bulb_set_light_state.c
+++ b/tests/lifx/bulb/test_bulb_set_light_state.c
@@ -2,6 +2,8 @@
 
 #define MOCKED_LGTD_LIFX_GATEWAY_UPDATE_TAG_REFCOUNTS
 #include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 static int update_tag_refcouts_call_counts = 0;
 
diff --git a/tests/lifx/bulb/test_bulb_set_power_state.c b/tests/lifx/bulb/test_bulb_set_power_state.c
--- a/tests/lifx/bulb/test_bulb_set_power_state.c
+++ b/tests/lifx/bulb/test_bulb_set_power_state.c
@@ -1,6 +1,8 @@
 #include "bulb.c"
 
 #include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 int
 main(void)
diff --git a/tests/lifx/bulb/test_bulb_set_tags.c b/tests/lifx/bulb/test_bulb_set_tags.c
--- a/tests/lifx/bulb/test_bulb_set_tags.c
+++ b/tests/lifx/bulb/test_bulb_set_tags.c
@@ -2,6 +2,8 @@
 
 #define MOCKED_LGTD_LIFX_GATEWAY_UPDATE_TAG_REFCOUNTS
 #include "mock_gateway.h"
+#include "mock_router.h"
+#include "mock_timer.h"
 
 static bool update_tag_refcouts_called = false;
 
diff --git a/tests/lifx/gateway/CMakeLists.txt b/tests/lifx/gateway/CMakeLists.txt
--- a/tests/lifx/gateway/CMakeLists.txt
+++ b/tests/lifx/gateway/CMakeLists.txt
@@ -16,7 +16,7 @@
     test_lifx_gateway STATIC
     ${LIGHTSD_SOURCE_DIR}/lifx/broadcast.c
     ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
-    ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/watchdog.c
     ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
 )
 
