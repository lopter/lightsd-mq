# HG changeset patch
# Parent  c514d06adcfb4c6cfbc918cb64aed9fe9570b030
Add the -p (--pidfile) option

Needed to properly support old school startup scripts.

diff --git a/core/daemon.c b/core/daemon.c
--- a/core/daemon.c
+++ b/core/daemon.c
@@ -371,6 +371,35 @@
     return true;
 }
 
+bool
+lgtd_daemon_write_pidfile(const char *filepath)
+{
+    assert(filepath);
+
+    char pidstr[32];
+    int pidlen = snprintf(pidstr, sizeof(pidstr), "%ju", (uintmax_t)getpid());
+    int written = 0;
+
+    mode_t mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
+    int fd = open(filepath, O_CREAT|O_WRONLY|O_TRUNC, mode);
+    if (fd == -1) {
+        return false;
+    }
+
+    if (lgtd_user_info && lgtd_group_info
+        && fchown(fd, lgtd_user_info->pw_uid, lgtd_group_info->gr_gid) == -1) {
+        lgtd_warn(
+            "can't chown %s to %s:%s",
+            filepath, lgtd_user_info->pw_name, lgtd_group_info->gr_name
+        );
+    }
+
+    written = write(fd, pidstr, (size_t)pidlen);
+
+    close(fd);
+    return written == pidlen;
+}
+
 int
 lgtd_daemon_syslog_facilitytoi(const char *facility)
 {
diff --git a/core/daemon.h b/core/daemon.h
--- a/core/daemon.h
+++ b/core/daemon.h
@@ -33,6 +33,7 @@
 void lgtd_daemon_die_if_running_as_root_unless_requested(const char *);
 void lgtd_daemon_set_user(const char *);
 void lgtd_daemon_set_group(const char *);
+bool lgtd_daemon_write_pidfile(const char *);
 void lgtd_daemon_drop_privileges(void);
 bool lgtd_daemon_makedirs(const char *);
 
diff --git a/core/lightsd.c b/core/lightsd.c
--- a/core/lightsd.c
+++ b/core/lightsd.c
@@ -65,7 +65,8 @@
     .group = NULL,
     .syslog = false,
     .syslog_facility = LOG_DAEMON,
-    .syslog_ident = "lightsd"
+    .syslog_ident = "lightsd",
+    .pidfile = NULL
 }; 
 
 struct event_base *lgtd_ev_base = NULL;
@@ -86,6 +87,9 @@
 #if LIBEVENT_VERSION_NUMBER >= 0x02010100
     libevent_global_shutdown();
 #endif
+    if (lgtd_opts.pidfile) {
+        unlink(lgtd_opts.pidfile);
+    }
 }
 
 static void
@@ -150,12 +154,13 @@
 "Usage: %s ...\n\n"
 "  [-l,--listen addr:port]              Listen for JSON-RPC commands over TCP at\n"
 "                                       this address (can be repeated).\n"
-"  [-c,--comand-pipe /command/fifo]     Open an unidirectional JSON-RPC\n"
+"  [-c,--command-pipe /command/fifo]    Open an unidirectional JSON-RPC\n"
 "                                       command pipe at this location (can be\n"
 "                                       repeated).\n"
 "  [-s,--socket /unix/socket]           Open an Unix socket at this location\n"
 "                                       (can be repeated).\n"
 "  [-d,--daemonize]                     Fork in the background.\n"
+"  [-p,--pidfile /path/to/pid.file]     Write lightsd's pid in the given file.\n"
 "  [-u,--user user]                     Drop privileges to this user (and the\n"
 "                                       group of this user if -g is missing).\n"
 "  [-g,--group group]                   Drop privileges to this group (-g requires\n"
@@ -197,6 +202,7 @@
         {"socket",          required_argument, NULL, 's'},
         {"foreground",      no_argument,       NULL, 'f'},
         {"daemonize",       no_argument,       NULL, 'd'},
+        {"pidfile",         required_argument, NULL, 'p'},
         {"user",            required_argument, NULL, 'u'},
         {"group",           required_argument, NULL, 'g'},
         {"syslog",          no_argument,       NULL, 'S'},
@@ -206,11 +212,11 @@
         {"help",            no_argument,       NULL, 'h'},
         {"verbosity",       required_argument, NULL, 'v'},
         {"version",         no_argument,       NULL, 'V'},
-        {"prefix",          no_argument,       NULL, 'p'},
+        {"prefix",          no_argument,       NULL, 'P'},
         {"rundir",          no_argument,       NULL, 'r'},
         {NULL,              0,                 NULL, 0}
     };
-    const char short_opts[] = "l:c:s:fdu:g:SF:I:thv:V";
+    const char short_opts[] = "l:c:s:fdp:u:g:SF:I:thv:V";
 
     if (argc == 1) {
         lgtd_usage(progname);
@@ -246,6 +252,10 @@
             break;
         case 'd':
             lgtd_opts.foreground = false;
+            break;
+        case 'p':
+            lgtd_opts.pidfile = optarg;
+            break;
         case 'u':
             lgtd_opts.user = optarg;
             break;
@@ -284,7 +294,7 @@
             printf("%s %s\n", progname, LGTD_VERSION);
             lgtd_cleanup();
             return 0;
-        case 'p':
+        case 'P':
             printf(
                 "%s%s\n", LGTD_INSTALL_PREFIX, LGTD_INSTALL_PREFIX[
                     LGTD_ARRAY_SIZE(LGTD_INSTALL_PREFIX) - 1
@@ -313,6 +323,11 @@
     if (lgtd_opts.user) {
         lgtd_daemon_set_user(lgtd_opts.user);
         lgtd_daemon_set_group(lgtd_opts.group);
+        // create the pidfile before we drop privileges:
+        if (lgtd_opts.pidfile
+            && !lgtd_daemon_write_pidfile(lgtd_opts.pidfile)) {
+            lgtd_warn("couldn't write pidfile at %s", lgtd_opts.pidfile);
+        }
         lgtd_daemon_drop_privileges();
     } else if (lgtd_opts.group) {
         lgtd_errx(1, "please, specify an user with the -u option");
@@ -332,6 +347,11 @@
         }
     }
 
+    // update the pidfile after we've forked:
+    if (lgtd_opts.pidfile && !lgtd_daemon_write_pidfile(lgtd_opts.pidfile)) {
+        lgtd_warn("couldn't write pidfile at %s", lgtd_opts.pidfile);
+    }
+
     lgtd_lifx_discovery_start();
 
     // update at least once: so that if no bulbs are discovered we still get a
diff --git a/core/lightsd.h b/core/lightsd.h
--- a/core/lightsd.h
+++ b/core/lightsd.h
@@ -114,6 +114,7 @@
     bool                syslog;
     int                 syslog_facility;
     const char          *syslog_ident;
+    const char          *pidfile;
 };
 
 extern struct lgtd_opts lgtd_opts;
diff --git a/docs/first-steps.rst b/docs/first-steps.rst
--- a/docs/first-steps.rst
+++ b/docs/first-steps.rst
@@ -145,25 +145,28 @@
 
    Usage: lightsd ...
 
-     [-l,--listen addr:port [+]]          Listen for JSON-RPC commands over TCP at
-                                          this address (can be repeated).
-     [-c,--comand-pipe /command/fifo [+]] Open an unidirectional JSON-RPC
-                                          command pipe at this location (can be
-                                          repeated).
-     [-s,--socket /unix/socket [+]]       Open an Unix socket at this location
-                                          (can be repeated).
-     [-d,--daemonize]                     Fork in the background.
-     [-u,--user user]                     Drop privileges to this user (and the
-                                          group of this user if -g is missing).
-     [-g,--group group]                   Drop privileges to this group (-g requires
-                                          the -u option to be used).
-     [-S,--syslog]                        Divert logging from the console to syslog.
-     [-F,--syslog-facility]               Facility to use with syslog (defaults to
-                                          daemon, other possible values are user and
-                                          local0-7, see syslog(3)).
-     [-t,--no-timestamps]                 Disable timestamps in logs.
-     [-h,--help]                          Display this.
-     [-V,--version]                       Display version and build information.
+     [-l,--listen addr:port [+]]            Listen for JSON-RPC commands over TCP at
+                                            this address (can be repeated).
+     [-c,--command-pipe /command/fifo [+]]  Open an unidirectional JSON-RPC
+                                            command pipe at this location (can be
+                                            repeated).
+     [-s,--socket /unix/socket [+]]         Open an Unix socket at this location
+                                            (can be repeated).
+     [-d,--daemonize]                       Fork in the background.
+     [-p,--pidfile /path/to/pid.file]       Write lightsd's pid in the given file.
+     [-u,--user user]                       Drop privileges to this user (and the
+                                            group of this user if -g is missing).
+     [-g,--group group]                     Drop privileges to this group (-g requires
+                                            the -u option to be used).
+     [-S,--syslog]                          Divert logging from the console to syslog.
+     [-F,--syslog-facility]                 Facility to use with syslog (defaults to
+                                            daemon, other possible values are user and
+                                            local0-7, see syslog(3)).
+     [-I,--syslog-ident]                    Identifier to use with syslog (defaults to
+                                            lightsd).
+     [-t,--no-timestamps]                   Disable timestamps in logs.
+     [-h,--help]                            Display this.
+     [-V,--version]                         Display version and build information.
      [-v,--verbosity debug|info|warning|error]
 
    or,
diff --git a/tests/core/daemon/test_daemon_writepidfile.c b/tests/core/daemon/test_daemon_writepidfile.c
new file mode 100644
--- /dev/null
+++ b/tests/core/daemon/test_daemon_writepidfile.c
@@ -0,0 +1,166 @@
+#include <pwd.h>
+#include <grp.h>
+#include <unistd.h>
+
+int mock_open(const char *, int, ...);
+int mock_fchown(int, uid_t, gid_t);
+int mock_write(int, const void *, size_t);
+int mock_close(int);
+pid_t mock_getpid(void);
+
+#define open(fp, flags, ...) mock_open(fp, flags, ##__VA_ARGS__)
+#define fchown(fd, uid, gid) mock_fchown(fd, uid, gid)
+#define write(fd, buf, sz) mock_write(fd, buf, sz)
+#define close(fd) mock_close(fd)
+#define getpid() mock_getpid()
+#include "daemon.c"
+
+#include "mock_gateway.h"
+#include "mock_pipe.h"
+#include "mock_router.h"
+#include "mock_log.h"
+#include "mock_timer.h"
+
+#include "tests_utils.h"
+
+int mock_getpid_call_count = 0;
+
+pid_t
+mock_getpid(void)
+{
+    mock_getpid_call_count++;
+
+    return 1234;
+}
+
+int mock_open_call_count = 0;
+
+int
+mock_open(const char *fp, int flags, ...)
+{
+    mock_open_call_count++;
+
+    va_list ap;
+    va_start(ap, flags);
+    mode_t mode = va_arg(ap, int);
+    va_end(ap);
+
+    if (strcmp(fp, "/test.pid")) {
+        lgtd_errx(1, "got fp %s (expected test.pid)", fp);
+    }
+
+    int expected_flags = O_CREAT|O_WRONLY|O_TRUNC;
+    if (flags != expected_flags) {
+        lgtd_errx(1, "got flags %#x (expected %#x)", flags, expected_flags);
+    }
+
+    mode_t expected_mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
+    if (mode != expected_mode) {
+        lgtd_errx(1, "got mode %#x (expected %#x)", mode, expected_mode);
+    }
+
+    return 42;
+}
+
+int mock_fchown_call_count = 0;
+
+int
+mock_fchown(int fd, uid_t uid, gid_t gid)
+{
+    mock_fchown_call_count++;
+
+    if (fd != 42) {
+        lgtd_errx(1, "god fd %d (expected 42)", fd);
+    }
+
+    if (uid != 1000) {
+        lgtd_errx(1, "god uid %d (expected 1000)", uid);
+    }
+    
+    if (gid != 500) {
+        lgtd_errx(1, "god gid %d (expected 500)", gid);
+    }
+
+    return 0;
+}
+
+int mock_write_call_count = 0;
+
+int
+mock_write(int fd, const void *buf, size_t nbytes)
+{
+    mock_write_call_count++;
+
+    if (fd != 42) {
+        lgtd_errx(1, "got fd %d (expected 42)", fd);
+    }
+
+    if (!buf || strcmp(buf, "1234")) {
+        lgtd_errx(1, "writing pid %s (expected 1234)", buf);
+    }
+
+    if (nbytes != 4) {
+        lgtd_errx(1, "got nbytes %ju (expected 4)", (uintmax_t)nbytes);
+    }
+
+    return 0;
+}
+
+int mock_close_call_count = 0;
+
+int
+mock_close(int fd)
+{
+    mock_close_call_count++;
+
+    if (fd != 42) {
+        lgtd_errx(1, "got fd %d (expected 42)", fd);
+    }
+
+    return 0;
+}
+
+int
+main(void)
+{
+    struct passwd user_info = { .pw_uid = 1000, .pw_gid = 500 };
+    lgtd_user_info = &user_info;
+    struct group group_info = { .gr_gid = 500 };
+    lgtd_group_info = &group_info;
+
+    lgtd_daemon_write_pidfile("/test.pid");
+    if (!mock_open_call_count) {
+        lgtd_errx(1, "open wasn't called");
+    }
+    if (!mock_fchown_call_count) {
+        lgtd_errx(1, "fchown wasn't called");
+    }
+    if (!mock_getpid_call_count) {
+        lgtd_errx(1, "getpid wasn't called");
+    }
+    if (!mock_write_call_count) {
+        lgtd_errx(1, "write wasn't called");
+    }
+    if (!mock_close_call_count) {
+        lgtd_errx(1, "close wasn't called");
+    }
+
+    lgtd_daemon_write_pidfile("/test.pid");
+    if (mock_open_call_count != 2) {
+        lgtd_errx(1, "open wasn't called");
+    }
+    if (mock_fchown_call_count != 2) {
+        lgtd_errx(1, "fchown wasn't called");
+    }
+    if (mock_getpid_call_count != 2) {
+        lgtd_errx(1, "getpid wasn't called");
+    }
+    if (mock_write_call_count != 2) {
+        lgtd_errx(1, "write wasn't called");
+    }
+    if (mock_close_call_count != 2) {
+        lgtd_errx(1, "close wasn't called");
+    }
+
+    return 0;
+}
