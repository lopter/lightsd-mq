# HG changeset patch
# Parent  eddbaaef38e32a21148df36923cd788befbf04f0

diff --git a/tests/core/client/CMakeLists.txt b/tests/core/client/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/core/client/CMakeLists.txt
@@ -0,0 +1,27 @@
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+ADD_LIBRARY(
+    test_core_client STATIC
+    ${LIGHTSD_SOURCE_DIR}/core/jsmn.c
+    ${LIGHTSD_SOURCE_DIR}/core/log.c
+    ${LIGHTSD_SOURCE_DIR}/core/stats.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/tagging.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_utils.c
+)
+
+TARGET_LINK_LIBRARIES(test_core_client ${TIME_MONOTONIC_LIBRARY})
+
+FUNCTION(ADD_CLIENT_TEST TEST_SOURCE)
+    ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE} test_core_client)
+ENDFUNCTION()
+
+FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
+FOREACH(TEST ${TESTS})
+    ADD_CLIENT_TEST(${TEST})
+ENDFOREACH()
diff --git a/tests/core/client/test_client_read_callback.c b/tests/core/client/test_client_read_callback.c
new file mode 100644
--- /dev/null
+++ b/tests/core/client/test_client_read_callback.c
@@ -0,0 +1,217 @@
+#include "client.c"
+
+#include "lifx/wire_proto.h"
+
+#define MOCKED_EVENT_NEW
+#define MOCKED_EVENT_DEL
+#define MOCKED_EVBUFFER_NEW
+#define MOCKED_EVBUFFER_READ
+#define MOCKED_EVBUFFER_PULLUP
+#define MOCKED_EVBUFFER_GET_LENGTH
+#define MOCKED_EVBUFFER_DRAIN
+#define MOCKED_BUFFEREVENT_GET_INPUT
+#include "mock_event2.h"
+#include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
+#include "mock_router.h"
+#include "mock_timer.h"
+
+#include "tests_utils.h"
+#include "tests_client_utils.h"
+
+static unsigned char request[] = ("{"
+    "\"jsonrpc\": \"2.0\","
+    "\"method\": \"get_light_state\","
+    "\"params\": [\"*\"],"
+    "\"id\": 42"
+"}");
+
+static char *tmpdir = NULL;
+
+void
+cleanup_tmpdir(void)
+{
+    lgtd_tests_remove_temp_dir(tmpdir);
+}
+
+static int jsonrpc_dispatch_request_call_count = 0;
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+
+    if (!parsed) {
+        errx(1, "number of parsed json tokens not passed in");
+    }
+
+    if (memcmp(client->json, request, sizeof(request))) {
+        errx(1, "got unexpected json");
+    }
+
+    jsonrpc_dispatch_request_call_count++;
+}
+
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    (void)base;
+    (void)fd;
+    (void)events;
+    (void)cb;
+    (void)ctx;
+
+    return (void *)1;
+}
+
+static int event_del_call_count = 0;
+
+int
+event_del(struct event *ev)
+{
+    (void)ev;
+    event_del_call_count++;
+    return 0;
+}
+
+static int
+get_nbytes_read(int call_count)
+{
+    switch (call_count) {
+    case 0:
+        return sizeof(request) - 1; // we don't return the '\0'
+    default:
+        return 0;
+    }
+}
+
+struct evbuffer *
+evbuffer_new(void)
+{
+    return (void *)2;
+}
+
+static int evbuffer_drain_call_count = 0;
+
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    switch (evbuffer_drain_call_count) {
+    case 0:
+        if (len != sizeof(request) - 1) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)sizeof(request) - 1
+            );
+        }
+        break;
+    default:
+        break;
+    }
+    evbuffer_drain_call_count++;
+
+    return 0;
+}
+
+static int evbuffer_pullup_call_count = 0;
+
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    if (size != -1) {
+        errx(
+            1, "got unexpected size %jd in pullup (expected -1)", (intmax_t)size
+        );
+    }
+
+    jsmn_parser jsmn_ctx;
+    jsmn_init(&jsmn_ctx);
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
+        errx(1, "the client json parser context wasn't re-initialized");
+    }
+
+    return &request[evbuffer_pullup_call_count++ ? sizeof(request) - 1 : 0];
+}
+
+static int evbuffer_get_length_call_count = 0;
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    return get_nbytes_read(evbuffer_get_length_call_count++);
+}
+
+static int evbuffer_read_call_count = 0;
+
+int
+evbuffer_read(struct evbuffer *buf, evutil_socket_t fd, int howmuch)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (fd != pipe->fd) {
+        errx(1, "got unexpected fd %d (expected %d)", fd, pipe->fd);
+    }
+
+    if (howmuch != -1) {
+        errx(
+            1, "got unexpected howmuch bytes to read %d (expected -1)", howmuch
+        );
+    }
+
+    return get_nbytes_read(evbuffer_read_call_count++);
+}
+
+int
+main(void)
+{
+    tmpdir = lgtd_tests_make_temp_dir();
+    atexit(cleanup_tmpdir);
+
+    char path[PATH_MAX] = { 0 };
+    snprintf(path, sizeof(path), "%s/lightsd.pipe", tmpdir);
+    if (!lgtd_command_pipe_open(path)) {
+        errx(1, "couldn't open pipe");
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    lgtd_command_pipe_read_callback(pipe->fd, EV_READ, pipe);
+    if (event_del_call_count != 1) {
+        errx(1, "the pipe wasn't reset");
+    }
+
+    jsonrpc_dispatch_request_call_count = 0;
+    evbuffer_drain_call_count = 0;
+    evbuffer_read_call_count = 0;
+    evbuffer_pullup_call_count = 0;
+    evbuffer_get_length_call_count = 0;
+    event_del_call_count = 0;
+    pipe = SLIST_FIRST(&lgtd_command_pipes);
+    lgtd_command_pipe_read_callback(pipe->fd, EV_READ, pipe);
+    if (event_del_call_count != 1) {
+        errx(1, "the pipe wasn't reset");
+    }
+
+    return 0;
+}
diff --git a/tests/core/client/test_client_read_callback_extra_data.c b/tests/core/client/test_client_read_callback_extra_data.c
new file mode 100644
--- /dev/null
+++ b/tests/core/client/test_client_read_callback_extra_data.c
@@ -0,0 +1,219 @@
+#include "client.c"
+
+#include "lifx/wire_proto.h"
+
+#define MOCKED_EVENT_NEW
+#define MOCKED_EVBUFFER_NEW
+#define MOCKED_EVBUFFER_READ
+#define MOCKED_EVBUFFER_PULLUP
+#define MOCKED_EVBUFFER_GET_LENGTH
+#define MOCKED_EVBUFFER_DRAIN
+#include "mock_event2.h"
+#include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
+#include "mock_router.h"
+#include "mock_timer.h"
+
+#include "tests_utils.h"
+#include "tests_client_utils.h"
+
+#define REQUEST_1 "{"                   \
+    "\"jsonrpc\": \"2.0\","             \
+    "\"method\": \"get_light_state\","  \
+    "\"params\": [\"*\"],"              \
+    "\"id\": 42"                        \
+"}"
+#define EXTRA_DATA "BLUBLBULBUBUHIFESHFUSsoundsaboutright" 
+
+static unsigned char request[] = (
+    REQUEST_1
+    EXTRA_DATA
+);
+
+static char *tmpdir = NULL;
+
+void
+cleanup_tmpdir(void)
+{
+    lgtd_tests_remove_temp_dir(tmpdir);
+}
+
+static int jsonrpc_dispatch_request_call_count = 0;
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+
+    if (!parsed) {
+        errx(1, "number of parsed json tokens not passed in");
+    }
+
+    if (memcmp(client->json, request, sizeof(request))) {
+        errx(1, "got unexpected json");
+    }
+
+    jsonrpc_dispatch_request_call_count++;
+}
+
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    (void)base;
+    (void)fd;
+    (void)events;
+    (void)cb;
+    (void)ctx;
+
+    return (void *)1;
+}
+
+static int
+get_nbytes_read(int call_count)
+{
+    switch (call_count) {
+    case 0:
+        return sizeof(request) - 1; // we don't return the '\0'
+    default:
+        return 0;
+    }
+}
+
+struct evbuffer *
+evbuffer_new(void)
+{
+    return (void *)2;
+}
+
+static int evbuffer_drain_call_count = 0;
+
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    switch (evbuffer_drain_call_count) {
+    case 0:
+        if (len != sizeof(request) - sizeof(REQUEST_1)) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)(sizeof(request) - sizeof(REQUEST_1))
+            );
+        }
+        break;
+    case 1:
+        if (len != sizeof(REQUEST_1) - 1) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)sizeof(request) - 1
+            );
+        }
+        break;
+    default:
+        break;
+    }
+    evbuffer_drain_call_count++;
+
+    return 0;
+}
+
+static int evbuffer_pullup_call_count = 0;
+
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    if (size != -1) {
+        errx(
+            1, "got unexpected size %jd in pullup (expected -1)", (intmax_t)size
+        );
+    }
+
+    jsmn_parser jsmn_ctx;
+    jsmn_init(&jsmn_ctx);
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
+        errx(1, "the client json parser context wasn't re-initialized");
+    }
+
+    return &request[evbuffer_pullup_call_count++ ? sizeof(request) - 1 : 0];
+}
+
+static int evbuffer_get_length_call_count = 0;
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    size_t len;
+    switch (evbuffer_get_length_call_count) {
+    case 0:
+        len = sizeof(request) - 1;
+        break;
+    case 1:
+        len = sizeof(request) - sizeof(REQUEST_1);
+        break;
+    default:
+        len = 0;
+        break;
+    }
+    evbuffer_get_length_call_count++;
+
+    return len;
+}
+
+static int evbuffer_read_call_count = 0;
+
+int
+evbuffer_read(struct evbuffer *buf, evutil_socket_t fd, int howmuch)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (fd != pipe->fd) {
+        errx(1, "got unexpected fd %d (expected %d)", fd, pipe->fd);
+    }
+
+    if (howmuch != -1) {
+        errx(
+            1, "got unexpected howmuch bytes to read %d (expected -1)", howmuch
+        );
+    }
+
+    return get_nbytes_read(evbuffer_read_call_count++);
+}
+
+int
+main(void)
+{
+    tmpdir = lgtd_tests_make_temp_dir();
+    atexit(cleanup_tmpdir);
+
+    char path[PATH_MAX] = { 0 };
+    snprintf(path, sizeof(path), "%s/lightsd.pipe", tmpdir);
+    if (!lgtd_command_pipe_open(path)) {
+        errx(1, "couldn't open pipe");
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+
+    lgtd_command_pipe_read_callback(pipe->fd, EV_READ, pipe);
+
+    return 0;
+}
diff --git a/tests/core/client/test_client_read_callback_multiple_requests.c b/tests/core/client/test_client_read_callback_multiple_requests.c
new file mode 100644
--- /dev/null
+++ b/tests/core/client/test_client_read_callback_multiple_requests.c
@@ -0,0 +1,259 @@
+#include "client.c"
+
+#include "lifx/wire_proto.h"
+
+#define MOCKED_EVENT_NEW
+#define MOCKED_EVBUFFER_NEW
+#define MOCKED_EVBUFFER_READ
+#define MOCKED_EVBUFFER_PULLUP
+#define MOCKED_EVBUFFER_GET_LENGTH
+#define MOCKED_EVBUFFER_DRAIN
+#include "mock_event2.h"
+#include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
+#include "mock_router.h"
+#include "mock_timer.h"
+
+#include "tests_utils.h"
+#include "tests_client_utils.h"
+
+#define REQUEST_1 "{"                   \
+    "\"jsonrpc\": \"2.0\","             \
+    "\"method\": \"get_light_state\","  \
+    "\"params\": [\"*\"],"              \
+    "\"id\": 42"                        \
+"}"
+
+#define REQUEST_2 "{"           \
+    "\"jsonrpc\": \"2.0\","     \
+    "\"method\": \"power_on\"," \
+    "\"params\": [\"*\"],"      \
+    "\"id\": 43"                \
+"}"
+
+static unsigned char request[] = (
+    REQUEST_1
+    REQUEST_2
+);
+
+static char *tmpdir = NULL;
+
+void
+cleanup_tmpdir(void)
+{
+    lgtd_tests_remove_temp_dir(tmpdir);
+}
+
+static int jsonrpc_dispatch_request_call_count = 0;
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+
+    if (!parsed) {
+        errx(1, "number of parsed json tokens not passed in");
+    }
+
+    switch (jsonrpc_dispatch_request_call_count) {
+    case 0:
+        if (memcmp(client->json, request, sizeof(request) - 1)) {
+            errx(
+                1, "got unexpected json %s (expected %s)",
+                client->json, request
+            );
+        }
+        break;
+    case 1:
+        if (memcmp(client->json, REQUEST_2, sizeof(REQUEST_2) - 1)) {
+            errx(
+                1, "got unexpected json %s (expected %s)",
+                client->json, REQUEST_2
+            );
+        }
+        break;
+    default:
+        errx(
+            1, "jsonrpc_dispatch_request_call_count = %d",
+            jsonrpc_dispatch_request_call_count
+        );
+        break;
+    }
+
+    jsonrpc_dispatch_request_call_count++;
+}
+
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    (void)base;
+    (void)fd;
+    (void)events;
+    (void)cb;
+    (void)ctx;
+
+    return (void *)1;
+}
+
+struct evbuffer *
+evbuffer_new(void)
+{
+    return (void *)2;
+}
+
+static int evbuffer_drain_call_count = 0;
+
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    switch (evbuffer_drain_call_count) {
+    case 0:
+        if (len != sizeof(REQUEST_1) - 1) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)sizeof(REQUEST_1) - 1
+            );
+        }
+        break;
+    case 1:
+        if (len != sizeof(REQUEST_2) - 1) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)sizeof(REQUEST_2) - 1
+            );
+        }
+        break;
+    default:
+        errx(1, "evbuffer_drain_call_count = %d", evbuffer_drain_call_count);
+        break;
+    }
+    evbuffer_drain_call_count++;
+
+    return 0;
+}
+
+static int evbuffer_pullup_call_count = 0;
+
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    if (size != -1) {
+        errx(
+            1, "got unexpected size %jd in pullup (expected -1)", (intmax_t)size
+        );
+    }
+
+    jsmn_parser jsmn_ctx;
+    jsmn_init(&jsmn_ctx);
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
+        errx(1, "the client json parser context wasn't re-initialized");
+    }
+
+    int offset;
+    switch (evbuffer_pullup_call_count) {
+    case 0:
+        offset = 0;
+        break;
+    case 1:
+        offset = sizeof(REQUEST_1) - 1;
+        break;
+    default:
+        offset = sizeof(request);
+        break;
+    }
+    evbuffer_pullup_call_count++;
+
+    return &request[offset];
+}
+
+static int evbuffer_get_length_call_count = 0;
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    size_t len;
+    switch (evbuffer_get_length_call_count) {
+    case 0:
+        len = sizeof(request) - 1;
+        break;
+    case 1:
+        len = sizeof(request) - sizeof(REQUEST_1);
+        break;
+    default:
+        len = 0;
+        break;
+    }
+    evbuffer_get_length_call_count++;
+
+    return len;
+}
+
+static int evbuffer_read_call_count = 0;
+
+int
+evbuffer_read(struct evbuffer *buf, evutil_socket_t fd, int howmuch)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (fd != pipe->fd) {
+        errx(1, "got unexpected fd %d (expected %d)", fd, pipe->fd);
+    }
+
+    if (howmuch != -1) {
+        errx(
+            1, "got unexpected howmuch bytes to read %d (expected -1)", howmuch
+        );
+    }
+
+    int rv = 0;
+    switch (evbuffer_read_call_count) {
+    case 0:
+        rv = sizeof(request) - 1;
+    default:
+        break;
+    }
+    evbuffer_read_call_count++;
+
+    return rv;
+}
+
+int
+main(void)
+{
+    tmpdir = lgtd_tests_make_temp_dir();
+    atexit(cleanup_tmpdir);
+
+    char path[PATH_MAX] = { 0 };
+    snprintf(path, sizeof(path), "%s/lightsd.pipe", tmpdir);
+    if (!lgtd_command_pipe_open(path)) {
+        errx(1, "couldn't open pipe");
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+
+    lgtd_command_pipe_read_callback(pipe->fd, EV_READ, pipe);
+
+    return 0;
+}
diff --git a/tests/core/client/test_client_read_callback_yield_on_eagain.c b/tests/core/client/test_client_read_callback_yield_on_eagain.c
new file mode 100644
--- /dev/null
+++ b/tests/core/client/test_client_read_callback_yield_on_eagain.c
@@ -0,0 +1,269 @@
+#include "client.c"
+
+#include "lifx/wire_proto.h"
+
+#define MOCKED_EVENT_NEW
+#define MOCKED_EVBUFFER_NEW
+#define MOCKED_EVBUFFER_READ
+#define MOCKED_EVBUFFER_PULLUP
+#define MOCKED_EVBUFFER_GET_LENGTH
+#define MOCKED_EVBUFFER_DRAIN
+#include "mock_event2.h"
+#include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
+#include "mock_router.h"
+#include "mock_timer.h"
+
+#include "tests_utils.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "tests_client_utils.h"
+
+#define REQUEST_1 "{"                   \
+    "\"jsonrpc\": \"2.0\","             \
+    "\"method\": \"get_light_state\","  \
+    "\"params\": [\"*\"],"              \
+    "\"id\": 42"                        \
+"}"
+
+#define REQUEST_2 "{"           \
+    "\"jsonrpc\": \"2.0\","     \
+    "\"method\": \"power_on\"," \
+    "\"params\": [\"*\"],"      \
+    "\"id\": 43"                \
+"}"
+
+static unsigned char request[] = (
+    REQUEST_1
+    REQUEST_2
+);
+
+static char *tmpdir = NULL;
+
+void
+cleanup_tmpdir(void)
+{
+    lgtd_tests_remove_temp_dir(tmpdir);
+}
+
+static int jsonrpc_dispatch_request_call_count = 0;
+
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+
+    if (!parsed) {
+        errx(1, "number of parsed json tokens not passed in");
+    }
+
+    switch (jsonrpc_dispatch_request_call_count) {
+    case 0:
+        if (memcmp(client->json, request, sizeof(request) - 1)) {
+            errx(
+                1, "got unexpected json %s (expected %s)",
+                client->json, request
+            );
+        }
+        break;
+    case 1:
+        if (memcmp(client->json, REQUEST_2, sizeof(REQUEST_2) - 1)) {
+            errx(
+                1, "got unexpected json %s (expected %s)",
+                client->json, REQUEST_2
+            );
+        }
+        break;
+    default:
+        errx(
+            1, "jsonrpc_dispatch_request_call_count = %d",
+            jsonrpc_dispatch_request_call_count
+        );
+        break;
+    }
+
+    jsonrpc_dispatch_request_call_count++;
+}
+
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    (void)base;
+    (void)fd;
+    (void)events;
+    (void)cb;
+    (void)ctx;
+
+    return (void *)1;
+}
+
+struct evbuffer *
+evbuffer_new(void)
+{
+    return (void *)2;
+}
+
+static int evbuffer_drain_call_count = 0;
+
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    switch (evbuffer_drain_call_count) {
+    case 0:
+        if (len != sizeof(REQUEST_1) - 1) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)sizeof(REQUEST_1) - 1
+            );
+        }
+        break;
+    case 1:
+        if (len != sizeof(REQUEST_2) - 1) {
+            errx(
+                1, "trying to drain %ju bytes (expected %ju)",
+                (uintmax_t)len, (uintmax_t)sizeof(REQUEST_2) - 1
+            );
+        }
+        break;
+    default:
+        errx(1, "evbuffer_drain_call_count = %d", evbuffer_drain_call_count);
+        break;
+    }
+    evbuffer_drain_call_count++;
+
+    return 0;
+}
+
+static int evbuffer_pullup_call_count = 0;
+
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    if (size != -1) {
+        errx(
+            1, "got unexpected size %jd in pullup (expected -1)", (intmax_t)size
+        );
+    }
+
+    jsmn_parser jsmn_ctx;
+    jsmn_init(&jsmn_ctx);
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
+        errx(1, "the client json parser context wasn't re-initialized");
+    }
+
+    int offset;
+    switch (evbuffer_pullup_call_count) {
+    case 0:
+        offset = 0;
+        break;
+    case 1:
+        offset = sizeof(REQUEST_1) - 1;
+        break;
+    default:
+        offset = sizeof(request);
+        break;
+    }
+    evbuffer_pullup_call_count++;
+
+    return &request[offset];
+}
+
+static int evbuffer_get_length_call_count = 0;
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    size_t len;
+    switch (evbuffer_get_length_call_count) {
+    case 0:
+        len = sizeof(REQUEST_1) - 1;
+        break;
+    case 1:
+        len = sizeof(request) - sizeof(REQUEST_1);
+        break;
+    default:
+        len = 0;
+        break;
+    }
+    evbuffer_get_length_call_count++;
+
+    return len;
+}
+
+static int evbuffer_read_call_count = 0;
+
+int
+evbuffer_read(struct evbuffer *buf, evutil_socket_t fd, int howmuch)
+{
+    if (buf != (void *)2) {
+        errx(1, "got unexpected buf %p (expected %p)", buf, (void *)2);
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+    if (fd != pipe->fd) {
+        errx(1, "got unexpected fd %d (expected %d)", fd, pipe->fd);
+    }
+
+    if (howmuch != -1) {
+        errx(
+            1, "got unexpected howmuch bytes to read %d (expected -1)", howmuch
+        );
+    }
+
+    int rv = 0;
+    switch (evbuffer_read_call_count) {
+    case 0:
+        rv = sizeof(REQUEST_1) - 1;
+        break;
+    case 1:
+        rv = -1;
+        errno = EAGAIN;
+        break;
+    case 2:
+        rv = sizeof(request) - sizeof(REQUEST_1);
+        break;
+    default:
+        break;
+    }
+    evbuffer_read_call_count++;
+
+    return rv;
+}
+
+int
+main(void)
+{
+    tmpdir = lgtd_tests_make_temp_dir();
+    atexit(cleanup_tmpdir);
+
+    char path[PATH_MAX] = { 0 };
+    snprintf(path, sizeof(path), "%s/lightsd.pipe", tmpdir);
+    if (!lgtd_command_pipe_open(path)) {
+        errx(1, "couldn't open pipe");
+    }
+
+    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
+
+    lgtd_command_pipe_read_callback(pipe->fd, EV_READ, pipe);
+    lgtd_command_pipe_read_callback(pipe->fd, EV_READ, pipe);
+
+    return 0;
+}
diff --git a/tests/core/client/tests_client_utils.h b/tests/core/client/tests_client_utils.h
new file mode 100644
--- /dev/null
+++ b/tests/core/client/tests_client_utils.h
@@ -0,0 +1,1 @@
+#pragma once
diff --git a/tests/core/mock_event2.h b/tests/core/mock_event2.h
--- a/tests/core/mock_event2.h
+++ b/tests/core/mock_event2.h
@@ -133,3 +133,12 @@
     return 0;
 }
 #endif
+
+#ifndef MOCKED_BUFFEREVENT_GET_INPUT
+struct evbuffer *
+bufferevent_get_input(struct bufferevent *bufev)
+{
+    (void)bufev;
+    return NULL;
+}
+#endif
diff --git a/tests/core/mock_jsonrpc.h b/tests/core/mock_jsonrpc.h
new file mode 100644
--- /dev/null
+++ b/tests/core/mock_jsonrpc.h
@@ -0,0 +1,10 @@
+#pragma once
+
+#ifndef MOCKED_JSONRPC_DISPATCH_REQUEST
+void
+lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
+{
+    (void)client;
+    (void)parsed;
+}
+#endif
diff --git a/tests/core/pipe/test_pipe_close.c b/tests/core/pipe/test_pipe_close.c
--- a/tests/core/pipe/test_pipe_close.c
+++ b/tests/core/pipe/test_pipe_close.c
@@ -13,6 +13,7 @@
 #define MOCKED_EVENT_FREE
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
diff --git a/tests/core/pipe/test_pipe_open.c b/tests/core/pipe/test_pipe_open.c
--- a/tests/core/pipe/test_pipe_open.c
+++ b/tests/core/pipe/test_pipe_open.c
@@ -12,6 +12,7 @@
 #define MOCKED_EVENT_ADD
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
diff --git a/tests/core/pipe/test_pipe_open_fifo_already_exists.c b/tests/core/pipe/test_pipe_open_fifo_already_exists.c
--- a/tests/core/pipe/test_pipe_open_fifo_already_exists.c
+++ b/tests/core/pipe/test_pipe_open_fifo_already_exists.c
@@ -12,6 +12,7 @@
 #define MOCKED_EVENT_ADD
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
diff --git a/tests/core/pipe/test_pipe_read_callback.c b/tests/core/pipe/test_pipe_read_callback.c
--- a/tests/core/pipe/test_pipe_read_callback.c
+++ b/tests/core/pipe/test_pipe_read_callback.c
@@ -15,11 +15,12 @@
 #define MOCKED_EVBUFFER_DRAIN
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#define MOCKED_JSONRPC_DISPATCH_REQUEST
 #include "tests_pipe_utils.h"
 
 static unsigned char request[] = ("{"
diff --git a/tests/core/pipe/test_pipe_read_callback_extra_data.c b/tests/core/pipe/test_pipe_read_callback_extra_data.c
--- a/tests/core/pipe/test_pipe_read_callback_extra_data.c
+++ b/tests/core/pipe/test_pipe_read_callback_extra_data.c
@@ -14,11 +14,12 @@
 #define MOCKED_EVBUFFER_DRAIN
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#define MOCKED_JSONRPC_DISPATCH_REQUEST
 #include "tests_pipe_utils.h"
 
 #define REQUEST_1 "{"                   \
diff --git a/tests/core/pipe/test_pipe_read_callback_multiple_requests.c b/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
--- a/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
+++ b/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
@@ -14,11 +14,12 @@
 #define MOCKED_EVBUFFER_DRAIN
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#define MOCKED_JSONRPC_DISPATCH_REQUEST
 #include "tests_pipe_utils.h"
 
 #define REQUEST_1 "{"                   \
diff --git a/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c b/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c
--- a/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c
+++ b/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c
@@ -14,11 +14,12 @@
 #define MOCKED_EVBUFFER_DRAIN
 #include "mock_event2.h"
 #include "mock_gateway.h"
+#define MOCKED_JSONRPC_DISPATCH_REQUEST
+#include "mock_jsonrpc.h"
 #include "mock_router.h"
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#define MOCKED_JSONRPC_DISPATCH_REQUEST
 #include "tests_pipe_utils.h"
 
 #define REQUEST_1 "{"                   \
diff --git a/tests/core/pipe/tests_pipe_utils.h b/tests/core/pipe/tests_pipe_utils.h
--- a/tests/core/pipe/tests_pipe_utils.h
+++ b/tests/core/pipe/tests_pipe_utils.h
@@ -10,12 +10,3 @@
     jsmn_init(&pipe_client->jsmn_ctx);
 }
 #endif
-
-#ifndef MOCKED_JSONRPC_DISPATCH_REQUEST
-void
-lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
-{
-    (void)client;
-    (void)parsed;
-}
-#endif
