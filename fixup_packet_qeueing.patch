# HG changeset patch
# Parent  743091f71e9e8704b7b707b31c35237b01b08925

diff --git a/tests/lifx/gateway/test_gateway_enqueue_packet.c b/tests/lifx/gateway/test_gateway_enqueue_packet.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_enqueue_packet.c
@@ -0,0 +1,65 @@
+#include "gateway.c"
+
+#include "test_gateway_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+    gw.write_ev = (void *)42;
+
+    struct lgtd_lifx_packet_power_state pkt;
+    pkt.power = LGTD_LIFX_POWER_ON;
+
+    union lgtd_lifx_target target = { .tags = 0 };
+
+    struct lgtd_lifx_packet_header hdr;
+    lgtd_lifx_wire_setup_header(
+        &hdr,
+        LGTD_LIFX_TARGET_ALL_DEVICES,
+        target,
+        gw.site.as_array,
+        LGTD_LIFX_SET_POWER_STATE
+    );
+
+    lgtd_lifx_gateway_enqueue_packet(
+        &gw, &hdr, LGTD_LIFX_SET_POWER_STATE, &pkt, sizeof(pkt)
+    );
+
+    if (memcmp(gw_write_buf, &hdr, sizeof(hdr))) {
+        errx(1, "header incorrectly buffered");
+    }
+
+    if (memcmp(&gw_write_buf[sizeof(hdr)], &pkt, sizeof(pkt))) {
+        errx(1, "pkt incorrectly buffered");
+    }
+
+    if (gw.pkt_ring[0].type != LGTD_LIFX_SET_POWER_STATE) {
+        errx(1, "packet type incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring[0].size != sizeof(pkt) + sizeof(hdr)) {
+        errx(1, "packet size incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring_head != 1) {
+        errx(1, "packet ring head should be on index 1");
+    }
+
+    if (gw.pkt_ring_tail != 0) {
+        errx(1, "packet ring tail should be on index 0");
+    }
+
+    if (gw.pkt_ring_full == true) {
+        errx(1, "packet ring shouldn't be full");
+    }
+
+    if (last_event_passed_to_event_add != gw.write_ev) {
+        errx(1, "event_add should have been called with gw.write_ev");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_enqueue_packet_ring_full.c b/tests/lifx/gateway/test_gateway_enqueue_packet_ring_full.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_enqueue_packet_ring_full.c
@@ -0,0 +1,89 @@
+#include "gateway.c"
+
+#include "test_gateway_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+    gw.write_ev = (void *)42;
+
+    struct lgtd_lifx_packet_power_state pkt;
+    pkt.power = LGTD_LIFX_POWER_ON;
+
+    union lgtd_lifx_target target = { .tags = 0 };
+
+    struct lgtd_lifx_packet_header hdr;
+    lgtd_lifx_wire_setup_header(
+        &hdr,
+        LGTD_LIFX_TARGET_ALL_DEVICES,
+        target,
+        gw.site.as_array,
+        LGTD_LIFX_SET_POWER_STATE
+    );
+
+    // set the head so it catches up the tail:
+    gw.pkt_ring_head = 1;
+    gw.pkt_ring_tail = 2;
+
+    lgtd_lifx_gateway_enqueue_packet(
+        &gw, &hdr, LGTD_LIFX_SET_POWER_STATE, &pkt, sizeof(pkt)
+    );
+
+    if (memcmp(gw_write_buf, &hdr, sizeof(hdr))) {
+        errx(1, "header incorrectly buffered");
+    }
+
+    if (memcmp(&gw_write_buf[sizeof(hdr)], &pkt, sizeof(pkt))) {
+        errx(1, "pkt incorrectly buffered");
+    }
+
+    if (gw.pkt_ring[1].type != LGTD_LIFX_SET_POWER_STATE) {
+        errx(1, "packet type incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring[1].size != sizeof(pkt) + sizeof(hdr)) {
+        errx(1, "packet size incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring_head != 2) {
+        errx(1, "packet ring head should be on index 2");
+    }
+
+    if (gw.pkt_ring_tail != 2) {
+        errx(1, "packet ring tail should be on index 2");
+    }
+
+    if (gw.pkt_ring_full != true) {
+        errx(1, "packet ring should be full");
+    }
+
+    if (last_event_passed_to_event_add != gw.write_ev) {
+        errx(1, "event_add should have been called with gw.write_ev");
+    }
+
+    lgtd_lifx_gateway_enqueue_packet(
+        &gw, &hdr, LGTD_LIFX_SET_POWER_STATE, &pkt, sizeof(pkt)
+    );
+
+    if (gw_write_buf_idx != sizeof(pkt) + sizeof(hdr)) {
+        errx(1, "nothing should have been buffered");
+    }
+
+    if (gw.pkt_ring_head != 2) {
+        errx(1, "packet ring head should be on index 2");
+    }
+
+    if (gw.pkt_ring_tail != 2) {
+        errx(1, "packet ring tail should be on index 2");
+    }
+
+    if (gw.pkt_ring_full != true) {
+        errx(1, "packet ring should be full");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_enqueue_packet_ring_wraparound.c b/tests/lifx/gateway/test_gateway_enqueue_packet_ring_wraparound.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_enqueue_packet_ring_wraparound.c
@@ -0,0 +1,71 @@
+#include "gateway.c"
+
+#include "test_gateway_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+    gw.write_ev = (void *)42;
+
+    struct lgtd_lifx_packet_power_state pkt;
+    pkt.power = LGTD_LIFX_POWER_ON;
+
+    union lgtd_lifx_target target = { .tags = 0 };
+
+    struct lgtd_lifx_packet_header hdr;
+    lgtd_lifx_wire_setup_header(
+        &hdr,
+        LGTD_LIFX_TARGET_ALL_DEVICES,
+        target,
+        gw.site.as_array,
+        LGTD_LIFX_SET_POWER_STATE
+    );
+
+    int pkt_ring_last_idx = LGTD_ARRAY_SIZE(gw.pkt_ring) - 1;
+
+    // set the head so it has to wrap-around and set the tail somewhere:
+    gw.pkt_ring_head = pkt_ring_last_idx;
+    gw.pkt_ring_tail = 2;
+
+    lgtd_lifx_gateway_enqueue_packet(
+        &gw, &hdr, LGTD_LIFX_SET_POWER_STATE, &pkt, sizeof(pkt)
+    );
+
+    if (memcmp(gw_write_buf, &hdr, sizeof(hdr))) {
+        errx(1, "header incorrectly buffered");
+    }
+
+    if (memcmp(&gw_write_buf[sizeof(hdr)], &pkt, sizeof(pkt))) {
+        errx(1, "pkt incorrectly buffered");
+    }
+
+    if (gw.pkt_ring[pkt_ring_last_idx].type != LGTD_LIFX_SET_POWER_STATE) {
+        errx(1, "packet type incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring[pkt_ring_last_idx].size != sizeof(pkt) + sizeof(hdr)) {
+        errx(1, "packet size incorrectly enqueued");
+    }
+
+    if (gw.pkt_ring_head != 0) {
+        errx(1, "packet ring head should have wrapped around to index 0");
+    }
+
+    if (gw.pkt_ring_tail != 2) {
+        errx(1, "packet ring tail should be on index 2");
+    }
+
+    if (gw.pkt_ring_full == true) {
+        errx(1, "packet ring shouldn't be full");
+    }
+
+    if (last_event_passed_to_event_add != gw.write_ev) {
+        errx(1, "event_add should have been called with gw.write_ev");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_write_callback.c b/tests/lifx/gateway/test_gateway_write_callback.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_write_callback.c
@@ -0,0 +1,77 @@
+#include "gateway.c"
+
+#define MOCKED_EVBUFFER_WRITE_ATMOST
+#define MOCKED_EVBUFFER_GET_LENGTH
+#include "test_gateway_utils.h"
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)42) {
+        errx(1, "didn't get the expected evbuffer");
+    }
+
+    // fake another packet to write:
+    return sizeof(struct lgtd_lifx_packet_header);
+}
+
+int
+evbuffer_write_atmost(struct evbuffer *buf,
+                      evutil_socket_t fd,
+                      ev_ssize_t howmuch)
+{
+    if (fd != 25) {
+        errx(1, "evbuffer_write_atmost didn't get the expected socket");
+    }
+
+    if (buf != (void *)42) {
+        errx(1, "evbuffer_write_atmost didn't get the expected evbuffer");
+    }
+
+    int expected = sizeof(struct lgtd_lifx_packet_header);
+    expected += sizeof(struct lgtd_lifx_packet_power_state);
+    if (howmuch != expected) {
+        errx(
+            1, "evbuffer_write_atmost expected %d but got %ld",
+            expected, howmuch
+        );
+    }
+
+    return howmuch;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    // fake some values:
+    gw.socket = 25;
+    gw.write_ev = (void *)21;
+    gw.write_buf = (void *)42;
+
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_header);
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_power_state);
+    gw.pkt_ring[0].type = LGTD_LIFX_SET_POWER_STATE;
+    gw.pkt_ring_head++;
+    gw.pkt_ring_head++;
+
+    lgtd_lifx_gateway_write_callback(-1, EV_WRITE, &gw);
+
+    if (gw.pkt_ring[0].size != 0 || gw.pkt_ring[0].type != 0) {
+        errx(1, "the ring entry should have been reset");
+    }
+
+    if (gw.pkt_ring_tail != 1) {
+        errx(1, "the tail shoud have been moved by one");
+    }
+
+    if (last_event_passed_to_event_del != NULL) {
+        errx(1, "event_del shouldn't have ben called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_write_callback_clears_ring_full_flag.c b/tests/lifx/gateway/test_gateway_write_callback_clears_ring_full_flag.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_write_callback_clears_ring_full_flag.c
@@ -0,0 +1,80 @@
+#include "gateway.c"
+
+#define MOCKED_EVBUFFER_WRITE_ATMOST
+#define MOCKED_EVBUFFER_GET_LENGTH
+#include "test_gateway_utils.h"
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)42) {
+        errx(1, "didn't get the expected evbuffer");
+    }
+
+    // fake another packet to write:
+    return sizeof(struct lgtd_lifx_packet_header);
+}
+
+int
+evbuffer_write_atmost(struct evbuffer *buf,
+                      evutil_socket_t fd,
+                      ev_ssize_t howmuch)
+{
+    if (fd != 25) {
+        errx(1, "evbuffer_write_atmost didn't get the expected socket");
+    }
+
+    if (buf != (void *)42) {
+        errx(1, "evbuffer_write_atmost didn't get the expected evbuffer");
+    }
+
+    int expected = sizeof(struct lgtd_lifx_packet_header);
+    expected += sizeof(struct lgtd_lifx_packet_power_state);
+    if (howmuch != expected) {
+        errx(
+            1, "evbuffer_write_atmost expected %d but got %ld",
+            expected, howmuch
+        );
+    }
+
+    return howmuch;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    // fake some values:
+    gw.socket = 25;
+    gw.write_ev = (void *)21;
+    gw.write_buf = (void *)42;
+
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_header);
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_power_state);
+    gw.pkt_ring[0].type = LGTD_LIFX_SET_POWER_STATE;
+    gw.pkt_ring_full = true;
+
+    lgtd_lifx_gateway_write_callback(-1, EV_WRITE, &gw);
+
+    if (gw.pkt_ring[0].size != 0 || gw.pkt_ring[0].type != 0) {
+        errx(1, "the ring entry should have been reset");
+    }
+
+    if (gw.pkt_ring_tail != 1) {
+        errx(1, "the tail shoud have been moved by one");
+    }
+
+    if (last_event_passed_to_event_del != NULL) {
+        errx(1, "event_del shouldn't have ben called");
+    }
+
+    if (gw.pkt_ring_full) {
+        errx(1, "the ring full flag should have been cleared out");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_write_callback_last_packet_on_ring.c b/tests/lifx/gateway/test_gateway_write_callback_last_packet_on_ring.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_write_callback_last_packet_on_ring.c
@@ -0,0 +1,76 @@
+#include "gateway.c"
+
+#define MOCKED_EVBUFFER_WRITE_ATMOST
+#define MOCKED_EVBUFFER_GET_LENGTH
+#include "test_gateway_utils.h"
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)42) {
+        errx(1, "didn't get the expected evbuffer");
+    }
+
+    return 0;
+}
+
+int
+evbuffer_write_atmost(struct evbuffer *buf,
+                      evutil_socket_t fd,
+                      ev_ssize_t howmuch)
+{
+    if (fd != 25) {
+        errx(1, "evbuffer_write_atmost didn't get the expected socket");
+    }
+
+    if (buf != (void *)42) {
+        errx(1, "evbuffer_write_atmost didn't get the expected evbuffer");
+    }
+
+    int expected = sizeof(struct lgtd_lifx_packet_header);
+    expected += sizeof(struct lgtd_lifx_packet_power_state);
+    if (howmuch != expected) {
+        errx(
+            1, "evbuffer_write_atmost expected %d but got %ld",
+            expected, howmuch
+        );
+    }
+
+    return howmuch;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    // fake some values:
+    gw.socket = 25;
+    gw.write_ev = (void *)21;
+    gw.write_buf = (void *)42;
+
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_header);
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_power_state);
+    gw.pkt_ring[0].type = LGTD_LIFX_SET_POWER_STATE;
+    gw.pkt_ring_head++;
+    gw.pkt_ring_head++;
+
+    lgtd_lifx_gateway_write_callback(-1, EV_WRITE, &gw);
+
+    if (gw.pkt_ring[0].size != 0 || gw.pkt_ring[0].type != 0) {
+        errx(1, "the ring entry should have been reset");
+    }
+
+    if (gw.pkt_ring_tail != 1) {
+        errx(1, "the tail shoud have been moved by one");
+    }
+
+    if (last_event_passed_to_event_del != (void *)21) {
+        errx(1, "event_del should have ben called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_write_callback_partial_write.c b/tests/lifx/gateway/test_gateway_write_callback_partial_write.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_write_callback_partial_write.c
@@ -0,0 +1,101 @@
+#include "gateway.c"
+
+#define MOCKED_EVBUFFER_WRITE_ATMOST
+#define MOCKED_EVBUFFER_GET_LENGTH
+#include "test_gateway_utils.h"
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)42) {
+        errx(1, "didn't get the expected evbuffer");
+    }
+
+    // fake another packet to write:
+    return sizeof(struct lgtd_lifx_packet_header);
+}
+
+int
+evbuffer_write_atmost(struct evbuffer *buf,
+                      evutil_socket_t fd,
+                      ev_ssize_t howmuch)
+{
+    if (fd != 25) {
+        errx(1, "evbuffer_write_atmost didn't get the expected socket");
+    }
+
+    if (buf != (void *)42) {
+        errx(1, "evbuffer_write_atmost didn't get the expected evbuffer");
+    }
+
+    static int expected = (
+        sizeof(struct lgtd_lifx_packet_header)
+        + sizeof(struct lgtd_lifx_packet_power_state)
+    );
+    if (howmuch != expected) {
+        errx(
+            1, "evbuffer_write_atmost expected %d but got %ld",
+            expected, howmuch
+        );
+    }
+
+    if (expected != sizeof(struct lgtd_lifx_packet_power_state)) {
+        expected -= sizeof(struct lgtd_lifx_packet_header);
+        return sizeof(struct lgtd_lifx_packet_header);
+    }
+
+    return howmuch;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    // fake some values:
+    gw.socket = 25;
+    gw.write_buf = (void *)42;
+
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_header);
+    gw.pkt_ring[0].size += sizeof(struct lgtd_lifx_packet_power_state);
+    gw.pkt_ring[0].type = LGTD_LIFX_SET_POWER_STATE;
+    gw.pkt_ring_head++;
+    gw.pkt_ring_head++;
+
+    lgtd_lifx_gateway_write_callback(-1, EV_WRITE, &gw);
+
+    if (gw.pkt_ring[0].type != LGTD_LIFX_SET_POWER_STATE) {
+        errx(1, "the ring entry doesn't have the right packet type");
+    }
+
+    if (gw.pkt_ring[0].size != sizeof(struct lgtd_lifx_packet_power_state)) {
+        errx(1, "the ring entry doesn't have the right size value");
+    }
+
+    if (gw.pkt_ring_tail != 0) {
+        errx(1, "the tail shoudn't have been moved by one");
+    }
+
+    if (last_event_passed_to_event_del != NULL) {
+        errx(1, "event_del shouldn't have ben called");
+    }
+
+    lgtd_lifx_gateway_write_callback(-1, EV_WRITE, &gw);
+
+    if (gw.pkt_ring[0].size != 0 || gw.pkt_ring[0].type != 0) {
+        errx(1, "the ring entry should have been reset");
+    }
+
+    if (gw.pkt_ring_tail != 1) {
+        errx(1, "the tail shoud have been moved by one");
+    }
+
+    if (last_event_passed_to_event_del != NULL) {
+        errx(1, "event_del shouldn't have ben called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_write_callback_ring_wraparound.c b/tests/lifx/gateway/test_gateway_write_callback_ring_wraparound.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_write_callback_ring_wraparound.c
@@ -0,0 +1,79 @@
+#include "gateway.c"
+
+#define MOCKED_EVBUFFER_WRITE_ATMOST
+#define MOCKED_EVBUFFER_GET_LENGTH
+#include "test_gateway_utils.h"
+
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    if (buf != (void *)42) {
+        errx(1, "didn't get the expected evbuffer");
+    }
+
+    // fake another packet to write:
+    return sizeof(struct lgtd_lifx_packet_header);
+}
+
+int
+evbuffer_write_atmost(struct evbuffer *buf,
+                      evutil_socket_t fd,
+                      ev_ssize_t howmuch)
+{
+    if (fd != 25) {
+        errx(1, "evbuffer_write_atmost didn't get the expected socket");
+    }
+
+    if (buf != (void *)42) {
+        errx(1, "evbuffer_write_atmost didn't get the expected evbuffer");
+    }
+
+    int expected = sizeof(struct lgtd_lifx_packet_header);
+    expected += sizeof(struct lgtd_lifx_packet_power_state);
+    if (howmuch != expected) {
+        errx(
+            1, "evbuffer_write_atmost expected %d but got %ld",
+            expected, howmuch
+        );
+    }
+
+    return howmuch;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    // fake some values:
+    gw.socket = 25;
+    gw.write_ev = (void *)21;
+    gw.write_buf = (void *)42;
+
+    int pkt_ring_last_idx = LGTD_ARRAY_SIZE(gw.pkt_ring) - 1;
+    gw.pkt_ring_tail = pkt_ring_last_idx;
+
+    gw.pkt_ring[pkt_ring_last_idx].size += sizeof(struct lgtd_lifx_packet_header);
+    gw.pkt_ring[pkt_ring_last_idx].size += sizeof(struct lgtd_lifx_packet_power_state);
+    gw.pkt_ring[pkt_ring_last_idx].type = LGTD_LIFX_SET_POWER_STATE;
+
+    lgtd_lifx_gateway_write_callback(-1, EV_WRITE, &gw);
+
+    if (gw.pkt_ring[pkt_ring_last_idx].size != 0
+        || gw.pkt_ring[pkt_ring_last_idx].type != 0) {
+        errx(1, "the ring entry should have been reset");
+    }
+
+    if (gw.pkt_ring_tail != 0) {
+        errx(1, "the tail shoud have wrapped around to 0");
+    }
+
+    if (last_event_passed_to_event_del != NULL) {
+        errx(1, "event_del shouldn't have ben called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/tests_shims.c b/tests/lifx/tests_shims.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/tests_shims.c
@@ -0,0 +1,37 @@
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+#include "core/lightsd.h"
+
+struct lgtd_opts lgtd_opts = {
+    .foreground = false,
+    .log_timestamps = false,
+    .verbosity = LGTD_DEBUG
+};
+
+struct event_base *lgtd_ev_base = NULL;
+
+void
+lgtd_cleanup(void)
+{
+}
+
+short
+lgtd_sockaddrport(const struct sockaddr_storage *peer)
+{
+    if (!peer) {
+        return -1;
+    }
+
+    if (peer->ss_family == AF_INET) {
+        const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
+        return ntohs(in_peer->sin_port);
+    } else {
+        const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
+        return ntohs(in6_peer->sin6_port);
+    }
+}
