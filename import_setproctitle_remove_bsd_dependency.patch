# HG changeset patch
# Parent  b53c2ad85dcb39d8d0773ce9b6e6584c877b2a04

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -26,10 +26,12 @@
 FIND_PACKAGE(Endian REQUIRED)
 
 INCLUDE(CheckFunctionExists)
+INCLUDE(CheckVariableExists)
+
 INCLUDE(TestBigEndian)
+INCLUDE(CompatReallocArray)
 INCLUDE(CompatSetProctitle)
 INCLUDE(CompatTimeMonotonic)
-INCLUDE(CompatReallocArray)
 
 TEST_BIG_ENDIAN(BIG_ENDIAN_SYSTEM)
 
@@ -58,8 +60,7 @@
     "-DLGTD_BIG_ENDIAN_SYSTEM=${BIG_ENDIAN_SYSTEM}"
     "-DLGTD_SIZEOF_VOID_P=${CMAKE_SIZEOF_VOID_P}"
 
-    "-DLGTD_HAVE_LIBBSD=${HAVE_LIBBSD}"
-    "-DLGTD_HAVE_PROCTITLE=${HAVE_PROCTITLE}"
+    "-DLGTD_HAVE_SETPROCTITLE=${HAVE_SETPROCTITLE}"
     "-DLGTD_HAVE_REALLOCARRAY=${HAVE_REALLOCARRAY}"
 
     "-DJSMN_STRICT=1"
diff --git a/CMakeScripts/CompatReallocArray.cmake b/CMakeScripts/CompatReallocArray.cmake
--- a/CMakeScripts/CompatReallocArray.cmake
+++ b/CMakeScripts/CompatReallocArray.cmake
@@ -4,12 +4,6 @@
 
 MESSAGE(STATUS "Looking for reallocarray")
 
-IF (HAVE_LIBBSD)
-    MESSAGE(STATUS "Looking for reallocarray - found")
-    SET(HAVE_REALLOCARRAY 1 CACHE INTERNAL "reallocarray found in libbsd")
-    RETURN()
-ENDIF ()
-
 SET(CMAKE_REQUIRED_QUIET TRUE)
 CHECK_FUNCTION_EXISTS("reallocarray" HAVE_REALLOCARRAY)
 UNSET(CMAKE_REQUIRED_QUIET)
diff --git a/CMakeScripts/CompatSetProctitle.cmake b/CMakeScripts/CompatSetProctitle.cmake
--- a/CMakeScripts/CompatSetProctitle.cmake
+++ b/CMakeScripts/CompatSetProctitle.cmake
@@ -1,20 +1,47 @@
-IF (NOT HAVE_PROCTITLE)
-    SET(CMAKE_REQUIRED_QUIET TRUE)
-    SET(HAVE_PROCTITLE 0 CACHE INTERNAL "setproctitle found in libbsd")
-    SET(HAVE_LIBBSD 0 CACHE INTERNAL "libbsd found")
-    MESSAGE(STATUS "Looking for setproctitle")
-    CHECK_FUNCTION_EXISTS("setproctitle" HAVE_PROCTITLE)
-    IF (NOT HAVE_PROCTITLE)
-        MESSAGE(STATUS "Looking for setproctitle - not found, falling back on libbsd")
-        FIND_PACKAGE(LibBSD)
-        IF (NOT LibBSD_FOUND)
-            MESSAGE(STATUS "Couldn't find setproctitle, no fancy report in the process list")
-        ELSE ()
-            SET(HAVE_PROCTITLE 1 CACHE INTERNAL "setproctitle found in libbsd")
-            SET(HAVE_LIBBSD 1 CACHE INTERNAL "libbsd found")
+IF (DEFINED HAVE_SETPROCTITLE)
+    IF (HAVE_SETPROCTITLE EQUAL 0)
+        IF (HAVE_CLEARENV)
+            ADD_DEFINITIONS("-DHAVE_CLEARENV=1")
         ENDIF ()
-    ELSE ()
-        SET(HAVE_PROCTITLE 1 CACHE INTERNAL "setproctitle found on the system")
+        IF (HAVE_GETEXECNAME)
+            ADD_DEFINITIONS("-DHAVE_GETEXECNAME=1")
+        ENDIF ()
+        IF (HAVE___PROGNAME)
+            ADD_DEFINITIONS("-DHAVE___PROGNAME=1")
+        ENDIF ()
+        IF (HAVE_HAVE_PROGRAM_INVOCATION_SHORT_NAME)
+            ADD_DEFINITIONS("-DHAVE_HAVE_PROGRAM_INVOCATION_SHORT_NAME=1")
+        ENDIF ()
     ENDIF ()
-    UNSET(CMAKE_REQUIRED_QUIET)
+    RETURN()
 ENDIF ()
+
+MESSAGE(STATUS "Looking for setproctitle")
+
+SET(CMAKE_REQUIRED_QUIET TRUE)
+CHECK_FUNCTION_EXISTS("setproctitle" HAVE_SETPROCTITLE)
+UNSET(CMAKE_REQUIRED_QUIET)
+IF (HAVE_SETPROCTITLE)
+    MESSAGE(
+        STATUS
+        "Looking for setproctitle - found"
+    )
+    SET(HAVE_SETPROCTITLE 1 CACHE INTERNAL "setproctitle found on the system")
+ELSE ()
+    MESSAGE(
+        STATUS
+        "Looking for setproctitle - not found, using built-in compatibilty file"
+    )
+    SET(
+        HAVE_SETPROCTITLE 0
+        CACHE INTERNAL
+        "setproctitle not found, using internal implementation"
+    )
+
+    CHECK_FUNCTION_EXISTS("clearenv" HAVE_CLEARENV)
+    CHECK_FUNCTION_EXISTS("getexecname" HAVE_GETEXECNAME)
+    CHECK_VARIABLE_EXISTS("__progname" HAVE___PROGNAME)
+    CHECK_VARIABLE_EXISTS(
+        "program_invocation_short_name" HAVE_PROGRAM_INVOCATION_SHORT_NAME
+    )
+ENDIF ()
diff --git a/CMakeScripts/FindLibBSD.cmake b/CMakeScripts/FindLibBSD.cmake
deleted file mode 100644
--- a/CMakeScripts/FindLibBSD.cmake
+++ /dev/null
@@ -1,10 +0,0 @@
-FIND_PATH(LIBBSD_INCLUDE_DIR bsd.h PATH_SUFFIXES bsd)
-
-FIND_LIBRARY(LIBBSD_LIBRARY bsd)
-IF(LIBBSD_LIBRARY)
-    SET(LibBSD_FOUND TRUE)
-ENDIF()
-
-INCLUDE(FindPackageHandleStandardArgs)
-
-FIND_PACKAGE_HANDLE_STANDARD_ARGS(LibBSD DEFAULT_MSG LIBBSD_LIBRARY LIBBSD_INCLUDE_DIR)
diff --git a/README.rst b/README.rst
--- a/README.rst
+++ b/README.rst
@@ -61,9 +61,6 @@
 - CMake ≥ 2.8.11 (released May 2013): only if you want to build lightsd from its
   sources.
 
-lightsd optionally depends on libbsd ≥ 0.5.0 on platforms missing
-``setproctitle`` (pretty much any non-BSD system, including Mac OS X).
-
 lightsd is actively developed and tested from Arch Linux, Debian and Mac OS X;
 both for 32/64 bits and little/big endian architectures.
 
diff --git a/core/CMakeLists.txt b/core/CMakeLists.txt
--- a/core/CMakeLists.txt
+++ b/core/CMakeLists.txt
@@ -22,6 +22,7 @@
     pipe.c
     proto.c
     router.c
+    setproctitle.c
     stats.c
     timer.c
 )
@@ -33,8 +34,4 @@
     ${TIME_MONOTONIC_LIBRARY}
 )
 
-IF (HAVE_LIBBSD)
-    TARGET_LINK_LIBRARIES(lightsd ${LIBBSD_LIBRARY})
-ENDIF (HAVE_LIBBSD)
-
 INSTALL(TARGETS lightsd RUNTIME DESTINATION bin)
diff --git a/core/daemon.c b/core/daemon.c
--- a/core/daemon.c
+++ b/core/daemon.c
@@ -27,10 +27,6 @@
 #include <string.h>
 #include <unistd.h>
 
-#if LGTD_HAVE_LIBBSD
-#include <bsd/bsd.h>
-#endif
-
 #include <event2/util.h>
 
 #include "time_monotonic.h"
@@ -91,14 +87,14 @@
 void
 lgtd_daemon_setup_proctitle(int argc, char *argv[], char *envp[])
 {
-#if LGTD_HAVE_LIBBSD
+#ifdef LGTD_HAVE_SETPROCTITLE
+    (void)argc;
+    (void)argv;
+    (void)envp;
+#else
     setproctitle_init(argc, argv, envp);
     lgtd_daemon_update_proctitle();
     lgtd_daemon_proctitle_initialized = true;
-#else
-    (void)argc;
-    (void)argv;
-    (void)envp;
 #endif
 }
 
@@ -109,7 +105,7 @@
         return;
     }
 
-#if LGTD_HAVE_PROCTITLE
+#ifdef LGTD_HAVE_SETPROCTITLE
     char title[LGTD_DAEMON_TITLE_SIZE] = { 0 };
     int i = 0;
 
diff --git a/core/lightsd.h b/core/lightsd.h
--- a/core/lightsd.h
+++ b/core/lightsd.h
@@ -101,8 +101,6 @@
     }
     return realloc(optr, size * nmemb);
 }
-#elif LGTD_HAVE_LIBBSD
-# include <bsd/bsd.h>
 #endif
 
 struct lgtd_opts {
diff --git a/core/log.c b/core/log.c
--- a/core/log.c
+++ b/core/log.c
@@ -32,10 +32,6 @@
 #include <string.h>
 #include <time.h>
 
-#if LGTD_HAVE_LIBBSD
-#include <bsd/unistd.h>
-#endif
-
 #include <event2/event.h>
 
 #include "lifx/wire_proto.h"
@@ -233,6 +229,6 @@
     case EVENT_LOG_MSG:     lgtd_info("%s", msg);  break;
     case EVENT_LOG_WARN:    lgtd_warnx("%s", msg)  break;
     case EVENT_LOG_ERR:     lgtd_warnx("%s", msg); break;
-    default:                                        break;
+    default:                                       break;
     }
 }
diff --git a/core/setproctitle.c b/core/setproctitle.c
new file mode 100644
--- /dev/null
+++ b/core/setproctitle.c
@@ -0,0 +1,325 @@
+#if !LGTD_HAVE_SETPROCTITLE
+/*
+ * Copyright © 2010 William Ahern
+ * Copyright © 2012-2013 Guillem Jover <guillem@hadrons.org>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to permit
+ * persons to whom the Software is furnished to do so, subject to the
+ * following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+ * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <errno.h>
+#include <stddef.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <err.h>
+#include <unistd.h>
+#include <string.h>
+
+extern char **environ;
+
+static struct {
+	/* Original value. */
+	const char *arg0;
+
+	/* Title space available. */
+	char *base, *end;
+
+	 /* Pointer to original nul character within base. */
+	char *nul;
+
+	bool warned;
+	bool reset;
+	int error;
+} SPT;
+
+
+static inline size_t
+spt_min(size_t a, size_t b)
+{
+	return a < b ? a : b;
+}
+
+/*
+ * For discussion on the portability of the various methods, see
+ * http://lists.freebsd.org/pipermail/freebsd-stable/2008-June/043136.html
+ */
+static int
+spt_clearenv(void)
+{
+#ifdef HAVE_CLEARENV
+	return clearenv();
+#else
+	char **tmp;
+
+	tmp = malloc(sizeof(*tmp));
+	if (tmp == NULL)
+		return errno;
+
+	tmp[0] = NULL;
+	environ = tmp;
+
+	return 0;
+#endif
+}
+
+static int
+spt_copyenv(int envc, char *envp[])
+{
+	char **envcopy;
+	char *eq;
+	int envsize;
+	int i, error;
+
+	if (environ != envp)
+		return 0;
+
+	/* Make a copy of the old environ array of pointers, in case
+	 * clearenv() or setenv() is implemented to free the internal
+	 * environ array, because we will need to access the old environ
+	 * contents to make the new copy. */
+	envsize = (envc + 1) * sizeof(char *);
+	envcopy = malloc(envsize);
+	if (envcopy == NULL)
+		return errno;
+	memcpy(envcopy, envp, envsize);
+
+	error = spt_clearenv();
+	if (error) {
+		environ = envp;
+		free(envcopy);
+		return error;
+	}
+
+	for (i = 0; envcopy[i]; i++) {
+		eq = strchr(envcopy[i], '=');
+		if (eq == NULL)
+			continue;
+
+		*eq = '\0';
+		if (setenv(envcopy[i], eq + 1, 1) < 0)
+			error = errno;
+		*eq = '=';
+
+		if (error) {
+#ifdef HAVE_CLEARENV
+			/* Because the old environ might not be available
+			 * anymore we will make do with the shallow copy. */
+			environ = envcopy;
+#else
+			environ = envp;
+			free(envcopy);
+#endif
+			return error;
+		}
+	}
+
+	/* Dispose of the shallow copy, now that we've finished transfering
+	 * the old environment. */
+	free(envcopy);
+
+	return 0;
+}
+
+static int
+spt_copyargs(int argc, char *argv[])
+{
+	char *tmp;
+	int i;
+
+	for (i = 1; i < argc || (i >= argc && argv[i]); i++) {
+		if (argv[i] == NULL)
+			continue;
+
+		tmp = strdup(argv[i]);
+		if (tmp == NULL)
+			return errno;
+
+		argv[i] = tmp;
+	}
+
+	return 0;
+}
+
+/* 
+  Rejected in glibc (http://sourceware.org/ml/libc-alpha/2006-03/msg00125.html)
+*/
+
+#ifdef HAVE___PROGNAME
+extern const char *__progname;
+#else
+static const char *__progname = NULL;
+#endif
+
+const char *
+getprogname(void)
+{
+#if defined(HAVE_PROGRAM_INVOCATION_SHORT_NAME)
+	if (__progname == NULL)
+		__progname = program_invocation_short_name;
+#elif defined(HAVE_GETEXECNAME)
+	/* getexecname(3) returns an absolute pathname, normalize it. */
+	if (__progname == NULL)
+		setprogname(getexecname());
+#endif
+
+	return __progname;
+}
+
+void
+setprogname(const char *progname)
+{
+	const char *last_slash;
+
+	last_slash = strrchr(progname, '/');
+	if (last_slash == NULL)
+		__progname = progname;
+	else
+		__progname = last_slash + 1;
+}
+
+void
+setproctitle_init(int argc, char *argv[], char *envp[])
+{
+	char *base, *end, *nul, *tmp;
+	int i, envc, error;
+
+	/* Try to make sure we got called with main() arguments. */
+	if (argc < 0)
+		return;
+
+	base = argv[0];
+	if (base == NULL)
+		return;
+
+	nul = &base[strlen(base)];
+	end = nul + 1;
+
+	for (i = 0; i < argc || (i >= argc && argv[i]); i++) {
+		if (argv[i] == NULL || argv[i] < end)
+			continue;
+
+		end = argv[i] + strlen(argv[i]) + 1;
+	}
+
+	for (i = 0; envp[i]; i++) {
+		if (envp[i] < end)
+			continue;
+
+		end = envp[i] + strlen(envp[i]) + 1;
+	}
+	envc = i;
+
+	SPT.arg0 = strdup(argv[0]);
+	if (SPT.arg0 == NULL) {
+		SPT.error = errno;
+		return;
+	}
+
+	tmp = strdup(getprogname());
+	if (tmp == NULL) {
+		SPT.error = errno;
+		return;
+	}
+	setprogname(tmp);
+
+	error = spt_copyenv(envc, envp);
+	if (error) {
+		SPT.error = error;
+		return;
+	}
+
+	error = spt_copyargs(argc, argv);
+	if (error) {
+		SPT.error = error;
+		return;
+	}
+
+	SPT.nul  = nul;
+	SPT.base = base;
+	SPT.end  = end;
+}
+
+#ifndef SPT_MAXTITLE
+#define SPT_MAXTITLE 255
+#endif
+
+void
+setproctitle(const char *fmt, ...)
+{
+	/* Use buffer in case argv[0] is passed. */
+	char buf[SPT_MAXTITLE + 1];
+	va_list ap;
+	char *nul;
+	int len;
+
+	if (SPT.base == NULL) {
+		if (!SPT.warned) {
+			warnx("setproctitle not initialized, please either call "
+			      "setproctitle_init() or link against libbsd-ctor.");
+			SPT.warned = true;
+		}
+		return;
+	}
+
+	if (fmt) {
+		if (fmt[0] == '-') {
+			/* Skip program name prefix. */
+			fmt++;
+			len = 0;
+		} else {
+			/* Print program name heading for grep. */
+			snprintf(buf, sizeof(buf), "%s: ", getprogname());
+			len = strlen(buf);
+		}
+
+		va_start(ap, fmt);
+		len += vsnprintf(buf + len, sizeof(buf) - len, fmt, ap);
+		va_end(ap);
+	} else {
+		len = snprintf(buf, sizeof(buf), "%s", SPT.arg0);
+	}
+
+	if (len <= 0) {
+		SPT.error = errno;
+		return;
+	}
+
+	if (!SPT.reset) {
+		memset(SPT.base, 0, SPT.end - SPT.base);
+		SPT.reset = true;
+	} else {
+		memset(SPT.base, 0, spt_min(sizeof(buf), SPT.end - SPT.base));
+	}
+
+	len = spt_min(len, spt_min(sizeof(buf), SPT.end - SPT.base) - 1);
+	memcpy(SPT.base, buf, len);
+	nul = &SPT.base[len];
+
+	if (nul < SPT.nul) {
+		*SPT.nul = '.';
+	} else if (nul == SPT.nul && &nul[1] < SPT.end) {
+		*SPT.nul = ' ';
+		*++nul = '\0';
+	}
+}
+#else
+typedef int hello_compiler;
+#endif
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -6,9 +6,6 @@
         ${LIGHTSD_SOURCE_DIR}/core/
         ${LIGHTSD_BINARY_DIR}/core/
     )
-    IF (HAVE_LIBBSD)
-        TARGET_LINK_LIBRARIES(${LIBNAME} ${LIBBSD_LIBRARY})
-    ENDIF (HAVE_LIBBSD)
 ENDFUNCTION()
 
 ADD_ALL_SUBDIRECTORIES()
diff --git a/tests/core/daemon/test_daemon_update_proctitle.c b/tests/core/daemon/test_daemon_update_proctitle.c
--- a/tests/core/daemon/test_daemon_update_proctitle.c
+++ b/tests/core/daemon/test_daemon_update_proctitle.c
@@ -1,7 +1,6 @@
 void mock_setproctitle(const char *fmt, ...)
     __attribute__((format(printf, 1, 2)));
 
-#undef LGTD_HAVE_LIBBSD
 #undef LGTD_HAVE_PROCTITLE
 #define LGTD_HAVE_PROCTITLE 1
 #define setproctitle mock_setproctitle
diff --git a/tests/lifx/tagging/CMakeLists.txt b/tests/lifx/tagging/CMakeLists.txt
--- a/tests/lifx/tagging/CMakeLists.txt
+++ b/tests/lifx/tagging/CMakeLists.txt
@@ -3,15 +3,12 @@
     ${CMAKE_CURRENT_BINARY_DIR}
 )
 
-ADD_LIBRARY(
+ADD_CORE_LIBRARY(
     test_lifx_tagging STATIC
     ${LIGHTSD_SOURCE_DIR}/core/log.c
     ${LIGHTSD_SOURCE_DIR}/core/stats.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
 )
-IF (HAVE_LIBBSD)
-    TARGET_LINK_LIBRARIES(test_lifx_tagging ${LIBBSD_LIBRARY})
-ENDIF (HAVE_LIBBSD)
 
 FUNCTION(ADD_TAGGING_TEST TEST_SOURCE)
     ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE} test_lifx_tagging)
