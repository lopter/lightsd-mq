# HG changeset patch
# Parent  a7322016398fcd00dbe298f2e549ad3733acbe2a
Add the ability to tag (group) or untag (ungroup) bulbs

diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -950,6 +950,90 @@
     lgtd_proto_target_list_clear(&targets);
 }
 
+static void
+lgtd_jsonrpc_check_and_call_proto_tag_or_untag(struct lgtd_client *client,
+                                               void (*lgtd_proto_fn)(struct lgtd_client *,
+                                                          const struct lgtd_proto_target_list *,
+                                                          const char *))
+
+{
+    struct lgtd_jsonrpc_target_args {
+        const jsmntok_t *target;
+        int             target_ntokens;
+        const jsmntok_t *tag;
+    } params = { NULL, 0, NULL };
+    static const struct lgtd_jsonrpc_node schema[] = {
+        LGTD_JSONRPC_NODE(
+            "target",
+            offsetof(struct lgtd_jsonrpc_target_args, target),
+            offsetof(struct lgtd_jsonrpc_target_args, target_ntokens),
+            lgtd_jsonrpc_type_string_number_or_array,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "tag",
+            offsetof(struct lgtd_jsonrpc_target_args, tag),
+            -1,
+            lgtd_jsonrpc_type_string,
+            false
+        )
+    };
+
+    struct lgtd_jsonrpc_request *req = client->current_request;
+    bool ok = lgtd_jsonrpc_extract_and_validate_params_against_schema(
+        &params,
+        schema,
+        LGTD_ARRAY_SIZE(schema),
+        req->params,
+        req->params_ntokens,
+        client->json
+    );
+    if (!ok) {
+        lgtd_jsonrpc_send_error(
+            client, LGTD_JSONRPC_INVALID_PARAMS, "Invalid parameters"
+        );
+        return;
+    }
+
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
+    ok = lgtd_jsonrpc_build_target_list(
+        &targets, client, params.target, params.target_ntokens
+    );
+    if (!ok) {
+        return;
+    }
+
+    char *tag = strndup(
+        &client->json[params.tag->start], LGTD_JSONRPC_TOKEN_LEN(params.tag)
+    );
+    if (!tag) {
+        lgtd_warn("can't allocate a tag");
+        lgtd_jsonrpc_send_error(
+            client, LGTD_JSONRPC_INTERNAL_ERROR, "Can't allocate memory"
+        );
+        goto error_strdup;
+    }
+
+    lgtd_proto_fn(client, &targets, tag);
+
+    free(tag);
+
+error_strdup:
+    lgtd_proto_target_list_clear(&targets);
+}
+
+static void
+lgtd_jsonrpc_check_and_call_tag(struct lgtd_client *client)
+{
+    return lgtd_jsonrpc_check_and_call_proto_tag_or_untag(client, lgtd_proto_tag);
+}
+
+static void
+lgtd_jsonrpc_check_and_call_untag(struct lgtd_client *client)
+{
+    return lgtd_jsonrpc_check_and_call_proto_tag_or_untag(client, lgtd_proto_untag);
+}
+
 void
 lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
 {
@@ -974,6 +1058,14 @@
         LGTD_JSONRPC_METHOD(
             "get_light_state", 1, // t
             lgtd_jsonrpc_check_and_call_get_light_state
+        ),
+        LGTD_JSONRPC_METHOD(
+            "tag", 2, // t, tag
+            lgtd_jsonrpc_check_and_call_tag
+        ),
+        LGTD_JSONRPC_METHOD(
+            "untag", 2, // t, tag
+            lgtd_jsonrpc_check_and_call_untag
         )
     };
 
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -209,10 +209,20 @@
         bool comma = false;
         int tag_id;
         LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, bulb->state.tags) {
-            LGTD_CLIENT_WRITE_STRING(client, comma ? ",\"" : "\"");
-            LGTD_CLIENT_WRITE_STRING(client, bulb->gw->tags[tag_id]->label);
-            LGTD_CLIENT_WRITE_STRING(client, "\"");
-            comma = true;
+            if (LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id) & bulb->gw->tag_ids) {
+                LGTD_CLIENT_WRITE_STRING(client, comma ? ",\"" : "\"");
+                LGTD_CLIENT_WRITE_STRING(client, bulb->gw->tags[tag_id]->label);
+                LGTD_CLIENT_WRITE_STRING(client, "\"");
+                comma = true;
+            } else {
+                lgtd_warnx(
+                    "tag_id %d on bulb %.*s (%s) doesn't "
+                    "exist on gw [%s]:%hu (site %s)",
+                    tag_id, (int)sizeof(bulb->state.label), bulb->state.label,
+                    lgtd_addrtoa(bulb->addr), bulb->gw->ip_addr, bulb->gw->port,
+                    lgtd_addrtoa(bulb->gw->site.as_array)
+                );
+            }
         }
 
         LGTD_CLIENT_WRITE_STRING(
@@ -224,3 +234,138 @@
 
     lgtd_router_device_list_free(devices);
 }
+
+void
+lgtd_proto_tag(struct lgtd_client *client,
+               const struct lgtd_proto_target_list *targets,
+               const char *tag_label)
+{
+    assert(client);
+    assert(targets);
+    assert(tag_label);
+
+    struct lgtd_router_device_list *devices;
+    devices = lgtd_router_targets_to_devices(targets);
+    if (!devices) {
+        goto error_tag_alloc;
+    }
+
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(tag_label);
+    if (!tag) {
+        tag = lgtd_lifx_tagging_allocate_tag(tag_label);
+        if (!tag) {
+            goto error_tag_alloc;
+        }
+        lgtd_info("created tag [%s]", tag_label);
+    }
+
+    struct lgtd_router_device *device;
+    struct lgtd_lifx_site *site;
+
+    // Loop over the devices and do allocations first, this makes error
+    // handling easier (since you can't rollback enqueued packets) and builb
+    // the list of affected gateways so we can do SET_TAG_LABELS:
+    SLIST_FOREACH(device, devices, link) {
+        struct lgtd_lifx_gateway *gw = device->device->gw;
+        int tag_id = lgtd_lifx_gateway_get_tag_id(gw, tag);
+        if (tag_id == -1) {
+            tag_id = lgtd_lifx_gateway_allocate_tag_id(gw, -1, tag_label);
+            if (tag_id == -1) {
+                goto error_site_alloc;
+            }
+        }
+    }
+
+    // SET_TAG_LABELS, this is idempotent, do it everytime so we can recover
+    // from any bad state:
+    LIST_FOREACH(site, &tag->sites, link) {
+        int tag_id = lgtd_lifx_gateway_get_tag_id(site->gw, tag);
+        struct lgtd_lifx_packet_tag_labels pkt = { 0 };
+        pkt.tags = LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
+        strncpy(pkt.label, tag_label, sizeof(pkt.label) - 1);
+        bool enqueued = lgtd_lifx_gateway_send_to_site(
+            site->gw, LGTD_LIFX_SET_TAG_LABELS, &pkt, sizeof(pkt)
+        );
+        if (!enqueued) {
+            goto error_site_alloc;
+        }
+        lgtd_info(
+            "created tag [%s] with id %d on gw [%s]:%hu",
+            tag_label, tag_id, site->gw->ip_addr, site->gw->port
+        );
+    }
+
+    // Finally SET_TAGS on the devices:
+    SLIST_FOREACH(device, devices, link) {
+        struct lgtd_lifx_bulb *bulb = device->device;
+        int tag_id = lgtd_lifx_gateway_get_tag_id(bulb->gw, tag);
+        assert(tag_id > -1 && tag_id < LGTD_LIFX_GATEWAY_MAX_TAGS);
+        struct lgtd_lifx_packet_tags pkt;
+        pkt.tags = bulb->state.tags | LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
+        lgtd_router_send_to_device(bulb, LGTD_LIFX_SET_TAGS, &pkt);
+    }
+
+    SEND_RESULT(client, true);
+    goto fini;
+
+error_site_alloc:
+    if (LIST_EMPTY(&tag->sites)) {
+        lgtd_lifx_tagging_deallocate_tag(tag);
+    } else { // tagging_decref will deallocate the tag for us:
+        struct lgtd_lifx_site *next_site;
+        LIST_FOREACH_SAFE(site, &tag->sites, link, next_site) {
+            lgtd_lifx_gateway_deallocate_tag_id(site->gw, site->tag_id);
+        }
+    }
+error_tag_alloc:
+    lgtd_client_send_error(
+        client, LGTD_CLIENT_INTERNAL_ERROR, "couldn't allocate new tag"
+    );
+fini:
+    lgtd_router_device_list_free(devices);
+    return;
+}
+
+void
+lgtd_proto_untag(struct lgtd_client *client,
+                 const struct lgtd_proto_target_list *targets,
+                 const char *tag_label)
+{
+    assert(client);
+    assert(targets);
+    assert(tag_label);
+
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(tag_label);
+    if (!tag) {
+        SEND_RESULT(client, true);
+        return;
+    }
+
+    struct lgtd_router_device_list *devices = NULL;
+    devices = lgtd_router_targets_to_devices(targets);
+    if (!devices) {
+        lgtd_client_send_error(
+            client, LGTD_CLIENT_INTERNAL_ERROR, "couldn't allocate memory"
+        );
+        return;
+    }
+
+    struct lgtd_router_device *device;
+    SLIST_FOREACH(device, devices, link) {
+        struct lgtd_lifx_bulb *bulb = device->device;
+        struct lgtd_lifx_gateway *gw = bulb->gw;
+        int tag_id = lgtd_lifx_gateway_get_tag_id(gw, tag);
+        if (tag_id != -1) {
+            int tag_value = LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
+            if (bulb->state.tags & tag_value) {
+                struct lgtd_lifx_packet_tags pkt;
+                pkt.tags = bulb->state.tags & ~tag_value;
+                lgtd_router_send_to_device(bulb, LGTD_LIFX_SET_TAGS, &pkt);
+            }
+        }
+    }
+
+    SEND_RESULT(client, true);
+
+    lgtd_router_device_list_free(devices);
+}
diff --git a/core/proto.h b/core/proto.h
--- a/core/proto.h
+++ b/core/proto.h
@@ -39,3 +39,5 @@
 void lgtd_proto_power_on(struct lgtd_client *, const struct lgtd_proto_target_list *);
 void lgtd_proto_power_off(struct lgtd_client *, const struct lgtd_proto_target_list *);
 void lgtd_proto_get_light_state(struct lgtd_client *, const struct lgtd_proto_target_list *);
+void lgtd_proto_tag(struct lgtd_client *, const struct lgtd_proto_target_list *, const char *);
+void lgtd_proto_untag(struct lgtd_client *, const struct lgtd_proto_target_list *, const char *);
diff --git a/core/router.c b/core/router.c
--- a/core/router.c
+++ b/core/router.c
@@ -372,8 +372,8 @@
 void
 lgtd_router_device_list_free(struct lgtd_router_device_list *devices)
 {
-    assert(devices);
-
-    lgtd_router_clear_device_list(devices);
-    free(devices);
+    if (devices) {
+        lgtd_router_clear_device_list(devices);
+        free(devices);
+    }
 }
diff --git a/lifx/bulb.c b/lifx/bulb.c
--- a/lifx/bulb.c
+++ b/lifx/bulb.c
@@ -107,6 +107,8 @@
         );
     }
 
+    lgtd_lifx_gateway_update_tag_refcounts(bulb->gw, bulb->state.tags, state->tags);
+
     bulb->last_light_state_at = received_at;
     memcpy(&bulb->state, state, sizeof(bulb->state));
 }
@@ -124,3 +126,13 @@
 
     bulb->state.power = power;
 }
+
+void
+lgtd_lifx_bulb_set_tags(struct lgtd_lifx_bulb *bulb, uint64_t tags)
+{
+    assert(bulb);
+
+    lgtd_lifx_gateway_update_tag_refcounts(bulb->gw, bulb->state.tags, tags);
+
+    bulb->state.tags = tags;
+}
diff --git a/lifx/bulb.h b/lifx/bulb.h
--- a/lifx/bulb.h
+++ b/lifx/bulb.h
@@ -68,3 +68,4 @@
                                     const struct lgtd_lifx_light_state *,
                                     lgtd_time_mono_t);
 void lgtd_lifx_bulb_set_power_state(struct lgtd_lifx_bulb *, uint16_t);
+void lgtd_lifx_bulb_set_tags(struct lgtd_lifx_bulb *, uint64_t);
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -155,30 +155,11 @@
 {
     assert(gw);
 
-    struct lgtd_lifx_packet_header hdr;
-    union lgtd_lifx_target target = { .addr = gw->site.as_array };
+    lgtd_lifx_gateway_send_to_site(gw, LGTD_LIFX_GET_LIGHT_STATE, NULL, 0);
 
-    lgtd_lifx_wire_setup_header(
-        &hdr,
-        LGTD_LIFX_TARGET_SITE,
-        target,
-        gw->site.as_array,
-        LGTD_LIFX_GET_LIGHT_STATE
-    );
-    lgtd_lifx_gateway_enqueue_packet(
-        gw, &hdr, LGTD_LIFX_GET_LIGHT_STATE, NULL, 0
-    );
-
-    struct lgtd_lifx_packet_get_tag_labels pkt = { .tags = LGTD_LIFX_ALL_TAGS };
-    lgtd_lifx_wire_setup_header(
-        &hdr,
-        LGTD_LIFX_TARGET_SITE,
-        target,
-        gw->site.as_array,
-        LGTD_LIFX_GET_TAG_LABELS
-    );
-    lgtd_lifx_gateway_enqueue_packet(
-        gw, &hdr, LGTD_LIFX_GET_TAG_LABELS, &pkt, sizeof(pkt)
+    struct lgtd_lifx_packet_tags pkt = { .tags = LGTD_LIFX_ALL_TAGS };
+    lgtd_lifx_gateway_send_to_site(
+        gw, LGTD_LIFX_GET_TAG_LABELS, &pkt, sizeof(pkt)
     );
 
     gw->pending_refresh_req = true;
@@ -369,6 +350,68 @@
     event_add(gw->write_ev, NULL);
 }
 
+bool
+lgtd_lifx_gateway_send_to_site(struct lgtd_lifx_gateway *gw,
+                               enum lgtd_lifx_packet_type pkt_type,
+                               const void *pkt,
+                               int pkt_size)
+{
+    assert(gw);
+
+    struct lgtd_lifx_packet_header hdr;
+    union lgtd_lifx_target target = { .addr = gw->site.as_array };
+    lgtd_lifx_wire_setup_header(
+        &hdr,
+        LGTD_LIFX_TARGET_SITE,
+        target,
+        gw->site.as_array,
+        pkt_type
+    );
+    lgtd_lifx_gateway_enqueue_packet(gw, &hdr, pkt_type, pkt, pkt_size);
+    
+    return true; // FIXME, have real return values on the send paths...
+}
+
+void
+lgtd_lifx_gateway_update_tag_refcounts(struct lgtd_lifx_gateway *gw,
+                                       uint64_t bulb_tags,
+                                       uint64_t pkt_tags)
+{
+    uint64_t changes = bulb_tags ^ pkt_tags;
+    uint64_t added_tags = changes & pkt_tags;
+    uint64_t removed_tags = changes & bulb_tags;
+    int tag_id;
+
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, added_tags) {
+        if (gw->tag_refcounts[tag_id] != UINT8_MAX) {
+            gw->tag_refcounts[tag_id]++;
+        } else {
+            lgtd_warnx(
+                "reached refcount limit (%hu) for tag [%s] (%d) on gw [%s]:%hu",
+                UINT8_MAX, gw->tags[tag_id] ? gw->tags[tag_id]->label : NULL,
+                tag_id, gw->ip_addr, gw->port
+            );
+        }
+    }
+
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, removed_tags) {
+        assert(gw->tag_refcounts[tag_id] > 0);
+        if (--gw->tag_refcounts[tag_id] == 0) {
+            lgtd_info(
+                "deleting unused tag [%s] (%d) from gw [%s]:%hu (site %s)",
+                gw->tags[tag_id] ? gw->tags[tag_id]->label : NULL, tag_id,
+                gw->ip_addr, gw->port, gw->site.as_array
+            );
+            struct lgtd_lifx_packet_tag_labels pkt = {
+                .tags = ~(gw->tag_ids & ~tag_id)
+            };
+            lgtd_lifx_gateway_send_to_site(
+                gw, LGTD_LIFX_SET_TAG_LABELS, &pkt, sizeof(pkt)
+            );
+        }
+    }
+}
+
 void
 lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *gw,
                                      const struct lgtd_lifx_packet_header *hdr,
@@ -484,16 +527,44 @@
 }
 
 int
+lgtd_lifx_gateway_get_tag_id(const struct lgtd_lifx_gateway *gw,
+                             const struct lgtd_lifx_tag *tag)
+{
+    assert(gw);
+    assert(tag);
+
+    int tag_id;
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, gw->tag_ids) {
+        if (gw->tags[tag_id] == tag) {
+            return tag_id;
+        }
+    }
+
+    return -1;
+}
+
+int
 lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *gw,
                                   int tag_id,
                                   const char *tag_label)
 {
     assert(gw);
     assert(tag_label);
-    // allocating a new tag_id (tag_id == -1) isn't supported yet:
-    assert(tag_id >= 0);
+    assert(tag_id >= -1);
     assert(tag_id < LGTD_LIFX_GATEWAY_MAX_TAGS);
 
+    if (tag_id == -1) {
+        tag_id = lgtd_lifx_wire_bitscan64_forward(~gw->tag_ids);
+        if (tag_id == -1) {
+            lgtd_warnx(
+                "no tag_id left for new tag [%s] on gw [%s]:%hu (site %s)",
+                tag_label, gw->ip_addr, gw->port,
+                lgtd_addrtoa(gw->site.as_array)
+            );
+            return -1;
+        }
+    }
+
     if (!(gw->tag_ids & LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id))) {
         struct lgtd_lifx_tag *tag;
         tag = lgtd_lifx_tagging_incref(tag_label, gw, tag_id);
@@ -544,9 +615,9 @@
     assert(gw && hdr && pkt);
 
     lgtd_debug(
-        "SET_TAG_LABELS <-- [%s]:%hu - %s label=%s, tags=%jx",
+        "SET_TAG_LABELS <-- [%s]:%hu - %s label=%.*s, tags=%jx",
         gw->ip_addr, gw->port, lgtd_addrtoa(hdr->target.device_addr),
-        pkt->label, (uintmax_t)pkt->tags
+        LGTD_LIFX_LABEL_SIZE, pkt->label, (uintmax_t)pkt->tags
     );
 
     int tag_id;
@@ -558,3 +629,38 @@
         }
     }
 }
+
+void lgtd_lifx_gateway_handle_tags(struct lgtd_lifx_gateway *gw,
+                                   const struct lgtd_lifx_packet_header *hdr,
+                                   const struct lgtd_lifx_packet_tags *pkt)
+{
+    assert(gw && hdr && pkt);
+
+    lgtd_debug(
+        "SET_TAGS <-- [%s]:%hu - %s tags=%#jx",
+        gw->ip_addr, gw->port, lgtd_addrtoa(hdr->target.device_addr),
+        (uintmax_t)pkt->tags
+    );
+
+    struct lgtd_lifx_bulb *b = lgtd_lifx_gateway_get_or_open_bulb(
+        gw, hdr->target.device_addr
+    );
+    if (!b) {
+        return;
+    }
+
+    int tag_id;
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, pkt->tags) {
+        if (!(gw->tag_ids & LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id))) {
+            lgtd_warnx(
+                "trying to set unknown tag_id %d (%#jx) "
+                "on bulb %s (%.*s), gw [%s]:%hu (site %s)",
+                tag_id, LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id),
+                lgtd_addrtoa(b->addr), LGTD_LIFX_LABEL_SIZE, b->state.label,
+                gw->ip_addr, gw->port, lgtd_addrtoa(gw->site.as_array)
+            );
+        }
+    }
+
+    lgtd_lifx_bulb_set_tags(b, pkt->tags);
+}
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -21,7 +21,7 @@
 // according to my own tests, aggressively polling a bulb doesn't raise its
 // consumption at all (and it's interesting to note that a turned off bulb
 // still draw about 2W in ZigBee and about 3W in WiFi).
-enum { LGTD_LIFX_GATEWAY_MIN_REFRESH_INTERVAL_MSECS = 200 };
+enum { LGTD_LIFX_GATEWAY_MIN_REFRESH_INTERVAL_MSECS = 1000 };
 
 // You can't send more than one lifx packet per UDP datagram.
 enum { LGTD_LIFX_GATEWAY_PACKET_RING_SIZE = 16 };
@@ -51,6 +51,7 @@
     }                               site;
     uint64_t                        tag_ids;
     struct lgtd_lifx_tag            *tags[LGTD_LIFX_GATEWAY_MAX_TAGS];
+    uint8_t                         tag_refcounts[LGTD_LIFX_GATEWAY_MAX_TAGS];
     evutil_socket_t                 socket;
     // Those three timers let us measure the latency of the gateway. If we
     // aren't the only client on the network then this won't be accurate since
@@ -92,7 +93,15 @@
                                       enum lgtd_lifx_packet_type,
                                       const void *,
                                       int);
+// This could be on router but it's LIFX specific so I'd rather keep it here:
+bool lgtd_lifx_gateway_send_to_site(struct lgtd_lifx_gateway *,
+                                    enum lgtd_lifx_packet_type,
+                                    const void *,
+                                    int);
 
+void lgtd_lifx_gateway_update_tag_refcounts(struct lgtd_lifx_gateway *, uint64_t, uint64_t);
+
+int lgtd_lifx_gateway_get_tag_id(const struct lgtd_lifx_gateway *, const struct lgtd_lifx_tag *);
 int lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *, int, const char *);
 void lgtd_lifx_gateway_deallocate_tag_id(struct lgtd_lifx_gateway *, int);
 
@@ -108,3 +117,6 @@
 void lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *,
                                          const struct lgtd_lifx_packet_header *,
                                          const struct lgtd_lifx_packet_tag_labels *);
+void lgtd_lifx_gateway_handle_tags(struct lgtd_lifx_gateway *,
+                                   const struct lgtd_lifx_packet_header *,
+                                   const struct lgtd_lifx_packet_tags *);
diff --git a/lifx/tagging.c b/lifx/tagging.c
--- a/lifx/tagging.c
+++ b/lifx/tagging.c
@@ -66,6 +66,32 @@
 }
 
 struct lgtd_lifx_tag *
+lgtd_lifx_tagging_allocate_tag(const char *tag_label)
+{
+    assert(tag_label);
+    assert(strlen(tag_label) < LGTD_LIFX_LABEL_SIZE);
+
+    struct lgtd_lifx_tag *tag = calloc(1, sizeof(*tag));
+    if (!tag) {
+        return NULL;
+    }
+
+    strncpy(tag->label, tag_label, sizeof(tag->label) - 1);
+    LIST_INSERT_HEAD(&lgtd_lifx_tags, tag, link);
+    return tag;
+}
+
+void
+lgtd_lifx_tagging_deallocate_tag(struct lgtd_lifx_tag *tag)
+{
+    assert(tag);
+    assert(LIST_EMPTY(&tag->sites));
+
+    LIST_REMOVE(tag, link);
+    free(tag);
+}
+
+struct lgtd_lifx_tag *
 lgtd_lifx_tagging_incref(const char *tag_label,
                          struct lgtd_lifx_gateway *gw,
                          int tag_id)
@@ -77,12 +103,10 @@
     bool dealloc_tag = false;
     struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(tag_label);
     if (!tag) {
-        tag = calloc(1, sizeof(*tag));
+        tag = lgtd_lifx_tagging_allocate_tag(tag_label);
         if (!tag) {
             return NULL;
         }
-        strncpy(tag->label, tag_label, sizeof(tag->label) - 1);
-        LIST_INSERT_HEAD(&lgtd_lifx_tags, tag, link);
         dealloc_tag = true;
     }
 
@@ -91,8 +115,7 @@
         site = calloc(1, sizeof(*site));
         if (!site) {
             if (dealloc_tag) {
-                LIST_REMOVE(tag, link);
-                free(tag);
+                lgtd_lifx_tagging_deallocate_tag(tag);
             }
             errno = ENOMEM;
             return NULL;
@@ -100,9 +123,10 @@
         if (dealloc_tag) {
             lgtd_info("discovered tag [%s]", tag_label);
         }
-        lgtd_debug(
-            "tag [%s] added to gw [%s]:%hu (site %s)",
-            tag_label, gw->ip_addr, gw->port, lgtd_addrtoa(gw->site.as_array)
+        lgtd_info(
+            "tag [%s] added to gw [%s]:%hu (site %s) with tag_id %d",
+            tag_label, gw->ip_addr, gw->port,
+            lgtd_addrtoa(gw->site.as_array), tag_id
         );
         site->gw = gw;
         site->tag_id = tag_id;
@@ -132,8 +156,7 @@
         free(site);
     }
     if (LIST_EMPTY(&tag->sites)) {
-        LIST_REMOVE(tag, link);
         lgtd_info("forgetting unused tag [%s]", tag->label);
-        free(tag);
+        lgtd_lifx_tagging_deallocate_tag(tag);
     }
 }
diff --git a/lifx/tagging.h b/lifx/tagging.h
--- a/lifx/tagging.h
+++ b/lifx/tagging.h
@@ -39,3 +39,6 @@
 void lgtd_lifx_tagging_decref(struct lgtd_lifx_tag *, struct lgtd_lifx_gateway *);
 
 struct lgtd_lifx_tag *lgtd_lifx_tagging_find_tag(const char *);
+struct lgtd_lifx_tag *lgtd_lifx_tagging_allocate_tag(const char *);
+
+void lgtd_lifx_tagging_deallocate_tag(struct lgtd_lifx_tag *);
diff --git a/lifx/timer.h b/lifx/timer.h
--- a/lifx/timer.h
+++ b/lifx/timer.h
@@ -20,8 +20,8 @@
 enum { LGTD_LIFX_TIMER_WATCHDOG_INTERVAL_MSECS = 200 };
 enum { LGTD_LIFX_TIMER_ACTIVE_DISCOVERY_INTERVAL_MSECS = 2000 };
 enum { LGTD_LIFX_TIMER_PASSIVE_DISCOVERY_INTERVAL_MSECS = 10000 };
-enum { LGTD_LIFX_TIMER_DEVICE_TIMEOUT_MSECS = 2000 };
-enum { LGTD_LIFX_TIMER_DEVICE_FORCE_REFRESH_MSECS = 600 };
+enum { LGTD_LIFX_TIMER_DEVICE_TIMEOUT_MSECS = 4000 };
+enum { LGTD_LIFX_TIMER_DEVICE_FORCE_REFRESH_MSECS = 2000 };
 
 bool lgtd_lifx_timer_setup(void);
 void lgtd_lifx_timer_close(void);
diff --git a/lifx/wire_proto.c b/lifx/wire_proto.c
--- a/lifx/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -92,6 +92,7 @@
     .handle = lgtd_lifx_wire_null_packet_handler
 
     static struct lgtd_lifx_packet_infos packet_table[] = {
+        // Gateway packets:
         {
             REQUEST_ONLY,
             NO_PAYLOAD,
@@ -108,6 +109,43 @@
         },
         {
             REQUEST_ONLY,
+            .name = "SET_TAG_LABELS",
+            .type = LGTD_LIFX_SET_TAG_LABELS,
+            .size = sizeof(struct lgtd_lifx_packet_tag_labels),
+            .encode = ENCODER(lgtd_lifx_wire_encode_tag_labels)
+        },
+        {
+            REQUEST_ONLY,
+            .name = "GET_TAG_LABELS",
+            .type = LGTD_LIFX_GET_TAG_LABELS,
+            .size = sizeof(struct lgtd_lifx_packet_tags),
+            .encode = ENCODER(lgtd_lifx_wire_encode_tags)
+        },
+        {
+            RESPONSE_ONLY,
+            .name = "TAG_LABELS",
+            .type = LGTD_LIFX_TAG_LABELS,
+            .size = sizeof(struct lgtd_lifx_packet_tag_labels),
+            .decode = DECODER(lgtd_lifx_wire_decode_tag_labels),
+            .handle = HANDLER(lgtd_lifx_gateway_handle_tag_labels)
+        },
+        // Bulb packets:
+        {
+            REQUEST_ONLY,
+            .name = "SET_LIGHT_COLOR",
+            .type = LGTD_LIFX_SET_LIGHT_COLOR,
+            .size = sizeof(struct lgtd_lifx_packet_light_color),
+            .encode = ENCODER(lgtd_lifx_wire_encode_light_color)
+        },
+        {
+            REQUEST_ONLY,
+            .name = "SET_WAVEFORM",
+            .type = LGTD_LIFX_SET_WAVEFORM,
+            .size = sizeof(struct lgtd_lifx_packet_waveform),
+            .encode = ENCODER(lgtd_lifx_wire_encode_waveform)
+        },
+        {
+            REQUEST_ONLY,
             NO_PAYLOAD,
             .name = "GET_LIGHT_STATUS",
             .type = LGTD_LIFX_GET_LIGHT_STATE
@@ -128,6 +166,7 @@
             .type = LGTD_LIFX_SET_POWER_STATE,
         },
         {
+            RESPONSE_ONLY,
             .name = "POWER_STATE",
             .type = LGTD_LIFX_POWER_STATE,
             .size = sizeof(struct lgtd_lifx_packet_power_state),
@@ -136,32 +175,18 @@
         },
         {
             REQUEST_ONLY,
-            .name = "SET_LIGHT_COLOR",
-            .type = LGTD_LIFX_SET_LIGHT_COLOR,
-            .size = sizeof(struct lgtd_lifx_packet_light_color),
-            .encode = ENCODER(lgtd_lifx_wire_encode_light_color)
-        },
-        {
-            REQUEST_ONLY,
-            .name = "SET_WAVEFORM",
-            .type = LGTD_LIFX_SET_WAVEFORM,
-            .size = sizeof(struct lgtd_lifx_packet_waveform),
-            .encode = ENCODER(lgtd_lifx_wire_encode_waveform)
-        },
-        {
-            REQUEST_ONLY,
-            .name = "GET_TAG_LABELS",
-            .type = LGTD_LIFX_GET_TAG_LABELS,
-            .size = sizeof(struct lgtd_lifx_packet_get_tag_labels),
-            .encode = lgtd_lifx_wire_null_packet_encoder_decoder
+            .name = "SET_TAGS",
+            .type = LGTD_LIFX_SET_TAGS,
+            .size = sizeof(struct lgtd_lifx_packet_tags),
+            .encode = ENCODER(lgtd_lifx_wire_encode_tags)
         },
         {
             RESPONSE_ONLY,
-            .name = "TAG_LABELS",
-            .type = LGTD_LIFX_TAG_LABELS,
-            .size = sizeof(struct lgtd_lifx_packet_tag_labels),
-            .decode = DECODER(lgtd_lifx_wire_decode_tag_labels),
-            .handle = HANDLER(lgtd_lifx_gateway_handle_tag_labels)
+            .name = "TAGS",
+            .type = LGTD_LIFX_TAGS,
+            .size = sizeof(struct lgtd_lifx_packet_tags),
+            .decode = DECODER(lgtd_lifx_wire_decode_tags),
+            .handle = HANDLER(lgtd_lifx_gateway_handle_tags)
         }
     };
 
@@ -357,11 +382,19 @@
     pkt->brightness = htole16(pkt->brightness);
     pkt->kelvin = htole16(pkt->kelvin);
     pkt->period = htole32(pkt->period);
-    pkt->cycles = lifx_wire_htolefloat(pkt->cycles);
+    pkt->cycles = lgtd_lifx_wire_htolefloat(pkt->cycles);
     pkt->skew_ratio = htole16(pkt->skew_ratio);
 }
 
 void
+lgtd_lifx_wire_encode_tag_labels(struct lgtd_lifx_packet_tag_labels *pkt)
+{
+    assert(pkt);
+
+    pkt->tags = htole64(pkt->tags);
+}
+
+void
 lgtd_lifx_wire_decode_tag_labels(struct lgtd_lifx_packet_tag_labels *pkt)
 {
     assert(pkt);
@@ -369,3 +402,19 @@
     pkt->label[sizeof(pkt->label) - 1] = '\0';
     pkt->tags = le64toh(pkt->tags);
 }
+
+void
+lgtd_lifx_wire_encode_tags(struct lgtd_lifx_packet_tags *pkt)
+{
+    assert(pkt);
+
+    pkt->tags = htole64(pkt->tags);
+}
+
+void
+lgtd_lifx_wire_decode_tags(struct lgtd_lifx_packet_tags *pkt)
+{
+    assert(pkt);
+
+    pkt->tags = le64toh(pkt->tags);
+}
diff --git a/lifx/wire_proto.h b/lifx/wire_proto.h
--- a/lifx/wire_proto.h
+++ b/lifx/wire_proto.h
@@ -26,14 +26,14 @@
 typedef float    floatle_t;
 
 static inline floatle_t
-lifx_wire_htolefloat(float f)
+lgtd_lifx_wire_htolefloat(float f)
 {
     *(uint32_t *)&f = htole32(*(uint32_t *)&f);
     return f;
 }
 
 static inline floatle_t
-lifx_wire_lefloattoh(float f)
+lgtd_lifx_wire_lefloattoh(float f)
 {
     *(uint32_t *)&f = le32toh(*(uint32_t *)&f);
     return f;
@@ -238,7 +238,7 @@
 };
 
 enum { LGTD_LIFX_ALL_TAGS = ~0 };
-struct lgtd_lifx_packet_get_tag_labels {
+struct lgtd_lifx_packet_tags {
     uint64le_t  tags;
 };
 
@@ -350,4 +350,7 @@
 void lgtd_lifx_wire_encode_light_color(struct lgtd_lifx_packet_light_color *);
 void lgtd_lifx_wire_encode_waveform(struct lgtd_lifx_packet_waveform *);
 
+void lgtd_lifx_wire_encode_tags(struct lgtd_lifx_packet_tags *);
+void lgtd_lifx_wire_decode_tags(struct lgtd_lifx_packet_tags *);
+void lgtd_lifx_wire_encode_tag_labels(struct lgtd_lifx_packet_tag_labels *);
 void lgtd_lifx_wire_decode_tag_labels(struct lgtd_lifx_packet_tag_labels *);
diff --git a/tests/core/jsonrpc/test_jsonrpc_utils.h b/tests/core/jsonrpc/test_jsonrpc_utils.h
--- a/tests/core/jsonrpc/test_jsonrpc_utils.h
+++ b/tests/core/jsonrpc/test_jsonrpc_utils.h
@@ -95,3 +95,27 @@
     (void)targets;
 }
 #endif
+
+#ifndef MOCKED_LGTD_TAG
+void
+lgtd_proto_tag(struct lgtd_client *client,
+               const struct lgtd_proto_target_list *targets,
+               const char *tag_label)
+{
+    (void)client;
+    (void)targets;
+    (void)tag_label;
+}
+#endif
+
+#ifndef MOCKED_LGTD_UNTAG
+void
+lgtd_proto_untag(struct lgtd_client *client,
+                 const struct lgtd_proto_target_list *targets,
+                 const char *tag_label)
+{
+    (void)client;
+    (void)targets;
+    (void)tag_label;
+}
+#endif
diff --git a/tests/core/proto/CMakeLists.txt b/tests/core/proto/CMakeLists.txt
--- a/tests/core/proto/CMakeLists.txt
+++ b/tests/core/proto/CMakeLists.txt
@@ -9,6 +9,7 @@
     ${LIGHTSD_SOURCE_DIR}/core/jsonrpc.c
     ${LIGHTSD_SOURCE_DIR}/core/stats.c
     ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/tagging.c
     ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
     ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
diff --git a/tests/core/proto/test_proto_set_waveform.c b/tests/core/proto/test_proto_set_waveform.c
--- a/tests/core/proto/test_proto_set_waveform.c
+++ b/tests/core/proto/test_proto_set_waveform.c
@@ -35,7 +35,7 @@
     int brightness = le16toh(waveform->brightness);
     int kelvin = le16toh(waveform->kelvin);
     int period = le32toh(waveform->period);
-    float cycles = lifx_wire_lefloattoh(waveform->cycles);
+    float cycles = lgtd_lifx_wire_lefloattoh(waveform->cycles);
     int skew_ratio = le16toh(waveform->skew_ratio);
 
     if (waveform_type != LGTD_LIFX_WAVEFORM_SAW) {
diff --git a/tests/core/proto/test_proto_set_waveform_on_routing_error.c b/tests/core/proto/test_proto_set_waveform_on_routing_error.c
--- a/tests/core/proto/test_proto_set_waveform_on_routing_error.c
+++ b/tests/core/proto/test_proto_set_waveform_on_routing_error.c
@@ -35,7 +35,7 @@
     int brightness = le16toh(waveform->brightness);
     int kelvin = le16toh(waveform->kelvin);
     int period = le32toh(waveform->period);
-    float cycles = lifx_wire_lefloattoh(waveform->cycles);
+    float cycles = lgtd_lifx_wire_lefloattoh(waveform->cycles);
     int skew_ratio = le16toh(waveform->skew_ratio);
 
     if (waveform_type != LGTD_LIFX_WAVEFORM_SAW) {
diff --git a/tests/core/proto/tests_proto_utils.h b/tests/core/proto/tests_proto_utils.h
--- a/tests/core/proto/tests_proto_utils.h
+++ b/tests/core/proto/tests_proto_utils.h
@@ -32,6 +32,18 @@
 }
 #endif
 
+#ifndef MOCKED_ROUTER_SEND_TO_DEVICE
+void
+lgtd_router_send_to_device(struct lgtd_lifx_bulb *bulb,
+                           enum lgtd_lifx_packet_type pkt_type,
+                           void *pkt)
+{
+    (void)bulb;
+    (void)pkt_type;
+    (void)pkt;
+}
+#endif
+
 #ifndef MOCKED_ROUTER_SEND
 bool
 lgtd_router_send(const struct lgtd_proto_target_list *targets,
diff --git a/tests/core/router/CMakeLists.txt b/tests/core/router/CMakeLists.txt
--- a/tests/core/router/CMakeLists.txt
+++ b/tests/core/router/CMakeLists.txt
@@ -9,6 +9,7 @@
     ${LIGHTSD_SOURCE_DIR}/core/proto.c
     ${LIGHTSD_SOURCE_DIR}/core/stats.c
     ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/tagging.c
     ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
     ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
diff --git a/tests/core/router/test_router_send_to_broadcast.c b/tests/core/router/test_router_send_to_broadcast.c
--- a/tests/core/router/test_router_send_to_broadcast.c
+++ b/tests/core/router/test_router_send_to_broadcast.c
@@ -1,6 +1,7 @@
 #include "router.c"
 
 #include "tests_utils.h"
+
 #include "tests_router_utils.h"
 
 int
diff --git a/tests/core/tests_shims.c b/tests/core/tests_shims.c
--- a/tests/core/tests_shims.c
+++ b/tests/core/tests_shims.c
@@ -70,14 +70,60 @@
     (void)pkt;
 }
 
-struct lgtd_lifx_tag *
-lgtd_lifx_tagging_find_tag(const char *tag_label)
+void lgtd_lifx_gateway_handle_tags(struct lgtd_lifx_gateway *gw,
+                                   const struct lgtd_lifx_packet_header *hdr,
+                                   const struct lgtd_lifx_packet_tags *pkt)
 {
-    struct lgtd_lifx_tag *tag = NULL;
-    LIST_FOREACH(tag, &lgtd_lifx_tags, link) {
-        if (!strcmp(tag->label, tag_label)) {
-            break;
-        }
-    }
-    return tag;
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
 }
+
+int
+lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *gw,
+                                  int tag_id,
+                                  const char *tag_label)
+{
+    (void)gw;
+    (void)tag_id;
+    (void)tag_label;
+    return -1;
+}
+
+void
+lgtd_lifx_gateway_deallocate_tag_id(struct lgtd_lifx_gateway *gw, int tag_id)
+{
+    (void)gw;
+    (void)tag_id;
+}
+
+int
+lgtd_lifx_gateway_get_tag_id(const struct lgtd_lifx_gateway *gw,
+                                 const struct lgtd_lifx_tag *tag)
+{
+    (void)gw;
+    (void)tag;
+    return -1;
+}
+
+bool lgtd_lifx_gateway_send_to_site(struct lgtd_lifx_gateway *gw,
+                                    enum lgtd_lifx_packet_type pkt_type,
+                                    const void *pkt,
+                                    int pkt_size)
+{
+    (void)gw;
+    (void)pkt_type;
+    (void)pkt;
+    (void)pkt_size;
+    return false;
+}
+
+void
+lgtd_lifx_gateway_update_tag_refcounts(struct lgtd_lifx_gateway *gw,
+                                       uint64_t bulb_tags,
+                                       uint64_t pkt_tags)
+{
+    (void)gw;
+    (void)bulb_tags;
+    (void)pkt_tags;
+}
diff --git a/tests/core/tests_utils.c b/tests/core/tests_utils.c
--- a/tests/core/tests_utils.c
+++ b/tests/core/tests_utils.c
@@ -26,9 +26,6 @@
 struct lgtd_lifx_gateway_list lgtd_lifx_gateways =
     LIST_HEAD_INITIALIZER(&lgtd_lifx_gateways);
 
-struct lgtd_lifx_tag_list lgtd_lifx_tags =
-    LIST_HEAD_INITIALIZER(&lgtd_lifx_tags);
-
 struct lgtd_lifx_gateway *
 lgtd_tests_insert_mock_gateway(int id)
 {
diff --git a/tests/lifx/wire_proto/test_wire_proto_utils.h b/tests/lifx/wire_proto/test_wire_proto_utils.h
--- a/tests/lifx/wire_proto/test_wire_proto_utils.h
+++ b/tests/lifx/wire_proto/test_wire_proto_utils.h
@@ -35,3 +35,12 @@
     (void)hdr;
     (void)pkt;
 }
+
+void lgtd_lifx_gateway_handle_tags(struct lgtd_lifx_gateway *gw,
+                                   const struct lgtd_lifx_packet_header *hdr,
+                                   const struct lgtd_lifx_packet_tags *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
diff --git a/tests/lightsc b/tests/lightsc
--- a/tests/lightsc
+++ b/tests/lightsc
@@ -72,6 +72,14 @@
 def get_light_state(socket, target):
     return jsonrpc_call(socket, "get_light_state", [target])
 
+
+def tag(socket, target, tag):
+    return jsonrpc_call(socket, "tag", [target, tag])
+
+
+def untag(socket, target, tag):
+    return jsonrpc_call(socket, "untag", [target, tag])
+
 if __name__ == "__main__":
     s = socket.create_connection(("localhost", 1234))
     h = 0
