# HG changeset patch
# Parent 2e97dc5fcde8302bf8222afc4ead0c0a0ea2520e
# Parent  75fd2d168876e06cfd8af556f4bd08dd8e302ad6
Add the get_light_state command

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -8,9 +8,8 @@
 SET(LIGHTSD_VERSION "${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}")
 
 MESSAGE(STATUS "CMake version: ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}")
-MESSAGE(STATUS "lgtd version: ${LIGHTSD_VERSION}")
-MESSAGE(STATUS "Build type: ${CMAKE_BUILD_TYPE}")
-MESSAGE(STATUS "System: ${CMAKE_SYSTEM_NAME} ${CMAKE_SYSTEM_VERSION}")
+MESSAGE(STATUS "lightsd version: ${LIGHTSD_VERSION}")
+MESSAGE(STATUS "Target system: ${CMAKE_SYSTEM_NAME} ${CMAKE_SYSTEM_VERSION} ${CMAKE_SYSTEM_PROCESSOR}")
 MESSAGE(STATUS "Install prefix: ${CMAKE_INSTALL_PREFIX}")
 MESSAGE(STATUS "Source directory: ${LIGHTSD_SOURCE_DIR}")
 
diff --git a/README.rst b/README.rst
--- a/README.rst
+++ b/README.rst
@@ -28,7 +28,7 @@
 - power_on;
 - set_light_from_hsbk;
 - set_waveform (change the light according to a function like SAW or SINE);
-- get_light_status (coming up).
+- get_light_status.
 
 lightsd can target single or multiple bulbs at once:
 
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -206,12 +206,13 @@
     assert(len > 0);
     assert(start < stop);
 
-    int range = stop * 10E5 - start * 10E5;
+    int range;
+    range = stop * LGTD_JSONRPC_FLOAT_PREC - start * LGTD_JSONRPC_FLOAT_PREC;
     const char *dot = NULL;
     long fracpart = 0;
-    long intpart = strtol(s, (char **)&dot, 10) * 10E5;
+    long intpart = strtol(s, (char **)&dot, 10) * LGTD_JSONRPC_FLOAT_PREC;
     if (dot - s != len && *dot == '.') {
-        for (int i = dot - s + 1, multiplier = 10E4;
+        for (int i = dot - s + 1, multiplier = LGTD_JSONRPC_FLOAT_PREC / 10;
              i != len && multiplier != 0;
              i++, multiplier /= 10) {
             fracpart += (s[i] - '0') * multiplier;
@@ -220,6 +221,45 @@
     return ((intpart + fracpart) * UINT16_MAX) / range;
 }
 
+void
+lgtd_jsonrpc_uint16_range_to_float_string(uint16_t encoded, int start, int stop,
+                                          char *out, int size)
+{
+    assert(out);
+    assert(size > 1);
+    assert(start < stop);
+
+    int range;
+    range = stop * LGTD_JSONRPC_FLOAT_PREC - start * LGTD_JSONRPC_FLOAT_PREC;
+    int value = (uint64_t)encoded * (uint64_t)range / UINT16_MAX;
+
+    int multiplier = 1;
+    while (value / (multiplier * 10)) {
+        multiplier *= 10;
+    }
+
+    int i = 0;
+    do {
+        if (multiplier == LGTD_JSONRPC_FLOAT_PREC / 10) {
+            if (i == 0) {
+                out[i++] = '0';
+            }
+            if (i != size) {
+                out[i++] = '.';
+            }
+        }
+        if (i != size) {
+            out[i++] = '0' + value / multiplier;
+        }
+        value -= value / multiplier * multiplier;
+        multiplier /= 10;
+    } while ((value || multiplier >= LGTD_JSONRPC_FLOAT_PREC)
+              && multiplier && i != size);
+    out[LGTD_MIN(i, size - 1)] = '\0';
+
+    assert(i <= size);
+}
+
 static int
 lgtd_jsonrpc_consume_object_or_array(const jsmntok_t *tokens,
                                      int ti,
@@ -895,6 +935,19 @@
     lgtd_proto_target_list_clear(&targets);
 }
 
+static void
+lgtd_jsonrpc_check_and_call_get_light_state(struct lgtd_client *client)
+{
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
+    bool ok = lgtd_jsonrpc_extract_target_list(&targets, client);
+    if (!ok) {
+        return;
+    }
+
+    lgtd_proto_get_light_state(client, &targets);
+    lgtd_proto_target_list_clear(&targets);
+}
+
 void
 lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
 {
@@ -916,6 +969,10 @@
             "set_waveform", 10,
             lgtd_jsonrpc_check_and_call_set_waveform
         ),
+        LGTD_JSONRPC_METHOD(
+            "get_light_state", 1, // t
+            lgtd_jsonrpc_check_and_call_get_light_state
+        ),
         LGTD_JSONRPC_METHOD("list_tags", 0, lgtd_proto_list_tags),
     };
 
diff --git a/core/jsonrpc.h b/core/jsonrpc.h
--- a/core/jsonrpc.h
+++ b/core/jsonrpc.h
@@ -19,6 +19,8 @@
 
 struct lgtd_client;
 
+enum { LGTD_JSONRPC_FLOAT_PREC = (int)10E5 };
+
 struct lgtd_jsonrpc_request {
     const jsmntok_t *method;
     const jsmntok_t *params;
@@ -90,3 +92,4 @@
                                 const char *);
 void lgtd_jsonrpc_start_send_response(struct lgtd_client *);
 void lgtd_jsonrpc_end_send_response(struct lgtd_client *);
+void lgtd_jsonrpc_uint16_range_to_float_string(uint16_t, int, int, char *, int);
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -36,6 +36,7 @@
 #include "jsmn.h"
 #include "jsonrpc.h"
 #include "client.h"
+#include "lifx/gateway.h"
 #include "proto.h"
 #include "router.h"
 #include "lightsd.h"
@@ -159,9 +160,83 @@
     LIST_FOREACH(tag, &lgtd_lifx_tags, link) {
         LGTD_CLIENT_WRITE_STRING(client, "\"");
         LGTD_CLIENT_WRITE_STRING(client, tag->label);
-        LGTD_CLIENT_WRITE_STRING(client, LIST_NEXT(tag, link) ? "\", " : "\"");
+        LGTD_CLIENT_WRITE_STRING(client, LIST_NEXT(tag, link) ? "\"," : "\"");
     }
     LGTD_CLIENT_WRITE_STRING(client, "]");
 
     lgtd_client_end_send_response(client);
 }
+
+void
+lgtd_proto_get_light_state(struct lgtd_client *client,
+                           const struct lgtd_proto_target_list *targets)
+{
+    assert(targets);
+
+    struct lgtd_router_device_list *devices;
+    devices = lgtd_router_targets_to_devices(targets);
+    if (!devices) {
+        lgtd_client_send_error(
+            client, LGTD_CLIENT_INTERNAL_ERROR, "couldn't allocate device list"
+        );
+        return;
+    }
+
+    static const char *state_fmt = ("{"
+        "\"hsbk\":[%s,%s,%s,%hu],"
+        "\"power\":%s,"
+        "\"label\":\"%s\","
+        "\"tags\":[");
+
+#define PRINT_COMPONENT(src, dst, start, stop)          \
+    lgtd_jsonrpc_uint16_range_to_float_string(          \
+        (src), (start), (stop), (dst), sizeof((dst))    \
+    )
+
+    lgtd_client_start_send_response(client);
+    LGTD_CLIENT_WRITE_STRING(client, "[");
+    struct lgtd_router_device *device;
+    SLIST_FOREACH(device, devices, link) {
+        struct lgtd_lifx_bulb *bulb = device->device;
+
+        char h[16], s[16], b[16];
+        PRINT_COMPONENT(bulb->state.hue, h, 0, 360);
+        PRINT_COMPONENT(bulb->state.saturation, s, 0, 1);
+        PRINT_COMPONENT(bulb->state.brightness, b, 0, 1);
+
+        char buf[3072];
+        int written = snprintf(
+            buf, sizeof(buf), state_fmt,
+            h, s, b, bulb->state.kelvin,
+            bulb->state.power == LGTD_LIFX_POWER_ON ? "true" : "false",
+            bulb->state.label
+        );
+        if (written == sizeof(buf)) {
+            lgtd_warnx(
+                "can't send state of bulb %s (%s) to client "
+                "[%s]:%hu: output buffer to small",
+                bulb->state.label, lgtd_addrtoa(bulb->addr),
+                client->ip_addr, client->port
+            );
+            continue;
+        }
+        LGTD_CLIENT_WRITE_STRING(client, buf);
+
+        bool comma = false;
+        int tag_id;
+        LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, bulb->state.tags) {
+            LGTD_CLIENT_WRITE_STRING(client, comma ? ",\"" : "\"");
+            LGTD_CLIENT_WRITE_STRING(client, bulb->gw->tags[tag_id]->label);
+            LGTD_CLIENT_WRITE_STRING(client, "\"");
+            comma = true;
+        }
+
+        LGTD_CLIENT_WRITE_STRING(
+            client, SLIST_NEXT(device, link) ?  "]}," : "]}"
+        );
+    }
+    LGTD_CLIENT_WRITE_STRING(client, "]");
+    lgtd_client_end_send_response(client);
+
+    lgtd_router_device_list_free(devices);
+}
diff --git a/core/proto.h b/core/proto.h
--- a/core/proto.h
+++ b/core/proto.h
@@ -38,4 +38,5 @@
                              int, float, int, bool);
 void lgtd_proto_power_on(struct lgtd_client *, const struct lgtd_proto_target_list *);
 void lgtd_proto_power_off(struct lgtd_client *, const struct lgtd_proto_target_list *);
+void lgtd_proto_get_light_state(struct lgtd_client *, const struct lgtd_proto_target_list *);
 void lgtd_proto_list_tags(struct lgtd_client *);
diff --git a/core/router.c b/core/router.c
--- a/core/router.c
+++ b/core/router.c
@@ -199,6 +199,22 @@
     }
 }
 
+static struct lgtd_lifx_bulb *
+lgtd_router_device_addr_to_device(const char *device_addr)
+{
+    errno = 0;
+    uint64_t device;
+    const char *endptr = NULL;
+    device = strtoull(device_addr, (char **)&endptr, 16);
+    if (!*endptr && errno != ERANGE) {
+        device = htobe64(device);
+        return lgtd_lifx_bulb_get(
+            (uint8_t *)&device + sizeof(device) - LGTD_LIFX_ADDR_LENGTH
+        );
+    }
+    return NULL;
+}
+
 bool
 lgtd_router_send(const struct lgtd_proto_target_list *targets,
                  enum lgtd_lifx_packet_type pkt_type,
@@ -225,20 +241,11 @@
             // NOTE: labels and hardware addresses are ambiguous target types,
             // we can't really solve this since json doesn't have hexadecimal.
             if (isxdigit(target->target[0])) {
-                errno = 0;
-                uint64_t device;
-                const char *endptr = NULL;
-                device = strtoull(target->target, (char **)&endptr, 16);
-                if (!*endptr && errno != ERANGE) {
-                    device = htobe64(device);
-                    struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_get(
-                        (uint8_t *)&device
-                        + sizeof(device) - LGTD_LIFX_ADDR_LENGTH
-                    );
-                    if (bulb) {
-                        lgtd_router_send_to_device(bulb, pkt_type, pkt);
-                        continue;
-                    }
+                struct lgtd_lifx_bulb *bulb =
+                    lgtd_router_device_addr_to_device(target->target);
+                if (bulb) {
+                    lgtd_router_send_to_device(bulb, pkt_type, pkt);
+                    continue;
                 }
                 lgtd_debug(
                     "%s looked like a device address but didn't "
@@ -254,3 +261,119 @@
 
     return rv;
 }
+
+static void
+lgtd_router_clear_device_list(struct lgtd_router_device_list *devices)
+{
+    assert(devices);
+
+    while (!SLIST_EMPTY(devices)) {
+        struct lgtd_router_device *device = SLIST_FIRST(devices);
+        SLIST_REMOVE_HEAD(devices, link);
+        free(device);
+    }
+}
+
+static struct lgtd_router_device *
+lgtd_router_insert_device_if_not_in_list(struct lgtd_router_device_list *devices,
+                                         struct lgtd_lifx_bulb *device)
+{
+    struct lgtd_router_device *it;
+    SLIST_FOREACH(it, devices, link) {
+        if (it->device == device) {
+            return it;
+        }
+    }
+
+    struct lgtd_router_device *new = calloc(1, sizeof(*new));
+    if (new) {
+        new->device = device;
+        SLIST_INSERT_HEAD(devices, new, link);
+    }
+
+    return new;
+}
+
+struct lgtd_router_device_list *
+lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *targets)
+{
+    assert(targets);
+
+    struct lgtd_router_device_list *devices = calloc(1, sizeof(*devices));
+    if (!devices) {
+        return NULL;
+    }
+
+    SLIST_INIT(devices);
+
+    struct lgtd_proto_target *target;
+    SLIST_FOREACH(target, targets, link) {
+        if (!strcmp(target->target, "*")) {
+            lgtd_router_clear_device_list(devices);
+            struct lgtd_lifx_bulb *bulb;
+            RB_FOREACH(bulb, lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table) {
+                struct lgtd_router_device *device = calloc(1, sizeof(*device));
+                if (!device) {
+                    goto device_alloc_error;
+                }
+                device->device = bulb;
+                SLIST_INSERT_HEAD(devices, device, link);
+            }
+            return devices;
+        } else if (target->target[0] == '#') {
+            const struct lgtd_lifx_tag *tag;
+            tag = lgtd_lifx_tagging_find_tag(&target->target[1]);
+            if (tag) {
+                struct lgtd_lifx_site *site;
+                LIST_FOREACH(site, &tag->sites, link) {
+                    struct lgtd_lifx_bulb *bulb;
+                    uint64_t tag = LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(site->tag_id);
+                    SLIST_FOREACH(bulb, &site->gw->bulbs, link_by_gw) {
+                        if (bulb->state.tags & tag) {
+                            struct lgtd_router_device *device;
+                            device = lgtd_router_insert_device_if_not_in_list(
+                                devices, bulb
+                            );
+                            if (!device) {
+                                goto device_alloc_error;
+                            }
+                        }
+                    }
+                }
+            }
+        } else if (target->target[0]) {
+            struct lgtd_lifx_bulb *bulb = NULL;
+            if (isxdigit(target->target[0])) {
+                bulb = lgtd_router_device_addr_to_device(target->target);
+            }
+            if (!bulb) {
+                RB_FOREACH(bulb, lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table) {
+                    if (!strcmp(bulb->state.label, target->target)) {
+                        break;
+                    }
+                }
+            }
+            if (!bulb) {
+                continue;
+            }
+            if (!lgtd_router_insert_device_if_not_in_list(devices, bulb)) {
+                goto device_alloc_error;
+            }
+        }
+    }
+
+    return devices;
+
+device_alloc_error:
+    lgtd_router_device_list_free(devices);
+    return NULL;
+}
+
+void
+lgtd_router_device_list_free(struct lgtd_router_device_list *devices)
+{
+    assert(devices);
+
+    lgtd_router_clear_device_list(devices);
+    free(devices);
+}
diff --git a/core/router.h b/core/router.h
--- a/core/router.h
+++ b/core/router.h
@@ -23,8 +23,16 @@
     LGTD_ROUTER_CANNOT_ENQUEUE_PACKET_ERROR
 };
 
+struct lgtd_router_device {
+    SLIST_ENTRY(lgtd_router_device) link;
+    struct lgtd_lifx_bulb           *device;
+};
+SLIST_HEAD(lgtd_router_device_list, lgtd_router_device);
+
 bool lgtd_router_send(const struct lgtd_proto_target_list *, enum lgtd_lifx_packet_type, void *);
 void lgtd_router_send_to_device(struct lgtd_lifx_bulb *, enum lgtd_lifx_packet_type, void *);
 void lgtd_router_send_to_tag(const struct lgtd_lifx_tag *, enum lgtd_lifx_packet_type, void *);
 void lgtd_router_send_to_label(const char *, enum lgtd_lifx_packet_type, void *);
 void lgtd_router_broadcast(enum lgtd_lifx_packet_type, void *);
+struct lgtd_router_device_list *lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *);
+void lgtd_router_device_list_free(struct lgtd_router_device_list *);
diff --git a/docs/protocol.rst b/docs/protocol.rst
--- a/docs/protocol.rst
+++ b/docs/protocol.rst
@@ -60,9 +60,15 @@
                           end of the waveform, otherwise it will revert back to
                           its original state.
 
-.. function:: list_tags()
+.. function:: get_light_state(target)
 
-    Return a dictionnary with tags as keys and arrays of devices addresses or
-    labels as values.
+    Return a list of dictionnaries, each dict representing the state of one
+    targeted bulb, the list is not in any specific order. Each dict has the
+    following fields:
+
+    - hsbk: tuple (h, s, b, k) see function:`set_light_from_hsbk`;
+    - label: bulb label (utf-8 encoded string);
+    - power: boolean, true when the bulb is powered on false otherwise;
+    - tags: list of tags applied to the bulb (utf-8 encoded strings).
 
 .. vim: set tw=80 spelllang=en spell:
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -49,26 +49,6 @@
 struct lgtd_lifx_gateway_list lgtd_lifx_gateways =
     LIST_HEAD_INITIALIZER(&lgtd_lifx_gateways);
 
-// Kim Walisch (2012)
-// http://chessprogramming.wikispaces.com/BitScan#DeBruijnMultiplation
-static inline int
-lgtd_lifx_bitscan64_forward(uint64_t n)
-{
-    enum { DEBRUIJN_NUMBER = 0x03f79d71b4cb0a89 };
-    static const int DEBRUIJN_SEQUENCE[64] = {
-        0, 47,  1, 56, 48, 27,  2, 60,
-       57, 49, 41, 37, 28, 16,  3, 61,
-       54, 58, 35, 52, 50, 42, 21, 44,
-       38, 32, 29, 23, 17, 11,  4, 62,
-       46, 55, 26, 59, 40, 36, 15, 53,
-       34, 51, 20, 43, 31, 22, 10, 45,
-       25, 39, 14, 33, 19, 30,  9, 24,
-       13, 18,  8, 12,  7,  6,  5, 63
-    };
-
-    return n ? DEBRUIJN_SEQUENCE[((n ^ (n - 1)) * DEBRUIJN_NUMBER) >> 58] : -1;
-}
-
 void
 lgtd_lifx_gateway_close(struct lgtd_lifx_gateway *gw)
 {
@@ -565,17 +545,12 @@
         pkt->label, (uintmax_t)pkt->tags
     );
 
-    uint64_t tags = pkt->tags;
-    while (true) {
-        int tag_id = lgtd_lifx_bitscan64_forward(tags);
-        if (tag_id == -1) {
-            break;
-        }
+    int tag_id;
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, pkt->tags) {
         if (pkt->label[0]) {
             lgtd_lifx_gateway_allocate_tag_id(gw, tag_id, pkt->label);
         } else if (gw->tags[tag_id]) {
             lgtd_lifx_gateway_deallocate_tag_id(gw, tag_id);
         }
-        tags &= ~LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
     }
 }
diff --git a/lifx/wire_proto.c b/lifx/wire_proto.c
--- a/lifx/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -35,7 +35,18 @@
 #include "gateway.h"
 #include "core/lightsd.h"
 
-union lgtd_lifx_target LGTD_LIFX_UNSPEC_TARGET = { .tags = 0 };
+const union lgtd_lifx_target LGTD_LIFX_UNSPEC_TARGET = { .tags = 0 };
+
+const int LGTD_LIFX_DEBRUIJN_SEQUENCE[64] = {
+    0, 47,  1, 56, 48, 27,  2, 60,
+   57, 49, 41, 37, 28, 16,  3, 61,
+   54, 58, 35, 52, 50, 42, 21, 44,
+   38, 32, 29, 23, 17, 11,  4, 62,
+   46, 55, 26, 59, 40, 36, 15, 53,
+   34, 51, 20, 43, 31, 22, 10, 45,
+   25, 39, 14, 33, 19, 30,  9, 24,
+   13, 18,  8, 12,  7,  6,  5, 63
+};
 
 static struct lgtd_lifx_packet_infos_map lgtd_lifx_packet_infos =
     RB_INITIALIZER(&lgtd_lifx_packets_infos);
diff --git a/lifx/wire_proto.h b/lifx/wire_proto.h
--- a/lifx/wire_proto.h
+++ b/lifx/wire_proto.h
@@ -245,7 +245,7 @@
     const uint8_t   *addr; //! site or device address
 };
 
-extern union lgtd_lifx_target LGTD_LIFX_UNSPEC_TARGET;
+extern const union lgtd_lifx_target LGTD_LIFX_UNSPEC_TARGET;
 
 #if LGTD_SIZEOF_VOID_P == 8
 #   define LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(x) (1UL << (x))
@@ -253,6 +253,37 @@
 #   define LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(x) (1ULL << (x))
 #endif
 
+// Kim Walisch (2012)
+// http://chessprogramming.wikispaces.com/BitScan#DeBruijnMultiplation
+
+enum { LGTD_LIFX_DEBRUIJN_NUMBER = 0x03f79d71b4cb0a89 };
+extern const int LGTD_LIFX_DEBRUIJN_SEQUENCE[64];
+
+static inline int
+lgtd_lifx_wire_bitscan64_forward(uint64_t n)
+{
+    return n ? LGTD_LIFX_DEBRUIJN_SEQUENCE[
+        ((n ^ (n - 1)) * LGTD_LIFX_DEBRUIJN_NUMBER) >> 58
+    ] : -1;
+}
+
+static inline int
+lgtd_lifx_wire_next_tag_id(int current_tag_id, uint64_t tags)
+{
+    // A bitshift >= than the width of the type is undefined behavior in C:
+    if (current_tag_id < 63) {
+        tags &= ~0ULL << (current_tag_id + 1);
+        return lgtd_lifx_wire_bitscan64_forward(tags);
+    }
+    return -1;
+}
+
+#define LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id_varname, tags)                         \
+    for ((tag_id_varname) = lgtd_lifx_wire_next_tag_id(-1, (tags));                 \
+         (tag_id_varname) != -1;                                                    \
+         (tag_id_varname) = lgtd_lifx_wire_next_tag_id((tag_id_varname), (tags)))
+
+
 enum lgtd_lifx_waveform_type lgtd_lifx_wire_waveform_string_id_to_type(const char *, int);
 
 const struct lgtd_lifx_packet_infos *lgtd_lifx_wire_get_packet_infos(enum lgtd_lifx_packet_type);
diff --git a/tests/core/jsonrpc/test_jsonrpc_uint16_range_to_float_string.c b/tests/core/jsonrpc/test_jsonrpc_uint16_range_to_float_string.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_uint16_range_to_float_string.c
@@ -0,0 +1,56 @@
+#include "jsonrpc.c"
+
+#include "mock_client_buf.h"
+#include "test_jsonrpc_utils.h"
+
+int
+main(void)
+{
+    char buf[32];
+    int bufsz = sizeof(buf);
+
+    lgtd_jsonrpc_uint16_range_to_float_string(UINT16_MAX, 0, 1, buf, bufsz);
+    if (strcmp(buf, "1")) {
+        lgtd_errx(
+            1, "UINT16_MAX converted to %.*s (expected %s)",
+            bufsz, buf, "1"
+        );
+    }
+
+    lgtd_jsonrpc_uint16_range_to_float_string(UINT16_MAX / 2, 0, 1, buf, bufsz);
+    if (strcmp(buf, "0.499992")) {
+        lgtd_errx(
+            1, "UINT16_MAX / 2 converted to %.*s (expected %s)",
+            bufsz, buf, "0.499992"
+        );
+    }
+
+    lgtd_jsonrpc_uint16_range_to_float_string(0, 0, 1, buf, bufsz);
+    if (strcmp(buf, "0")) {
+        lgtd_errx(
+            1, "UINT16_MAX / 2 converted to %.*s (expected %s)",
+            bufsz, buf, "0"
+        );
+    }
+
+    lgtd_jsonrpc_uint16_range_to_float_string(0xaaaa, 0, 360, buf, bufsz);
+    if (strcmp(buf, "240")) {
+        lgtd_errx(
+            1, "0xaaaa converted to %.*s (expected %s)",
+            bufsz, buf, "240"
+        );
+    }
+
+    bufsz = 2;
+    lgtd_jsonrpc_uint16_range_to_float_string(UINT16_MAX / 2, 0, 1, buf, bufsz);
+    if (strcmp(buf, "0")) {
+        lgtd_errx(
+            1,
+            "UINT16_MAX / 2 converted to %.*s "
+            "(expected %s in case of overflow)",
+            bufsz, buf, "0"
+        );
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_utils.h b/tests/core/jsonrpc/test_jsonrpc_utils.h
--- a/tests/core/jsonrpc/test_jsonrpc_utils.h
+++ b/tests/core/jsonrpc/test_jsonrpc_utils.h
@@ -85,3 +85,13 @@
     (void)transient;
 }
 #endif
+
+#ifndef MOCKED_LGTD_GET_LIGHT_STATE
+void
+lgtd_proto_get_light_state(struct lgtd_client *client,
+                           const struct lgtd_proto_target_list *targets)
+{
+    (void)client;
+    (void)targets;
+}
+#endif
diff --git a/tests/core/proto/CMakeLists.txt b/tests/core/proto/CMakeLists.txt
--- a/tests/core/proto/CMakeLists.txt
+++ b/tests/core/proto/CMakeLists.txt
@@ -6,6 +6,7 @@
 ADD_LIBRARY(
     test_core_proto STATIC
     ${LIGHTSD_SOURCE_DIR}/core/log.c
+    ${LIGHTSD_SOURCE_DIR}/core/jsonrpc.c
     ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
     ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
     ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
diff --git a/tests/core/proto/test_proto_get_light_state.c b/tests/core/proto/test_proto_get_light_state.c
new file mode 100644
--- /dev/null
+++ b/tests/core/proto/test_proto_get_light_state.c
@@ -0,0 +1,123 @@
+#include "proto.c"
+
+#include "mock_client_buf.h"
+#include "tests_utils.h"
+
+#define MOCKED_ROUTER_TARGETS_TO_DEVICES
+#define MOCKED_ROUTER_DEVICE_LIST_FREE
+#include "tests_proto_utils.h"
+
+static bool device_list_free_called = false;
+
+void
+lgtd_router_device_list_free(struct lgtd_router_device_list *devices)
+{
+    if (!devices) {
+        lgtd_errx(1, "the device list must be passed");
+    }
+
+    device_list_free_called = true;
+}
+
+struct lgtd_router_device_list *
+lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *targets)
+{
+    if (targets != (void *)0x2a) {
+        lgtd_errx(1, "unexpected targets list");
+    }
+
+    static struct lgtd_router_device_list devices =
+        SLIST_HEAD_INITIALIZER(&devices);
+
+    static struct lgtd_lifx_bulb bulb_1 = {
+        .addr = { 1, 2, 3, 4, 5 },
+        .state = {
+            .hue = 0xaaaa,
+            .saturation = 0xffff,
+            .brightness = 0xbbbb,
+            .kelvin = 3600,
+            .label = "wave",
+            .power = LGTD_LIFX_POWER_ON,
+            .tags = 0
+        }
+    };
+    static struct lgtd_router_device device_1 = { .device = &bulb_1 };
+    SLIST_INSERT_HEAD(&devices, &device_1, link);
+
+    struct lgtd_lifx_tag *gw_2_tag_1 = lgtd_tests_insert_mock_tag("vapor");
+    struct lgtd_lifx_tag *gw_2_tag_2 = lgtd_tests_insert_mock_tag("d^-^b");
+    struct lgtd_lifx_tag *gw_2_tag_3 = lgtd_tests_insert_mock_tag("wave~");
+    static struct lgtd_lifx_gateway gw_bulb_2 = {
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_2.bulbs),
+        .tag_ids = 0x7
+    };
+    lgtd_tests_add_tag_to_gw(gw_2_tag_1, &gw_bulb_2, 0);
+    lgtd_tests_add_tag_to_gw(gw_2_tag_2, &gw_bulb_2, 1);
+    lgtd_tests_add_tag_to_gw(gw_2_tag_3, &gw_bulb_2, 2);
+    static struct lgtd_lifx_bulb bulb_2 = {
+        .addr = { 5, 4, 3, 2, 1 },
+        .state = {
+            .hue = 0x0000,
+            .saturation = 0x0000,
+            .brightness = 0xffff,
+            .kelvin = 4000,
+            .label = "",
+            .power = LGTD_LIFX_POWER_OFF,
+            .tags = 0x3
+        },
+        .gw = &gw_bulb_2
+    };
+    static struct lgtd_router_device device_2 = { .device = &bulb_2 };
+    SLIST_INSERT_HEAD(&devices, &device_2, link);
+
+    return &devices;
+}
+
+int
+main(void)
+{
+    struct lgtd_client client;
+    struct lgtd_proto_target_list *targets = (void *)0x2a;
+
+    lgtd_proto_get_light_state(&client, targets);
+
+    const char expected[] = (
+        "["
+            "{"
+                "\"hsbk\":[0,0,1,4000],"
+                "\"power\":false,"
+                "\"label\":\"\","
+                "\"tags\":[\"vapor\",\"d^-^b\"]"
+            "},"
+            "{"
+                "\"hsbk\":[240,1,0.733333,3600],"
+                "\"power\":true,"
+                "\"label\":\"wave\","
+                "\"tags\":[]"
+            "}"
+        "]"
+    );
+
+    if (client_write_buf_idx != sizeof(expected) - 1) {
+        lgtd_errx(
+            1,
+            "%d bytes written, expected %lu "
+            "(got %.*s instead of %s)",
+            client_write_buf_idx, sizeof(expected) - 1,
+            client_write_buf_idx, client_write_buf, expected
+        );
+    }
+
+    if (memcmp(expected, client_write_buf, sizeof(expected) - 1)) {
+        lgtd_errx(
+            1, "got %.*s instead of %s",
+            client_write_buf_idx, client_write_buf, expected
+        );
+    }
+
+    if (!device_list_free_called) {
+        lgtd_errx(1, "the list of devices hasn't been freed");
+    }
+
+    return 0;
+}
diff --git a/tests/core/proto/test_proto_get_light_state_empty_device_list.c b/tests/core/proto/test_proto_get_light_state_empty_device_list.c
new file mode 100644
--- /dev/null
+++ b/tests/core/proto/test_proto_get_light_state_empty_device_list.c
@@ -0,0 +1,60 @@
+#include "proto.c"
+
+#include "mock_client_buf.h"
+#include "tests_utils.h"
+
+#define MOCKED_ROUTER_TARGETS_TO_DEVICES
+#define MOCKED_ROUTER_DEVICE_LIST_FREE
+#include "tests_proto_utils.h"
+
+static bool device_list_free_called = false;
+
+void
+lgtd_router_device_list_free(struct lgtd_router_device_list *devices)
+{
+    if (!devices) {
+        lgtd_errx(1, "the device list must be passed");
+    }
+
+    device_list_free_called = true;
+}
+
+struct lgtd_router_device_list *
+lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *targets)
+{
+    if (targets != (void *)0x2a) {
+        lgtd_errx(1, "unexpected targets list");
+    }
+
+    static struct lgtd_router_device_list devices =
+        SLIST_HEAD_INITIALIZER(&devices);
+
+    return &devices;
+}
+
+int
+main(void)
+{
+    struct lgtd_client client;
+    struct lgtd_proto_target_list *targets = (void *)0x2a;
+
+    lgtd_proto_get_light_state(&client, targets);
+
+    const char expected[] = "[]";
+
+    if (client_write_buf_idx != sizeof(expected) - 1) {
+        lgtd_errx(
+            1, "%d bytes written, expected %lu",
+            client_write_buf_idx, sizeof(expected) - 1
+        );
+    }
+
+    if (memcmp(expected, client_write_buf, sizeof(expected) - 1)) {
+        lgtd_errx(
+            1, "got %.*s instead of %s",
+            client_write_buf_idx, client_write_buf, expected
+        );
+    }
+
+    return 0;
+}
diff --git a/tests/core/proto/test_proto_get_light_state_null_device_list.c b/tests/core/proto/test_proto_get_light_state_null_device_list.c
new file mode 100644
--- /dev/null
+++ b/tests/core/proto/test_proto_get_light_state_null_device_list.c
@@ -0,0 +1,58 @@
+#include "proto.c"
+
+#include "mock_client_buf.h"
+#include "tests_utils.h"
+
+#define MOCKED_ROUTER_TARGETS_TO_DEVICES
+#define MOCKED_CLIENT_SEND_ERROR
+#include "tests_proto_utils.h"
+
+static bool send_error_called = false;
+
+struct lgtd_router_device_list *
+lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *targets)
+{
+    if (targets != (void *)0x2a) {
+        lgtd_errx(1, "unexpected targets list");
+    }
+
+    return NULL;
+}
+
+void
+lgtd_client_send_error(struct lgtd_client *client,
+                       enum lgtd_client_error_code error,
+                       const char *msg)
+{
+    if (!client) {
+        lgtd_errx(1, "Expected client");
+    }
+
+    if (error != LGTD_CLIENT_INTERNAL_ERROR) {
+        lgtd_errx(
+            1, "Got error code %d (expected %d)",
+            error, LGTD_CLIENT_INTERNAL_ERROR
+        );
+    }
+
+    if (!msg) {
+        lgtd_errx(1, "Expected error message");
+    }
+
+    send_error_called = true;
+}
+
+int
+main(void)
+{
+    struct lgtd_client client;
+    struct lgtd_proto_target_list *targets = (void *)0x2a;
+
+    lgtd_proto_get_light_state(&client, targets);
+
+    if (!send_error_called) {
+        lgtd_errx(1, "lgtd_client_send_error hasn't been called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/proto/test_proto_list_tags.c b/tests/core/proto/test_proto_list_tags.c
--- a/tests/core/proto/test_proto_list_tags.c
+++ b/tests/core/proto/test_proto_list_tags.c
@@ -30,9 +30,9 @@
     reset_client_write_buf();
     lgtd_tests_insert_mock_tag("@_@");
     lgtd_proto_list_tags(&client);
-    if (strcmp(client_write_buf, "[\"@_@\", \"test\"]")) {
+    if (strcmp(client_write_buf, "[\"@_@\",\"test\"]")) {
         errx(
-            1, "expected [\"@_@\", \"test\"] but got %s instead",
+            1, "expected [\"@_@\",\"test\"] but got %s instead",
             client_write_buf
         );
     }
diff --git a/tests/core/proto/tests_proto_utils.h b/tests/core/proto/tests_proto_utils.h
--- a/tests/core/proto/tests_proto_utils.h
+++ b/tests/core/proto/tests_proto_utils.h
@@ -20,6 +20,18 @@
 }
 #endif
 
+#ifndef MOCKED_CLIENT_SEND_ERROR
+void
+lgtd_client_send_error(struct lgtd_client *client,
+                       enum lgtd_client_error_code error,
+                       const char *msg)
+{
+    (void)client;
+    (void)error;
+    (void)msg;
+}
+#endif
+
 #ifndef MOCKED_ROUTER_SEND
 bool
 lgtd_router_send(const struct lgtd_proto_target_list *targets,
@@ -32,3 +44,20 @@
     return true;
 }
 #endif
+
+#ifndef MOCKED_ROUTER_TARGETS_TO_DEVICES
+struct lgtd_router_device_list *
+lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *targets)
+{
+    (void)targets;
+    return NULL;
+}
+#endif
+
+#ifndef MOCKED_ROUTER_DEVICE_LIST_FREE
+void
+lgtd_router_device_list_free(struct lgtd_router_device_list *devices)
+{
+    (void)devices;
+}
+#endif
diff --git a/tests/core/router/test_router_targets_to_devices.c b/tests/core/router/test_router_targets_to_devices.c
new file mode 100644
--- /dev/null
+++ b/tests/core/router/test_router_targets_to_devices.c
@@ -0,0 +1,171 @@
+#include "router.c"
+
+#include "tests_utils.h"
+#include "tests_router_utils.h"
+
+static int
+count_device(const struct lgtd_router_device_list *devices, const void *device)
+{
+    if (!devices) {
+        lgtd_errx(1, "unexpected NULL devices list");
+    }
+
+    int count = 0;
+    struct lgtd_router_device *it;
+    SLIST_FOREACH(it, devices, link) {
+        if (it->device == device) {
+            count++;
+        }
+    }
+
+    return count;
+}
+
+static int
+len(const struct lgtd_router_device_list *devices)
+{
+    if (!devices) {
+        lgtd_errx(1, "unexpected NULL devices list");
+    }
+
+    int count = 0;
+    struct lgtd_router_device *it;
+    SLIST_FOREACH(it, devices, link) {
+        count++;
+    }
+
+    return count;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway *gw_1 = lgtd_tests_insert_mock_gateway(1);
+    struct lgtd_lifx_gateway *gw_2 = lgtd_tests_insert_mock_gateway(2);
+
+    struct lgtd_lifx_tag *tag_foo = lgtd_tests_insert_mock_tag("foo");
+    lgtd_tests_add_tag_to_gw(tag_foo, gw_1, 42);
+    lgtd_tests_add_tag_to_gw(tag_foo, gw_2, 63);
+
+    struct lgtd_lifx_tag *tag_bar = lgtd_tests_insert_mock_tag("bar");
+    lgtd_tests_add_tag_to_gw(tag_bar, gw_2, 42);
+
+    struct lgtd_lifx_bulb *bulb_1_gw_1 = lgtd_tests_insert_mock_bulb(gw_1, 3);
+    bulb_1_gw_1->state.tags = LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(42);
+
+    struct lgtd_lifx_bulb *bulb_2_gw_1 = lgtd_tests_insert_mock_bulb(gw_1, 4);
+
+    struct lgtd_lifx_bulb *bulb_1_gw_2 = lgtd_tests_insert_mock_bulb(gw_2, 5);
+    strcpy(bulb_1_gw_2->state.label, "desk");
+
+    struct lgtd_lifx_bulb *bulb_2_gw_2 = lgtd_tests_insert_mock_bulb(gw_2, 6);
+    bulb_2_gw_2->state.tags =
+        LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(63) | LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(42);
+
+    struct lgtd_proto_target_list *targets;
+    struct lgtd_router_device_list *devices;
+    int count;
+
+    targets = lgtd_tests_build_target_list(NULL);
+    devices = lgtd_router_targets_to_devices(targets);
+    if ((count = len(devices)) != 0) {
+        lgtd_errx(1, "expected 0 devices but got %d", count);
+    }
+
+    targets = lgtd_tests_build_target_list("#pouet", NULL);
+    devices = lgtd_router_targets_to_devices(targets);
+    if ((count = len(devices))) {
+        lgtd_errx(1, "expected 0 device but got %d", count);
+    }
+
+    targets = lgtd_tests_build_target_list("#pouet", "label", NULL);
+    devices = lgtd_router_targets_to_devices(targets);
+    if ((count = len(devices))) {
+        lgtd_errx(1, "expected 0 device but got %d", count);
+    }
+
+    targets = lgtd_tests_build_target_list("#foo", NULL);
+    devices = lgtd_router_targets_to_devices(targets);
+    if ((count = count_device(devices, bulb_1_gw_1)) != 1) {
+        lgtd_errx(1, "bulb bulb_1_gw_1 found %d times, expected 1", count);
+    }
+    if ((count = count_device(devices, bulb_2_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_2_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = len(devices)) != 2) {
+        lgtd_errx(1, "expected 2 devices but got %d", count);
+    }
+
+    targets = lgtd_tests_build_target_list("#bar", NULL);
+    devices = lgtd_router_targets_to_devices(targets);
+    if ((count = count_device(devices, bulb_2_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_2_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = len(devices)) != 1) {
+        lgtd_errx(1, "expected 1 devices but got %d", count);
+    }
+
+    targets = lgtd_tests_build_target_list("desk", NULL);
+    devices = lgtd_router_targets_to_devices(targets);
+    if ((count = count_device(devices, bulb_1_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_1_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = len(devices)) != 1) {
+        lgtd_errx(1, "expected 1 device but got %d", count);
+    }
+
+    targets = lgtd_tests_build_target_list("4", NULL);
+    devices = lgtd_router_targets_to_devices(targets);
+    if ((count = count_device(devices, bulb_2_gw_1)) != 1) {
+        lgtd_errx(1, "bulb bulb_2_gw_1 found %d times, expected 1", count);
+    }
+    if ((count = len(devices)) != 1) {
+        lgtd_errx(1, "expected 1 device but got %d", count);
+    }
+
+    targets = lgtd_tests_build_target_list("desk", "5", NULL);
+    devices = lgtd_router_targets_to_devices(targets);
+    if ((count = count_device(devices, bulb_1_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_1_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = len(devices)) != 1) {
+        lgtd_errx(1, "expected 1 device but got %d", count);
+    }
+
+    targets = lgtd_tests_build_target_list("desk", "5", "#foo", NULL);
+    devices = lgtd_router_targets_to_devices(targets);
+    if ((count = count_device(devices, bulb_1_gw_1)) != 1) {
+        lgtd_errx(1, "bulb bulb_1_gw_1 found %d times, expected 1", count);
+    }
+    if ((count = count_device(devices, bulb_1_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_1_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = count_device(devices, bulb_2_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_2_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = len(devices)) != 3) {
+        lgtd_errx(1, "expected 3 device but got %d", count);
+    }
+
+    targets = lgtd_tests_build_target_list("*", "#foo", "*", NULL);
+    devices = lgtd_router_targets_to_devices(targets);
+    if ((count = count_device(devices, bulb_1_gw_1)) != 1) {
+        lgtd_errx(1, "bulb bulb_1_gw_1 found %d times, expected 1", count);
+    }
+    if ((count = count_device(devices, bulb_1_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_1_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = count_device(devices, bulb_1_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_1_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = count_device(devices, bulb_2_gw_2)) != 1) {
+        lgtd_errx(1, "bulb bulb_2_gw_2 found %d times, expected 1", count);
+    }
+    if ((count = len(devices)) != 4) {
+        lgtd_errx(1, "expected 4 device but got %d", count);
+    }
+
+    return 0;
+}
diff --git a/tests/core/tests_utils.c b/tests/core/tests_utils.c
--- a/tests/core/tests_utils.c
+++ b/tests/core/tests_utils.c
@@ -51,8 +51,11 @@
         uint8_t     as_array[LGTD_LIFX_ADDR_LENGTH];
         uint64_t    as_scalar;
     } bulb_addr = { .as_scalar = htobe64(addr) >> 16 };
+    struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_open(gw, bulb_addr.as_array);
 
-    return lgtd_lifx_bulb_open(gw, bulb_addr.as_array);
+    SLIST_INSERT_HEAD(&gw->bulbs, bulb, link_by_gw);
+
+    return bulb;
 }
 
 struct lgtd_proto_target_list *
@@ -61,21 +64,25 @@
     struct lgtd_proto_target_list *targets = malloc(sizeof(*targets));
     SLIST_INIT(targets);
 
-    struct lgtd_proto_target *tail = malloc(
-        sizeof(*tail) + strlen(target) + 1
-    );
-    strcpy(tail->target, target);
-    SLIST_INSERT_HEAD(targets, tail, link);
+    if (target) {
+        struct lgtd_proto_target *tail = malloc(
+            sizeof(*tail) + strlen(target) + 1
+        );
+        strcpy(tail->target, target);
+        SLIST_INSERT_HEAD(targets, tail, link);
 
-    va_list ap;
-    va_start(ap, target);
-    while ((target = va_arg(ap, const char *))) {
-        struct lgtd_proto_target *t = malloc(sizeof(*t) + strlen(target) + 1);
-        strcpy(t->target, target);
-        SLIST_INSERT_AFTER(tail, t, link);
-        tail = t;
+        va_list ap;
+        va_start(ap, target);
+        while ((target = va_arg(ap, const char *))) {
+            struct lgtd_proto_target *t = malloc(
+                sizeof(*t) + strlen(target) + 1
+            );
+            strcpy(t->target, target);
+            SLIST_INSERT_AFTER(tail, t, link);
+            tail = t;
+        }
+        va_end(ap);
     }
-    va_end(ap);
 
     return targets;
 }
diff --git a/tests/lightsc b/tests/lightsc
--- a/tests/lightsc
+++ b/tests/lightsc
@@ -1,43 +1,49 @@
 #!/usr/bin/env python
 
 import json
+import pprint
 import socket
 import sys
 import time
+import uuid
 
 from IPython.terminal.embed import InteractiveShellEmbed
 
 
-def jsonrpc_call(socket, id, method, params):
+def jsonrpc_call(socket, method, params):
     payload = {
         "method": method,
         "params": params,
         "jsonrpc": "2.0",
-        "id": id,
+        "id": str(uuid.uuid4()),
     }
-    socket.send(json.dumps(payload).encode("ascii"))
-    response = socket.recv(2048)
-    response = json.loads(response.decode("ascii"))
-    print(response)
+    socket.send(json.dumps(payload).encode("utf-8"))
+    response = socket.recv(2048).decode("utf-8")
+    try:
+        response = json.loads(response)
+    except ValueError:
+        print("received invalid json: {}".format(response))
+        return None
+    return response
 
 
-def set_light_from_hsbk(socket, id, target, h, s, b, k, t):
-    jsonrpc_call(socket, id, "set_light_from_hsbk", [
+def set_light_from_hsbk(socket, target, h, s, b, k, t):
+    return jsonrpc_call(socket, "set_light_from_hsbk", [
         target, h, s, b, k, t
     ])
 
 
-def set_waveform(socket, id, target, waveform,
+def set_waveform(socket, target, waveform,
                  h, s, b, k,
                  period, cycles, skew_ratio, transient):
-    jsonrpc_call(socket, id, "set_waveform", [
+    return jsonrpc_call(socket, "set_waveform", [
         target, waveform, h, s, b, k, period, cycles, skew_ratio, transient
     ])
 
 
-def saw(socket, id, target, h, s, b, k, period, cycles, transient=True):
-    set_waveform(
-        socket, id, target, "SAW", h, s, b, k,
+def saw(socket, target, h, s, b, k, period, cycles, transient=True):
+    return set_waveform(
+        socket, target, "SAW", h, s, b, k,
         cycles=cycles,
         period=period,
         skew_ratio=0.5,
@@ -45,9 +51,9 @@
     )
 
 
-def sine(socket, id, target, h, s, b, k, period, cycles, peak=0.5, transient=True):
-    set_waveform(
-        socket, id, target, "SINE", h, s, b, k,
+def sine(socket, target, h, s, b, k, period, cycles, peak=0.5, transient=True):
+    return set_waveform(
+        socket, target, "SINE", h, s, b, k,
         cycles=cycles,
         period=period,
         skew_ratio=peak,
@@ -55,16 +61,16 @@
     )
 
 
-def power_on(socket, id, target):
-    jsonrpc_call(socket, id, "power_on", {"target": target})
+def power_on(socket, target):
+    return jsonrpc_call(socket, "power_on", {"target": target})
 
 
-def power_off(socket, id, target):
-    jsonrpc_call(socket, id, "power_off", {"target": target})
+def power_off(socket, target):
+    return jsonrpc_call(socket, "power_off", {"target": target})
 
 
-def list_tags(socket, id):
-    jsonrpc_call(socket, id, "list_tags", [])
+def get_light_state(socket, target):
+    return jsonrpc_call(socket, "get_light_state", [target])
 
 if __name__ == "__main__":
     s = socket.create_connection(("localhost", 1234))
@@ -80,12 +86,12 @@
             ipshell = InteractiveShellEmbed()
             ipshell()
             sys.exit(0)
-        power_on(s, id, target)
+        power_on(s, target)
         while True:
             h = (h + 5) % 360
             id += 1
-            set_light_from_hsbk(s, id, target, h, 0.8, 0.1, 2500, 450)
+            set_light_from_hsbk(s, target, h, 0.8, 0.1, 2500, 450)
             time.sleep(0.5)
-        power_off(s, id, target)
+        power_off(s, target)
     finally:
         s.close()
