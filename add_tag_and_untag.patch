# HG changeset patch
# Parent  e6a5c70e43bf38915cfe7bf4614b7aa71be843e9

diff --git a/README.rst b/README.rst
--- a/README.rst
+++ b/README.rst
@@ -29,8 +29,7 @@
 - set_light_from_hsbk;
 - set_waveform (change the light according to a function like SAW or SINE);
 - get_light_state;
-- tag/untag (group/ungroup bulbs together, coming up: need unit & regression
-  tests);
+- tag/untag (group/ungroup bulbs together);
 - toggle (power on if off and vice-versa, coming up).
 
 The JSON-RPC interface works on top on IPv4/v6, over a command (named) pipe and
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -977,6 +977,90 @@
     lgtd_proto_target_list_clear(&targets);
 }
 
+static void
+lgtd_jsonrpc_check_and_call_proto_tag_or_untag(struct lgtd_client *client,
+                                               void (*lgtd_proto_fn)(struct lgtd_client *,
+                                                          const struct lgtd_proto_target_list *,
+                                                          const char *))
+
+{
+    struct lgtd_jsonrpc_target_args {
+        const jsmntok_t *target;
+        int             target_ntokens;
+        const jsmntok_t *tag;
+    } params = { NULL, 0, NULL };
+    static const struct lgtd_jsonrpc_node schema[] = {
+        LGTD_JSONRPC_NODE(
+            "target",
+            offsetof(struct lgtd_jsonrpc_target_args, target),
+            offsetof(struct lgtd_jsonrpc_target_args, target_ntokens),
+            lgtd_jsonrpc_type_string_number_or_array,
+            false
+        ),
+        LGTD_JSONRPC_NODE(
+            "tag",
+            offsetof(struct lgtd_jsonrpc_target_args, tag),
+            -1,
+            lgtd_jsonrpc_type_string,
+            false
+        )
+    };
+
+    struct lgtd_jsonrpc_request *req = client->current_request;
+    bool ok = lgtd_jsonrpc_extract_and_validate_params_against_schema(
+        &params,
+        schema,
+        LGTD_ARRAY_SIZE(schema),
+        req->params,
+        req->params_ntokens,
+        client->json
+    );
+    if (!ok) {
+        lgtd_jsonrpc_send_error(
+            client, LGTD_JSONRPC_INVALID_PARAMS, "Invalid parameters"
+        );
+        return;
+    }
+
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
+    ok = lgtd_jsonrpc_build_target_list(
+        &targets, client, params.target, params.target_ntokens
+    );
+    if (!ok) {
+        return;
+    }
+
+    char *tag = strndup(
+        &client->json[params.tag->start], LGTD_JSONRPC_TOKEN_LEN(params.tag)
+    );
+    if (!tag) {
+        lgtd_warn("can't allocate a tag");
+        lgtd_jsonrpc_send_error(
+            client, LGTD_JSONRPC_INTERNAL_ERROR, "Can't allocate memory"
+        );
+        goto error_strdup;
+    }
+
+    lgtd_proto_fn(client, &targets, tag);
+
+    free(tag);
+
+error_strdup:
+    lgtd_proto_target_list_clear(&targets);
+}
+
+static void
+lgtd_jsonrpc_check_and_call_tag(struct lgtd_client *client)
+{
+    return lgtd_jsonrpc_check_and_call_proto_tag_or_untag(client, lgtd_proto_tag);
+}
+
+static void
+lgtd_jsonrpc_check_and_call_untag(struct lgtd_client *client)
+{
+    return lgtd_jsonrpc_check_and_call_proto_tag_or_untag(client, lgtd_proto_untag);
+}
+
 void
 lgtd_jsonrpc_dispatch_request(struct lgtd_client *client, int parsed)
 {
@@ -1001,6 +1085,14 @@
         LGTD_JSONRPC_METHOD(
             "get_light_state", 1, // t
             lgtd_jsonrpc_check_and_call_get_light_state
+        ),
+        LGTD_JSONRPC_METHOD(
+            "tag", 2, // t, tag
+            lgtd_jsonrpc_check_and_call_tag
+        ),
+        LGTD_JSONRPC_METHOD(
+            "untag", 2, // t, tag
+            lgtd_jsonrpc_check_and_call_untag
         )
     };
 
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -224,3 +224,145 @@
 
     lgtd_router_device_list_free(devices);
 }
+
+void
+lgtd_proto_tag(struct lgtd_client *client,
+               const struct lgtd_proto_target_list *targets,
+               const char *tag_label)
+{
+    assert(client);
+    assert(targets);
+    assert(tag_label);
+
+    struct lgtd_router_device_list *devices;
+    devices = lgtd_router_targets_to_devices(targets);
+    if (!devices) {
+        goto error_tag_alloc;
+    }
+
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(tag_label);
+    if (!tag) {
+        tag = lgtd_lifx_tagging_allocate_tag(tag_label);
+        if (!tag) {
+            goto error_tag_alloc;
+        }
+        lgtd_info("created tag [%s]", tag_label);
+    }
+
+    struct lgtd_router_device *device;
+    struct lgtd_lifx_site *site;
+
+    // Loop over the devices and do allocations first, this makes error
+    // handling easier (since you can't rollback enqueued packets) and build
+    // the list of affected gateways so we can do SET_TAG_LABELS:
+    SLIST_FOREACH(device, devices, link) {
+        struct lgtd_lifx_gateway *gw = device->device->gw;
+        int tag_id = lgtd_lifx_gateway_get_tag_id(gw, tag);
+        if (tag_id == -1) {
+            tag_id = lgtd_lifx_gateway_allocate_tag_id(gw, -1, tag_label);
+            if (tag_id == -1) {
+                goto error_site_alloc;
+            }
+        }
+    }
+
+    // SET_TAG_LABELS, this is idempotent, do it everytime so we can recover
+    // from any bad state:
+    LIST_FOREACH(site, &tag->sites, link) {
+        int tag_id = site->tag_id;
+        assert(tag_id > -1 && tag_id < LGTD_LIFX_GATEWAY_MAX_TAGS);
+        struct lgtd_lifx_packet_tag_labels pkt = { .tags = 0 };
+        pkt.tags = LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
+        strncpy(pkt.label, tag_label, sizeof(pkt.label) - 1);
+        lgtd_lifx_wire_encode_tag_labels(&pkt);
+        bool enqueued = lgtd_lifx_gateway_send_to_site(
+            site->gw, LGTD_LIFX_SET_TAG_LABELS, &pkt
+        );
+        if (!enqueued) {
+            goto error_site_alloc;
+        }
+        lgtd_info(
+            "created tag [%s] with id %d on gw [%s]:%hu",
+            tag_label, tag_id, site->gw->ip_addr, site->gw->port
+        );
+    }
+
+    // Finally SET_TAGS on the devices:
+    SLIST_FOREACH(device, devices, link) {
+        struct lgtd_lifx_bulb *bulb = device->device;
+        int tag_id = lgtd_lifx_gateway_get_tag_id(bulb->gw, tag);
+        assert(tag_id > -1 && tag_id < LGTD_LIFX_GATEWAY_MAX_TAGS);
+        int tag_value = LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
+        if (!(bulb->state.tags & tag_value)) {
+            struct lgtd_lifx_packet_tags pkt;
+            pkt.tags = bulb->state.tags | tag_value;
+            lgtd_lifx_wire_encode_tags(&pkt);
+            lgtd_router_send_to_device(bulb, LGTD_LIFX_SET_TAGS, &pkt);
+        }
+    }
+
+    SEND_RESULT(client, true);
+    goto fini;
+
+error_site_alloc:
+    if (LIST_EMPTY(&tag->sites)) {
+        lgtd_lifx_tagging_deallocate_tag(tag);
+    } else { // tagging_decref will deallocate the tag for us:
+        struct lgtd_lifx_site *next_site;
+        LIST_FOREACH_SAFE(site, &tag->sites, link, next_site) {
+            lgtd_lifx_gateway_deallocate_tag_id(site->gw, site->tag_id);
+        }
+    }
+error_tag_alloc:
+    lgtd_client_send_error(
+        client, LGTD_CLIENT_INTERNAL_ERROR, "couldn't allocate new tag"
+    );
+fini:
+    lgtd_router_device_list_free(devices);
+    return;
+}
+
+void
+lgtd_proto_untag(struct lgtd_client *client,
+                 const struct lgtd_proto_target_list *targets,
+                 const char *tag_label)
+{
+    assert(client);
+    assert(targets);
+    assert(tag_label);
+
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(tag_label);
+    if (!tag) {
+        SEND_RESULT(client, true);
+        return;
+    }
+
+    struct lgtd_router_device_list *devices = NULL;
+    devices = lgtd_router_targets_to_devices(targets);
+    if (!devices) {
+        lgtd_client_send_error(
+            client, LGTD_CLIENT_INTERNAL_ERROR, "couldn't allocate memory"
+        );
+        return;
+    }
+
+    struct lgtd_router_device *device;
+    SLIST_FOREACH(device, devices, link) {
+        struct lgtd_lifx_bulb *bulb = device->device;
+        struct lgtd_lifx_gateway *gw = bulb->gw;
+        int tag_id = lgtd_lifx_gateway_get_tag_id(gw, tag);
+        if (tag_id != -1) {
+            int tag_value = LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
+            if (bulb->state.tags & tag_value) {
+                struct lgtd_lifx_packet_tags pkt;
+                pkt.tags = bulb->state.tags & ~tag_value;
+                lgtd_lifx_wire_encode_tags(&pkt);
+                lgtd_router_send_to_device(bulb, LGTD_LIFX_SET_TAGS, &pkt);
+            }
+        }
+    }
+
+    SEND_RESULT(client, true);
+
+    lgtd_router_device_list_free(devices);
+}
diff --git a/core/proto.h b/core/proto.h
--- a/core/proto.h
+++ b/core/proto.h
@@ -39,3 +39,5 @@
 void lgtd_proto_power_on(struct lgtd_client *, const struct lgtd_proto_target_list *);
 void lgtd_proto_power_off(struct lgtd_client *, const struct lgtd_proto_target_list *);
 void lgtd_proto_get_light_state(struct lgtd_client *, const struct lgtd_proto_target_list *);
+void lgtd_proto_tag(struct lgtd_client *, const struct lgtd_proto_target_list *, const char *);
+void lgtd_proto_untag(struct lgtd_client *, const struct lgtd_proto_target_list *, const char *);
diff --git a/lifx/bulb.c b/lifx/bulb.c
--- a/lifx/bulb.c
+++ b/lifx/bulb.c
@@ -77,12 +77,29 @@
     assert(bulb);
     assert(bulb->gw);
 
+#ifndef NDEBUG
+    // FIXME: Yeah, so an unit test lgtd_lifx_gateway_remove_and_close_bulb
+    // would be better because it can be automated, but this looks so much
+    // easier to do and this code path is often exercised:
+    int tag_id;
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, bulb->state.tags) {
+        int n = 0;
+        struct lgtd_lifx_bulb *gw_bulb;
+        SLIST_FOREACH(gw_bulb, &bulb->gw->bulbs, link_by_gw) {
+            assert(gw_bulb != bulb);
+            if (LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id) & gw_bulb->state.tags) {
+                n++;
+            }
+        }
+        assert(bulb->gw->tag_refcounts[tag_id] == n);
+    }
+#endif
+
     LGTD_STATS_ADD_AND_UPDATE_PROCTITLE(bulbs, -1);
     if (bulb->state.power == LGTD_LIFX_POWER_ON) {
         LGTD_STATS_ADD_AND_UPDATE_PROCTITLE(bulbs_powered_on, -1);
     }
     RB_REMOVE(lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table, bulb);
-    SLIST_REMOVE(&bulb->gw->bulbs, bulb, lgtd_lifx_bulb, link_by_gw);
     lgtd_info(
         "closed bulb \"%.*s\" (%s) on [%s]:%hu",
         LGTD_LIFX_LABEL_SIZE,
@@ -108,6 +125,8 @@
         );
     }
 
+    lgtd_lifx_gateway_update_tag_refcounts(bulb->gw, bulb->state.tags, state->tags);
+
     bulb->last_light_state_at = received_at;
     memcpy(&bulb->state, state, sizeof(bulb->state));
 }
@@ -125,3 +144,13 @@
 
     bulb->state.power = power;
 }
+
+void
+lgtd_lifx_bulb_set_tags(struct lgtd_lifx_bulb *bulb, uint64_t tags)
+{
+    assert(bulb);
+
+    lgtd_lifx_gateway_update_tag_refcounts(bulb->gw, bulb->state.tags, tags);
+
+    bulb->state.tags = tags;
+}
diff --git a/lifx/bulb.h b/lifx/bulb.h
--- a/lifx/bulb.h
+++ b/lifx/bulb.h
@@ -68,3 +68,4 @@
                                     const struct lgtd_lifx_light_state *,
                                     lgtd_time_mono_t);
 void lgtd_lifx_bulb_set_power_state(struct lgtd_lifx_bulb *, uint16_t);
+void lgtd_lifx_bulb_set_tags(struct lgtd_lifx_bulb *, uint64_t);
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -71,9 +71,9 @@
             lgtd_lifx_tagging_decref(gw->tags[i], gw);
         }
     }
-    struct lgtd_lifx_bulb *bulb, *next_bulb;
-    SLIST_FOREACH_SAFE(bulb, &gw->bulbs, link_by_gw, next_bulb) {
-        lgtd_lifx_bulb_close(bulb);
+    while (!SLIST_EMPTY(&gw->bulbs)) {
+        struct lgtd_lifx_bulb *bulb = SLIST_FIRST(&gw->bulbs);
+        lgtd_lifx_gateway_remove_and_close_bulb(gw, bulb);
     }
 
     lgtd_info(
@@ -83,6 +83,23 @@
     free(gw);
 }
 
+void
+lgtd_lifx_gateway_remove_and_close_bulb(struct lgtd_lifx_gateway *gw,
+                                        struct lgtd_lifx_bulb *bulb)
+{
+    assert(gw);
+    assert(bulb);
+
+    int tag_id;
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, bulb->state.tags) {
+        assert(gw->tag_refcounts[tag_id] > 0);
+        gw->tag_refcounts[tag_id]--;
+    }
+    SLIST_REMOVE(&gw->bulbs, bulb, lgtd_lifx_bulb, link_by_gw);
+
+    lgtd_lifx_bulb_close(bulb);
+}
+
 static void
 lgtd_lifx_gateway_write_callback(evutil_socket_t socket,
                                  short events, void *ctx)
@@ -151,36 +168,77 @@
     }
 }
 
+static bool
+lgtd_lifx_gateway_send_to_site_impl(struct lgtd_lifx_gateway *gw,
+                                    enum lgtd_lifx_packet_type pkt_type,
+                                    const void *pkt,
+                                    const struct lgtd_lifx_packet_infos **pkt_infos)
+{
+    assert(gw);
+    assert(pkt_infos);
+
+    struct lgtd_lifx_packet_header hdr;
+    union lgtd_lifx_target target = { .addr = gw->site.as_array };
+    *pkt_infos = lgtd_lifx_wire_setup_header(
+        &hdr,
+        LGTD_LIFX_TARGET_SITE,
+        target,
+        gw->site.as_array,
+        pkt_type
+    );
+    assert(*pkt_infos);
+
+    lgtd_lifx_gateway_enqueue_packet(gw, &hdr, pkt_type, pkt, (*pkt_infos)->size);
+
+    return true; // FIXME, have real return values on the send paths...
+}
+
+static bool
+lgtd_lifx_gateway_send_to_site_quiet(struct lgtd_lifx_gateway *gw,
+                                     enum lgtd_lifx_packet_type pkt_type,
+                                     const void *pkt)
+{
+
+    const struct lgtd_lifx_packet_infos *pkt_infos;
+    bool rv = lgtd_lifx_gateway_send_to_site_impl(
+        gw, pkt_type, pkt, &pkt_infos
+    );
+
+    lgtd_debug(
+        "sending %s to site %s",
+        pkt_infos->name, lgtd_addrtoa(gw->site.as_array)
+    );
+
+    return rv; // FIXME, have real return values on the send paths...
+}
+
+bool
+lgtd_lifx_gateway_send_to_site(struct lgtd_lifx_gateway *gw,
+                               enum lgtd_lifx_packet_type pkt_type,
+                               const void *pkt)
+{
+    const struct lgtd_lifx_packet_infos *pkt_infos;
+    bool rv = lgtd_lifx_gateway_send_to_site_impl(
+        gw, pkt_type, pkt, &pkt_infos
+    );
+
+    lgtd_info(
+        "sending %s to site %s",
+        pkt_infos->name, lgtd_addrtoa(gw->site.as_array)
+    );
+
+    return rv; // FIXME, have real return values on the send paths...
+}
+
 static void
 lgtd_lifx_gateway_send_get_all_light_state(struct lgtd_lifx_gateway *gw)
 {
     assert(gw);
 
-    struct lgtd_lifx_packet_header hdr;
-    union lgtd_lifx_target target = { .addr = gw->site.as_array };
+    lgtd_lifx_gateway_send_to_site_quiet(gw, LGTD_LIFX_GET_LIGHT_STATE, NULL);
 
-    lgtd_lifx_wire_setup_header(
-        &hdr,
-        LGTD_LIFX_TARGET_SITE,
-        target,
-        gw->site.as_array,
-        LGTD_LIFX_GET_LIGHT_STATE
-    );
-    lgtd_lifx_gateway_enqueue_packet(
-        gw, &hdr, LGTD_LIFX_GET_LIGHT_STATE, NULL, 0
-    );
-
-    struct lgtd_lifx_packet_get_tag_labels pkt = { .tags = LGTD_LIFX_ALL_TAGS };
-    lgtd_lifx_wire_setup_header(
-        &hdr,
-        LGTD_LIFX_TARGET_SITE,
-        target,
-        gw->site.as_array,
-        LGTD_LIFX_GET_TAG_LABELS
-    );
-    lgtd_lifx_gateway_enqueue_packet(
-        gw, &hdr, LGTD_LIFX_GET_TAG_LABELS, &pkt, sizeof(pkt)
-    );
+    struct lgtd_lifx_packet_tags pkt = { .tags = LGTD_LIFX_ALL_TAGS };
+    lgtd_lifx_gateway_send_to_site_quiet(gw, LGTD_LIFX_GET_TAG_LABELS, &pkt);
 
     gw->pending_refresh_req = true;
 }
@@ -371,19 +429,55 @@
 }
 
 void
+lgtd_lifx_gateway_update_tag_refcounts(struct lgtd_lifx_gateway *gw,
+                                       uint64_t bulb_tags,
+                                       uint64_t pkt_tags)
+{
+    uint64_t changes = bulb_tags ^ pkt_tags;
+    uint64_t added_tags = changes & pkt_tags;
+    uint64_t removed_tags = changes & bulb_tags;
+    int tag_id;
+
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, added_tags) {
+        if (gw->tag_refcounts[tag_id] != UINT8_MAX) {
+            gw->tag_refcounts[tag_id]++;
+        } else {
+            lgtd_warnx(
+                "reached refcount limit (%u) for tag [%s] (%d) on gw [%s]:%hu",
+                UINT8_MAX, gw->tags[tag_id] ? gw->tags[tag_id]->label : NULL,
+                tag_id, gw->ip_addr, gw->port
+            );
+        }
+    }
+
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, removed_tags) {
+        assert(gw->tag_refcounts[tag_id] > 0);
+        if (--gw->tag_refcounts[tag_id] == 0) {
+            lgtd_info(
+                "deleting unused tag [%s] (%d) from gw [%s]:%hu (site %s)",
+                gw->tags[tag_id] ? gw->tags[tag_id]->label : NULL, tag_id,
+                gw->ip_addr, gw->port, lgtd_addrtoa(gw->site.as_array)
+            );
+            struct lgtd_lifx_packet_tag_labels pkt = {
+                .tags = ~(gw->tag_ids & ~LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id))
+            };
+            lgtd_lifx_wire_encode_tag_labels(&pkt);
+            lgtd_lifx_gateway_send_to_site(gw, LGTD_LIFX_SET_TAG_LABELS, &pkt);
+        }
+    }
+}
+
+void
 lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *gw,
                                      const struct lgtd_lifx_packet_header *hdr,
                                      const struct lgtd_lifx_packet_pan_gateway *pkt)
 {
-    (void)pkt;
-
     assert(gw && hdr && pkt);
 
     lgtd_debug(
-        "SET_PAN_GATEWAY <-- [%s]:%hu - %s site=%s",
-        gw->ip_addr, gw->port,
-        lgtd_addrtoa(hdr->target.device_addr),
-        lgtd_addrtoa(hdr->site)
+        "SET_PAN_GATEWAY <-- [%s]:%hu - %s site=%s, service_type=%d",
+        gw->ip_addr, gw->port, lgtd_addrtoa(hdr->target.device_addr),
+        lgtd_addrtoa(hdr->site), pkt->service_type
     );
 }
 
@@ -485,16 +579,44 @@
 }
 
 int
+lgtd_lifx_gateway_get_tag_id(const struct lgtd_lifx_gateway *gw,
+                             const struct lgtd_lifx_tag *tag)
+{
+    assert(gw);
+    assert(tag);
+
+    int tag_id;
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, gw->tag_ids) {
+        if (gw->tags[tag_id] == tag) {
+            return tag_id;
+        }
+    }
+
+    return -1;
+}
+
+int
 lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *gw,
                                   int tag_id,
                                   const char *tag_label)
 {
     assert(gw);
     assert(tag_label);
-    // allocating a new tag_id (tag_id == -1) isn't supported yet:
-    assert(tag_id >= 0);
+    assert(tag_id >= -1);
     assert(tag_id < LGTD_LIFX_GATEWAY_MAX_TAGS);
 
+    if (tag_id == -1) {
+        tag_id = lgtd_lifx_wire_bitscan64_forward(~gw->tag_ids);
+        if (tag_id == -1) {
+            lgtd_warnx(
+                "no tag_id left for new tag [%s] on gw [%s]:%hu (site %s)",
+                tag_label, gw->ip_addr, gw->port,
+                lgtd_addrtoa(gw->site.as_array)
+            );
+            return -1;
+        }
+    }
+
     if (!(gw->tag_ids & LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id))) {
         struct lgtd_lifx_tag *tag;
         tag = lgtd_lifx_tagging_incref(tag_label, gw, tag_id);
@@ -545,9 +667,9 @@
     assert(gw && hdr && pkt);
 
     lgtd_debug(
-        "SET_TAG_LABELS <-- [%s]:%hu - %s label=%s, tags=%jx",
+        "SET_TAG_LABELS <-- [%s]:%hu - %s label=%.*s, tags=%jx",
         gw->ip_addr, gw->port, lgtd_addrtoa(hdr->target.device_addr),
-        pkt->label, (uintmax_t)pkt->tags
+        LGTD_LIFX_LABEL_SIZE, pkt->label, (uintmax_t)pkt->tags
     );
 
     int tag_id;
@@ -559,3 +681,38 @@
         }
     }
 }
+
+void lgtd_lifx_gateway_handle_tags(struct lgtd_lifx_gateway *gw,
+                                   const struct lgtd_lifx_packet_header *hdr,
+                                   const struct lgtd_lifx_packet_tags *pkt)
+{
+    assert(gw && hdr && pkt);
+
+    lgtd_debug(
+        "SET_TAGS <-- [%s]:%hu - %s tags=%#jx",
+        gw->ip_addr, gw->port, lgtd_addrtoa(hdr->target.device_addr),
+        (uintmax_t)pkt->tags
+    );
+
+    struct lgtd_lifx_bulb *b = lgtd_lifx_gateway_get_or_open_bulb(
+        gw, hdr->target.device_addr
+    );
+    if (!b) {
+        return;
+    }
+
+    int tag_id;
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, pkt->tags) {
+        if (!(gw->tag_ids & LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id))) {
+            lgtd_warnx(
+                "trying to set unknown tag_id %d (%#jx) "
+                "on bulb %s (%.*s), gw [%s]:%hu (site %s)",
+                tag_id, LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id),
+                lgtd_addrtoa(b->addr), LGTD_LIFX_LABEL_SIZE, b->state.label,
+                gw->ip_addr, gw->port, lgtd_addrtoa(gw->site.as_array)
+            );
+        }
+    }
+
+    lgtd_lifx_bulb_set_tags(b, pkt->tags);
+}
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -51,6 +51,7 @@
     }                               site;
     uint64_t                        tag_ids;
     struct lgtd_lifx_tag            *tags[LGTD_LIFX_GATEWAY_MAX_TAGS];
+    uint8_t                         tag_refcounts[LGTD_LIFX_GATEWAY_MAX_TAGS];
     evutil_socket_t                 socket;
     // Those three timers let us measure the latency of the gateway. If we
     // aren't the only client on the network then this won't be accurate since
@@ -84,6 +85,7 @@
 
 void lgtd_lifx_gateway_close(struct lgtd_lifx_gateway *);
 void lgtd_lifx_gateway_close_all(void);
+void lgtd_lifx_gateway_remove_and_close_bulb(struct lgtd_lifx_gateway *, struct lgtd_lifx_bulb *);
 
 void lgtd_lifx_gateway_force_refresh(struct lgtd_lifx_gateway *);
 
@@ -92,7 +94,14 @@
                                       enum lgtd_lifx_packet_type,
                                       const void *,
                                       int);
+// This could be on router but it's LIFX specific so I'd rather keep it here:
+bool lgtd_lifx_gateway_send_to_site(struct lgtd_lifx_gateway *,
+                                    enum lgtd_lifx_packet_type,
+                                    const void *);
 
+void lgtd_lifx_gateway_update_tag_refcounts(struct lgtd_lifx_gateway *, uint64_t, uint64_t);
+
+int lgtd_lifx_gateway_get_tag_id(const struct lgtd_lifx_gateway *, const struct lgtd_lifx_tag *);
 int lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *, int, const char *);
 void lgtd_lifx_gateway_deallocate_tag_id(struct lgtd_lifx_gateway *, int);
 
@@ -108,3 +117,6 @@
 void lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *,
                                          const struct lgtd_lifx_packet_header *,
                                          const struct lgtd_lifx_packet_tag_labels *);
+void lgtd_lifx_gateway_handle_tags(struct lgtd_lifx_gateway *,
+                                   const struct lgtd_lifx_packet_header *,
+                                   const struct lgtd_lifx_packet_tags *);
diff --git a/lifx/tagging.c b/lifx/tagging.c
--- a/lifx/tagging.c
+++ b/lifx/tagging.c
@@ -66,6 +66,32 @@
 }
 
 struct lgtd_lifx_tag *
+lgtd_lifx_tagging_allocate_tag(const char *tag_label)
+{
+    assert(tag_label);
+    assert(strlen(tag_label) < LGTD_LIFX_LABEL_SIZE);
+
+    struct lgtd_lifx_tag *tag = calloc(1, sizeof(*tag));
+    if (!tag) {
+        return NULL;
+    }
+
+    strncpy(tag->label, tag_label, sizeof(tag->label) - 1);
+    LIST_INSERT_HEAD(&lgtd_lifx_tags, tag, link);
+    return tag;
+}
+
+void
+lgtd_lifx_tagging_deallocate_tag(struct lgtd_lifx_tag *tag)
+{
+    assert(tag);
+    assert(LIST_EMPTY(&tag->sites));
+
+    LIST_REMOVE(tag, link);
+    free(tag);
+}
+
+struct lgtd_lifx_tag *
 lgtd_lifx_tagging_incref(const char *tag_label,
                          struct lgtd_lifx_gateway *gw,
                          int tag_id)
@@ -77,12 +103,10 @@
     bool dealloc_tag = false;
     struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(tag_label);
     if (!tag) {
-        tag = calloc(1, sizeof(*tag));
+        tag = lgtd_lifx_tagging_allocate_tag(tag_label);
         if (!tag) {
             return NULL;
         }
-        strncpy(tag->label, tag_label, sizeof(tag->label) - 1);
-        LIST_INSERT_HEAD(&lgtd_lifx_tags, tag, link);
         dealloc_tag = true;
     }
 
@@ -91,8 +115,7 @@
         site = calloc(1, sizeof(*site));
         if (!site) {
             if (dealloc_tag) {
-                LIST_REMOVE(tag, link);
-                free(tag);
+                lgtd_lifx_tagging_deallocate_tag(tag);
             }
             errno = ENOMEM;
             return NULL;
@@ -100,9 +123,10 @@
         if (dealloc_tag) {
             lgtd_info("discovered tag [%s]", tag_label);
         }
-        lgtd_debug(
-            "tag [%s] added to gw [%s]:%hu (site %s)",
-            tag_label, gw->ip_addr, gw->port, lgtd_addrtoa(gw->site.as_array)
+        lgtd_info(
+            "tag [%s] added to gw [%s]:%hu (site %s) with tag_id %d",
+            tag_label, gw->ip_addr, gw->port,
+            lgtd_addrtoa(gw->site.as_array), tag_id
         );
         site->gw = gw;
         site->tag_id = tag_id;
@@ -132,8 +156,7 @@
         free(site);
     }
     if (LIST_EMPTY(&tag->sites)) {
-        LIST_REMOVE(tag, link);
         lgtd_info("forgetting unused tag [%s]", tag->label);
-        free(tag);
+        lgtd_lifx_tagging_deallocate_tag(tag);
     }
 }
diff --git a/lifx/tagging.h b/lifx/tagging.h
--- a/lifx/tagging.h
+++ b/lifx/tagging.h
@@ -39,3 +39,6 @@
 void lgtd_lifx_tagging_decref(struct lgtd_lifx_tag *, struct lgtd_lifx_gateway *);
 
 struct lgtd_lifx_tag *lgtd_lifx_tagging_find_tag(const char *);
+struct lgtd_lifx_tag *lgtd_lifx_tagging_allocate_tag(const char *);
+
+void lgtd_lifx_tagging_deallocate_tag(struct lgtd_lifx_tag *);
diff --git a/lifx/timer.c b/lifx/timer.c
--- a/lifx/timer.c
+++ b/lifx/timer.c
@@ -95,7 +95,7 @@
                 "closing bulb \"%.*s\" that hasn't been updated for %dms",
                 LGTD_LIFX_LABEL_SIZE, bulb->state.label, light_state_lag
             );
-            lgtd_lifx_bulb_close(bulb);
+            lgtd_lifx_gateway_remove_and_close_bulb(bulb->gw, bulb);
             start_discovery = true;
             continue;
         }
diff --git a/lifx/wire_proto.c b/lifx/wire_proto.c
--- a/lifx/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -92,6 +92,7 @@
     .handle = lgtd_lifx_wire_null_packet_handler
 
     static struct lgtd_lifx_packet_infos packet_table[] = {
+        // Gateway packets:
         {
             REQUEST_ONLY,
             NO_PAYLOAD,
@@ -108,6 +109,43 @@
         },
         {
             REQUEST_ONLY,
+            .name = "SET_TAG_LABELS",
+            .type = LGTD_LIFX_SET_TAG_LABELS,
+            .size = sizeof(struct lgtd_lifx_packet_tag_labels),
+            .encode = ENCODER(lgtd_lifx_wire_encode_tag_labels)
+        },
+        {
+            REQUEST_ONLY,
+            .name = "GET_TAG_LABELS",
+            .type = LGTD_LIFX_GET_TAG_LABELS,
+            .size = sizeof(struct lgtd_lifx_packet_tags),
+            .encode = ENCODER(lgtd_lifx_wire_encode_tags)
+        },
+        {
+            RESPONSE_ONLY,
+            .name = "TAG_LABELS",
+            .type = LGTD_LIFX_TAG_LABELS,
+            .size = sizeof(struct lgtd_lifx_packet_tag_labels),
+            .decode = DECODER(lgtd_lifx_wire_decode_tag_labels),
+            .handle = HANDLER(lgtd_lifx_gateway_handle_tag_labels)
+        },
+        // Bulb packets:
+        {
+            REQUEST_ONLY,
+            .name = "SET_LIGHT_COLOR",
+            .type = LGTD_LIFX_SET_LIGHT_COLOR,
+            .size = sizeof(struct lgtd_lifx_packet_light_color),
+            .encode = ENCODER(lgtd_lifx_wire_encode_light_color)
+        },
+        {
+            REQUEST_ONLY,
+            .name = "SET_WAVEFORM",
+            .type = LGTD_LIFX_SET_WAVEFORM,
+            .size = sizeof(struct lgtd_lifx_packet_waveform),
+            .encode = ENCODER(lgtd_lifx_wire_encode_waveform)
+        },
+        {
+            REQUEST_ONLY,
             NO_PAYLOAD,
             .name = "GET_LIGHT_STATUS",
             .type = LGTD_LIFX_GET_LIGHT_STATE
@@ -128,6 +166,7 @@
             .type = LGTD_LIFX_SET_POWER_STATE,
         },
         {
+            RESPONSE_ONLY,
             .name = "POWER_STATE",
             .type = LGTD_LIFX_POWER_STATE,
             .size = sizeof(struct lgtd_lifx_packet_power_state),
@@ -136,32 +175,18 @@
         },
         {
             REQUEST_ONLY,
-            .name = "SET_LIGHT_COLOR",
-            .type = LGTD_LIFX_SET_LIGHT_COLOR,
-            .size = sizeof(struct lgtd_lifx_packet_light_color),
-            .encode = ENCODER(lgtd_lifx_wire_encode_light_color)
-        },
-        {
-            REQUEST_ONLY,
-            .name = "SET_WAVEFORM",
-            .type = LGTD_LIFX_SET_WAVEFORM,
-            .size = sizeof(struct lgtd_lifx_packet_waveform),
-            .encode = ENCODER(lgtd_lifx_wire_encode_waveform)
-        },
-        {
-            REQUEST_ONLY,
-            .name = "GET_TAG_LABELS",
-            .type = LGTD_LIFX_GET_TAG_LABELS,
-            .size = sizeof(struct lgtd_lifx_packet_get_tag_labels),
-            .encode = lgtd_lifx_wire_null_packet_encoder_decoder
+            .name = "SET_TAGS",
+            .type = LGTD_LIFX_SET_TAGS,
+            .size = sizeof(struct lgtd_lifx_packet_tags),
+            .encode = ENCODER(lgtd_lifx_wire_encode_tags)
         },
         {
             RESPONSE_ONLY,
-            .name = "TAG_LABELS",
-            .type = LGTD_LIFX_TAG_LABELS,
-            .size = sizeof(struct lgtd_lifx_packet_tag_labels),
-            .decode = DECODER(lgtd_lifx_wire_decode_tag_labels),
-            .handle = HANDLER(lgtd_lifx_gateway_handle_tag_labels)
+            .name = "TAGS",
+            .type = LGTD_LIFX_TAGS,
+            .size = sizeof(struct lgtd_lifx_packet_tags),
+            .decode = DECODER(lgtd_lifx_wire_decode_tags),
+            .handle = HANDLER(lgtd_lifx_gateway_handle_tags)
         }
     };
 
@@ -356,6 +381,14 @@
 }
 
 void
+lgtd_lifx_wire_encode_tag_labels(struct lgtd_lifx_packet_tag_labels *pkt)
+{
+    assert(pkt);
+
+    pkt->tags = htole64(pkt->tags);
+}
+
+void
 lgtd_lifx_wire_decode_tag_labels(struct lgtd_lifx_packet_tag_labels *pkt)
 {
     assert(pkt);
@@ -363,3 +396,19 @@
     pkt->label[sizeof(pkt->label) - 1] = '\0';
     pkt->tags = le64toh(pkt->tags);
 }
+
+void
+lgtd_lifx_wire_encode_tags(struct lgtd_lifx_packet_tags *pkt)
+{
+    assert(pkt);
+
+    pkt->tags = htole64(pkt->tags);
+}
+
+void
+lgtd_lifx_wire_decode_tags(struct lgtd_lifx_packet_tags *pkt)
+{
+    assert(pkt);
+
+    pkt->tags = le64toh(pkt->tags);
+}
diff --git a/lifx/wire_proto.h b/lifx/wire_proto.h
--- a/lifx/wire_proto.h
+++ b/lifx/wire_proto.h
@@ -238,7 +238,7 @@
 };
 
 enum { LGTD_LIFX_ALL_TAGS = ~0 };
-struct lgtd_lifx_packet_get_tag_labels {
+struct lgtd_lifx_packet_tags {
     uint64le_t  tags;
 };
 
@@ -350,4 +350,7 @@
 void lgtd_lifx_wire_encode_light_color(struct lgtd_lifx_packet_light_color *);
 void lgtd_lifx_wire_encode_waveform(struct lgtd_lifx_packet_waveform *);
 
+void lgtd_lifx_wire_encode_tags(struct lgtd_lifx_packet_tags *);
+void lgtd_lifx_wire_decode_tags(struct lgtd_lifx_packet_tags *);
+void lgtd_lifx_wire_encode_tag_labels(struct lgtd_lifx_packet_tag_labels *);
 void lgtd_lifx_wire_decode_tag_labels(struct lgtd_lifx_packet_tag_labels *);
diff --git a/tests/core/jsonrpc/test_jsonrpc_build_target_list.c b/tests/core/jsonrpc/test_jsonrpc_build_target_list.c
--- a/tests/core/jsonrpc/test_jsonrpc_build_target_list.c
+++ b/tests/core/jsonrpc/test_jsonrpc_build_target_list.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 static void
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 
 #define LGTD_TESTING_POWER_OFF
 #include "test_jsonrpc_utils.h"
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off_missing_target.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off_missing_target.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off_missing_target.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off_missing_target.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 
 #define LGTD_TESTING_POWER_OFF
 #include "test_jsonrpc_utils.h"
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 
 #define LGTD_TESTING_POWER_ON
 #include "test_jsonrpc_utils.h"
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on_missing_target.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on_missing_target.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on_missing_target.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on_missing_target.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 
 #define LGTD_TESTING_POWER_ON
 #include "test_jsonrpc_utils.h"
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 
 #define LGTD_TESTING_SET_LIGHT_FROM_HSBK
 #include "test_jsonrpc_utils.h"
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_from_array.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_from_array.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_from_array.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_from_array.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 
 #define LGTD_TESTING_SET_LIGHT_FROM_HSBK
 #include "test_jsonrpc_utils.h"
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_invalid_params.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_invalid_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_invalid_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_invalid_params.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 
 #define LGTD_TESTING_SET_LIGHT_FROM_HSBK
 #include "test_jsonrpc_utils.h"
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 
 #define LGTD_TESTING_SET_WAVEFORM
 #include "test_jsonrpc_utils.h"
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform_invalid_params.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform_invalid_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform_invalid_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform_invalid_params.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 
 #define LGTD_TESTING_SET_WAVEFORM
 #include "test_jsonrpc_utils.h"
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag.c
@@ -0,0 +1,65 @@
+#include "jsonrpc.c"
+
+#include "mock_client_buf.h"
+#include "mock_gateway.h"
+
+#define MOCKED_LGTD_TAG
+#include "test_jsonrpc_utils.h"
+
+static bool tag_called = false;
+
+void
+lgtd_proto_tag(struct lgtd_client *client,
+               const struct lgtd_proto_target_list *targets,
+               const char *tag)
+{
+    if (!client) {
+        errx(1, "missing client!");
+    }
+
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+
+    if (strcmp(tag, "suspensions")) {
+        errx(1, "Invalid tag [%s] (expected=[suspensions])", tag);
+    }
+
+    tag_called = true;
+}
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"tag\","
+        "\"params\": {\"target\": \"*\", \"tag\": \"suspensions\"},"
+        "\"id\": \"42\""
+    "}");
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    bool ok;
+    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
+    struct lgtd_client client = {
+        .io = NULL, .current_request = &req, .json = json
+    };
+    ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
+    if (!ok) {
+        errx(1, "can't parse request");
+    }
+
+    lgtd_jsonrpc_check_and_call_proto_tag_or_untag(&client, lgtd_proto_tag);
+
+    if (!tag_called) {
+        errx(1, "lgtd_proto_tag wasn't called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag_missing_params.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag_missing_params.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_tag_missing_params.c
@@ -0,0 +1,53 @@
+#include "jsonrpc.c"
+
+#include "mock_client_buf.h"
+#include "mock_gateway.h"
+
+#define MOCKED_LGTD_TAG
+#include "test_jsonrpc_utils.h"
+
+static bool tag_called = false;
+
+void
+lgtd_proto_tag(struct lgtd_client *client,
+               const struct lgtd_proto_target_list *targets,
+               const char *tag)
+{
+    (void)client;
+    (void)targets;
+    (void)tag;
+    tag_called = true;
+}
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"tag\","
+        "\"params\": {\"tag\": \"suspensions\"},"
+        "\"id\": \"42\""
+    "}");
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    bool ok;
+    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
+    struct lgtd_client client = {
+        .io = NULL, .current_request = &req, .json = json
+    };
+    ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
+    if (!ok) {
+        errx(1, "can't parse request");
+    }
+
+    lgtd_jsonrpc_check_and_call_proto_tag_or_untag(&client, lgtd_proto_tag);
+
+    if (tag_called) {
+        errx(1, "lgtd_proto_tag was called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag.c
@@ -0,0 +1,65 @@
+#include "jsonrpc.c"
+
+#include "mock_client_buf.h"
+#include "mock_gateway.h"
+
+#define MOCKED_LGTD_UNTAG
+#include "test_jsonrpc_utils.h"
+
+static bool untag_called = false;
+
+void
+lgtd_proto_untag(struct lgtd_client *client,
+                 const struct lgtd_proto_target_list *targets,
+                 const char *tag)
+{
+    if (!client) {
+        errx(1, "missing client!");
+    }
+
+    if (strcmp(SLIST_FIRST(targets)->target, "#suspensions")) {
+        errx(
+            1, "Invalid target [%s] (expected=[#suspensions])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+
+    if (strcmp(tag, "suspensions")) {
+        errx(1, "Invalid tag [%s] (expected=[suspensions])", tag);
+    }
+
+    untag_called = true;
+}
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"tag\","
+        "\"params\": [[\"#suspensions\"], \"suspensions\"],"
+        "\"id\": \"42\""
+    "}");
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    bool ok;
+    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
+    struct lgtd_client client = {
+        .io = NULL, .current_request = &req, .json = json
+    };
+    ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
+    if (!ok) {
+        errx(1, "can't parse request");
+    }
+
+    lgtd_jsonrpc_check_and_call_proto_tag_or_untag(&client, lgtd_proto_untag);
+
+    if (!untag_called) {
+        errx(1, "lgtd_proto_tag wasn't called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag_invalid_params.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag_invalid_params.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_untag_invalid_params.c
@@ -0,0 +1,53 @@
+#include "jsonrpc.c"
+
+#include "mock_client_buf.h"
+#include "mock_gateway.h"
+
+#define MOCKED_LGTD_UNTAG
+#include "test_jsonrpc_utils.h"
+
+static bool untag_called = false;
+
+void
+lgtd_proto_untag(struct lgtd_client *client,
+                 const struct lgtd_proto_target_list *targets,
+                 const char *tag)
+{
+    (void)client;
+    (void)targets;
+    (void)tag;
+    untag_called = true;
+}
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("{"
+        "\"jsonrpc\": \"2.0\","
+        "\"method\": \"tag\","
+        "\"params\": [[\"#suspensions\"], [\"suspensions\"]],"
+        "\"id\": \"42\""
+    "}");
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    bool ok;
+    struct lgtd_jsonrpc_request req = TEST_REQUEST_INITIALIZER;
+    struct lgtd_client client = {
+        .io = NULL, .current_request = &req, .json = json
+    };
+    ok = lgtd_jsonrpc_check_and_extract_request(&req, tokens, parsed, json);
+    if (!ok) {
+        errx(1, "can't parse request");
+    }
+
+    lgtd_jsonrpc_check_and_call_proto_tag_or_untag(&client, lgtd_proto_untag);
+
+    if (untag_called) {
+        errx(1, "lgtd_proto_tag was called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_extract_request_no_params.c b/tests/core/jsonrpc/test_jsonrpc_extract_request_no_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_extract_request_no_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_extract_request_no_params.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 int
diff --git a/tests/core/jsonrpc/test_jsonrpc_extract_request_notification_no_params.c b/tests/core/jsonrpc/test_jsonrpc_extract_request_notification_no_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_extract_request_notification_no_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_extract_request_notification_no_params.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 int
diff --git a/tests/core/jsonrpc/test_jsonrpc_extract_request_params_array.c b/tests/core/jsonrpc/test_jsonrpc_extract_request_params_array.c
--- a/tests/core/jsonrpc/test_jsonrpc_extract_request_params_array.c
+++ b/tests/core/jsonrpc/test_jsonrpc_extract_request_params_array.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 int
diff --git a/tests/core/jsonrpc/test_jsonrpc_extract_request_params_obj.c b/tests/core/jsonrpc/test_jsonrpc_extract_request_params_obj.c
--- a/tests/core/jsonrpc/test_jsonrpc_extract_request_params_obj.c
+++ b/tests/core/jsonrpc/test_jsonrpc_extract_request_params_obj.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 int
diff --git a/tests/core/jsonrpc/test_jsonrpc_extract_request_valid_notification.c b/tests/core/jsonrpc/test_jsonrpc_extract_request_valid_notification.c
--- a/tests/core/jsonrpc/test_jsonrpc_extract_request_valid_notification.c
+++ b/tests/core/jsonrpc/test_jsonrpc_extract_request_valid_notification.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 int
diff --git a/tests/core/jsonrpc/test_jsonrpc_send_error.c b/tests/core/jsonrpc/test_jsonrpc_send_error.c
--- a/tests/core/jsonrpc/test_jsonrpc_send_error.c
+++ b/tests/core/jsonrpc/test_jsonrpc_send_error.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 int
diff --git a/tests/core/jsonrpc/test_jsonrpc_send_response.c b/tests/core/jsonrpc/test_jsonrpc_send_response.c
--- a/tests/core/jsonrpc/test_jsonrpc_send_response.c
+++ b/tests/core/jsonrpc/test_jsonrpc_send_response.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 int
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_invalid.c b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_invalid.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_invalid.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_invalid.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 static void
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_valid.c b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_valid.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_valid.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_1_valid.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 static void
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_invalid.c b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_invalid.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_invalid.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_invalid.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 static void
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_valid.c b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_valid.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_valid.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_float_between_0_and_360_valid.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 static void
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_integer.c b/tests/core/jsonrpc/test_jsonrpc_type_integer.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_integer.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_integer.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 int
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_integer_invalid_characters.c b/tests/core/jsonrpc/test_jsonrpc_type_integer_invalid_characters.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_integer_invalid_characters.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_integer_invalid_characters.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 int
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_integer_too_big.c b/tests/core/jsonrpc/test_jsonrpc_type_integer_too_big.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_integer_too_big.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_integer_too_big.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 int
diff --git a/tests/core/jsonrpc/test_jsonrpc_type_integer_too_small.c b/tests/core/jsonrpc/test_jsonrpc_type_integer_too_small.c
--- a/tests/core/jsonrpc/test_jsonrpc_type_integer_too_small.c
+++ b/tests/core/jsonrpc/test_jsonrpc_type_integer_too_small.c
@@ -1,6 +1,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 int
diff --git a/tests/core/jsonrpc/test_jsonrpc_uint16_range_to_float_string.c b/tests/core/jsonrpc/test_jsonrpc_uint16_range_to_float_string.c
--- a/tests/core/jsonrpc/test_jsonrpc_uint16_range_to_float_string.c
+++ b/tests/core/jsonrpc/test_jsonrpc_uint16_range_to_float_string.c
@@ -3,6 +3,7 @@
 #include "jsonrpc.c"
 
 #include "mock_client_buf.h"
+#include "mock_gateway.h"
 #include "test_jsonrpc_utils.h"
 
 int
diff --git a/tests/core/jsonrpc/test_jsonrpc_utils.h b/tests/core/jsonrpc/test_jsonrpc_utils.h
--- a/tests/core/jsonrpc/test_jsonrpc_utils.h
+++ b/tests/core/jsonrpc/test_jsonrpc_utils.h
@@ -95,3 +95,27 @@
     (void)targets;
 }
 #endif
+
+#ifndef MOCKED_LGTD_TAG
+void
+lgtd_proto_tag(struct lgtd_client *client,
+               const struct lgtd_proto_target_list *targets,
+               const char *tag_label)
+{
+    (void)client;
+    (void)targets;
+    (void)tag_label;
+}
+#endif
+
+#ifndef MOCKED_LGTD_UNTAG
+void
+lgtd_proto_untag(struct lgtd_client *client,
+                 const struct lgtd_proto_target_list *targets,
+                 const char *tag_label)
+{
+    (void)client;
+    (void)targets;
+    (void)tag_label;
+}
+#endif
diff --git a/tests/core/mock_event2.h b/tests/core/mock_event2.h
new file mode 100644
--- /dev/null
+++ b/tests/core/mock_event2.h
@@ -0,0 +1,109 @@
+#pragma once
+
+#ifndef MOCKED_EVBUFFER_DRAIN
+int
+evbuffer_drain(struct evbuffer *buf, size_t len)
+{
+    (void)buf;
+    (void)len;
+    return 0;
+}
+#endif
+
+#ifndef MOCKED_EVBUFFER_NEW
+struct evbuffer *
+evbuffer_new(void)
+{
+    return NULL;
+}
+#endif
+
+#ifndef MOCKED_EVENT_FREE
+void
+evbuffer_free(struct evbuffer *buf)
+{
+    (void)buf;
+}
+#endif
+
+#ifndef MOCKED_EVBUFFER_GET_LENGTH
+size_t
+evbuffer_get_length(const struct evbuffer *buf)
+{
+    (void)buf;
+    return 0;
+}
+#endif
+
+#ifndef MOCKED_EVBUFFER_PULLUP
+unsigned char *
+evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
+{
+    (void)buf;
+    (void)size;
+    return NULL;
+}
+#endif
+
+#ifndef MOCKED_EVBUFFER_READ
+int
+evbuffer_read(struct evbuffer *buffer, evutil_socket_t fd, int howmuch)
+{
+    (void)buffer;
+    (void)fd;
+    return howmuch;
+}
+#endif
+
+#ifndef MOCKED_EVENT_ADD
+int
+event_add(struct event *ev, const struct timeval *timeout)
+{
+    (void)ev;
+    (void)timeout;
+    return 0;
+}
+#endif
+
+#ifndef MOCKED_EVENT_DEL
+int
+event_del(struct event *ev)
+{
+    (void)ev;
+    return 0;
+}
+#endif
+
+#ifndef MOCKED_EVENT_FREE
+void
+event_free(struct event *ev)
+{
+    (void)ev;
+}
+#endif
+
+#ifndef MOCKED_EVENT_NEW
+struct event *
+event_new(struct event_base *base,
+          evutil_socket_t fd,
+          short events,
+          event_callback_fn cb,
+          void *ctx)
+{
+    (void)base;
+    (void)fd;
+    (void)events;
+    (void)cb;
+    (void)ctx;
+    return NULL;
+}
+#endif
+
+#ifndef MOCKED_EVUTIL_MAKE_SOCKET_NONBLOCKING
+int
+evutil_make_socket_nonblocking(evutil_socket_t fd)
+{
+    (void)fd;
+    return 0;
+}
+#endif
diff --git a/tests/core/proto/CMakeLists.txt b/tests/core/proto/CMakeLists.txt
--- a/tests/core/proto/CMakeLists.txt
+++ b/tests/core/proto/CMakeLists.txt
@@ -9,6 +9,7 @@
     ${LIGHTSD_SOURCE_DIR}/core/jsonrpc.c
     ${LIGHTSD_SOURCE_DIR}/core/stats.c
     ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/tagging.c
     ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
     ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
diff --git a/tests/core/proto/test_proto_get_light_state_empty_device_list.c b/tests/core/proto/test_proto_get_light_state_empty_device_list.c
--- a/tests/core/proto/test_proto_get_light_state_empty_device_list.c
+++ b/tests/core/proto/test_proto_get_light_state_empty_device_list.c
@@ -2,6 +2,7 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_gateway.h"
 #include "tests_utils.h"
 
 #define MOCKED_ROUTER_TARGETS_TO_DEVICES
diff --git a/tests/core/proto/test_proto_get_light_state_null_device_list.c b/tests/core/proto/test_proto_get_light_state_null_device_list.c
--- a/tests/core/proto/test_proto_get_light_state_null_device_list.c
+++ b/tests/core/proto/test_proto_get_light_state_null_device_list.c
@@ -2,6 +2,7 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_gateway.h"
 #include "tests_utils.h"
 
 #define MOCKED_ROUTER_TARGETS_TO_DEVICES
diff --git a/tests/core/proto/test_proto_power_off.c b/tests/core/proto/test_proto_power_off.c
--- a/tests/core/proto/test_proto_power_off.c
+++ b/tests/core/proto/test_proto_power_off.c
@@ -2,6 +2,7 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_gateway.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_power_off_routing_error.c b/tests/core/proto/test_proto_power_off_routing_error.c
--- a/tests/core/proto/test_proto_power_off_routing_error.c
+++ b/tests/core/proto/test_proto_power_off_routing_error.c
@@ -2,6 +2,7 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_gateway.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_power_on.c b/tests/core/proto/test_proto_power_on.c
--- a/tests/core/proto/test_proto_power_on.c
+++ b/tests/core/proto/test_proto_power_on.c
@@ -2,6 +2,7 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_gateway.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_power_on_routing_error.c b/tests/core/proto/test_proto_power_on_routing_error.c
--- a/tests/core/proto/test_proto_power_on_routing_error.c
+++ b/tests/core/proto/test_proto_power_on_routing_error.c
@@ -2,6 +2,7 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_gateway.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_set_light_from_hsbk.c b/tests/core/proto/test_proto_set_light_from_hsbk.c
--- a/tests/core/proto/test_proto_set_light_from_hsbk.c
+++ b/tests/core/proto/test_proto_set_light_from_hsbk.c
@@ -4,6 +4,7 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_gateway.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_set_light_from_hsbk_on_routing_error.c b/tests/core/proto/test_proto_set_light_from_hsbk_on_routing_error.c
--- a/tests/core/proto/test_proto_set_light_from_hsbk_on_routing_error.c
+++ b/tests/core/proto/test_proto_set_light_from_hsbk_on_routing_error.c
@@ -4,6 +4,7 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_gateway.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_set_waveform.c b/tests/core/proto/test_proto_set_waveform.c
--- a/tests/core/proto/test_proto_set_waveform.c
+++ b/tests/core/proto/test_proto_set_waveform.c
@@ -4,6 +4,7 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_gateway.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_set_waveform_on_routing_error.c b/tests/core/proto/test_proto_set_waveform_on_routing_error.c
--- a/tests/core/proto/test_proto_set_waveform_on_routing_error.c
+++ b/tests/core/proto/test_proto_set_waveform_on_routing_error.c
@@ -4,6 +4,7 @@
 
 #include "mock_client_buf.h"
 #include "mock_daemon.h"
+#include "mock_gateway.h"
 #include "tests_utils.h"
 
 #define MOCKED_CLIENT_SEND_RESPONSE
diff --git a/tests/core/proto/test_proto_tag_create.c b/tests/core/proto/test_proto_tag_create.c
new file mode 100644
--- /dev/null
+++ b/tests/core/proto/test_proto_tag_create.c
@@ -0,0 +1,253 @@
+#include "proto.c"
+
+#include "mock_client_buf.h"
+#include "mock_daemon.h"
+#define MOCKED_LIFX_GATEWAY_SEND_TO_SITE
+#define MOCKED_LIFX_GATEWAY_ALLOCATE_TAG_ID
+#include "mock_gateway.h"
+#include "tests_utils.h"
+
+#define MOCKED_ROUTER_TARGETS_TO_DEVICES
+#define MOCKED_ROUTER_SEND_TO_DEVICE
+#define MOCKED_ROUTER_DEVICE_LIST_FREE
+#include "tests_proto_utils.h"
+
+#define FAKE_TARGET_LIST (void *)0x2a
+
+static struct lgtd_router_device_list devices = 
+    SLIST_HEAD_INITIALIZER(&devices);
+static struct lgtd_router_device_list device_1_only =
+    SLIST_HEAD_INITIALIZER(&device_1_only);
+
+static bool send_to_device_called = false;
+
+void
+lgtd_router_send_to_device(struct lgtd_lifx_bulb *bulb,
+                           enum lgtd_lifx_packet_type pkt_type,
+                           void *pkt)
+{
+    if (!bulb) {
+        errx(1, "lgtd_router_send_to_device must be called with a bulb");
+    }
+
+    uint8_t expected_addr[LGTD_LIFX_ADDR_LENGTH] = { 1, 2, 3, 4, 5 };
+    if (memcmp(bulb->addr, expected_addr, LGTD_LIFX_ADDR_LENGTH)) {
+        errx(
+            1, "got bulb with addr %s (expected %s)",
+            lgtd_addrtoa(bulb->addr), lgtd_addrtoa(expected_addr)
+        );
+    }
+
+    if (pkt_type != LGTD_LIFX_SET_TAGS) {
+        errx(
+            1, "got packet type %d (expected %d)", pkt_type, LGTD_LIFX_SET_TAGS
+        );
+    }
+
+    if (!pkt) {
+        errx(1, "missing SET_TAGS payload");
+    }
+
+    const struct lgtd_lifx_packet_tags *pkt_tags = pkt;
+    uint64_t tags = le64toh(pkt_tags->tags);
+    if (tags != 0x1) {
+        errx(
+            1, "invalid SET_TAGS payload=%#jx (expected %#x)",
+            (uintmax_t)tags, 0x1
+        );
+    }
+
+    send_to_device_called = true;
+}
+
+static bool gateway_send_to_site_called = false;
+
+bool
+lgtd_lifx_gateway_send_to_site(struct lgtd_lifx_gateway *gw,
+                               enum lgtd_lifx_packet_type pkt_type,
+                               const void *pkt)
+{
+    if (!gw) {
+        errx(1, "missing gateway");
+    }
+
+    if (pkt_type != LGTD_LIFX_SET_TAG_LABELS) {
+        errx(
+            1, "got packet type %#x (expected %#x)",
+            pkt_type, LGTD_LIFX_SET_TAG_LABELS
+        );
+    }
+
+    const struct lgtd_lifx_packet_tag_labels *pkt_tag_labels = pkt;
+    uint64_t tags = le64toh(pkt_tag_labels->tags);
+    if (tags != 0x1) {
+        errx(1, "got tags %#jx (expected %#x)", (uintmax_t)tags, 0x1);
+    }
+
+    if (strcmp(pkt_tag_labels->label, "dub")) {
+        errx(1, "got label %s (expected dub)", pkt_tag_labels->label);
+    }
+
+    gateway_send_to_site_called = true;
+
+    return true;
+}
+
+static bool gateway_allocate_tag_id_called = false;
+
+int
+lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *gw,
+                                  int tag_id,
+                                  const char *tag_label)
+{
+    if (gateway_allocate_tag_id_called) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id "
+            "should have been called once only"
+        );
+    }
+
+    if (tag_id != -1) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id "
+            "tag_id %d (expected -1)", tag_id
+        );
+    }
+
+    if (!gw) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id "
+            "must be called with gateway"
+        );
+    }
+
+    if (!tag_label) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id "
+            "must be called with a tag_label"
+        );
+    }
+
+    tag_id = 0;
+
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(tag_label);
+    if (!tag) {
+        errx(1, "tag %s wasn't found", tag_label);
+    }
+    lgtd_tests_add_tag_to_gw(tag, gw, tag_id);
+
+    gateway_allocate_tag_id_called = true;
+
+    return tag_id;
+}
+
+static bool device_list_free_called = false;
+
+void
+lgtd_router_device_list_free(struct lgtd_router_device_list *devices)
+{
+    if (!devices) {
+        lgtd_errx(1, "the device list must be passed");
+    }
+
+    device_list_free_called = true;
+}
+
+struct lgtd_router_device_list *
+lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *targets)
+{
+    if (targets != FAKE_TARGET_LIST) {
+        lgtd_errx(1, "unexpected targets list");
+    }
+
+    return &device_1_only;
+}
+
+static void
+setup_devices(void)
+{
+    static struct lgtd_lifx_gateway gw_bulb_1 = {
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_1.bulbs)
+    };
+    static struct lgtd_lifx_bulb bulb_1 = {
+        .addr = { 1, 2, 3, 4, 5 },
+        .state = {
+            .hue = 0xaaaa,
+            .saturation = 0xffff,
+            .brightness = 0xbbbb,
+            .kelvin = 3600,
+            .label = "wave",
+            .power = LGTD_LIFX_POWER_ON,
+            .tags = 0
+        },
+        .gw = &gw_bulb_1
+    };
+    static struct lgtd_router_device device_1 = { .device = &bulb_1 };
+    SLIST_INSERT_HEAD(&devices, &device_1, link);
+    SLIST_INSERT_HEAD(&device_1_only, &device_1, link);
+
+    struct lgtd_lifx_tag *gw_2_tag_1 = lgtd_tests_insert_mock_tag("vapor");
+    struct lgtd_lifx_tag *gw_2_tag_2 = lgtd_tests_insert_mock_tag("d^-^b");
+    struct lgtd_lifx_tag *gw_2_tag_3 = lgtd_tests_insert_mock_tag("wave~");
+    static struct lgtd_lifx_gateway gw_bulb_2 = {
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_2.bulbs),
+        .tag_ids = 0x7
+    };
+    lgtd_tests_add_tag_to_gw(gw_2_tag_1, &gw_bulb_2, 0);
+    lgtd_tests_add_tag_to_gw(gw_2_tag_2, &gw_bulb_2, 1);
+    lgtd_tests_add_tag_to_gw(gw_2_tag_3, &gw_bulb_2, 2);
+    static struct lgtd_lifx_bulb bulb_2 = {
+        .addr = { 5, 4, 3, 2, 1 },
+        .state = {
+            .hue = 0x0000,
+            .saturation = 0x0000,
+            .brightness = 0xffff,
+            .kelvin = 4000,
+            .label = "",
+            .power = LGTD_LIFX_POWER_OFF,
+            .tags = 0x3
+        },
+        .gw = &gw_bulb_2
+    };
+    static struct lgtd_router_device device_2 = { .device = &bulb_2 };
+    SLIST_INSERT_HEAD(&devices, &device_2, link);
+}
+
+int
+main(void)
+{
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+
+    setup_devices();
+
+    lgtd_proto_tag(&client, FAKE_TARGET_LIST, "dub");
+
+    const char expected[] = "true";
+    if (client_write_buf_idx != sizeof(expected) - 1) {
+        lgtd_errx(
+            1,
+            "%d bytes written, expected %lu "
+            "(got %.*s instead of %s)",
+            client_write_buf_idx, sizeof(expected) - 1UL,
+            client_write_buf_idx, client_write_buf, expected
+        );
+    }
+    if (memcmp(expected, client_write_buf, sizeof(expected) - 1)) {
+        lgtd_errx(
+            1, "got %.*s instead of %s",
+            client_write_buf_idx, client_write_buf, expected
+        );
+    }
+
+    if (!gateway_send_to_site_called) {
+        lgtd_errx(1, "SET_TAG_LABELS wasn't sent");
+    }
+    if (!device_list_free_called) {
+        lgtd_errx(1, "the list of devices hasn't been freed");
+    }
+    if (!send_to_device_called) {
+        lgtd_errx(1, "SET_TAGS wasn't send to any device");
+    }
+
+    return 0;
+}
diff --git a/tests/core/proto/test_proto_tag_create_lifx_gw_tag_ids_full.c b/tests/core/proto/test_proto_tag_create_lifx_gw_tag_ids_full.c
new file mode 100644
--- /dev/null
+++ b/tests/core/proto/test_proto_tag_create_lifx_gw_tag_ids_full.c
@@ -0,0 +1,209 @@
+#include "proto.c"
+
+#include "mock_client_buf.h"
+#include "mock_daemon.h"
+#define MOCKED_LIFX_GATEWAY_SEND_TO_SITE
+#define MOCKED_LIFX_GATEWAY_ALLOCATE_TAG_ID
+#include "mock_gateway.h"
+#include "tests_utils.h"
+
+#define MOCKED_CLIENT_SEND_ERROR
+#define MOCKED_ROUTER_TARGETS_TO_DEVICES
+#define MOCKED_ROUTER_SEND_TO_DEVICE
+#define MOCKED_ROUTER_DEVICE_LIST_FREE
+#include "tests_proto_utils.h"
+
+#define FAKE_TARGET_LIST (void *)0x2a
+
+static struct lgtd_router_device_list devices =
+    SLIST_HEAD_INITIALIZER(&devices);
+static struct lgtd_router_device_list device_1_only =
+    SLIST_HEAD_INITIALIZER(&device_1_only);
+
+static bool client_send_error_called = false;
+
+void
+lgtd_client_send_error(struct lgtd_client *client,
+                       enum lgtd_client_error_code error,
+                       const char *msg)
+{
+    if (!client) {
+        errx(1, "client_send_error called without a client");
+    }
+
+    if (!error) {
+        errx(1, "client_send_error called without an error code");
+    }
+
+    if (!msg) {
+        errx(1, "client_send_error called without an error message");
+    }
+
+    client_send_error_called = true;
+}
+
+static bool send_to_device_called = false;
+
+void
+lgtd_router_send_to_device(struct lgtd_lifx_bulb *bulb,
+                           enum lgtd_lifx_packet_type pkt_type,
+                           void *pkt)
+{
+    (void)bulb;
+    (void)pkt_type;
+    (void)pkt;
+
+    send_to_device_called = true;
+}
+
+static bool gateway_send_to_site_called = false;
+
+bool
+lgtd_lifx_gateway_send_to_site(struct lgtd_lifx_gateway *gw,
+                               enum lgtd_lifx_packet_type pkt_type,
+                               const void *pkt)
+{
+    (void)gw;
+    (void)pkt_type;
+    (void)pkt;
+
+    gateway_send_to_site_called = true;
+
+    return true;
+}
+
+static bool gateway_allocate_tag_id_called = false;
+
+int
+lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *gw,
+                                  int tag_id,
+                                  const char *tag_label)
+{
+    if (gateway_allocate_tag_id_called) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id "
+            "should have been called once only"
+        );
+    }
+
+    if (tag_id != -1) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id "
+            "tag_id %d (expected -1)", tag_id
+        );
+    }
+
+    if (!gw) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id "
+            "must be called with gateway"
+        );
+    }
+
+    if (!tag_label) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id "
+            "must be called with a tag_label"
+        );
+    }
+
+    return -1;  // no more tag id available
+}
+
+static bool device_list_free_called = false;
+
+void
+lgtd_router_device_list_free(struct lgtd_router_device_list *devices)
+{
+    if (!devices) {
+        lgtd_errx(1, "the device list must be passed");
+    }
+
+    device_list_free_called = true;
+}
+
+struct lgtd_router_device_list *
+lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *targets)
+{
+    if (targets != FAKE_TARGET_LIST) {
+        lgtd_errx(1, "unexpected targets list");
+    }
+
+    return &device_1_only;
+}
+
+static void
+setup_devices(void)
+{
+    static struct lgtd_lifx_gateway gw_bulb_1 = {
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_1.bulbs)
+    };
+    static struct lgtd_lifx_bulb bulb_1 = {
+        .addr = { 1, 2, 3, 4, 5 },
+        .state = {
+            .hue = 0xaaaa,
+            .saturation = 0xffff,
+            .brightness = 0xbbbb,
+            .kelvin = 3600,
+            .label = "wave",
+            .power = LGTD_LIFX_POWER_ON,
+            .tags = 0
+        },
+        .gw = &gw_bulb_1
+    };
+    static struct lgtd_router_device device_1 = { .device = &bulb_1 };
+    SLIST_INSERT_HEAD(&devices, &device_1, link);
+    SLIST_INSERT_HEAD(&device_1_only, &device_1, link);
+
+    struct lgtd_lifx_tag *gw_2_tag_1 = lgtd_tests_insert_mock_tag("vapor");
+    struct lgtd_lifx_tag *gw_2_tag_2 = lgtd_tests_insert_mock_tag("d^-^b");
+    struct lgtd_lifx_tag *gw_2_tag_3 = lgtd_tests_insert_mock_tag("wave~");
+    static struct lgtd_lifx_gateway gw_bulb_2 = {
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_2.bulbs),
+        .tag_ids = 0x7
+    };
+    lgtd_tests_add_tag_to_gw(gw_2_tag_1, &gw_bulb_2, 0);
+    lgtd_tests_add_tag_to_gw(gw_2_tag_2, &gw_bulb_2, 1);
+    lgtd_tests_add_tag_to_gw(gw_2_tag_3, &gw_bulb_2, 2);
+    static struct lgtd_lifx_bulb bulb_2 = {
+        .addr = { 5, 4, 3, 2, 1 },
+        .state = {
+            .hue = 0x0000,
+            .saturation = 0x0000,
+            .brightness = 0xffff,
+            .kelvin = 4000,
+            .label = "",
+            .power = LGTD_LIFX_POWER_OFF,
+            .tags = 0x3
+        },
+        .gw = &gw_bulb_2
+    };
+    static struct lgtd_router_device device_2 = { .device = &bulb_2 };
+    SLIST_INSERT_HEAD(&devices, &device_2, link);
+}
+
+int
+main(void)
+{
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+
+    setup_devices();
+
+    lgtd_proto_tag(&client, FAKE_TARGET_LIST, "dub");
+
+
+    if (gateway_send_to_site_called) {
+        lgtd_errx(1, "SET_TAG_LABELS shouldn't have been sent");
+    }
+    if (!device_list_free_called) {
+        lgtd_errx(1, "the list of devices hasn't been freed");
+    }
+    if (send_to_device_called) {
+        lgtd_errx(1, "SET_TAGS shouldn't have been to any device");
+    }
+    if (!client_send_error_called) {
+        lgtd_errx(1, "client_send_error should have been called");
+    }
+
+    return 0;
+}
diff --git a/tests/core/proto/test_proto_tag_update.c b/tests/core/proto/test_proto_tag_update.c
new file mode 100644
--- /dev/null
+++ b/tests/core/proto/test_proto_tag_update.c
@@ -0,0 +1,283 @@
+#include "proto.c"
+
+#include "mock_client_buf.h"
+#include "mock_daemon.h"
+#define MOCKED_LIFX_GATEWAY_SEND_TO_SITE
+#define MOCKED_LIFX_GATEWAY_ALLOCATE_TAG_ID
+#include "mock_gateway.h"
+#include "tests_utils.h"
+
+#define MOCKED_ROUTER_TARGETS_TO_DEVICES
+#define MOCKED_ROUTER_SEND_TO_DEVICE
+#define MOCKED_ROUTER_DEVICE_LIST_FREE
+#include "tests_proto_utils.h"
+
+#define FAKE_TARGET_LIST (void *)0x2a
+
+static struct lgtd_router_device_list devices =
+    SLIST_HEAD_INITIALIZER(&devices);
+
+static bool send_to_device_called = false;
+
+void
+lgtd_router_send_to_device(struct lgtd_lifx_bulb *bulb,
+                           enum lgtd_lifx_packet_type pkt_type,
+                           void *pkt)
+{
+    if (send_to_device_called) {
+        errx(1, "lgtd_router_send_to_device should have been called once only");
+    }
+
+    if (!bulb) {
+        errx(1, "lgtd_router_send_to_device must be called with a bulb");
+    }
+
+    uint8_t expected_addr[LGTD_LIFX_ADDR_LENGTH] = { 5, 4, 3, 2, 1 };
+    if (memcmp(bulb->addr, expected_addr, LGTD_LIFX_ADDR_LENGTH)) {
+        errx(
+            1, "got bulb with addr %s (expected %s)",
+            lgtd_addrtoa(bulb->addr), lgtd_addrtoa(expected_addr)
+        );
+    }
+
+    if (pkt_type != LGTD_LIFX_SET_TAGS) {
+        errx(
+            1, "got packet type %d (expected %d)", pkt_type, LGTD_LIFX_SET_TAGS
+        );
+    }
+
+    if (!pkt) {
+        errx(1, "missing SET_TAGS payload");
+    }
+
+    const struct lgtd_lifx_packet_tags *pkt_tags = pkt;
+    uint64_t tags = le64toh(pkt_tags->tags);
+
+    if (tags != 0x7) {
+        errx(
+            1, "invalid SET_TAGS payload=%#jx (expected %#x)",
+            (uintmax_t)tags, 0x7
+        );
+    }
+
+    send_to_device_called = true;
+}
+
+static bool gateway_send_to_site_called_for_gw_1 = false;
+static bool gateway_send_to_site_called_for_gw_2 = false;
+
+bool
+lgtd_lifx_gateway_send_to_site(struct lgtd_lifx_gateway *gw,
+                               enum lgtd_lifx_packet_type pkt_type,
+                               const void *pkt)
+{
+    if (!gw) {
+        errx(1, "missing gateway");
+    }
+
+    if (pkt_type != LGTD_LIFX_SET_TAG_LABELS) {
+        errx(
+            1, "got packet type %#x (expected %#x)",
+            pkt_type, LGTD_LIFX_SET_TAG_LABELS
+        );
+    }
+
+    const struct lgtd_lifx_packet_tag_labels *pkt_tag_labels = pkt;
+    uint64_t tags = le64toh(pkt_tag_labels->tags);
+
+    if (strcmp(pkt_tag_labels->label, "dub")) {
+        errx(1, "got label %s (expected dub)", pkt_tag_labels->label);
+    }
+
+    if (gw->site.as_integer == 42) {
+        if (tags != 0x1) {
+            errx(1, "got tags %#jx (expected %#x)", (uintmax_t)tags, 0x1);
+        }
+        if (gateway_send_to_site_called_for_gw_1) {
+            errx(1, "LGTD_LIFX_SET_TAG_LABELS already called for gw 1");
+        }
+        gateway_send_to_site_called_for_gw_1 = true;
+    } else if (gw->site.as_integer == 44) {
+        if (tags != 0x4) {
+            errx(1, "got tags %#jx (expected %#x)", (uintmax_t)tags, 0x4);
+        }
+        if (gateway_send_to_site_called_for_gw_2) {
+            errx(1, "LGTD_LIFX_SET_TAG_LABELS already called for gw 2");
+        }
+        gateway_send_to_site_called_for_gw_2 = true;
+    } else {
+        errx(1, "LGTD_LIFX_SET_TAG_LABELS received an invalid gateway");
+    }
+
+    return true;
+}
+
+static bool gateway_allocate_tag_id_called = false;
+
+int
+lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *gw,
+                                  int tag_id,
+                                  const char *tag_label)
+{
+    if (gateway_allocate_tag_id_called) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id "
+            "should have been called once only"
+        );
+    }
+
+    if (tag_id != -1) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id "
+            "tag_id %d (expected -1)", tag_id
+        );
+    }
+
+    if (!gw) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id "
+            "must be called with gateway"
+        );
+    }
+
+    if (!tag_label) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id "
+            "must be called with a tag_label"
+        );
+    }
+
+    if (gw->site.as_integer != 44) {
+        errx(
+            1, "lgtd_lifx_gateway_allocate_tag_id got the wrong gateway "
+            "%#jx (expected %d)", (uintmax_t)gw->site.as_integer, 44
+        );
+    }
+
+    tag_id = 2;
+
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(tag_label);
+    if (!tag) {
+        errx(1, "tag %s wasn't found", tag_label);
+    }
+    lgtd_tests_add_tag_to_gw(tag, gw, tag_id);
+
+    gateway_allocate_tag_id_called = true;
+
+    return tag_id;
+}
+
+static bool device_list_free_called = false;
+
+void
+lgtd_router_device_list_free(struct lgtd_router_device_list *devices)
+{
+    if (!devices) {
+        lgtd_errx(1, "the device list must be passed");
+    }
+
+    device_list_free_called = true;
+}
+
+struct lgtd_router_device_list *
+lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *targets)
+{
+    if (targets != FAKE_TARGET_LIST) {
+        lgtd_errx(1, "unexpected targets list");
+    }
+
+    return &devices;
+}
+
+static void
+setup_devices(void)
+{
+    static struct lgtd_lifx_gateway gw_bulb_1 = {
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_1.bulbs),
+        .site = { .as_integer = 42 }
+    };
+    static struct lgtd_lifx_bulb bulb_1 = {
+        .addr = { 1, 2, 3, 4, 5 },
+        .state = {
+            .hue = 0xaaaa,
+            .saturation = 0xffff,
+            .brightness = 0xbbbb,
+            .kelvin = 3600,
+            .label = "wave",
+            .power = LGTD_LIFX_POWER_ON,
+            .tags = 1
+        },
+        .gw = &gw_bulb_1
+    };
+    static struct lgtd_router_device device_1 = { .device = &bulb_1 };
+    SLIST_INSERT_HEAD(&devices, &device_1, link);
+    struct lgtd_lifx_tag *gw_1_tag_1 = lgtd_tests_insert_mock_tag("dub");
+    lgtd_tests_add_tag_to_gw(gw_1_tag_1, &gw_bulb_1, 0);
+
+    struct lgtd_lifx_tag *gw_2_tag_1 = lgtd_tests_insert_mock_tag("vapor");
+    struct lgtd_lifx_tag *gw_2_tag_2 = lgtd_tests_insert_mock_tag("d^-^b");
+    static struct lgtd_lifx_gateway gw_bulb_2 = {
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_2.bulbs),
+        .site = { .as_integer = 44 },
+        .tag_ids = 0x3
+    };
+    lgtd_tests_add_tag_to_gw(gw_2_tag_1, &gw_bulb_2, 0);
+    lgtd_tests_add_tag_to_gw(gw_2_tag_2, &gw_bulb_2, 1);
+    static struct lgtd_lifx_bulb bulb_2 = {
+        .addr = { 5, 4, 3, 2, 1 },
+        .state = {
+            .hue = 0x0000,
+            .saturation = 0x0000,
+            .brightness = 0xffff,
+            .kelvin = 4000,
+            .label = "",
+            .power = LGTD_LIFX_POWER_OFF,
+            .tags = 0x3
+        },
+        .gw = &gw_bulb_2
+    };
+    static struct lgtd_router_device device_2 = { .device = &bulb_2 };
+    SLIST_INSERT_HEAD(&devices, &device_2, link);
+}
+
+int
+main(void)
+{
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+
+    setup_devices();
+
+    lgtd_proto_tag(&client, FAKE_TARGET_LIST, "dub");
+
+    const char expected[] = "true";
+    if (client_write_buf_idx != sizeof(expected) - 1) {
+        lgtd_errx(
+            1,
+            "%d bytes written, expected %lu "
+            "(got %.*s instead of %s)",
+            client_write_buf_idx, sizeof(expected) - 1UL,
+            client_write_buf_idx, client_write_buf, expected
+        );
+    }
+    if (memcmp(expected, client_write_buf, sizeof(expected) - 1)) {
+        lgtd_errx(
+            1, "got %.*s instead of %s",
+            client_write_buf_idx, client_write_buf, expected
+        );
+    }
+
+    if (!gateway_send_to_site_called_for_gw_1) {
+        lgtd_errx(1, "SET_TAG_LABELS wasn't sent to gw 1");
+    }
+    if (!gateway_send_to_site_called_for_gw_2) {
+        lgtd_errx(1, "SET_TAG_LABELS wasn't sent to gw 2");
+    }
+    if (!device_list_free_called) {
+        lgtd_errx(1, "the list of devices hasn't been freed");
+    }
+    if (!send_to_device_called) {
+        lgtd_errx(1, "SET_TAGS wasn't send to any device");
+    }
+
+    return 0;
+}
diff --git a/tests/core/proto/test_proto_untag.c b/tests/core/proto/test_proto_untag.c
new file mode 100644
--- /dev/null
+++ b/tests/core/proto/test_proto_untag.c
@@ -0,0 +1,170 @@
+#include "proto.c"
+
+#include "mock_client_buf.h"
+#include "mock_daemon.h"
+#include "mock_gateway.h"
+#include "tests_utils.h"
+
+#define MOCKED_ROUTER_TARGETS_TO_DEVICES
+#define MOCKED_ROUTER_SEND_TO_DEVICE
+#define MOCKED_ROUTER_DEVICE_LIST_FREE
+#include "tests_proto_utils.h"
+
+static bool device_list_free_called = false;
+
+void
+lgtd_router_device_list_free(struct lgtd_router_device_list *devices)
+{
+    if (device_list_free_called) {
+        errx(1, "the device list should have been freed once");
+    }
+
+    if (!devices) {
+        errx(1, "the device list must be passed");
+    }
+
+    device_list_free_called = true;
+}
+
+static struct lgtd_lifx_tag *tag_vapor = NULL;
+
+struct lgtd_router_device_list *
+lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *targets)
+{
+    if (targets != (void *)0x2a) {
+        lgtd_errx(1, "unexpected targets list");
+    }
+
+    static struct lgtd_router_device_list devices =
+        SLIST_HEAD_INITIALIZER(&devices);
+
+    static struct lgtd_lifx_gateway gw_bulb_1 = {
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_1.bulbs)
+    };
+    static struct lgtd_lifx_bulb bulb_1 = {
+        .addr = { 1, 2, 3, 4, 5 },
+        .state = {
+            .hue = 0xaaaa,
+            .saturation = 0xffff,
+            .brightness = 0xbbbb,
+            .kelvin = 3600,
+            .label = "wave",
+            .power = LGTD_LIFX_POWER_ON,
+            .tags = 0
+        },
+        .gw = &gw_bulb_1
+    };
+    static struct lgtd_router_device device_1 = { .device = &bulb_1 };
+    SLIST_INSERT_HEAD(&devices, &device_1, link);
+
+    struct lgtd_lifx_tag *gw_2_tag_2 = lgtd_tests_insert_mock_tag("d^-^b");
+    struct lgtd_lifx_tag *gw_2_tag_3 = lgtd_tests_insert_mock_tag("wave~");
+    static struct lgtd_lifx_gateway gw_bulb_2 = {
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_2.bulbs),
+        .tag_ids = 0x7
+    };
+    lgtd_tests_add_tag_to_gw(tag_vapor, &gw_bulb_2, 0);
+    lgtd_tests_add_tag_to_gw(gw_2_tag_2, &gw_bulb_2, 1);
+    lgtd_tests_add_tag_to_gw(gw_2_tag_3, &gw_bulb_2, 2);
+    static struct lgtd_lifx_bulb bulb_2 = {
+        .addr = { 5, 4, 3, 2, 1 },
+        .state = {
+            .hue = 0x0000,
+            .saturation = 0x0000,
+            .brightness = 0xffff,
+            .kelvin = 4000,
+            .label = "",
+            .power = LGTD_LIFX_POWER_OFF,
+            .tags = 0x3
+        },
+        .gw = &gw_bulb_2
+    };
+    static struct lgtd_router_device device_2 = { .device = &bulb_2 };
+    SLIST_INSERT_HEAD(&devices, &device_2, link);
+
+    return &devices;
+}
+
+static bool send_to_device_called = false;
+
+void
+lgtd_router_send_to_device(struct lgtd_lifx_bulb *bulb,
+                           enum lgtd_lifx_packet_type pkt_type,
+                           void *pkt)
+{
+    if (send_to_device_called) {
+        errx(1, "lgtd_router_send_to_device should have been called once");
+    }
+
+    if (!bulb) {
+        errx(1, "lgtd_router_send_to_device must be called with a bulb");
+    }
+
+    uint8_t expected_addr[LGTD_LIFX_ADDR_LENGTH] = { 5, 4, 3, 2, 1 };
+    if (memcmp(bulb->addr, expected_addr, LGTD_LIFX_ADDR_LENGTH)) {
+        errx(
+            1, "got bulb with addr %s (expected %s)",
+            lgtd_addrtoa(bulb->addr), lgtd_addrtoa(expected_addr)
+        );
+    }
+
+    if (pkt_type != LGTD_LIFX_SET_TAGS) {
+        errx(
+            1, "got packet type %d (expected %d)", pkt_type, LGTD_LIFX_SET_TAGS
+        );
+    }
+
+    if (!pkt) {
+        errx(1, "missing SET_TAGS payload");
+    }
+
+    struct lgtd_lifx_packet_tags *pkt_tags = pkt;
+    if (pkt_tags->tags != 0x2) {
+        errx(
+            1, "invalid SET_TAGS payload=%#jx (expected %#x)",
+            (uintmax_t)pkt_tags->tags, 0x2
+        );
+    }
+
+    send_to_device_called = true;
+}
+
+int
+main(void)
+{
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+
+    struct lgtd_proto_target_list *targets = (void *)0x2a;
+
+    tag_vapor = lgtd_tests_insert_mock_tag("vapor");
+
+    lgtd_proto_untag(&client, targets, "vapor");
+
+    const char expected[] = "true";
+
+    if (client_write_buf_idx != sizeof(expected) - 1) {
+        lgtd_errx(
+            1,
+            "%d bytes written, expected %lu "
+            "(got %.*s instead of %s)",
+            client_write_buf_idx, sizeof(expected) - 1UL,
+            client_write_buf_idx, client_write_buf, expected
+        );
+    }
+
+    if (memcmp(expected, client_write_buf, sizeof(expected) - 1)) {
+        lgtd_errx(
+            1, "got %.*s instead of %s",
+            client_write_buf_idx, client_write_buf, expected
+        );
+    }
+
+    if (!device_list_free_called) {
+        lgtd_errx(1, "the list of devices hasn't been freed");
+    }
+    if (!send_to_device_called) {
+        lgtd_errx(1, "nothing was send to any device");
+    }
+
+    return 0;
+}
diff --git a/tests/core/proto/test_proto_untag_tag_does_not_exist.c b/tests/core/proto/test_proto_untag_tag_does_not_exist.c
new file mode 100644
--- /dev/null
+++ b/tests/core/proto/test_proto_untag_tag_does_not_exist.c
@@ -0,0 +1,90 @@
+#include "proto.c"
+
+#include "mock_client_buf.h"
+#include "mock_daemon.h"
+#include "mock_gateway.h"
+#include "tests_utils.h"
+
+#define MOCKED_ROUTER_TARGETS_TO_DEVICES
+#define MOCKED_ROUTER_SEND_TO_DEVICE
+#define MOCKED_ROUTER_DEVICE_LIST_FREE
+#include "tests_proto_utils.h"
+
+static bool device_list_free_called = false;
+
+void
+lgtd_router_device_list_free(struct lgtd_router_device_list *devices)
+{
+    (void)devices;
+
+    device_list_free_called = true;
+}
+
+static bool targets_to_devices_called = false;
+
+struct lgtd_router_device_list *
+lgtd_router_targets_to_devices(const struct lgtd_proto_target_list *targets)
+{
+    (void)targets;
+
+    targets_to_devices_called = true;
+
+    static struct lgtd_router_device_list devices =
+        SLIST_HEAD_INITIALIZER(&devices);
+
+    return &devices;
+}
+
+static bool send_to_device_called = false;
+
+void
+lgtd_router_send_to_device(struct lgtd_lifx_bulb *bulb,
+                           enum lgtd_lifx_packet_type pkt_type,
+                           void *pkt)
+{
+    (void)bulb;
+    (void)pkt_type;
+    (void)pkt;
+    send_to_device_called = true;
+}
+
+int
+main(void)
+{
+    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+
+    struct lgtd_proto_target_list *targets;
+    targets = lgtd_tests_build_target_list("*", NULL);
+
+    lgtd_proto_untag(&client, targets, "vapor");
+
+    const char expected[] = "true";
+
+    if (client_write_buf_idx != sizeof(expected) - 1) {
+        lgtd_errx(
+            1,
+            "%d bytes written, expected %lu "
+            "(got %.*s instead of %s)",
+            client_write_buf_idx, sizeof(expected) - 1UL,
+            client_write_buf_idx, client_write_buf, expected
+        );
+    }
+    if (memcmp(expected, client_write_buf, sizeof(expected) - 1)) {
+        lgtd_errx(
+            1, "got %.*s instead of %s",
+            client_write_buf_idx, client_write_buf, expected
+        );
+    }
+
+    if (targets_to_devices_called) {
+        lgtd_errx(1, "unexpected call to targets_to_devices");
+    }
+    if (device_list_free_called) {
+        lgtd_errx(1, "nothing should have been freed");
+    }
+    if (send_to_device_called) {
+        lgtd_errx(1, "nothing should have been sent to any device");
+    }
+
+    return 0;
+}
diff --git a/tests/core/proto/tests_proto_utils.h b/tests/core/proto/tests_proto_utils.h
--- a/tests/core/proto/tests_proto_utils.h
+++ b/tests/core/proto/tests_proto_utils.h
@@ -34,6 +34,18 @@
 }
 #endif
 
+#ifndef MOCKED_ROUTER_SEND_TO_DEVICE
+void
+lgtd_router_send_to_device(struct lgtd_lifx_bulb *bulb,
+                           enum lgtd_lifx_packet_type pkt_type,
+                           void *pkt)
+{
+    (void)bulb;
+    (void)pkt_type;
+    (void)pkt;
+}
+#endif
+
 #ifndef MOCKED_ROUTER_SEND
 bool
 lgtd_router_send(const struct lgtd_proto_target_list *targets,
diff --git a/tests/core/router/CMakeLists.txt b/tests/core/router/CMakeLists.txt
--- a/tests/core/router/CMakeLists.txt
+++ b/tests/core/router/CMakeLists.txt
@@ -9,6 +9,7 @@
     ${LIGHTSD_SOURCE_DIR}/core/proto.c
     ${LIGHTSD_SOURCE_DIR}/core/stats.c
     ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/tagging.c
     ${LIGHTSD_SOURCE_DIR}/lifx/timer.c
     ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
diff --git a/tests/core/router/tests_router_utils.h b/tests/core/router/tests_router_utils.h
--- a/tests/core/router/tests_router_utils.h
+++ b/tests/core/router/tests_router_utils.h
@@ -1,5 +1,7 @@
 #pragma once
 
+#include "mock_gateway.h"
+
 int lgtd_tests_gw_pkt_queue_size = 0;
 struct {
     struct lgtd_lifx_gateway        *gw;
diff --git a/tests/core/tests_shims.c b/tests/core/tests_shims.c
--- a/tests/core/tests_shims.c
+++ b/tests/core/tests_shims.c
@@ -30,52 +30,3 @@
 lgtd_cleanup(void)
 {
 }
-
-
-void lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *gw,
-                                          const struct lgtd_lifx_packet_header *hdr,
-                                          const struct lgtd_lifx_packet_pan_gateway *pkt)
-{
-    (void)gw;
-    (void)hdr;
-    (void)pkt;
-}
-
-void lgtd_lifx_gateway_handle_light_status(struct lgtd_lifx_gateway *gw,
-                                           const struct lgtd_lifx_packet_header *hdr,
-                                           const struct lgtd_lifx_packet_light_status *pkt)
-{
-    (void)gw;
-    (void)hdr;
-    (void)pkt;
-}
-
-void lgtd_lifx_gateway_handle_power_state(struct lgtd_lifx_gateway *gw,
-                                          const struct lgtd_lifx_packet_header *hdr,
-                                          const struct lgtd_lifx_packet_power_state *pkt)
-{
-    (void)gw;
-    (void)hdr;
-    (void)pkt;
-}
-
-void lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *gw,
-                                         const struct lgtd_lifx_packet_header *hdr,
-                                         const struct lgtd_lifx_packet_tag_labels *pkt)
-{
-    (void)gw;
-    (void)hdr;
-    (void)pkt;
-}
-
-struct lgtd_lifx_tag *
-lgtd_lifx_tagging_find_tag(const char *tag_label)
-{
-    struct lgtd_lifx_tag *tag = NULL;
-    LIST_FOREACH(tag, &lgtd_lifx_tags, link) {
-        if (!strcmp(tag->label, tag_label)) {
-            break;
-        }
-    }
-    return tag;
-}
diff --git a/tests/core/tests_shims.h b/tests/core/tests_shims.h
new file mode 100644
--- /dev/null
+++ b/tests/core/tests_shims.h
@@ -0,0 +1,23 @@
+#pragma once
+
+struct lgtd_opts lgtd_opts = {
+    .foreground = false,
+    .log_timestamps = false,
+    .verbosity = LGTD_DEBUG
+};
+
+struct event_base *lgtd_ev_base = NULL;
+
+const char *lgtd_binds = NULL;
+
+void
+lgtd_cleanup(void)
+{
+}
+
+#ifndef MOCKED_DAEMON_UPDATE_PROCTITLE
+void
+lgtd_daemon_update_proctitle(void)
+{
+}
+#endif
diff --git a/tests/core/tests_utils.c b/tests/core/tests_utils.c
--- a/tests/core/tests_utils.c
+++ b/tests/core/tests_utils.c
@@ -118,8 +118,11 @@
     struct lgtd_lifx_site *site = calloc(1, sizeof(*site));
     site->gw = gw;
     site->tag_id = tag_id;
+    LIST_INSERT_HEAD(&tag->sites, site, link);
+
     gw->tags[tag_id] = tag;
-    LIST_INSERT_HEAD(&tag->sites, site, link);
+    gw->tag_ids |= LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
+
     return site;
 }
 
diff --git a/tests/lifx/bulb/CMakeLists.txt b/tests/lifx/bulb/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/lifx/bulb/CMakeLists.txt
@@ -0,0 +1,29 @@
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+ADD_CORE_LIBRARY(
+    test_lifx_bulb_core STATIC
+    ${LIGHTSD_SOURCE_DIR}/core/log.c
+    ${LIGHTSD_SOURCE_DIR}/core/router.c
+    ${LIGHTSD_SOURCE_DIR}/core/stats.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
+)
+
+ADD_LIBRARY(
+    test_lifx_bulb STATIC
+    ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
+)
+
+FUNCTION(ADD_BULB_TEST TEST_SOURCE)
+    ADD_TEST_FROM_C_SOURCES(
+        ${TEST_SOURCE} test_lifx_bulb_core test_lifx_bulb
+    )
+ENDFUNCTION()
+
+FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
+FOREACH(TEST ${TESTS})
+    ADD_BULB_TEST(${TEST})
+ENDFOREACH()
diff --git a/tests/lifx/bulb/test_bulb_close.c b/tests/lifx/bulb/test_bulb_close.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/bulb/test_bulb_close.c
@@ -0,0 +1,33 @@
+#include "bulb.c"
+
+#include "mock_gateway.h"
+
+int
+main(void)
+{
+    struct lgtd_lifx_gateway gw;
+    uint8_t bulb_addr[LGTD_LIFX_ADDR_LENGTH] = { 5, 4, 3, 2, 1, 0 };
+    struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_open(&gw, bulb_addr);
+
+    bulb->state.power = LGTD_LIFX_POWER_ON;
+    LGTD_STATS_ADD_AND_UPDATE_PROCTITLE(bulbs_powered_on, 1);
+
+    lgtd_lifx_bulb_close(bulb);
+
+    if (!RB_EMPTY(&lgtd_lifx_bulbs_table)) {
+        errx(1, "The bulbs table should be empty!");
+    }
+
+    if (LGTD_STATS_GET(bulbs) != 0) {
+        errx(1, "The bulbs counter is %d (expected 0)", LGTD_STATS_GET(bulbs));
+    }
+
+    if (LGTD_STATS_GET(bulbs_powered_on) != 0) {
+        errx(
+            1, "The powered on bulbs counter is %d (expected 0)",
+            LGTD_STATS_GET(bulbs_powered_on)
+        );
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/bulb/test_bulb_open.c b/tests/lifx/bulb/test_bulb_open.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/bulb/test_bulb_open.c
@@ -0,0 +1,44 @@
+#include "bulb.c"
+
+#include "mock_gateway.h"
+
+int
+main(void)
+{
+    struct lgtd_lifx_gateway gw;
+    uint8_t bulb_addr[LGTD_LIFX_ADDR_LENGTH] = { 5, 4, 3, 2, 1, 0 };
+    lgtd_time_mono_t now = lgtd_time_monotonic_msecs();
+    struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_open(&gw, bulb_addr);
+
+    if (!bulb) {
+        errx(1, "lgtd_lifx_bulb_open didn't return any bulb");
+    }
+
+    if (memcmp(bulb->addr, bulb_addr, LGTD_LIFX_ADDR_LENGTH)) {
+        errx(
+            1, "got bulb addr %s (expected %s)",
+            lgtd_addrtoa(bulb->addr), lgtd_addrtoa(bulb_addr)
+        );
+    }
+
+    if (bulb->gw != &gw) {
+        errx(1, "got bulb gateway %p (expected %p)", bulb->gw, &gw);
+    }
+
+    if (lgtd_lifx_bulb_get(bulb_addr) != bulb) {
+        errx(1, "the new bulb can't be found");
+    }
+
+    if (bulb->last_light_state_at < now) {
+        errx(
+            1, "got bulb->last_light_state_at %ju (expected >= %ju)",
+            bulb->last_light_state_at, (uintmax_t)now
+        );
+    }
+
+    if (LGTD_STATS_GET(bulbs) != 1) {
+        errx(1, "bulbs counter is %d (expected 1)", LGTD_STATS_GET(bulbs));
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/bulb/test_bulb_set_light_state.c b/tests/lifx/bulb/test_bulb_set_light_state.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/bulb/test_bulb_set_light_state.c
@@ -0,0 +1,92 @@
+#include "bulb.c"
+
+#define MOCKED_LGTD_LIFX_GATEWAY_UPDATE_TAG_REFCOUNTS
+#include "mock_gateway.h"
+
+static int update_tag_refcouts_call_counts = 0;
+
+void
+lgtd_lifx_gateway_update_tag_refcounts(struct lgtd_lifx_gateway *gw,
+                                       uint64_t bulb_tags,
+                                       uint64_t pkt_tags)
+{
+    if (gw != (void *)0xdeaf) {
+        errx(1, "got wrong gw %p (expected 0xdeaf)", gw);
+    }
+
+    if (pkt_tags != 0xfeed) {
+        errx(1, "got pkt_tags %#jx (expected 0xfeed)", (uintmax_t)pkt_tags);
+    }
+
+    if (!update_tag_refcouts_call_counts) {
+        if (bulb_tags != 0x2a) {
+            errx(1, "got bulb_tags %#jx (expected 0x2a)", (uintmax_t)bulb_tags);
+        }
+    } else {
+        if (bulb_tags != 0xfeed) {
+            errx(1, "got bulb_tags %#jx (expected 0xfeed)", (uintmax_t)bulb_tags);
+        }
+    }
+
+    update_tag_refcouts_call_counts++;
+}
+
+int
+main(void)
+{
+    struct lgtd_lifx_bulb bulb = {
+        .state = {
+            .hue = 54321,
+            .brightness = UINT16_MAX,
+            .kelvin = 12345,
+            .dim = 808,
+            .power = LGTD_LIFX_POWER_OFF,
+            .label = "lair",
+            .tags = 0x2a
+        },
+        .gw = (void *)0xdeaf
+    };
+
+    struct lgtd_lifx_light_state new_state = {
+        .hue = 22222,
+        .brightness = UINT16_MAX / 2,
+        .kelvin = 54321,
+        .dim = 303,
+        .power = LGTD_LIFX_POWER_ON,
+        .label = "caverne",
+        .tags = 0xfeed
+    };
+
+    lgtd_lifx_bulb_set_light_state(&bulb, &new_state, 2015);
+    if (memcmp(&bulb.state, &new_state, sizeof(new_state))) {
+        errx(1, "new light state incorrectly set");
+    }
+    if (LGTD_STATS_GET(bulbs_powered_on) != 1) {
+        errx(
+            1, "unexpected bulbs_powered_on counter value %d (expected 1)",
+            LGTD_STATS_GET(bulbs_powered_on)
+        );
+    }
+    if (bulb.last_light_state_at != 2015) {
+        errx(
+            1, "got bulb.last_light_state = %jx (expected 2015)",
+            (uintmax_t)bulb.last_light_state_at
+        );
+    }
+    if (update_tag_refcouts_call_counts != 1) {
+        errx(1, "lgtd_lifx_gateway_update_tag_refcounts wasn't called");
+    }
+
+    lgtd_lifx_bulb_set_light_state(&bulb, &new_state, 2015);
+    if (update_tag_refcouts_call_counts != 2) {
+        errx(1, "lgtd_lifx_gateway_update_tag_refcounts wasn't called");
+    }
+    if (LGTD_STATS_GET(bulbs_powered_on) != 1) {
+        errx(
+            1, "unexpected bulbs_powered_on counter value %d (expected 1)",
+            LGTD_STATS_GET(bulbs_powered_on)
+        );
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/bulb/test_bulb_set_power_state.c b/tests/lifx/bulb/test_bulb_set_power_state.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/bulb/test_bulb_set_power_state.c
@@ -0,0 +1,39 @@
+#include "bulb.c"
+
+#include "mock_gateway.h"
+
+int
+main(void)
+{
+    struct lgtd_lifx_bulb bulb = {
+        .state = {
+            .hue = 54321,
+            .brightness = UINT16_MAX,
+            .kelvin = 12345,
+            .dim = 808,
+            .power = LGTD_LIFX_POWER_OFF,
+            .label = "lair",
+            .tags = 0x2a
+        },
+        .gw = (void *)0xdeaf
+    };
+    struct lgtd_lifx_light_state new_state;
+    memcpy(&new_state, &bulb.state, sizeof(new_state));
+    new_state.power = LGTD_LIFX_POWER_ON;
+
+
+    for (int i = 0; i != 2; i++) {
+        lgtd_lifx_bulb_set_power_state(&bulb, LGTD_LIFX_POWER_ON);
+        if (memcmp(&bulb.state, &new_state, sizeof(new_state))) {
+            errx(1, "new light state incorrectly set");
+        }
+        if (LGTD_STATS_GET(bulbs_powered_on) != 1) {
+            errx(
+                1, "unexpected bulbs_powered_on counter value %d (expected 1)",
+                LGTD_STATS_GET(bulbs_powered_on)
+            );
+        }
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/bulb/test_bulb_set_tags.c b/tests/lifx/bulb/test_bulb_set_tags.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/bulb/test_bulb_set_tags.c
@@ -0,0 +1,50 @@
+#include "bulb.c"
+
+#define MOCKED_LGTD_LIFX_GATEWAY_UPDATE_TAG_REFCOUNTS
+#include "mock_gateway.h"
+
+static bool update_tag_refcouts_called = false;
+
+void
+lgtd_lifx_gateway_update_tag_refcounts(struct lgtd_lifx_gateway *gw,
+                                       uint64_t bulb_tags,
+                                       uint64_t pkt_tags)
+{
+    if (gw != (void *)0xdeaf) {
+        errx(1, "got wrong gw %p (expected 0xdeaf)", gw);
+    }
+
+    if (bulb_tags != 0x2a) {
+        errx(1, "got bulb_tags %#jx (expected 0x2a)", (uintmax_t)bulb_tags);
+    }
+
+    if (pkt_tags != 0xfeed) {
+        errx(1, "got pkt_tags %#jx (expected 0xfeed)", (uintmax_t)pkt_tags);
+    }
+
+    update_tag_refcouts_called = true;
+}
+
+int
+main(void)
+{
+    struct lgtd_lifx_bulb bulb = {
+        .state = { .tags = 0x2a },
+        .gw = (void *)0xdeaf
+    };
+
+    lgtd_lifx_bulb_set_tags(&bulb, 0xfeed);
+
+    if (bulb.state.tags != 0xfeed) {
+        errx(
+            1, "got bulb.state.tags = %#jx (expected 0xfeed)",
+            (uintmax_t)bulb.state.tags
+        );
+    }
+
+    if (!update_tag_refcouts_called) {
+        errx(1, "lgtd_lifx_gateway_update_tag_refcounts wasn't called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_allocate_tag_id.c b/tests/lifx/gateway/test_gateway_allocate_tag_id.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_allocate_tag_id.c
@@ -0,0 +1,102 @@
+#include "gateway.c"
+
+#include <string.h>
+
+#define MOCKED_LIFX_TAGGING_INCREF
+#include "test_gateway_utils.h"
+
+static bool tagging_incref_called = false;
+
+struct lgtd_lifx_tag *
+lgtd_lifx_tagging_incref(const char *label,
+                         struct lgtd_lifx_gateway *gw,
+                         int tag_id)
+{
+    if (!label) {
+        errx(1, "missing tag label");
+    }
+    if (!gw) {
+        errx(1, "missing gateway");
+    }
+    if (tag_id > 2) {
+        errx(1, "got tag_id %d but expected < 3", tag_id);
+    }
+
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(label);
+    if (!tag) {
+        tag = calloc(1, sizeof(*tag));
+        strcpy(tag->label, label);
+        struct lgtd_lifx_site *site = calloc(1, sizeof(*site));
+        site->gw = gw;
+        site->tag_id = tag_id;
+        LIST_INSERT_HEAD(&tag->sites, site, link);
+    }
+
+    tagging_incref_called = true;
+
+    return tag;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    struct lgtd_lifx_packet_header hdr;
+    memset(&hdr, 0, sizeof(hdr));
+
+    uint64_t expected_tag_ids = LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(0);
+
+    lgtd_lifx_gateway_allocate_tag_id(&gw, 0, "test");
+    if (!gw.tags[0]) {
+        errx(1, "gw.tag_ids[0] shouldn't be NULL");
+    }
+    if (strcmp(gw.tags[0]->label, "test")) {
+        errx(
+            1, "unexpected tag %.*s (expected test)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[0]->label
+        );
+    }
+    if (gw.tag_ids != LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(0)) {
+        errx(
+            1, "tag_ids = %jx (expected %jx)",
+            (uintmax_t)gw.tag_ids, (uintmax_t)expected_tag_ids
+        );
+    }
+    if (!tagging_incref_called) {
+        errx(1, "lgtd_lifx_tagging_incref should have been called");
+    }
+    tagging_incref_called = false;
+
+    for (int i = 1; i != 3; i++) {
+        int tag_id = lgtd_lifx_gateway_allocate_tag_id(&gw, -1, "lounge");
+        if (tag_id < 1) {
+            errx(1, "no tag_id was allocated (received tag_id %d)", tag_id);
+        }
+        if (!gw.tags[tag_id]) {
+            errx(1, "gw.tag_ids[%d] shouldn't be NULL", i);
+        }
+        if (strcmp(gw.tags[tag_id]->label, "lounge")) {
+            errx(
+                1, "unexpected tag %.*s (expected lounge)",
+                (int)sizeof(gw.tags[tag_id]->label), gw.tags[tag_id]->label
+            );
+        }
+        expected_tag_ids |= LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
+        if (gw.tag_ids != expected_tag_ids) {
+            errx(
+                1, "tag_ids = %jx (expected %jx)",
+                (uintmax_t)gw.tag_ids, (uintmax_t)expected_tag_ids
+            );
+        }
+        if (!tagging_incref_called) {
+            errx(1, "lgtd_lifx_tagging_incref should have been called");
+        }
+        tagging_incref_called = false;
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_allocate_tag_id_no_tag_id_left.c b/tests/lifx/gateway/test_gateway_allocate_tag_id_no_tag_id_left.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_allocate_tag_id_no_tag_id_left.c
@@ -0,0 +1,89 @@
+
+#include <string.h>
+
+#include "gateway.c"
+
+#define MOCKED_LIFX_TAGGING_INCREF
+#include "test_gateway_utils.h"
+
+static bool tagging_incref_called = false;
+
+struct lgtd_lifx_tag *
+lgtd_lifx_tagging_incref(const char *label,
+                         struct lgtd_lifx_gateway *gw,
+                         int tag_id)
+{
+    if (!label) {
+        errx(1, "missing tag label");
+    }
+    if (!gw) {
+        errx(1, "missing gateway");
+    }
+    if (tag_id < 0) {
+        errx(1, "got tag_id %d but expected >= 0", tag_id);
+    }
+
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(label);
+    if (!tag) {
+        tag = calloc(1, sizeof(*tag));
+        strcpy(tag->label, label);
+        struct lgtd_lifx_site *site = calloc(1, sizeof(*site));
+        site->gw = gw;
+        site->tag_id = tag_id;
+        LIST_INSERT_HEAD(&tag->sites, site, link);
+    }
+
+    tagging_incref_called = true;
+
+    return tag;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    struct lgtd_lifx_packet_header hdr;
+    memset(&hdr, 0, sizeof(hdr));
+
+    uint64_t expected_tag_ids = 0;
+    for (int i = 0; i != LGTD_LIFX_GATEWAY_MAX_TAGS; i++) {
+        int tag_id = lgtd_lifx_gateway_allocate_tag_id(&gw, -1, "lounge");
+        if (tag_id < 0) {
+            errx(1, "no tag_id was allocated (received tag_id %d)", tag_id);
+        }
+        if (!gw.tags[tag_id]) {
+            errx(1, "gw.tag_ids[%d] shouldn't be NULL", i);
+        }
+        if (strcmp(gw.tags[tag_id]->label, "lounge")) {
+            errx(
+                1, "unexpected tag %.*s (expected lounge)",
+                (int)sizeof(gw.tags[tag_id]->label), gw.tags[tag_id]->label
+            );
+        }
+        expected_tag_ids |= LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
+        if (gw.tag_ids != expected_tag_ids) {
+            errx(
+                1, "tag_ids = %jx (expected %jx)",
+                (uintmax_t)gw.tag_ids, (uintmax_t)expected_tag_ids
+            );
+        }
+        if (!tagging_incref_called) {
+            errx(1, "lgtd_lifx_tagging_incref should have been called");
+        }
+        tagging_incref_called = false;
+    }
+
+    int tag_id = lgtd_lifx_gateway_allocate_tag_id(&gw, -1, "lounge");
+    if (tag_id != -1) {
+        errx(1, "tag_ids full but tag_id %d was allocated", tag_id);
+    }
+    if (tagging_incref_called) {
+        errx(1, "lgtd_lifx_tagging_incref should not have been called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_update_tag_refcounts.c b/tests/lifx/gateway/test_gateway_update_tag_refcounts.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_update_tag_refcounts.c
@@ -0,0 +1,106 @@
+#include "gateway.c"
+
+#include "test_gateway_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    lgtd_lifx_gateway_update_tag_refcounts(&gw, 0, 0);
+    for (int i = 0; i != LGTD_LIFX_GATEWAY_MAX_TAGS; i++) {
+        if (gw.tag_refcounts[i]) {
+            errx(
+                1, "gw.tag_refcounts[%d] was %d, (expected 0)",
+                i, gw.tag_refcounts[i]
+            );
+        }
+    }
+
+    for (int n = 1; n != 3; n++) {
+        lgtd_lifx_gateway_update_tag_refcounts(&gw, 0, 1);
+        if (gw.tag_refcounts[0] != n) {
+            errx(
+                1, "gw.tag_refcounts[0] was %d (expected %d)",
+                gw.tag_refcounts[0], n
+            );
+        }
+        for (int i = 1; i != LGTD_LIFX_GATEWAY_MAX_TAGS; i++) {
+            if (gw.tag_refcounts[i]) {
+                errx(
+                    1, "gw.tag_refcounts[%d] was %d (expected 0)",
+                    i, gw.tag_refcounts[i]
+                );
+            }
+        }
+    }
+
+    lgtd_lifx_gateway_update_tag_refcounts(&gw, 0, 2);
+    gw.tag_ids = 0x2;
+
+    for (int n = 1; n >= 0; n--) {
+        lgtd_lifx_gateway_update_tag_refcounts(&gw, 1, 0);
+        if (gw.tag_refcounts[0] != n) {
+            errx(
+                1, "gw.tag_refcounts[0] was %d (expected %d)",
+                gw.tag_refcounts[0], n - 1
+            );
+        }
+        if (gw.tag_refcounts[1] != 1) {
+            errx(
+                1, "gw.tag_refcounts[1] was %d (expected 1)",
+                gw.tag_refcounts[1]
+            );
+        }
+        for (int i = 2; i != LGTD_LIFX_GATEWAY_MAX_TAGS; i++) {
+            if (gw.tag_refcounts[i]) {
+                errx(
+                    1, "gw.tag_refcounts[%d] was %d (expected 0)",
+                    i, gw.tag_refcounts[i]
+                );
+            }
+        }
+    }
+    if (gw.pkt_ring[0].type != LGTD_LIFX_SET_TAG_LABELS) {
+        errx(1, "SET_TAG_LABELS should have been enqueued on the gateway");
+    }
+
+    struct lgtd_lifx_packet_tag_labels *pkt =
+        (void *)&gw_write_buf[sizeof(struct lgtd_lifx_packet_header)];
+    uint64_t tags = le64toh(pkt->tags);
+    if (tags != ~2ULL) {
+        errx(
+            1, "tags on LGTD_LIFX_SET_TAG_LABELS was %#jx (expected %#jx)",
+            (uintmax_t)tags, (uintmax_t)~2ULL
+        );
+    }
+    const char blank_label[LGTD_LIFX_LABEL_SIZE] = { 0 };
+    if (memcmp(pkt->label, blank_label, LGTD_LIFX_LABEL_SIZE)) {
+        errx(
+            1, "label on LGTD_LIFX_SET_TAG_LABELS should be "
+            "all zero but got %.*s", LGTD_LIFX_LABEL_SIZE, pkt->label
+        );
+    }
+
+    for (int n = 0; n != UINT8_MAX; n++) {
+        lgtd_lifx_gateway_update_tag_refcounts(&gw, 0, 4);
+    }
+    if (gw.tag_refcounts[2] != UINT8_MAX) {
+        errx(
+            1, "gw.tag_refcounts[2] was %d (expected %d)",
+            gw.tag_refcounts[2], UINT8_MAX
+        );
+    }
+    lgtd_lifx_gateway_update_tag_refcounts(&gw, 0, 4);
+    if (gw.tag_refcounts[2] != UINT8_MAX) {
+        errx(
+            1, "gw.tag_refcounts[2] was %d (expected %d)",
+            gw.tag_refcounts[2], UINT8_MAX
+        );
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/mock_gateway.h b/tests/lifx/mock_gateway.h
new file mode 100644
--- /dev/null
+++ b/tests/lifx/mock_gateway.h
@@ -0,0 +1,131 @@
+#pragma once
+
+#include "core/time_monotonic.h"
+#include "lifx/bulb.h"
+#include "lifx/gateway.h"
+
+struct lgtd_lifx_tag;
+struct lgtd_lifx_gateway;
+
+#ifndef MOCKED_LIFX_GATEWAY_SEND_TO_SITE
+bool
+lgtd_lifx_gateway_send_to_site(struct lgtd_lifx_gateway *gw,
+                               enum lgtd_lifx_packet_type pkt_type,
+                               const void *pkt)
+{
+    (void)gw;
+    (void)pkt_type;
+    (void)pkt;
+    return false;
+}
+#endif
+
+#ifndef MOCKED_LIFX_GATEWAY_ALLOCATE_TAG_ID
+int
+lgtd_lifx_gateway_allocate_tag_id(struct lgtd_lifx_gateway *gw,
+                                  int tag_id,
+                                  const char *tag_label)
+{
+    (void)gw;
+    (void)tag_id;
+    (void)tag_label;
+    return -1;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_HANDLE_PAN_GATEWAY
+void
+lgtd_lifx_gateway_handle_pan_gateway(struct lgtd_lifx_gateway *gw,
+                                     const struct lgtd_lifx_packet_header *hdr,
+                                     const struct lgtd_lifx_packet_pan_gateway *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_HANDLE_LIGHT_STATUS
+void
+lgtd_lifx_gateway_handle_light_status(struct lgtd_lifx_gateway *gw,
+                                      const struct lgtd_lifx_packet_header *hdr,
+                                      const struct lgtd_lifx_packet_light_status *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_HANDLE_POWER_STATE
+void
+lgtd_lifx_gateway_handle_power_state(struct lgtd_lifx_gateway *gw,
+                                     const struct lgtd_lifx_packet_header *hdr,
+                                     const struct lgtd_lifx_packet_power_state *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_HANDLE_TAG_LABELS
+void
+lgtd_lifx_gateway_handle_tag_labels(struct lgtd_lifx_gateway *gw,
+                                    const struct lgtd_lifx_packet_header *hdr,
+                                    const struct lgtd_lifx_packet_tag_labels *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_HANDLE_TAGS
+void
+lgtd_lifx_gateway_handle_tags(struct lgtd_lifx_gateway *gw,
+                              const struct lgtd_lifx_packet_header *hdr,
+                              const struct lgtd_lifx_packet_tags *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_DEALLOCATE_TAG_ID
+void
+lgtd_lifx_gateway_deallocate_tag_id(struct lgtd_lifx_gateway *gw, int tag_id)
+{
+    (void)gw;
+    (void)tag_id;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_GET_TAG_ID
+int
+lgtd_lifx_gateway_get_tag_id(const struct lgtd_lifx_gateway *gw,
+                             const struct lgtd_lifx_tag *tag)
+{
+    int tag_id;
+    LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, gw->tag_ids) {
+        if (gw->tags[tag_id] == tag) {
+            return tag_id;
+        }
+    }
+
+    return -1;
+}
+#endif
+
+#ifndef MOCKED_LGTD_LIFX_GATEWAY_UPDATE_TAG_REFCOUNTS
+void
+lgtd_lifx_gateway_update_tag_refcounts(struct lgtd_lifx_gateway *gw,
+                                       uint64_t bulb_tags,
+                                       uint64_t pkt_tags)
+{
+    (void)gw;
+    (void)bulb_tags;
+    (void)pkt_tags;
+}
+#endif
diff --git a/tests/lifx/wire_proto/test_wire_proto_utils.h b/tests/lifx/wire_proto/test_wire_proto_utils.h
--- a/tests/lifx/wire_proto/test_wire_proto_utils.h
+++ b/tests/lifx/wire_proto/test_wire_proto_utils.h
@@ -35,3 +35,12 @@
     (void)hdr;
     (void)pkt;
 }
+
+void lgtd_lifx_gateway_handle_tags(struct lgtd_lifx_gateway *gw,
+                                   const struct lgtd_lifx_packet_header *hdr,
+                                   const struct lgtd_lifx_packet_tags *pkt)
+{
+    (void)gw;
+    (void)hdr;
+    (void)pkt;
+}
diff --git a/tests/lightsc b/tests/lightsc
--- a/tests/lightsc
+++ b/tests/lightsc
@@ -72,6 +72,14 @@
 def get_light_state(socket, target):
     return jsonrpc_call(socket, "get_light_state", [target])
 
+
+def tag(socket, target, tag):
+    return jsonrpc_call(socket, "tag", [target, tag])
+
+
+def untag(socket, target, tag):
+    return jsonrpc_call(socket, "untag", [target, tag])
+
 if __name__ == "__main__":
     s = socket.create_connection(("localhost", 1234))
     h = 0
