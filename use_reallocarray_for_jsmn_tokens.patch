# HG changeset patch
# Parent  75cd134adc360abec2ada7b5c83613626cbe27ef

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -30,6 +30,15 @@
 INCLUDE(CompatSetProctitle)
 INCLUDE(CompatTimeMonotonic)
 
+IF (NOT HAVE_LIBBSD)
+    CHECK_FUNCTION_EXISTS("reallocarray" HAVE_REALLOCARRAY)
+    IF (HAVE_REALLOCARRAY)
+        SET(HAVE_REALLOCARRAY 1 CACHE INTERNAL "reallocarray found in libbsd")
+    ENDIF ()
+ELSE ()
+    SET(HAVE_REALLOCARRAY 1)
+ENDIF()
+
 TEST_BIG_ENDIAN(BIG_ENDIAN_SYSTEM)
 
 ### Global definitions #########################################################
@@ -59,8 +68,10 @@
 
     "-DLGTD_HAVE_LIBBSD=${HAVE_LIBBSD}"
     "-DLGTD_HAVE_PROCTITLE=${HAVE_PROCTITLE}"
+    "-DLGTD_HAVE_REALLOCARRAY=${HAVE_REALLOCARRAY}"
 
     "-DJSMN_STRICT=1"
+    "-DJSMN_PARENT_LINKS=1"
 )
 
 IF (CMAKE_BUILD_TYPE MATCHES "DEBUG")
diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -53,6 +53,7 @@
         bufferevent_free(client->io);
     }
     free(client->addr);
+    free(client->jsmn_tokens);
     free(client);
 }
 
@@ -80,15 +81,12 @@
     // Get the actual pointer to the beginning of the evbuf:
     const char *buf = (char *)evbuffer_pullup(input, nbytes);
 
+    jsmntok_t *tokens = NULL;
+    int ntokens = 0;
     do {
-        jsmn_init(&client->jsmn_ctx);
-        jsmnerr_t rv = jsmn_parse(
-            &client->jsmn_ctx,
-            buf,
-            nbytes,
-            client->jsmn_tokens,
-            LGTD_ARRAY_SIZE(client->jsmn_tokens)
-        );
+        jsmn_parser jsmn_ctx;
+        jsmn_init(&jsmn_ctx);
+        jsmnerr_t rv = jsmn_parse(&jsmn_ctx, buf, nbytes, tokens, ntokens);
         switch (rv) {
         case JSMN_ERROR_NOMEM:
         case JSMN_ERROR_INVAL:
@@ -110,19 +108,29 @@
             }
             break;
         default:
-            client->json = buf;
-            lgtd_jsonrpc_dispatch_request(client, rv);
-            client->json = NULL;
-            size_t request_size = client->jsmn_tokens[0].end;
-            evbuffer_drain(input, request_size);
-            if (request_size < nbytes) {
-                buf += request_size;
-                nbytes -= request_size;
-                // FIXME: instead of calling jsmn_parse again, return the number
-                // of tokens consumed from jsonrpc and make this case a loop.
-                continue;
+            ntokens = rv;
+            if (tokens) {
+                client->json = buf;
+                lgtd_jsonrpc_dispatch_request(client, ntokens);
+                client->json = NULL;
+                size_t request_size = tokens[0].end;
+                tokens = NULL;
+                evbuffer_drain(input, request_size);
+                if (request_size < nbytes) {
+                    buf += request_size;
+                    nbytes -= request_size;
+                    // FIXME: instead of calling jsmn_parse again, return the
+                    // number of tokens consumed from jsonrpc and make this
+                    // case a loop.
+                    continue;
+                }
+                break;
+            } else {
+                client->jsmn_tokens = reallocarray(
+                    client->jsmn_tokens, ntokens, sizeof(*tokens)
+                );
+                tokens = client->jsmn_tokens;
             }
-            break;
         }
         // pullup and resume parsing:
         buf = (char *)evbuffer_pullup(input, -1);
diff --git a/core/client.h b/core/client.h
--- a/core/client.h
+++ b/core/client.h
@@ -34,8 +34,7 @@
     LIST_ENTRY(lgtd_client)     link;
     struct bufferevent          *io;
     struct sockaddr             *addr;
-    jsmn_parser                 jsmn_ctx;
-    jsmntok_t                   jsmn_tokens[LGTD_CLIENT_JSMN_TOKENS_NUM];
+    jsmntok_t                   *jsmn_tokens;
     const char                  *json;
     struct lgtd_jsonrpc_request *current_request;
 };
diff --git a/core/lightsd.h b/core/lightsd.h
--- a/core/lightsd.h
+++ b/core/lightsd.h
@@ -68,6 +68,16 @@
 
 enum { LGTD_SOCKADDR_STRLEN = 128 };  // should be >= sockaddr_un.sun_path
 
+#if !LGTD_HAVE_REALLOCARRAY
+static inline void *
+reallocarray(void *ptr, size_t nmemb, size_t size)
+{
+    return realloc(ptr, nmemb * size); // FIXME: actually check for overflow
+}
+#elif LGTD_HAVE_LIBBSD
+# include <bsd/bsd.h>
+#endif
+
 struct lgtd_opts {
     bool                foreground;
     bool                log_timestamps;
diff --git a/core/pipe.c b/core/pipe.c
--- a/core/pipe.c
+++ b/core/pipe.c
@@ -52,6 +52,7 @@
     SLIST_REMOVE(&lgtd_command_pipes, pipe, lgtd_command_pipe, link);
     evbuffer_free(pipe->read_buf);
     event_free(pipe->read_ev);
+    free(pipe->client.jsmn_tokens);
     free(pipe);
 }
 
@@ -93,17 +94,14 @@
         }
 
         if (!drain) {
+        jsmntok_t *tokens = NULL;
+        int ntokens = 0;
+        jsmn_parser jsmn_ctx;
         next_request:
-            jsmn_init(&pipe->client.jsmn_ctx);
+            jsmn_init(&jsmn_ctx);
             const char *buf = (char *)evbuffer_pullup(pipe->read_buf, -1);
             ssize_t bufsz = evbuffer_get_length(pipe->read_buf);
-            jsmnerr_t rv = jsmn_parse(
-                &pipe->client.jsmn_ctx,
-                buf,
-                bufsz,
-                pipe->client.jsmn_tokens,
-                LGTD_ARRAY_SIZE(pipe->client.jsmn_tokens)
-            );
+            jsmnerr_t rv = jsmn_parse(&jsmn_ctx, buf, bufsz, tokens, ntokens);
             switch (rv) {
             case JSMN_ERROR_NOMEM:
             case JSMN_ERROR_INVAL:
@@ -122,17 +120,24 @@
                 }
                 break;
             default:
-                pipe->client.json = buf;
-                int ntokens = rv;
-                lgtd_jsonrpc_dispatch_request(&pipe->client, ntokens);
-
-                pipe->client.json = NULL;
-                int request_size = pipe->client.jsmn_tokens[0].end;
-                evbuffer_drain(pipe->read_buf, request_size);
-                if (request_size < bufsz) {
-                    goto next_request;
+                ntokens = rv;
+                if (tokens) {
+                    pipe->client.json = buf;
+                    lgtd_jsonrpc_dispatch_request(&pipe->client, ntokens);
+                    pipe->client.json = NULL;
+                    int request_size = tokens[0].end;
+                    tokens = NULL;
+                    evbuffer_drain(pipe->read_buf, request_size);
+                    if (request_size >= bufsz) {
+                        break;
+                    }
+                } else {
+                    pipe->client.jsmn_tokens = reallocarray(
+                        pipe->client.jsmn_tokens, ntokens, sizeof(*tokens)
+                    );
+                    tokens = pipe->client.jsmn_tokens;
                 }
-                break;
+                goto next_request;
             }
         }
 
diff --git a/lifx/watchdog.c b/lifx/watchdog.c
--- a/lifx/watchdog.c
+++ b/lifx/watchdog.c
@@ -51,17 +51,17 @@
     (void)ctx;
 
     if (LIST_EMPTY(&lgtd_lifx_gateways)) {
-        lgtd_debug(
+        lgtd_info(
             "discovery didn't returned anything in %dms, restarting it",
             LGTD_LIFX_WATCHDOG_ACTIVE_DISCOVERY_INTERVAL_MSECS
         );
         discovery_timeout = LGTD_LIFX_WATCHDOG_ACTIVE_DISCOVERY_INTERVAL_MSECS;
     } else {
-        lgtd_debug("sending periodic discovery packet");
         discovery_timeout = LGTD_MIN(
             discovery_timeout * 2,
             LGTD_LIFX_WATCHDOG_PASSIVE_DISCOVERY_INTERVAL_MSECS
         );
+        lgtd_info("sending periodic discovery packet, timeout=%d", discovery_timeout);
     }
 
     struct timeval tv = LGTD_MSECS_TO_TIMEVAL(discovery_timeout);
