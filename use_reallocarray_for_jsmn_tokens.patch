# HG changeset patch
# Parent  bfaf17289204b95c28ce5d7da5385b020d90a7f4

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -29,6 +29,7 @@
 INCLUDE(TestBigEndian)
 INCLUDE(CompatSetProctitle)
 INCLUDE(CompatTimeMonotonic)
+INCLUDE(CompatReallocArray)
 
 TEST_BIG_ENDIAN(BIG_ENDIAN_SYSTEM)
 
@@ -59,8 +60,10 @@
 
     "-DLGTD_HAVE_LIBBSD=${HAVE_LIBBSD}"
     "-DLGTD_HAVE_PROCTITLE=${HAVE_PROCTITLE}"
+    "-DLGTD_HAVE_REALLOCARRAY=${HAVE_REALLOCARRAY}"
 
     "-DJSMN_STRICT=1"
+    "-DJSMN_PARENT_LINKS=1"
 )
 
 IF (CMAKE_BUILD_TYPE MATCHES "DEBUG")
diff --git a/CMakeScripts/CompatReallocArray.cmake b/CMakeScripts/CompatReallocArray.cmake
new file mode 100644
--- /dev/null
+++ b/CMakeScripts/CompatReallocArray.cmake
@@ -0,0 +1,33 @@
+IF (DEFINED HAVE_REALLOCARRAY)
+    RETURN()
+ENDIF ()
+
+MESSAGE(STATUS "Looking for reallocarray")
+
+IF (HAVE_LIBBSD)
+    MESSAGE(STATUS "Looking for reallocarray - found")
+    SET(HAVE_REALLOCARRAY 1 CACHE INTERNAL "reallocarray found in libbsd")
+    RETURN()
+ENDIF ()
+
+SET(CMAKE_REQUIRED_QUIET TRUE)
+CHECK_FUNCTION_EXISTS("reallocarray" HAVE_REALLOCARRAY)
+UNSET(CMAKE_REQUIRED_QUIET)
+IF (HAVE_REALLOCARRAY)
+    MESSAGE(STATUS "Looking for reallocarray - found")
+    SET(
+        HAVE_REALLOCARRAY 1
+        CACHE INTERNAL
+        "reallocarray found on the system"
+    )
+ELSE ()
+    MESSAGE(
+        STATUS
+        "Looking for reallocarray - not found, using built-in compatibilty file"
+    )
+    SET(
+        HAVE_REALLOCARRAY 0
+        CACHE INTERNAL
+        "reallocarray not found, using internal implementation"
+    )
+ENDIF ()
diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -53,6 +53,7 @@
         bufferevent_free(client->io);
     }
     free(client->addr);
+    free(client->jsmn_tokens);
     free(client);
 }
 
@@ -80,15 +81,12 @@
     // Get the actual pointer to the beginning of the evbuf:
     const char *buf = (char *)evbuffer_pullup(input, nbytes);
 
+    jsmntok_t *tokens = NULL;
+    int ntokens = 0;
     do {
-        jsmn_init(&client->jsmn_ctx);
-        jsmnerr_t rv = jsmn_parse(
-            &client->jsmn_ctx,
-            buf,
-            nbytes,
-            client->jsmn_tokens,
-            LGTD_ARRAY_SIZE(client->jsmn_tokens)
-        );
+        jsmn_parser jsmn_ctx;
+        jsmn_init(&jsmn_ctx);
+        jsmnerr_t rv = jsmn_parse(&jsmn_ctx, buf, nbytes, tokens, ntokens);
         switch (rv) {
         case JSMN_ERROR_NOMEM:
         case JSMN_ERROR_INVAL:
@@ -110,19 +108,29 @@
             }
             break;
         default:
-            client->json = buf;
-            lgtd_jsonrpc_dispatch_request(client, rv);
-            client->json = NULL;
-            size_t request_size = client->jsmn_tokens[0].end;
-            evbuffer_drain(input, request_size);
-            if (request_size < nbytes) {
-                buf += request_size;
-                nbytes -= request_size;
-                // FIXME: instead of calling jsmn_parse again, return the number
-                // of tokens consumed from jsonrpc and make this case a loop.
-                continue;
+            ntokens = rv;
+            if (tokens) {
+                client->json = buf;
+                lgtd_jsonrpc_dispatch_request(client, ntokens);
+                client->json = NULL;
+                size_t request_size = tokens[0].end;
+                tokens = NULL;
+                evbuffer_drain(input, request_size);
+                if (request_size < nbytes) {
+                    buf += request_size;
+                    nbytes -= request_size;
+                    // FIXME: instead of calling jsmn_parse again, return the
+                    // number of tokens consumed from jsonrpc and make this
+                    // case a loop.
+                    continue;
+                }
+                break;
+            } else {
+                client->jsmn_tokens = reallocarray(
+                    client->jsmn_tokens, ntokens, sizeof(*tokens)
+                );
+                tokens = client->jsmn_tokens;
             }
-            break;
         }
         // pullup and resume parsing:
         buf = (char *)evbuffer_pullup(input, -1);
diff --git a/core/client.h b/core/client.h
--- a/core/client.h
+++ b/core/client.h
@@ -34,15 +34,13 @@
     LIST_ENTRY(lgtd_client)     link;
     struct bufferevent          *io;
     struct sockaddr             *addr;
-    jsmn_parser                 jsmn_ctx;
-    jsmntok_t                   jsmn_tokens[LGTD_CLIENT_JSMN_TOKENS_NUM];
+    jsmntok_t                   *jsmn_tokens;
     const char                  *json;
     struct lgtd_jsonrpc_request *current_request;
 };
 LIST_HEAD(lgtd_client_list, lgtd_client);
 
 struct lgtd_client *lgtd_client_open(evutil_socket_t, const struct sockaddr *, int);
-void lgtd_client_open_from_pipe(struct lgtd_client *);
 void lgtd_client_close_all(void);
 
 void lgtd_client_write_string(struct lgtd_client *, const char *);
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -1162,7 +1162,7 @@
                 );
                 goto error;
             }
-            struct bufferevent *client_io;
+            struct bufferevent *client_io = NULL; // keep compilers happy...
             if (!request->id) {
                 // Ugly hack to behave correctly on jsonrpc notifications, it's
                 // not worth it do it properly right now. It is especially ugly
diff --git a/core/lightsd.h b/core/lightsd.h
--- a/core/lightsd.h
+++ b/core/lightsd.h
@@ -15,6 +15,23 @@
 // You should have received a copy of the GNU General Public License
 // along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
 
+// reallocarray has been copied from OpenBSD under the following license:
+/*
+ * Copyright (c) 2008 Otto Moerbeek <otto@drijf.net>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
 #pragma once
 
 #ifndef __attribute__
@@ -70,6 +87,24 @@
 // reasonable value for that:
 enum { LGTD_SOCKADDR_STRLEN = 128 };
 
+#if !LGTD_HAVE_REALLOCARRAY
+# define MUL_NO_OVERFLOW ((size_t)1 << (sizeof(size_t) * 4))
+static inline void *
+reallocarray(void *optr, size_t nmemb, size_t size)
+{
+    if ((nmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) &&
+        nmemb > 0 && SIZE_MAX / nmemb < size) {
+# ifndef NDEBUG
+        abort();
+# endif
+        return NULL;
+    }
+    return realloc(optr, size * nmemb);
+}
+#elif LGTD_HAVE_LIBBSD
+# include <bsd/bsd.h>
+#endif
+
 struct lgtd_opts {
     bool                foreground;
     bool                log_timestamps;
diff --git a/core/pipe.c b/core/pipe.c
--- a/core/pipe.c
+++ b/core/pipe.c
@@ -52,6 +52,7 @@
     SLIST_REMOVE(&lgtd_command_pipes, pipe, lgtd_command_pipe, link);
     evbuffer_free(pipe->read_buf);
     event_free(pipe->read_ev);
+    free(pipe->client.jsmn_tokens);
     free(pipe);
 }
 
@@ -93,17 +94,14 @@
         }
 
         if (!drain) {
+        jsmntok_t *tokens = NULL;
+        int ntokens = 0;
+        jsmn_parser jsmn_ctx;
         next_request:
-            jsmn_init(&pipe->client.jsmn_ctx);
+            jsmn_init(&jsmn_ctx);
             const char *buf = (char *)evbuffer_pullup(pipe->read_buf, -1);
             ssize_t bufsz = evbuffer_get_length(pipe->read_buf);
-            jsmnerr_t rv = jsmn_parse(
-                &pipe->client.jsmn_ctx,
-                buf,
-                bufsz,
-                pipe->client.jsmn_tokens,
-                LGTD_ARRAY_SIZE(pipe->client.jsmn_tokens)
-            );
+            jsmnerr_t rv = jsmn_parse(&jsmn_ctx, buf, bufsz, tokens, ntokens);
             switch (rv) {
             case JSMN_ERROR_NOMEM:
             case JSMN_ERROR_INVAL:
@@ -122,17 +120,24 @@
                 }
                 break;
             default:
-                pipe->client.json = buf;
-                int ntokens = rv;
-                lgtd_jsonrpc_dispatch_request(&pipe->client, ntokens);
-
-                pipe->client.json = NULL;
-                int request_size = pipe->client.jsmn_tokens[0].end;
-                evbuffer_drain(pipe->read_buf, request_size);
-                if (request_size < bufsz) {
-                    goto next_request;
+                ntokens = rv;
+                if (tokens) {
+                    pipe->client.json = buf;
+                    lgtd_jsonrpc_dispatch_request(&pipe->client, ntokens);
+                    pipe->client.json = NULL;
+                    int request_size = tokens[0].end;
+                    tokens = NULL;
+                    evbuffer_drain(pipe->read_buf, request_size);
+                    if (request_size >= bufsz) {
+                        break;
+                    }
+                } else {
+                    pipe->client.jsmn_tokens = reallocarray(
+                        pipe->client.jsmn_tokens, ntokens, sizeof(*tokens)
+                    );
+                    tokens = pipe->client.jsmn_tokens;
                 }
-                break;
+                goto next_request;
             }
         }
 
@@ -172,7 +177,6 @@
         return false;
     }
 
-    lgtd_client_open_from_pipe(&pipe->client);
     pipe->path = path;
     pipe->fd = -1;
 
diff --git a/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c b/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c
@@ -25,14 +25,12 @@
         "\"id\": \"42\""
     "}");
     struct lgtd_client client = { .json = json };
+    client.jsmn_tokens = calloc(32, sizeof(*client.jsmn_tokens));
     int parsed = parse_json(
-        client.jsmn_tokens,
-        LGTD_ARRAY_SIZE(client.jsmn_tokens),
-        json,
-        sizeof(json)
+        client.jsmn_tokens, 32, json, sizeof(json)
     );
-
-    lgtd_jsonrpc_dispatch_one(&client, client.jsmn_tokens, parsed);
+    struct lgtd_jsonrpc_request req;
+    lgtd_jsonrpc_dispatch_one(&client, client.jsmn_tokens, parsed, &req);
 
     const char expected[] = ("{"
         "\"jsonrpc\": \"2.0\", "
diff --git a/tests/core/pipe/test_pipe_close.c b/tests/core/pipe/test_pipe_close.c
--- a/tests/core/pipe/test_pipe_close.c
+++ b/tests/core/pipe/test_pipe_close.c
@@ -6,6 +6,7 @@
 
 #include "lifx/wire_proto.h"
 
+#include "mock_daemon.h"
 #define MOCKED_EVENT_NEW
 #define MOCKED_EVBUFFER_NEW
 #define MOCKED_EVENT_DEL
@@ -18,7 +19,6 @@
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#include "tests_pipe_utils.h"
 
 char *tmpdir = NULL;
 
diff --git a/tests/core/pipe/test_pipe_open.c b/tests/core/pipe/test_pipe_open.c
--- a/tests/core/pipe/test_pipe_open.c
+++ b/tests/core/pipe/test_pipe_open.c
@@ -6,6 +6,7 @@
 
 #include "lifx/wire_proto.h"
 
+#include "mock_daemon.h"
 #define MOCKED_EVUTIL_MAKE_SOCKET_NONBLOCKING
 #define MOCKED_EVENT_NEW
 #define MOCKED_EVBUFFER_NEW
@@ -17,8 +18,6 @@
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#define MOCKED_CLIENT_OPEN_FROM_PIPE
-#include "tests_pipe_utils.h"
 
 char *tmpdir = NULL;
 
@@ -103,18 +102,6 @@
     return 0;
 }
 
-static int client_open_from_pipe_call_count = 0;
-
-void
-lgtd_client_open_from_pipe(struct lgtd_client *pipe_client)
-{
-    if (!pipe_client) {
-        errx(1, "missing pipe_client");
-    }
-
-    client_open_from_pipe_call_count++;
-}
-
 int
 main(void)
 {
diff --git a/tests/core/pipe/test_pipe_open_fifo_already_exists.c b/tests/core/pipe/test_pipe_open_fifo_already_exists.c
--- a/tests/core/pipe/test_pipe_open_fifo_already_exists.c
+++ b/tests/core/pipe/test_pipe_open_fifo_already_exists.c
@@ -6,6 +6,7 @@
 
 #include "lifx/wire_proto.h"
 
+#include "mock_daemon.h"
 #define MOCKED_EVUTIL_MAKE_SOCKET_NONBLOCKING
 #define MOCKED_EVENT_NEW
 #define MOCKED_EVBUFFER_NEW
@@ -17,8 +18,6 @@
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#define MOCKED_CLIENT_OPEN_FROM_PIPE
-#include "tests_pipe_utils.h"
 
 char *tmpdir = NULL;
 
@@ -103,18 +102,6 @@
     return 0;
 }
 
-static int client_open_from_pipe_call_count = 0;
-
-void
-lgtd_client_open_from_pipe(struct lgtd_client *pipe_client)
-{
-    if (!pipe_client) {
-        errx(1, "missing pipe_client");
-    }
-
-    client_open_from_pipe_call_count++;
-}
-
 int
 main(void)
 {
diff --git a/tests/core/pipe/test_pipe_read_callback.c b/tests/core/pipe/test_pipe_read_callback.c
--- a/tests/core/pipe/test_pipe_read_callback.c
+++ b/tests/core/pipe/test_pipe_read_callback.c
@@ -6,6 +6,7 @@
 
 #include "lifx/wire_proto.h"
 
+#include "mock_daemon.h"
 #define MOCKED_EVENT_NEW
 #define MOCKED_EVENT_DEL
 #define MOCKED_EVBUFFER_NEW
@@ -21,7 +22,6 @@
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#include "tests_pipe_utils.h"
 
 static unsigned char request[] = ("{"
     "\"jsonrpc\": \"2.0\","
@@ -141,13 +141,6 @@
         );
     }
 
-    jsmn_parser jsmn_ctx;
-    jsmn_init(&jsmn_ctx);
-    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
-    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
-        errx(1, "the client json parser context wasn't re-initialized");
-    }
-
     return &request[evbuffer_pullup_call_count++ ? sizeof(request) - 1 : 0];
 }
 
diff --git a/tests/core/pipe/test_pipe_read_callback_extra_data.c b/tests/core/pipe/test_pipe_read_callback_extra_data.c
--- a/tests/core/pipe/test_pipe_read_callback_extra_data.c
+++ b/tests/core/pipe/test_pipe_read_callback_extra_data.c
@@ -6,6 +6,7 @@
 
 #include "lifx/wire_proto.h"
 
+#include "mock_daemon.h"
 #define MOCKED_EVENT_NEW
 #define MOCKED_EVBUFFER_NEW
 #define MOCKED_EVBUFFER_READ
@@ -20,7 +21,6 @@
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#include "tests_pipe_utils.h"
 
 #define REQUEST_1 "{"                   \
     "\"jsonrpc\": \"2.0\","             \
@@ -144,13 +144,6 @@
         );
     }
 
-    jsmn_parser jsmn_ctx;
-    jsmn_init(&jsmn_ctx);
-    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
-    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
-        errx(1, "the client json parser context wasn't re-initialized");
-    }
-
     return &request[evbuffer_pullup_call_count++ ? sizeof(request) - 1 : 0];
 }
 
diff --git a/tests/core/pipe/test_pipe_read_callback_multiple_requests.c b/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
--- a/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
+++ b/tests/core/pipe/test_pipe_read_callback_multiple_requests.c
@@ -6,6 +6,7 @@
 
 #include "lifx/wire_proto.h"
 
+#include "mock_daemon.h"
 #define MOCKED_EVENT_NEW
 #define MOCKED_EVBUFFER_NEW
 #define MOCKED_EVBUFFER_READ
@@ -20,7 +21,6 @@
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#include "tests_pipe_utils.h"
 
 #define REQUEST_1 "{"                   \
     "\"jsonrpc\": \"2.0\","             \
@@ -161,13 +161,6 @@
         );
     }
 
-    jsmn_parser jsmn_ctx;
-    jsmn_init(&jsmn_ctx);
-    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
-    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
-        errx(1, "the client json parser context wasn't re-initialized");
-    }
-
     int offset;
     switch (evbuffer_pullup_call_count) {
     case 0:
diff --git a/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c b/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c
--- a/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c
+++ b/tests/core/pipe/test_pipe_read_callback_yield_on_eagain.c
@@ -6,6 +6,7 @@
 
 #include "lifx/wire_proto.h"
 
+#include "mock_daemon.h"
 #define MOCKED_EVENT_NEW
 #define MOCKED_EVBUFFER_NEW
 #define MOCKED_EVBUFFER_READ
@@ -20,7 +21,6 @@
 #include "mock_timer.h"
 
 #include "tests_utils.h"
-#include "tests_pipe_utils.h"
 
 #define REQUEST_1 "{"                   \
     "\"jsonrpc\": \"2.0\","             \
@@ -161,13 +161,6 @@
         );
     }
 
-    jsmn_parser jsmn_ctx;
-    jsmn_init(&jsmn_ctx);
-    struct lgtd_command_pipe *pipe = SLIST_FIRST(&lgtd_command_pipes);
-    if (memcmp(&pipe->client.jsmn_ctx, &jsmn_ctx, sizeof(jsmn_ctx))) {
-        errx(1, "the client json parser context wasn't re-initialized");
-    }
-
     int offset;
     switch (evbuffer_pullup_call_count) {
     case 0:
diff --git a/tests/core/pipe/tests_pipe_utils.h b/tests/core/pipe/tests_pipe_utils.h
deleted file mode 100644
--- a/tests/core/pipe/tests_pipe_utils.h
+++ /dev/null
@@ -1,12 +0,0 @@
-#pragma once
-
-#include "mock_daemon.h"
-
-#ifndef MOCKED_CLIENT_OPEN_FROM_PIPE
-void
-lgtd_client_open_from_pipe(struct lgtd_client *pipe_client)
-{
-    memset(pipe_client, 0, sizeof(*pipe_client));
-    jsmn_init(&pipe_client->jsmn_ctx);
-}
-#endif
