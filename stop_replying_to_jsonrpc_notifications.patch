# HG changeset patch
# Parent  8403e23edf212b5ab68773db1052d7653c60c9ec

diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -49,7 +49,9 @@
     LGTD_STATS_ADD_AND_UPDATE_PROCTITLE(clients, -1);
 
     LIST_REMOVE(client, link);
-    bufferevent_free(client->io);
+    if (client->io) { // XXX: see ugly hack in lgtd_jsonrpc_dispatch_one
+        bufferevent_free(client->io);
+    }
     free(client->addr);
     free(client);
 }
diff --git a/core/client.h b/core/client.h
--- a/core/client.h
+++ b/core/client.h
@@ -17,7 +17,7 @@
 
 #pragma once
 
-enum { LGTD_CLIENT_JSMN_TOKENS_NUM = 48 };
+enum { LGTD_CLIENT_JSMN_TOKENS_NUM = 96 };
 enum { LGTD_CLIENT_MAX_REQUEST_BUF_SIZE = 2048 };
 
 enum lgtd_client_error_code {
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -1080,10 +1080,26 @@
     );
 }
 
+static void
+lgtd_jsonrpc_batch_prepare_next_part(struct lgtd_client *client,
+                                     const int *batch_sent)
+{
+    assert(client);
+
+    if (batch_sent) {
+        if (*batch_sent == 1) {
+            lgtd_client_write_string(client, "[");
+        } else if (*batch_sent) {
+            lgtd_client_write_string(client, ",");
+        }
+    }
+}
+
 static int
 lgtd_jsonrpc_dispatch_one(struct lgtd_client *client,
                           const jsmntok_t *tokens,
-                          int ntokens)
+                          int ntokens,
+                          int *batch_sent)
 {
     static const struct lgtd_jsonrpc_method methods[] = {
         LGTD_JSONRPC_METHOD(
@@ -1125,6 +1141,13 @@
         )
     };
 
+    if (batch_sent) {
+        ++*batch_sent;
+    }
+
+    enum lgtd_jsonrpc_error_code error_code;
+    const char *error_msg;
+
     struct lgtd_jsonrpc_request request;
     memset(&request, 0, sizeof(request));
     bool ok = lgtd_jsonrpc_check_and_extract_request(
@@ -1132,12 +1155,12 @@
     );
     client->current_request = &request;
     if (!ok) {
-        lgtd_jsonrpc_send_error(
-            client, LGTD_JSONRPC_INVALID_REQUEST, "Invalid request"
-        );
-        return lgtd_jsonrpc_consume_object_or_array(
+        error_code = LGTD_JSONRPC_INVALID_REQUEST;
+        error_msg = "Invalid request";
+        request.request_ntokens = lgtd_jsonrpc_consume_object_or_array(
             tokens, 0, ntokens, client->json
         );
+        goto error;
     }
 
     assert(request.method);
@@ -1154,22 +1177,40 @@
         if (!diff) {
             int params_count = request.params ? request.params->size : 0;
             if (params_count != methods[i].params_count) {
-                lgtd_jsonrpc_send_error(
-                    client, LGTD_JSONRPC_INVALID_PARAMS,
-                    "Invalid number of parameters"
-                );
+                error_code = LGTD_JSONRPC_INVALID_PARAMS;
+                error_msg = "Invalid number of parameters";
                 goto error;
             }
+            struct bufferevent *client_io = NULL; // keep compilers happy...
+            if (!request.id) {
+                // Ugly hack to behave correctly on jsonrpc notifications, it's
+                // not worth it do it properly right now. It is especially ugly
+                // since we can't properly close that client now (but we don't
+                // do that in lgtd_proto and signals are deferred with the
+                // event loop).
+                client_io = client->io;
+                client->io = NULL;
+                if (batch_sent) {
+                    --*batch_sent;
+                }
+            } else {
+                lgtd_jsonrpc_batch_prepare_next_part(client, batch_sent);
+            }
             methods[i].method(client);
+            if (!request.id) {
+                client->io = client_io;
+            }
             client->current_request = NULL;
             return request.request_ntokens;
         }
     }
 
-    lgtd_jsonrpc_send_error(
-        client, LGTD_JSONRPC_METHOD_NOT_FOUND, "Method not found"
-    );
+    error_code = LGTD_JSONRPC_METHOD_NOT_FOUND;
+    error_msg = "Method not found";
+
 error:
+    lgtd_jsonrpc_batch_prepare_next_part(client, batch_sent);
+    lgtd_jsonrpc_send_error(client, error_code, error_msg);
     client->current_request = NULL;
     return request.request_ntokens;
 }
@@ -1188,20 +1229,21 @@
     }
 
     if (!lgtd_jsonrpc_type_array(client->jsmn_tokens, client->json)) {
-        lgtd_jsonrpc_dispatch_one(client, client->jsmn_tokens, parsed);
+        lgtd_jsonrpc_dispatch_one(client, client->jsmn_tokens, parsed, NULL);
         return;
     }
 
-    bool comma = false;
+    int batch_sent = 0;
     for (int ti = 1; ti < parsed;) {
         const jsmntok_t *tok = &client->jsmn_tokens[ti];
 
-        lgtd_client_write_string(client, comma ? "," : "[");
-        comma = true;
-
         if (lgtd_jsonrpc_type_object(tok, client->json)) {
-            ti += lgtd_jsonrpc_dispatch_one(client, tok, parsed - ti);
+            ti += lgtd_jsonrpc_dispatch_one(
+                client, tok, parsed - ti, &batch_sent
+            );
         } else {
+            batch_sent++;
+            lgtd_jsonrpc_batch_prepare_next_part(client, &batch_sent);
             lgtd_jsonrpc_send_error(
                 client, LGTD_JSONRPC_INVALID_REQUEST, "Invalid request"
             );
@@ -1214,5 +1256,8 @@
             }
         }
     }
-    lgtd_client_write_string(client, "]");
+
+    if (batch_sent) {
+        lgtd_client_write_string(client, "]");
+    }
 }
diff --git a/core/pipe.c b/core/pipe.c
--- a/core/pipe.c
+++ b/core/pipe.c
@@ -107,7 +107,7 @@
             switch (rv) {
             case JSMN_ERROR_NOMEM:
             case JSMN_ERROR_INVAL:
-                lgtd_warnx("pipe %s: request too big or invalid", pipe->path);
+                lgtd_warnx("pipe %s: request too big or invalid: %s", pipe->path, buf);
                 // ignore what's left
                 drain = true;
                 break;
diff --git a/tests/core/jsonrpc/test_jsonrpc_batch.c b/tests/core/jsonrpc/test_jsonrpc_batch.c
--- a/tests/core/jsonrpc/test_jsonrpc_batch.c
+++ b/tests/core/jsonrpc/test_jsonrpc_batch.c
@@ -53,6 +53,7 @@
 int
 main(void)
 {
+    jsmntok_t tokens[32];
     const char json[] = ("["
         "{"
             "\"method\": \"power_on\","
@@ -67,12 +68,9 @@
             "\"jsonrpc\": \"2.0\""
         "}"
     "]");
-    struct lgtd_client client = { .json = json };
+    struct lgtd_client client = { .json = json, .jsmn_tokens = tokens };
     int parsed = parse_json(
-        client.jsmn_tokens,
-        LGTD_ARRAY_SIZE(client.jsmn_tokens),
-        json,
-        sizeof(json)
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
     );
 
     lgtd_jsonrpc_dispatch_request(&client, parsed);
diff --git a/tests/core/jsonrpc/test_jsonrpc_batch_notifications_only.c b/tests/core/jsonrpc/test_jsonrpc_batch_notifications_only.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_batch_notifications_only.c
@@ -0,0 +1,90 @@
+#include "jsonrpc.c"
+
+#include "mock_client_buf.h"
+#define MOCKED_LGTD_PROTO_GET_LIGHT_STATE
+#define MOCKED_LGTD_PROTO_POWER_ON
+#include "mock_proto.h"
+#include "test_jsonrpc_utils.h"
+
+static int power_on_call_count = 0;
+
+void
+lgtd_proto_power_on(struct lgtd_client *client,
+                    const struct lgtd_proto_target_list *targets)
+{
+    if (!client) {
+        errx(1, "missing client!");
+    }
+
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+
+    if (power_on_call_count++) {
+        errx(1, "proto_power_on should have been called once");
+    }
+}
+
+static int get_light_state_call_count = 0;
+
+void
+lgtd_proto_get_light_state(struct lgtd_client *client,
+                           const struct lgtd_proto_target_list *targets)
+{
+    if (!client) {
+        errx(1, "missing client!");
+    }
+
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+
+    if (get_light_state_call_count++) {
+        errx(1, "proto_power_on should have been called once");
+    }
+}
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("["
+        "{"
+            "\"method\": \"power_on\","
+            "\"params\": [\"*\"],"
+            "\"jsonrpc\": \"2.0\""
+        "},"
+        "{"
+            "\"method\": \"get_light_state\","
+            "\"params\": [\"*\"],"
+            "\"jsonrpc\": \"2.0\""
+        "}"
+    "]");
+    struct lgtd_client client = { .json = json, .jsmn_tokens = tokens };
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    lgtd_jsonrpc_dispatch_request(&client, parsed);
+
+    if (!power_on_call_count) {
+        errx(1, "power_on was never called");
+    }
+
+    if (!get_light_state_call_count) {
+        errx(1, "get_light_state was never called");
+    }
+
+    const char expected[] = "";
+    if (strcmp(expected, client_write_buf)) {
+        errx(1, "got client buf %s (expected %s)", client_write_buf, expected);
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_batch_one_invalid_request.c b/tests/core/jsonrpc/test_jsonrpc_batch_one_invalid_request.c
--- a/tests/core/jsonrpc/test_jsonrpc_batch_one_invalid_request.c
+++ b/tests/core/jsonrpc/test_jsonrpc_batch_one_invalid_request.c
@@ -30,6 +30,7 @@
 int
 main(void)
 {
+    jsmntok_t tokens[32];
     const char json[] = ("["
         "{"
             "\"method\": \"power_on\","
@@ -44,12 +45,9 @@
             "\"jsonrpc\": \"2.0\""
         "}"
     "]");
-    struct lgtd_client client = { .json = json };
+    struct lgtd_client client = { .json = json, .jsmn_tokens = tokens };
     int parsed = parse_json(
-        client.jsmn_tokens,
-        LGTD_ARRAY_SIZE(client.jsmn_tokens),
-        json,
-        sizeof(json)
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
     );
 
     lgtd_jsonrpc_dispatch_request(&client, parsed);
@@ -58,7 +56,8 @@
         errx(1, "power_on was never called");
     }
 
-    const char expected[] = ("[,"
+    const char expected[] = ("["
+        "," // we mocked the first function
         "{"
             "\"jsonrpc\": \"2.0\", "
             "\"id\": \"1f7a32c8-6741-4ee7-bec1-8431c7d514dc\", "
diff --git a/tests/core/jsonrpc/test_jsonrpc_batch_one_notification.c b/tests/core/jsonrpc/test_jsonrpc_batch_one_notification.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_batch_one_notification.c
@@ -0,0 +1,91 @@
+#include "jsonrpc.c"
+
+#include "mock_client_buf.h"
+#define MOCKED_LGTD_PROTO_GET_LIGHT_STATE
+#define MOCKED_LGTD_PROTO_POWER_ON
+#include "mock_proto.h"
+#include "test_jsonrpc_utils.h"
+
+static int power_on_call_count = 0;
+
+void
+lgtd_proto_power_on(struct lgtd_client *client,
+                    const struct lgtd_proto_target_list *targets)
+{
+    if (!client) {
+        errx(1, "missing client!");
+    }
+
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+
+    if (power_on_call_count++) {
+        errx(1, "proto_power_on should have been called once");
+    }
+}
+
+static int get_light_state_call_count = 0;
+
+void
+lgtd_proto_get_light_state(struct lgtd_client *client,
+                           const struct lgtd_proto_target_list *targets)
+{
+    if (!client) {
+        errx(1, "missing client!");
+    }
+
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+
+    if (get_light_state_call_count++) {
+        errx(1, "proto_power_on should have been called once");
+    }
+}
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("["
+        "{"
+            "\"method\": \"power_on\","
+            "\"id\": \"004daf12-0561-4fbc-bfdb-bfe69cfbf4b5\","
+            "\"params\": [\"*\"],"
+            "\"jsonrpc\": \"2.0\""
+        "},"
+        "{"
+            "\"method\": \"get_light_state\","
+            "\"params\": [\"*\"],"
+            "\"jsonrpc\": \"2.0\""
+        "}"
+    "]");
+    struct lgtd_client client = { .json = json, .jsmn_tokens = tokens };
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    lgtd_jsonrpc_dispatch_request(&client, parsed);
+
+    if (!power_on_call_count) {
+        errx(1, "power_on was never called");
+    }
+
+    if (!get_light_state_call_count) {
+        errx(1, "get_light_state was never called");
+    }
+
+    const char expected[] = "[]";  // we mocked the functions
+    if (strcmp(expected, client_write_buf)) {
+        errx(1, "got client buf %s (expected %s)", client_write_buf, expected);
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c b/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c
@@ -19,6 +19,7 @@
 int
 main(void)
 {
+    jsmntok_t tokens[32];
     const char json[] = ("{"
         "\"jsonrpc\": \"2.0\","
         "\"method\": \"power_on\","
@@ -26,13 +27,10 @@
     "}");
     struct lgtd_client client = { .json = json };
     int parsed = parse_json(
-        client.jsmn_tokens,
-        LGTD_ARRAY_SIZE(client.jsmn_tokens),
-        json,
-        sizeof(json)
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
     );
 
-    lgtd_jsonrpc_dispatch_one(&client, client.jsmn_tokens, parsed);
+    lgtd_jsonrpc_dispatch_one(&client, tokens, parsed, NULL);
 
     const char expected[] = ("{"
         "\"jsonrpc\": \"2.0\", "
