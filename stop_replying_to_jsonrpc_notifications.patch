# HG changeset patch
# Parent  87c34a0a6e12448f22923853d35ccf70826ba2eb

diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -49,7 +49,9 @@
     LGTD_STATS_ADD_AND_UPDATE_PROCTITLE(clients, -1);
 
     LIST_REMOVE(client, link);
-    bufferevent_free(client->io);
+    if (client->io) { // XXX: see ugly hack in lgtd_jsonrpc_dispatch_one
+        bufferevent_free(client->io);
+    }
     free(client);
 }
 
diff --git a/core/client.h b/core/client.h
--- a/core/client.h
+++ b/core/client.h
@@ -17,7 +17,7 @@
 
 #pragma once
 
-enum { LGTD_CLIENT_JSMN_TOKENS_NUM = 48 };
+enum { LGTD_CLIENT_JSMN_TOKENS_NUM = 96 };
 enum { LGTD_CLIENT_MAX_REQUEST_BUF_SIZE = 2048 };
 
 enum lgtd_client_error_code {
diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -1083,7 +1083,8 @@
 static int
 lgtd_jsonrpc_dispatch_one(struct lgtd_client *client,
                           const jsmntok_t *tokens,
-                          int ntokens)
+                          int ntokens,
+                          struct lgtd_jsonrpc_request *request)
 {
     static const struct lgtd_jsonrpc_method methods[] = {
         LGTD_JSONRPC_METHOD(
@@ -1125,12 +1126,11 @@
         )
     };
 
-    struct lgtd_jsonrpc_request request;
-    memset(&request, 0, sizeof(request));
+    memset(request, 0, sizeof(*request));
     bool ok = lgtd_jsonrpc_check_and_extract_request(
-        &request, tokens, ntokens, client->json
+        request, tokens, ntokens, client->json
     );
-    client->current_request = &request;
+    client->current_request = request;
     if (!ok) {
         lgtd_jsonrpc_send_error(
             client, LGTD_JSONRPC_INVALID_REQUEST, "Invalid request"
@@ -1140,19 +1140,21 @@
         );
     }
 
-    assert(request.method);
-    assert(request.request_ntokens);
+    assert(request->method);
+    assert(request->request_ntokens);
 
     for (int i = 0; i != LGTD_ARRAY_SIZE(methods); i++) {
-        int parsed_method_namelen = LGTD_JSONRPC_TOKEN_LEN(request.method);
+        int parsed_method_namelen = LGTD_JSONRPC_TOKEN_LEN(request->method);
         if (parsed_method_namelen != methods[i].namelen) {
             continue;
         }
         int diff = memcmp(
-            methods[i].name, &client->json[request.method->start], methods[i].namelen
+            methods[i].name,
+            &client->json[request->method->start],
+            methods[i].namelen
         );
         if (!diff) {
-            int params_count = request.params ? request.params->size : 0;
+            int params_count = request->params ? request->params->size : 0;
             if (params_count != methods[i].params_count) {
                 lgtd_jsonrpc_send_error(
                     client, LGTD_JSONRPC_INVALID_PARAMS,
@@ -1160,9 +1162,22 @@
                 );
                 goto error;
             }
+            struct bufferevent *client_io;
+            if (!request->id) {
+                // Ugly hack to behave correctly on jsonrpc notifications, it's
+                // not worth it do it properly right now. It is especially ugly
+                // since we can't properly close that client now (but we don't
+                // do that in lgtd_proto and signals are deferred with the
+                // event loop).
+                client_io = client->io;
+                client->io = NULL;
+            }
             methods[i].method(client);
+            if (!request->id) {
+                client->io = client_io;
+            }
             client->current_request = NULL;
-            return request.request_ntokens;
+            return request->request_ntokens;
         }
     }
 
@@ -1171,7 +1186,7 @@
     );
 error:
     client->current_request = NULL;
-    return request.request_ntokens;
+    return request->request_ntokens;
 }
 
 void
@@ -1187,8 +1202,12 @@
         return;
     }
 
+    struct lgtd_jsonrpc_request request = { .id = NULL };
+
     if (!lgtd_jsonrpc_type_array(client->jsmn_tokens, client->json)) {
-        lgtd_jsonrpc_dispatch_one(client, client->jsmn_tokens, parsed);
+        lgtd_jsonrpc_dispatch_one(
+            client, client->jsmn_tokens, parsed, &request
+        );
         return;
     }
 
@@ -1196,11 +1215,15 @@
     for (int ti = 1; ti < parsed;) {
         const jsmntok_t *tok = &client->jsmn_tokens[ti];
 
-        lgtd_client_write_string(client, comma ? "," : "[");
-        comma = true;
+        if (!comma) {
+            lgtd_client_write_string(client, "[");
+            comma = true;
+        } else if (request.id) {
+            lgtd_client_write_string(client, ",");
+        }
 
         if (lgtd_jsonrpc_type_object(tok, client->json)) {
-            ti += lgtd_jsonrpc_dispatch_one(client, tok, parsed - ti);
+            ti += lgtd_jsonrpc_dispatch_one(client, tok, parsed - ti, &request);
         } else {
             lgtd_jsonrpc_send_error(
                 client, LGTD_JSONRPC_INVALID_REQUEST, "Invalid request"
diff --git a/core/pipe.c b/core/pipe.c
--- a/core/pipe.c
+++ b/core/pipe.c
@@ -107,7 +107,7 @@
             switch (rv) {
             case JSMN_ERROR_NOMEM:
             case JSMN_ERROR_INVAL:
-                lgtd_warnx("pipe %s: request too big or invalid", pipe->path);
+                lgtd_warnx("pipe %s: request too big or invalid: %s", pipe->path, buf);
                 // ignore what's left
                 drain = true;
                 break;
