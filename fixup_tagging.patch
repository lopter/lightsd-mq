# HG changeset patch
# Parent  4bcc2f80d419f4e2e4baf803c8ecb9fd6efc4017

diff --git a/lifx/tagging.c b/lifx/tagging.c
new file mode 100644
--- /dev/null
+++ b/lifx/tagging.c
@@ -0,0 +1,135 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#include <sys/queue.h>
+#include <sys/tree.h>
+#include <arpa/inet.h>
+#include <assert.h>
+#include <endian.h>
+#include <err.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <event2/util.h>
+
+#include "wire_proto.h"
+#include "core/time_monotonic.h"
+#include "bulb.h"
+#include "gateway.h"
+#include "tagging.h"
+#include "core/lightsd.h"
+
+struct lgtd_lifx_tag_list lgtd_lifx_tags =
+    LIST_HEAD_INITIALIZER(&lgtd_lifx_tags);
+
+static struct lgtd_lifx_tag *
+lgtd_lifx_tagging_find_tag(const char *tag_label)
+{
+    struct lgtd_lifx_tag *tag = NULL;
+    LIST_FOREACH(tag, &lgtd_lifx_tags, link) {
+        if (!strcmp(tag->label, tag_label)) {
+            break;
+        }
+    }
+    return tag;
+}
+
+static struct lgtd_lifx_site *
+lgtd_lifx_tagging_find_site(struct lgtd_lifx_site_list *sites,
+                            const struct lgtd_lifx_gateway *gw)
+{
+    struct lgtd_lifx_site *site = NULL;
+    LIST_FOREACH(site, sites, link) {
+        if (site->gw == gw) {
+            break;
+        }
+    }
+    return site;
+}
+
+struct lgtd_lifx_tag *
+lgtd_lifx_tagging_incref(const char *tag_label,
+                         const struct lgtd_lifx_gateway *gw)
+{
+    assert(strlen(tag_label) < LGTD_LIFX_LABEL_SIZE);
+    assert(gw);
+
+    bool dealloc_tag = false;
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(tag_label);
+    if (!tag) {
+        tag = calloc(1, sizeof(*tag));
+        if (!tag) {
+            return NULL;
+        }
+        strncpy(tag->label, tag_label, sizeof(tag->label) - 1);
+        LIST_INSERT_HEAD(&lgtd_lifx_tags, tag, link);
+        dealloc_tag = true;
+    }
+
+    struct lgtd_lifx_site *site = lgtd_lifx_tagging_find_site(&tag->sites, gw);
+    if (!site) {
+        site = calloc(1, sizeof(*site));
+        if (!site) {
+            if (dealloc_tag) {
+                LIST_REMOVE(tag, link);
+                free(tag);
+            }
+            errno = ENOMEM;
+            return NULL;
+        }
+        if (dealloc_tag) {
+            lgtd_info("discovered tag [%s]", tag_label);
+        }
+        lgtd_debug(
+            "tag [%s] added to gw [%s]:%hu (site %s)",
+            tag_label, gw->ip_addr, gw->port, lgtd_addrtoa(gw->site.as_array)
+        );
+        site->gw = gw;
+        LIST_INSERT_HEAD(&tag->sites, site, link);
+    }
+
+    return tag;
+}
+
+void
+lgtd_lifx_tagging_decref(struct lgtd_lifx_tag *tag,
+                         const struct lgtd_lifx_gateway *gw)
+{
+    assert(tag);
+    assert(gw);
+
+    struct lgtd_lifx_site *site;
+    site = lgtd_lifx_tagging_find_site(&tag->sites, gw);
+    if (site) {
+        lgtd_debug(
+            "tag [%s] removed from gw [%s]:%hu (site %s)",
+            tag->label, gw->ip_addr, gw->port,
+            lgtd_addrtoa(gw->site.as_array)
+        );
+        LIST_REMOVE(site, link);
+        free(site);
+    }
+    if (LIST_EMPTY(&tag->sites)) {
+        LIST_REMOVE(tag, link);
+        lgtd_info("forgetting unused tag [%s]", tag->label);
+        free(tag);
+    }
+}
diff --git a/lifx/tagging.h b/lifx/tagging.h
new file mode 100644
--- /dev/null
+++ b/lifx/tagging.h
@@ -0,0 +1,37 @@
+// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
+//
+// This file is part of lighstd.
+//
+// lighstd is free software: you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation, either version 3 of the License, or
+// (at your option) any later version.
+//
+// lighstd is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
+
+#pragma once
+
+extern struct lgtd_lifx_tag_list lgtd_lifx_tags;
+
+struct lgtd_lifx_site {
+    LIST_ENTRY(lgtd_lifx_site)      link;
+    const struct lgtd_lifx_gateway  *gw;
+};
+LIST_HEAD(lgtd_lifx_site_list, lgtd_lifx_site);
+
+struct lgtd_lifx_tag {
+    LIST_ENTRY(lgtd_lifx_tag)   link;
+    char                        label[LGTD_LIFX_LABEL_SIZE];
+    struct lgtd_lifx_site_list  sites;
+};
+LIST_HEAD(lgtd_lifx_tag_list, lgtd_lifx_tag);
+
+struct lgtd_lifx_tag *lgtd_lifx_tagging_incref(const char *,
+                                               const struct lgtd_lifx_gateway *);
+void lgtd_lifx_tagging_decref(struct lgtd_lifx_tag *, const struct lgtd_lifx_gateway *);
diff --git a/tests/lifx/gateway/test_gateway_allocate_tag_id_from_lifx_network.c b/tests/lifx/gateway/test_gateway_allocate_tag_id_from_lifx_network.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_allocate_tag_id_from_lifx_network.c
@@ -0,0 +1,122 @@
+#include <string.h>
+
+#include "gateway.c"
+
+#define MOCKED_LIFX_TAGGING_INCREF
+#include "test_gateway_utils.h"
+
+static bool tagging_incref_called = false;
+
+struct lgtd_lifx_tag *
+lgtd_lifx_tagging_incref(const char *label, const struct lgtd_lifx_gateway *gw)
+{
+    if (!label) {
+        errx(1, "missing tag label");
+    }
+    if (!gw) {
+        errx(1, "missing gateway");
+    }
+
+    static struct lgtd_lifx_tag *tag = NULL;
+
+    if (!tag) {
+        tag = calloc(1, sizeof(*tag));
+        strcpy(tag->label, label);
+        struct lgtd_lifx_site *site = calloc(1, sizeof(*site));
+        site->gw = gw;
+        LIST_INSERT_HEAD(&tag->sites, site, link);
+    }
+
+    tagging_incref_called = true;
+
+    return tag;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    struct lgtd_lifx_packet_header hdr;
+    memset(&hdr, 0, sizeof(hdr));
+
+    lgtd_lifx_gateway_allocate_tag_id(&gw, 4, "test");
+    if (!gw.tags[4]) {
+        errx(1, "gw.tag_ids[4] shouldn't be NULL");
+    }
+    if (strcmp(gw.tags[4]->label, "test")) {
+        errx(
+            1, "unexpected tag %.*s (expected test)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[4]->label
+        );
+    }
+    if (gw.tag_ids != TAG_ID_TO_VALUE(4)) {
+        errx(
+            1, "tag_ids = %jx (expected %jx)",
+            (uintmax_t)gw.tag_ids, (uintmax_t)TAG_ID_TO_VALUE(4)
+        );
+    }
+
+    lgtd_lifx_gateway_allocate_tag_id(&gw, 63, "test");
+    if (!gw.tags[4]) {
+        errx(1, "gw.tag_ids[4] shouldn't be NULL");
+    }
+    if (strcmp(gw.tags[4]->label, "test")) {
+        errx(
+            1, "unexpected tag %.*s (expected test)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[4]->label
+        );
+    }
+    if (!gw.tags[63]) {
+        errx(1, "gw.tag_ids[63] shouldn't be NULL");
+    }
+    if (strcmp(gw.tags[63]->label, "test")) {
+        errx(
+            1, "unexpected tag %.*s (expected test)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[4]->label
+        );
+    }
+    if (gw.tag_ids != (TAG_ID_TO_VALUE(4) | TAG_ID_TO_VALUE(63))) {
+        errx(
+            1, "tag_ids = %jx (expected %jx)",
+            (uintmax_t)gw.tag_ids,
+            (uintmax_t)(TAG_ID_TO_VALUE(4) | TAG_ID_TO_VALUE(63))
+        );
+    }
+
+    tagging_incref_called = false;
+    lgtd_lifx_gateway_allocate_tag_id(&gw, 4, "test");
+    if (!gw.tags[4]) {
+        errx(1, "gw.tag_ids[4] shouldn't be NULL");
+    }
+    if (strcmp(gw.tags[4]->label, "test")) {
+        errx(
+            1, "unexpected tag %.*s (expected test)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[4]->label
+        );
+    }
+    if (!gw.tags[63]) {
+        errx(1, "gw.tag_ids[63] shouldn't be NULL");
+    }
+    if (strcmp(gw.tags[63]->label, "test")) {
+        errx(
+            1, "unexpected tag %.*s (expected test)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[4]->label
+        );
+    }
+    if (gw.tag_ids != (TAG_ID_TO_VALUE(4) | TAG_ID_TO_VALUE(63))) {
+        errx(
+            1, "tag_ids = %jx (expected %jx)",
+            (uintmax_t)gw.tag_ids,
+            (uintmax_t)(TAG_ID_TO_VALUE(4) | TAG_ID_TO_VALUE(63))
+        );
+    }
+    if (tagging_incref_called) {
+        errx(1, "lgtd_lifx_tagging_incref shouldn't have been called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_deallocate_tag_id_from_lifx_network.c b/tests/lifx/gateway/test_gateway_deallocate_tag_id_from_lifx_network.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_deallocate_tag_id_from_lifx_network.c
@@ -0,0 +1,72 @@
+#include <string.h>
+
+#include "gateway.c"
+
+#define MOCKED_LIFX_TAGGING_DECREF
+#include "test_gateway_utils.h"
+
+static bool tagging_decref_called = false;
+
+void
+lgtd_lifx_tagging_decref(struct lgtd_lifx_tag *tag, const struct lgtd_lifx_gateway *gw)
+{
+    if (!tag) {
+        errx(1, "missing tag");
+    }
+    if (!gw) {
+        errx(1, "missing gateway");
+    }
+
+    tagging_decref_called = true;
+}
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    struct lgtd_lifx_packet_header hdr;
+    memset(&hdr, 0, sizeof(hdr));
+
+    struct lgtd_lifx_tag tag = {
+        .label = "test",
+        .sites = LIST_HEAD_INITIALIZER(&tag.sites)
+    };
+
+    gw.tags[0] = &tag;
+    gw.tag_ids = TAG_ID_TO_VALUE(0) | TAG_ID_TO_VALUE(42);
+
+    lgtd_lifx_gateway_deallocate_tag_id(&gw, 0);
+    if (gw.tags[0]) {
+        errx(1, "gw.tags[0] should have been set to NULL");
+    }
+    if (gw.tag_ids != TAG_ID_TO_VALUE(42)) {
+        errx(
+            1, "unexpected gw.tag_ids value = %jx (expected %jx)",
+            gw.tag_ids, TAG_ID_TO_VALUE(42)
+        );
+    }
+    if (!tagging_decref_called) {
+        errx(1, "lgtd_lifx_tagging_decref should have been called");
+    }
+
+    tagging_decref_called = false;
+    lgtd_lifx_gateway_deallocate_tag_id(&gw, 0);
+    if (gw.tags[0]) {
+        errx(1, "gw.tags[0] should be NULL");
+    }
+    if (gw.tag_ids != TAG_ID_TO_VALUE(42)) {
+        errx(
+            1, "unexpected gw.tag_ids value = %jx (expected %jx)",
+            gw.tag_ids, TAG_ID_TO_VALUE(42)
+        );
+    }
+    if (tagging_decref_called) {
+        errx(1, "lgtd_lifx_tagging_decref shouldn't have been called");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/gateway/test_gateway_handle_tag_labels.c b/tests/lifx/gateway/test_gateway_handle_tag_labels.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/gateway/test_gateway_handle_tag_labels.c
@@ -0,0 +1,78 @@
+#include <string.h>
+
+#include "gateway.c"
+
+#include "test_gateway_utils.h"
+
+int
+main(void)
+{
+    lgtd_lifx_wire_load_packet_infos_map();
+
+    struct lgtd_lifx_gateway gw;
+    memset(&gw, 0, sizeof(gw));
+
+    struct lgtd_lifx_packet_header hdr;
+    memset(&hdr, 0, sizeof(hdr));
+
+    struct lgtd_lifx_packet_tag_labels pkt = {
+        .label = "test", .tags = 0
+    };
+
+    lgtd_lifx_gateway_handle_tag_labels(&gw, &hdr, &pkt);
+    if (gw.tag_ids != 0) {
+        errx(1, "expected gw.tags == 0 but got %jx", (uintmax_t)gw.tags);
+    }
+
+    pkt.tags = TAG_ID_TO_VALUE(42);
+    lgtd_lifx_gateway_handle_tag_labels(&gw, &hdr, &pkt);
+    if (gw.tag_ids != TAG_ID_TO_VALUE(42)) {
+        errx(
+            1, "expected gw.tags == %jx but got %jx",
+            TAG_ID_TO_VALUE(42), (uintmax_t)gw.tags
+        );
+    }
+    if (!gw.tags[42]) {
+        errx(1, "tag_id 42 should have been set");
+    }
+    if (strcmp(gw.tags[42]->label, pkt.label)) {
+        errx(
+            1, "unexpected label %.*s (expected %s)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[42]->label, pkt.label
+        );
+    }
+
+    strcpy(pkt.label, "toto");
+    pkt.tags = TAG_ID_TO_VALUE(2) | TAG_ID_TO_VALUE(4);
+    lgtd_lifx_gateway_handle_tag_labels(&gw, &hdr, &pkt);
+    memset(&pkt, 0, sizeof(pkt));
+    lgtd_lifx_gateway_handle_tag_labels(&gw, &hdr, &pkt);
+    uint64_t expected;
+    expected = TAG_ID_TO_VALUE(42) | TAG_ID_TO_VALUE(2) | TAG_ID_TO_VALUE(4);
+    if (gw.tag_ids != expected) {
+        errx(
+            1, "expected gw.tags == %jx but got %jx",
+            TAG_ID_TO_VALUE(42), (uintmax_t)gw.tags
+        );
+    }
+    if (strcmp(gw.tags[2]->label, "toto")) {
+        errx(
+            1, "unexpected label %.*s (expected %s)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[2]->label, "toto"
+        );
+    }
+    if (strcmp(gw.tags[4]->label, "toto")) {
+        errx(
+            1, "unexpected label %.*s (expected %s)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[4]->label, "toto"
+        );
+    }
+    if (strcmp(gw.tags[42]->label, "test")) {
+        errx(
+            1, "unexpected label %.*s (expected %s)",
+            (int)sizeof(gw.tags[0]->label), gw.tags[42]->label, "test"
+        );
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/tagging/CMakeLists.txt b/tests/lifx/tagging/CMakeLists.txt
new file mode 100644
--- /dev/null
+++ b/tests/lifx/tagging/CMakeLists.txt
@@ -0,0 +1,19 @@
+INCLUDE_DIRECTORIES(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+ADD_LIBRARY(
+    test_lifx_tagging STATIC
+    ${LIGHTSD_SOURCE_DIR}/core/log.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
+)
+
+FUNCTION(ADD_TAGGING_TEST TEST_SOURCE)
+    ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE} test_lifx_tagging)
+ENDFUNCTION()
+
+FILE(GLOB TESTS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} "test_*.c")
+FOREACH(TEST ${TESTS})
+    ADD_TAGGING_TEST(${TEST})
+ENDFOREACH()
diff --git a/tests/lifx/tagging/test_tagging_decref.c b/tests/lifx/tagging/test_tagging_decref.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/tagging/test_tagging_decref.c
@@ -0,0 +1,67 @@
+#include "tagging.c"
+
+static int
+count_tag(const char *tag_label)
+{
+    int count = 0;
+    struct lgtd_lifx_tag *tag;
+    LIST_FOREACH(tag, &lgtd_lifx_tags, link) {
+        if (!strcmp(tag_label, tag->label)) {
+            count++;
+        }
+    }
+    return count;
+}
+
+static int
+count_site(struct lgtd_lifx_site_list *list, const struct lgtd_lifx_gateway *gw)
+{
+    int count = 0;
+    struct lgtd_lifx_site *site;
+    LIST_FOREACH(site, list, link) {
+        if (site->gw == gw) {
+            count++;
+        }
+    }
+    return count;
+}
+
+int
+main(void)
+{
+    struct lgtd_lifx_gateway gw1, gw2;
+    memset(&gw1, 0, sizeof(gw1));
+    memset(&gw2, 0, sizeof(gw2));
+
+    struct lgtd_lifx_site *site_gw1 = calloc(1, sizeof(*site_gw1));
+    site_gw1->gw = &gw1;
+    struct lgtd_lifx_site *site_gw2 = calloc(1, sizeof(*site_gw2));
+    site_gw2->gw = &gw2;
+
+    const char *rawr = "rawr";
+    struct lgtd_lifx_tag *tag = calloc(1, sizeof(*tag));
+    strcpy(tag->label, rawr);
+    LIST_INSERT_HEAD(&tag->sites, site_gw1, link);
+    LIST_INSERT_HEAD(&tag->sites, site_gw2, link);
+    LIST_INSERT_HEAD(&lgtd_lifx_tags, tag, link);
+
+    for (int i = 0; i != 2; i++) {
+        lgtd_lifx_tagging_decref(tag, &gw2);
+        if (count_site(&tag->sites, &gw2) != 0) {
+            errx(1, "gw2 shouldn't be in the sites list");
+        }
+        if (count_site(&tag->sites, &gw1) != 1) {
+            errx(1, "gw1 wasn't found once in the sites list");
+        }
+        if (count_tag(rawr) != 1) {
+            errx(1, "%s wasn't found once in the tags list");
+        }
+    }
+
+    lgtd_lifx_tagging_decref(tag, &gw1);
+    if (count_tag(rawr)) {
+        errx(1, "the tags list should be empty");
+    }
+
+    return 0;
+}
diff --git a/tests/lifx/tagging/test_tagging_incref.c b/tests/lifx/tagging/test_tagging_incref.c
new file mode 100644
--- /dev/null
+++ b/tests/lifx/tagging/test_tagging_incref.c
@@ -0,0 +1,65 @@
+#include "tagging.c"
+
+static int
+count_tag(const char *tag_label)
+{
+    int count = 0;
+    struct lgtd_lifx_tag *tag;
+    LIST_FOREACH(tag, &lgtd_lifx_tags, link) {
+        if (!strcmp(tag_label, tag->label)) {
+            count++;
+        }
+    }
+    return count;
+}
+
+static int
+count_site(struct lgtd_lifx_site_list *list, const struct lgtd_lifx_gateway *gw)
+{
+    int count = 0;
+    struct lgtd_lifx_site *site;
+    LIST_FOREACH(site, list, link) {
+        if (site->gw == gw) {
+            count++;
+        }
+    }
+    return count;
+}
+
+int
+main(void)
+{
+    struct lgtd_lifx_gateway gw1, gw2;
+    memset(&gw1, 0, sizeof(gw1));
+    memset(&gw2, 0, sizeof(gw2));
+
+    const char *rawr = "rawr";
+    const char *awww = "awww";
+
+    for (int i = 0; i != 2; i++) {
+        lgtd_lifx_tagging_incref(rawr, &gw1);
+        if (count_tag(rawr) != 1) {
+            errx(1, "%s wasn't found once the list of tags", rawr);
+        }
+        if (count_site(&LIST_FIRST(&lgtd_lifx_tags)->sites, &gw1) != 1) {
+            errx(1, "site %p wasn't found once in the list of sites", &gw1);
+        }
+    }
+
+    lgtd_lifx_tagging_incref(rawr, &gw2);
+    struct lgtd_lifx_tag *tag = lgtd_lifx_tagging_find_tag(rawr);
+    if (count_site(&tag->sites, &gw2) != 1) {
+        errx(1, "gw2 wasn't found once in the sites of tag %s", tag->label);
+    }
+
+    lgtd_lifx_tagging_incref(awww, &gw1);
+    if (count_tag(awww) != 1) {
+        errx(1, "%s wasn't found once in the list of tags", awww);
+    }
+    tag = lgtd_lifx_tagging_find_tag(awww);
+    if (count_site(&tag->sites, &gw1) != 1) {
+        errx(1, "gw1 wasn't found once in the sites of tag %s", awww);
+    }
+
+    return 0;
+}
