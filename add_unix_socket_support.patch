# HG changeset patch
# Parent  e42f250e88b5a28532e25521a60238a483f8655e
Add support for unix sockets with the -s option (--socket)

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,10 +1,11 @@
-CMAKE_MINIMUM_REQUIRED(VERSION 2.8.11)  # first version TARGET_INCLUDE_DIRECTORIES
+# first version with TARGET_INCLUDE_DIRECTORIES:
+CMAKE_MINIMUM_REQUIRED(VERSION 2.8.11)
 
 PROJECT(LIGHTSD C)
 
 SET(CPACK_PACKAGE_VERSION_MAJOR "0")
 SET(CPACK_PACKAGE_VERSION_MINOR "9")
-SET(CPACK_PACKAGE_VERSION_PATCH "1")
+SET(CPACK_PACKAGE_VERSION_PATCH "2")
 SET(LIGHTSD_VERSION "${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}")
 
 MESSAGE(STATUS "CMake version: ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}")
@@ -14,7 +15,7 @@
 MESSAGE(STATUS "Install prefix: ${CMAKE_INSTALL_PREFIX}")
 MESSAGE(STATUS "Source directory: ${LIGHTSD_SOURCE_DIR}")
 
-SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${LIGHTSD_SOURCE_DIR}/CMakeScripts)
+SET(CMAKE_MODULE_PATH "${CMAKE_MODULE_PATH}" "${LIGHTSD_SOURCE_DIR}/CMakeScripts")
 
 ENABLE_TESTING()
 
@@ -38,9 +39,11 @@
 
 SET(CMAKE_EXPORT_COMPILE_COMMANDS TRUE)
 
-SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE}} -pipe")
+SET(CMAKE_C_FLAGS "-pipe ${CMAKE_C_FLAGS}")
+STRING(STRIP "${CMAKE_C_FLAGS}" CMAKE_C_FLAGS)
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE}}")
+STRING(STRIP "${CMAKE_C_FLAGS}" CMAKE_C_FLAGS)
 SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wextra -Wall -Wstrict-prototypes -std=c99")
-STRING(STRIP "${CMAKE_C_FLAGS}" CMAKE_C_FLAGS)
 SET(CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE} "")
 
 ADD_DEFINITIONS(
diff --git a/README.rst b/README.rst
--- a/README.rst
+++ b/README.rst
@@ -33,8 +33,8 @@
 - set_label;
 - tag/untag (group/ungroup bulbs together).
 
-The JSON-RPC interface works on top of TCP/IPv4/v6 or over a command pipe (named
-pipe, see mkfifo(1)).
+The JSON-RPC interface works on top of TCP/IPv4/v6, Unix sockets, or over a
+command pipe (named pipe, see mkfifo(1)).
 
 lightsd can target single or multiple bulbs at once:
 
diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -69,6 +69,9 @@
 
     struct lgtd_client *client = ctx;
 
+    char addr[LGTD_SOCKADDR_STRLEN];
+    LGTD_SOCKADDRTOA(client->addr, addr);
+
     struct evbuffer *input = bufferevent_get_input(bev);
     size_t nbytes = evbuffer_get_contiguous_space(input);
     // Get the actual pointer to the beginning of the evbuf:
@@ -86,10 +89,7 @@
         switch (rv) {
         case JSMN_ERROR_NOMEM:
         case JSMN_ERROR_INVAL:
-            lgtd_warnx(
-                "client [%s]:%hu: request too big or invalid",
-                client->ip_addr, client->port
-            );
+            lgtd_warnx("client %s: request too big or invalid", addr);
             evbuffer_drain(input, nbytes);
             break;
         case JSMN_ERROR_PART:
@@ -100,10 +100,7 @@
             (void)0;
             size_t buflen = evbuffer_get_length(input);
             if (buflen > LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) {
-                lgtd_warnx(
-                    "client [%s]:%hu: request too big or invalid",
-                    client->ip_addr, client->port
-                );
+                lgtd_warnx("client %s: request too big or invalid", addr);
                 evbuffer_drain(input, buflen);
             } else if (nbytes == buflen) {
                 return; // We pulled up everything already, wait for more data
@@ -139,10 +136,10 @@
     struct lgtd_client *client = ctx;
 
     if (events & (BEV_EVENT_ERROR|BEV_EVENT_EOF)) {
-        lgtd_info(
-            "lost connection with client [%s]:%hu",
-            client->ip_addr, client->port
-        );
+        char addr[LGTD_SOCKADDR_STRLEN];
+        lgtd_info("lost connection with client %s", LGTD_SOCKADDRTOA(
+            client->addr, addr
+        ));
         lgtd_client_close(client);
     }
 }
@@ -197,21 +194,29 @@
 }
 
 struct lgtd_client *
-lgtd_client_open(evutil_socket_t peer, const struct sockaddr_storage *peer_addr)
+lgtd_client_open(evutil_socket_t peer, const struct sockaddr *addr, int addrlen)
 {
     assert(peer != -1);
-    assert(peer_addr);
+    assert(addr);
 
     struct lgtd_client *client = calloc(1, sizeof(*client));
     if (!client) {
         return NULL;
     }
+
     client->io = bufferevent_socket_new(
         lgtd_ev_base, peer, BEV_OPT_CLOSE_ON_FREE
     );
     if (!client->io) {
-        return NULL;
+        goto error;
     }
+
+    client->addr = calloc(1, addrlen);
+    if (!client->addr) {
+        goto error;
+    }
+    memcpy(client->addr, addr, addrlen);
+
     bufferevent_setcb(
         client->io,
         lgtd_client_read_callback,
@@ -219,15 +224,23 @@
         lgtd_client_event_callback,
         client
     );
-    lgtd_sockaddrtoa(peer_addr, client->ip_addr, sizeof(client->ip_addr));
-    client->port = lgtd_sockaddrport(peer_addr);
-    bufferevent_enable(client->io, EV_READ|EV_WRITE|EV_TIMEOUT);
+    if (bufferevent_enable(client->io, EV_READ|EV_WRITE|EV_TIMEOUT) == -1) {
+        goto error;
+    }
 
     LIST_INSERT_HEAD(&lgtd_clients, client, link);
 
     LGTD_STATS_ADD_AND_UPDATE_PROCTITLE(clients, 1);
 
     return client;
+
+error:
+    if (client->io) {
+        bufferevent_free(client->io);
+    }
+    free(client->addr);
+    free(client);
+    return NULL;
 }
 
 void
diff --git a/core/client.h b/core/client.h
--- a/core/client.h
+++ b/core/client.h
@@ -33,8 +33,7 @@
 struct lgtd_client {
     LIST_ENTRY(lgtd_client)     link;
     struct bufferevent          *io;
-    char                        ip_addr[INET6_ADDRSTRLEN];
-    uint16_t                    port;
+    struct sockaddr             *addr;
     jsmn_parser                 jsmn_ctx;
     jsmntok_t                   jsmn_tokens[LGTD_CLIENT_JSMN_TOKENS_NUM];
     const char                  *json;
@@ -42,7 +41,7 @@
 };
 LIST_HEAD(lgtd_client_list, lgtd_client);
 
-struct lgtd_client *lgtd_client_open(evutil_socket_t, const struct sockaddr_storage *);
+struct lgtd_client *lgtd_client_open(evutil_socket_t, const struct sockaddr *, int);
 void lgtd_client_open_from_pipe(struct lgtd_client *);
 void lgtd_client_close_all(void);
 
diff --git a/core/daemon.c b/core/daemon.c
--- a/core/daemon.c
+++ b/core/daemon.c
@@ -135,9 +135,10 @@
     }                                                         \
 } while (0)
 
+    char addr[LGTD_SOCKADDR_STRLEN];
     LOOP(
         SLIST, &lgtd_listeners, struct lgtd_listen,
-        "listening_on", "%s:[%s]", it->addr, it->port
+        "listening_on", "%s", LGTD_SOCKADDRTOA(it->sockaddr, addr)
     );
 
     LOOP(
diff --git a/core/lightsd.c b/core/lightsd.c
--- a/core/lightsd.c
+++ b/core/lightsd.c
@@ -76,20 +76,6 @@
 #endif
 }
 
-short
-lgtd_sockaddrport(const struct sockaddr_storage *peer)
-{
-    assert(peer);
-
-    if (peer->ss_family == AF_INET) {
-        const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
-        return ntohs(in_peer->sin_port);
-    } else {
-        const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
-        return ntohs(in6_peer->sin6_port);
-    }
-}
-
 static void
 lgtd_signal_event_callback(int signum, short events, void *ctx)
 {
@@ -143,6 +129,8 @@
 "  [-c,--comand-pipe /command/fifo [+]] Open an unidirectional JSON-RPC \n"
 "                                       command pipe at this location (can \n"
 "                                       be repeated).\n"
+"  [-s,--socket /unix/socket [+]]       Open an Unix socket at this location \n"
+"                                       (can be repeated).\n"
 "  [-f,--foreground]                    Stay in the foreground (default).\n"
 "  [-d,--daemonize]                     Fork in the background.\n"
 "  [-t,--no-timestamps]                 Disable timestamps in logs.\n"
@@ -168,6 +156,7 @@
     static const struct option long_opts[] = {
         {"listen",          required_argument, NULL, 'l'},
         {"command-pipe",    required_argument, NULL, 'c'},
+        {"socket",          required_argument, NULL, 's'},
         {"foreground",      no_argument,       NULL, 'f'},
         {"daemonize",       no_argument,       NULL, 'd'},
         {"no-timestamps",   no_argument,       NULL, 't'},
@@ -177,7 +166,7 @@
         {"prefix",          no_argument,       NULL, 'p'},
         {NULL,              0,                 NULL, 0}
     };
-    const char short_opts[] = "l:c:fdthv:V";
+    const char short_opts[] = "l:c:s:fdthv:V";
 
     if (argc == 1) {
         lgtd_usage(argv[0]);
@@ -203,6 +192,11 @@
                 exit(1);
             }
             break;
+        case 's':
+            if (!lgtd_listen_unix_open(optarg)) {
+                exit(1);
+            }
+            break;
         case 'f':
             lgtd_opts.foreground = true;
             break;
@@ -229,6 +223,7 @@
             break;
         case 'V':
             printf("lightsd %s\n", LGTD_VERSION);
+            lgtd_cleanup();
             return 0;
         case 'p':
             printf(
diff --git a/core/lightsd.h b/core/lightsd.h
--- a/core/lightsd.h
+++ b/core/lightsd.h
@@ -66,6 +66,8 @@
 
 enum { LGTD_ERROR_MSG_BUFSIZE = 2048 };
 
+enum { LGTD_SOCKADDR_STRLEN = 128 };  // should be >= sockaddr_un.sun_path
+
 struct lgtd_opts {
     bool                foreground;
     bool                log_timestamps;
@@ -79,8 +81,9 @@
 char *lgtd_iee8023mactoa(const uint8_t *addr, char *buf, int buflen);
 #define LGTD_IEEE8023MACTOA(addr, buf) \
     lgtd_iee8023mactoa((addr), (buf), sizeof(buf))
-void lgtd_sockaddrtoa(const struct sockaddr_storage *, char *buf, int buflen);
-short lgtd_sockaddrport(const struct sockaddr_storage *);
+char *lgtd_sockaddrtoa(const struct sockaddr *, char *buf, int buflen);
+#define LGTD_SOCKADDRTOA(addr, buf) \
+    lgtd_sockaddrtoa((addr), (buf), sizeof(buf))
 
 char *lgtd_print_duration(uint64_t, char *, int);
 #define LGTD_PRINT_DURATION(secs, arr) \
diff --git a/core/listen.c b/core/listen.c
--- a/core/listen.c
+++ b/core/listen.c
@@ -16,8 +16,12 @@
 // along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <sys/queue.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/un.h>
 #include <assert.h>
 #include <err.h>
+#include <errno.h>
 #include <stdbool.h>
 #include <stdlib.h>
 #include <string.h>
@@ -39,26 +43,38 @@
 static void
 lgtd_listen_accept_new_client(struct evconnlistener *evlistener,
                               evutil_socket_t peer,
-                              struct sockaddr *peer_addr,
+                              struct sockaddr *addr,
                               int addrlen,
                               void *ctx)
 {
     (void)evlistener;
-    (void)addrlen;
+    struct lgtd_listen *listener = ctx;
 
-    struct lgtd_listen *listener = ctx;
-    struct lgtd_client *client = lgtd_client_open(
-        peer, (struct sockaddr_storage *)peer_addr
-    );
-    if (client) {
-        lgtd_info(
-            "accepted new client [%s]:%hu", client->ip_addr, client->port
+    char bufserver[LGTD_SOCKADDR_STRLEN];
+    LGTD_SOCKADDRTOA(listener->sockaddr, bufserver);
+
+    struct lgtd_client *client = NULL;
+    if (addr->sa_family == AF_UNIX) {
+        struct sockaddr_storage sockname;
+        memset(&sockname, 0, sizeof(sockname));
+        ev_socklen_t socklen = sizeof(sockname);
+        getsockname(peer, (struct sockaddr *)&sockname, &socklen);
+        client = lgtd_client_open(peer, (struct sockaddr *)&sockname, socklen);
+    } else {
+        client = lgtd_client_open(peer, addr, addrlen);
+    }
+
+    if (!client) {
+        char bufclient[LGTD_SOCKADDR_STRLEN];
+        lgtd_warn(
+            "can't accept new client %s on %s",
+            LGTD_SOCKADDRTOA(client->addr, bufclient),
+            bufserver
         );
         return;
     }
-    lgtd_warn(
-        "can't accept new client on %s:%s", listener->addr, listener->port
-    );
+
+    lgtd_info("accepted new client %s", bufserver);
 }
 
 void
@@ -67,7 +83,15 @@
     while (!SLIST_EMPTY(&lgtd_listeners)) {
         struct lgtd_listen *listener = SLIST_FIRST(&lgtd_listeners);
         SLIST_REMOVE_HEAD(&lgtd_listeners, link);
+        if (listener->sockaddr->sa_family == AF_UNIX) {
+            struct sockaddr_un *sockpath;
+            sockpath = (struct sockaddr_un *)listener->sockaddr;
+            unlink(sockpath->sun_path);
+        }
         evconnlistener_free(listener->evlistener);
+        char addr[LGTD_SOCKADDR_STRLEN];
+        LGTD_SOCKADDRTOA(listener->sockaddr, addr);
+        lgtd_info("closed socket %s", addr);
         free(listener);
     }
 
@@ -80,13 +104,6 @@
     assert(addr);
     assert(port);
 
-    struct lgtd_listen *listener;
-    SLIST_FOREACH(listener, &lgtd_listeners, link) {
-        if (!strcmp(listener->addr, addr) && listener->port == port) {
-            return true;
-        }
-    }
-
     struct evutil_addrinfo *res = NULL, hints = {
         .ai_family = AF_UNSPEC,
         .ai_socktype = SOCK_STREAM,
@@ -102,13 +119,25 @@
         return false;
     }
 
+    struct lgtd_listen *listener;
     struct evconnlistener *evlistener;
     for (struct evutil_addrinfo *it = res; it; it = it->ai_next) {
+        SLIST_FOREACH(listener, &lgtd_listeners, link) {
+            if (listener->addrlen == it->ai_addrlen
+                && memcmp(listener->sockaddr, it->ai_addr, it->ai_addrlen)) {
+                return true;
+            }
+        }
+
         evlistener = NULL;
         listener = calloc(1, sizeof(*listener));
         if (!listener) {
             goto error;
         }
+        listener->sockaddr = calloc(1, it->ai_addrlen);
+        if (!listener->sockaddr) {
+            goto error;
+        }
         evlistener = evconnlistener_new_bind(
             lgtd_ev_base,
             lgtd_listen_accept_new_client,
@@ -121,9 +150,11 @@
         if (!evlistener) {
             goto error;
         }
+
         listener->evlistener = evlistener;
-        listener->addr = addr;
-        listener->port = port;
+        listener->addrlen = it->ai_addrlen;
+        memcpy(listener->sockaddr, it->ai_addr, it->ai_addrlen);
+
         SLIST_INSERT_HEAD(&lgtd_listeners, listener, link);
         lgtd_info(
             "listening on %s:%s (%s)",
@@ -139,10 +170,110 @@
 
 error:
     lgtd_warn("can't listen on %s:%s", addr, port);
-    if (evlistener) {
-        evconnlistener_free(evlistener);
+    if (listener) {
+        if (listener->evlistener) {
+            evconnlistener_free(evlistener);
+        }
+        free(listener->sockaddr);
+        free(listener);
     }
-    free(listener);
     evutil_freeaddrinfo(res);
     return false;
 }
+
+bool
+lgtd_listen_unix_open(const char *path)
+{
+    assert(path);
+
+    static const int maxpathlen =
+        sizeof(struct sockaddr_un) - offsetof(struct sockaddr_un, sun_path);
+    int pathlen = strlen(path);
+    if (pathlen > maxpathlen) {
+        lgtd_warnx(
+            "%s (%d bytes) is too long, your system only supports paths up to "
+            "%d bytes", path, pathlen, maxpathlen
+        );
+        return false;
+    }
+
+    struct lgtd_listen *listener;
+    SLIST_FOREACH(listener, &lgtd_listeners, link) {
+        if (listener->addrlen == sizeof(struct sockaddr_un)) {
+            struct sockaddr_un *sockaddr;
+            sockaddr = (struct sockaddr_un *)listener->sockaddr;
+            if (!strcmp(sockaddr->sun_path, path)) {
+                return true;
+            }
+        }
+    }
+
+    evutil_socket_t fd = -1;
+
+    listener = calloc(1, sizeof(*listener));
+    if (!listener) {
+        goto error;
+    }
+
+    struct sockaddr_un *sockpath = calloc(1, sizeof(*sockpath));
+    if (!sockpath) {
+        goto error;
+    }
+    sockpath->sun_family = AF_UNIX;
+    memcpy(sockpath->sun_path, path, pathlen);
+    listener->sockaddr = (struct sockaddr *)sockpath;
+    listener->addrlen = sizeof(*sockpath);
+
+    fd = socket(AF_UNIX, SOCK_STREAM, 0);
+    if (fd == -1) {
+        goto error;
+    }
+
+    if (evutil_make_socket_nonblocking(fd) == -1) {
+        goto error;
+    }
+
+    struct stat sb;
+    if (stat(path, &sb) == -1) {
+        if (errno != ENOENT) {
+            goto error;
+        }
+    } else if ((sb.st_mode & S_IFMT) == S_IFSOCK) {
+        lgtd_warnx("removing existing unix socket: %s", path);
+        if (unlink(path) == -1 && errno != ENOENT) {
+            goto error;
+        }
+    } else {
+        errno = EEXIST;
+        goto error;
+    }
+
+    if (bind(fd, (struct sockaddr *)sockpath, sizeof(*sockpath)) == -1) {
+        goto error;
+    }
+
+    listener->evlistener = evconnlistener_new(
+        lgtd_ev_base,
+        lgtd_listen_accept_new_client,
+        listener,
+        LEV_OPT_CLOSE_ON_FREE,
+        -1,
+        fd
+    );
+    if (!listener->evlistener) {
+        goto error;
+    }
+
+    SLIST_INSERT_HEAD(&lgtd_listeners, listener, link);
+    lgtd_info("unix socket ready at %s", path);
+
+    return true;
+
+error:
+    lgtd_warn("can't open unix at %s", path);
+    if (fd != -1) {
+        close(fd);
+    }
+    free(listener);
+    return false;
+}
diff --git a/core/listen.h b/core/listen.h
--- a/core/listen.h
+++ b/core/listen.h
@@ -21,8 +21,8 @@
 
 struct lgtd_listen {
     SLIST_ENTRY(lgtd_listen)    link;
-    const char                  *addr;
-    const char                  *port;
+    ev_socklen_t                addrlen;
+    struct sockaddr             *sockaddr;
     struct evconnlistener       *evlistener;
 };
 SLIST_HEAD(lgtd_listen_list, lgtd_listen);
@@ -30,4 +30,5 @@
 extern struct lgtd_listen_list lgtd_listeners;
 
 bool lgtd_listen_open(const char *, const char *);
+bool lgtd_listen_unix_open(const char *);
 void lgtd_listen_close_all(void);
diff --git a/core/log.c b/core/log.c
--- a/core/log.c
+++ b/core/log.c
@@ -15,8 +15,10 @@
 // You should have received a copy of the GNU General Public License
 // along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
 
+#include <sys/socket.h>
 #include <sys/tree.h>
 #include <sys/time.h>
+#include <sys/un.h>
 #include <arpa/inet.h>
 #include <assert.h>
 #include <endian.h>
@@ -27,6 +29,7 @@
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <time.h>
 
 #if LGTD_HAVE_LIBBSD
@@ -88,23 +91,50 @@
     return buf;
 }
 
-void
-lgtd_sockaddrtoa(const struct sockaddr_storage *peer, char *buf, int buflen)
+char *
+lgtd_sockaddrtoa(const struct sockaddr *peer, char *buf, int buflen)
 {
     assert(peer);
     assert(buf);
-    assert(buflen > 0);
+    assert(buflen > 1);
 
-    const char *printed;
-    if (peer->ss_family == AF_INET) {
+    const char *printed = NULL;
+    int i = 0;
+    switch (peer->sa_family) {
+    case AF_INET:
+        (void)0;
         const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
-        int i = 0;
-        LGTD_SNPRINTF_APPEND(buf, i, buflen, "::ffff:");
+        LGTD_SNPRINTF_APPEND(buf, i, buflen, "[::ffff:");
         printed = inet_ntop(AF_INET, &in_peer->sin_addr, &buf[i], buflen - i);
-    } else {
+        if (printed) {
+            i += strlen(printed);
+            LGTD_SNPRINTF_APPEND(
+                buf, i, buflen, "]:%hu", ntohs(in_peer->sin_port)
+            );
+        }
+        break;
+    case AF_INET6:
+        (void)0;
         const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
-        printed = inet_ntop(AF_INET6, &in6_peer->sin6_addr, buf, buflen);
+        LGTD_SNPRINTF_APPEND(buf, i, buflen, "[");
+        printed = inet_ntop(AF_INET6, &in6_peer->sin6_addr, &buf[i], buflen - i);
+        if (printed) {
+            i += strlen(printed);
+            LGTD_SNPRINTF_APPEND(
+                buf, i, buflen, "]:%hu", ntohs(in6_peer->sin6_port)
+            );
+        }
+        break;
+    case AF_UNIX:
+        (void)0;
+        const struct sockaddr_un *un_path = (const struct sockaddr_un *)peer;
+        LGTD_SNPRINTF_APPEND(buf, i, buflen, "at %s", un_path->sun_path);
+        printed = buf;
+        break;
+    default:
+        break;
     }
+
     if (!printed) {
         buf[0] = 0;
         lgtd_warnx("not enough space to log an ip address");
@@ -112,6 +142,8 @@
         abort();
 #endif
     }
+
+    return buf;
 }
 
 char *
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -195,6 +195,9 @@
         return;
     }
 
+    char client_ip_addr[LGTD_SOCKADDR_STRLEN];
+    LGTD_SOCKADDRTOA(client->addr, client_ip_addr);
+
     lgtd_client_start_send_response(client);
     lgtd_client_write_string(client, "[");
     struct lgtd_router_device *device;
@@ -216,11 +219,10 @@
                     "\"addr\":\"%s\","
                     "\"gateway\":{"
                         "\"site\":\"%s\","
-                        "\"url\":\"tcp://[%s]:%hu\","
+                        "\"url\":\"tcp://%s\","
                         "\"latency\":%ju"
                     "}",
-            bulb_addr, site_addr,
-            bulb->gw->ip_addr, bulb->gw->port,
+            bulb_addr, site_addr, bulb->gw->peeraddr,
             (uintmax_t)lgtd_lifx_gateway_latency(bulb->gw)
         );
 
@@ -347,8 +349,8 @@
         if (i >= (int)sizeof(buf)) {
             lgtd_warnx(
                 "can't send state of bulb %s (%s) to client "
-                "[%s]:%hu: output buffer to small",
-                bulb->state.label, bulb_addr, client->ip_addr, client->port
+                "%s: output buffer to small",
+                bulb->state.label, bulb_addr, client_ip_addr
             );
             continue;
         }
@@ -365,9 +367,9 @@
             } else {
                 lgtd_warnx(
                     "tag_id %d on bulb %.*s (%s) doesn't "
-                    "exist on gw [%s]:%hu (site %s)",
+                    "exist on gw %s (site %s)",
                     tag_id, (int)sizeof(bulb->state.label), bulb->state.label,
-                    bulb_addr, bulb->gw->ip_addr, bulb->gw->port, site_addr
+                    bulb_addr, bulb->gw->peeraddr, site_addr
                 );
             }
         }
@@ -439,8 +441,8 @@
             goto error_site_alloc;
         }
         lgtd_info(
-            "created tag [%s] with id %d on gw [%s]:%hu",
-            tag_label, tag_id, site->gw->ip_addr, site->gw->port
+            "created tag [%s] with id %d on gw %s",
+            tag_label, tag_id, site->gw->peeraddr
         );
     }
 
diff --git a/examples/lightsc.py b/examples/lightsc.py
--- a/examples/lightsc.py
+++ b/examples/lightsc.py
@@ -33,15 +33,25 @@
 import json
 import socket
 import sys
+import urllib.parse
 import uuid
 
 
 class LightsClient:
 
-    def __init__(self, host, port):
-        self.host = host
-        self.port = port
-        self._socket = socket.create_connection((host, port))
+    def __init__(self, url):
+        self.url = url
+
+        parts = urllib.parse.urlparse(args.url)
+
+        if parts.scheme == "unix":
+            self._socket = socket.socket(socket.AF_UNIX)
+            self._socket.connect(parts.path)
+        elif parts.scheme == "tcp":
+            self._socket = socket.create_connection((parts.hostname, parts.port))
+        else:
+            raise ValueError("Unsupported url {}".format(url))
+
         self._pipeline = []
         self._batch = False
 
@@ -191,8 +201,8 @@
     middle = "d073d502e530"  # noqa
 
     banner = (
-        "Connected to {}:{}, use the variable c to interact with your "
-        "bulbs:\n\n>>> r = c.get_light_state(\"*\")".format(c.host, c.port)
+        "Connected to {}, use the variable c to interact with your "
+        "bulbs:\n\n>>> r = c.get_light_state(\"*\")".format(c.url)
     )
 
     try:
@@ -213,18 +223,19 @@
         description="lightsc.py is an interactive lightsd Python client"
     )
     parser.add_argument(
-        "host", type=str, help="The hostname or ip where lightsd is running"
-    )
-    parser.add_argument(
-        "port", type=int, help="The port on which lightsd is listening on"
+        "url", type=str,
+        help="How to connect to lightsd (e.g: "
+             "unix:///run/lightsd.sock or tcp://[::1]:1234)"
     )
     args = parser.parse_args()
+
     try:
-        _drop_to_shell(LightsClient(args.host, args.port))
-    except socket.error as ex:
+        with LightsClient(args.url) as client:
+            _drop_to_shell(client)
+    except Exception as ex:
         print(
-            "Couldn't connect to lightsd@{}:{}, is it running? "
-            "({})".format(args.host, args.port, ex.strerror),
+            "Couldn't connect to {}, is lightsd running? "
+            "({})".format(args.url, ex),
             file=sys.stderr
         )
         sys.exit(1)
diff --git a/lifx/broadcast.c b/lifx/broadcast.c
--- a/lifx/broadcast.c
+++ b/lifx/broadcast.c
@@ -88,29 +88,23 @@
 
         lgtd_time_mono_t received_at = lgtd_time_monotonic_msecs();
         char peer_addr[INET6_ADDRSTRLEN];
-        lgtd_sockaddrtoa(&peer, peer_addr, sizeof(peer_addr));
-        short peer_port = lgtd_sockaddrport(&peer);
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&peer, peer_addr);
 
         if (nbytes < LGTD_LIFX_PACKET_HEADER_SIZE) {
-            lgtd_warnx(
-                "broadcast packet too short from [%s]:%hu", peer_addr, peer_port
-            );
+            lgtd_warnx("broadcast packet too short from %s", peer_addr);
             return false;
         }
 
         lgtd_lifx_wire_decode_header(&read.hdr);
         if (read.hdr.size != nbytes) {
-            lgtd_warnx(
-                "incomplete broadcast packet from [%s]:%hu",
-                peer_addr, peer_port
-            );
+            lgtd_warnx("incomplete broadcast packet from %s", peer_addr);
             return false;
         }
         int proto_version = read.hdr.protocol & LGTD_LIFX_PROTOCOL_VERSION_MASK;
         if (proto_version != LGTD_LIFX_PROTOCOL_V1) {
             lgtd_warnx(
-                "unsupported protocol %d from [%s]:%hu",
-                read.hdr.protocol & 0x0fff, peer_addr, peer_port
+                "unsupported protocol %d from %s",
+                read.hdr.protocol & LGTD_LIFX_PROTOCOL_VERSION_MASK, peer_addr
             );
         }
         if (read.hdr.packet_type == LGTD_LIFX_GET_PAN_GATEWAY) {
@@ -121,22 +115,23 @@
             lgtd_lifx_wire_get_packet_info(read.hdr.packet_type);
         if (!pkt_info) {
             lgtd_warnx(
-                "received unknown packet %#x from [%s]:%hu",
-                read.hdr.packet_type, peer_addr, peer_port
+                "received unknown packet %#x from %s",
+                read.hdr.packet_type, peer_addr
             );
             continue;
         }
         if (!(read.hdr.protocol & LGTD_LIFX_PROTOCOL_ADDRESSABLE)) {
             lgtd_warnx(
-                "received non-addressable packet %s from [%s]:%hu",
-                pkt_info->name, peer_addr, peer_port
+                "received non-addressable packet %s from %s",
+                pkt_info->name, peer_addr
             );
             continue;
         }
-        struct lgtd_lifx_gateway *gw = lgtd_lifx_gateway_get(&peer);
+        struct lgtd_lifx_gateway *gw;
+        gw = lgtd_lifx_gateway_get((struct sockaddr *)&peer, addrlen);
         if (!gw && read.hdr.packet_type == LGTD_LIFX_PAN_GATEWAY) {
             gw = lgtd_lifx_gateway_open(
-                &peer, addrlen, read.hdr.site, received_at
+                (struct sockaddr *)&peer, addrlen, read.hdr.site, received_at
             );
             if (!gw) {
                 lgtd_err(1, "can't allocate gateway");
@@ -148,9 +143,7 @@
             pkt_info->decode(pkt);
             pkt_info->handle(gw, &read.hdr, pkt);
         } else {
-            lgtd_warnx(
-                "got packet from unknown gateway [%s]:%hu", peer_addr, peer_port
-            );
+            lgtd_warnx("got packet from unknown gateway %s", peer_addr);
         }
     }
 }
diff --git a/lifx/bulb.c b/lifx/bulb.c
--- a/lifx/bulb.c
+++ b/lifx/bulb.c
@@ -197,12 +197,11 @@
     RB_REMOVE(lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table, bulb);
     char addr[LGTD_LIFX_ADDR_STRLEN];
     lgtd_info(
-        "closed bulb \"%.*s\" (%s) on [%s]:%hu",
+        "closed bulb \"%.*s\" (%s) on %s",
         LGTD_LIFX_LABEL_SIZE,
         bulb->state.label,
         LGTD_IEEE8023MACTOA(bulb->addr, addr),
-        bulb->gw->ip_addr,
-        bulb->gw->port
+        bulb->gw->peeraddr
     );
     free(bulb);
 }
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -78,9 +78,10 @@
 
     char site[LGTD_LIFX_ADDR_STRLEN];
     lgtd_info(
-        "connection with gateway bulb [%s]:%hu (site %s) closed",
-        gw->ip_addr, gw->port, LGTD_IEEE8023MACTOA(gw->site.as_array, site)
+        "connection with gateway bulb %s (site %s) closed",
+        gw->peeraddr, LGTD_IEEE8023MACTOA(gw->site.as_array, site)
     );
+    free(gw->peer);
     free(gw);
 }
 
@@ -112,9 +113,7 @@
     struct lgtd_lifx_gateway *gw = (struct lgtd_lifx_gateway *)ctx;
 
     if (events & EV_TIMEOUT) {  // Not sure how that could happen in UDP but eh.
-        lgtd_warn(
-            "lost connection with gateway bulb [%s]:%hu", gw->ip_addr, gw->port
-        );
+        lgtd_warn("lost connection with gateway bulb %s", gw->peeraddr);
         lgtd_lifx_gateway_close(gw);
         if (!lgtd_lifx_broadcast_discovery()) {
             lgtd_err(1, "can't start auto discovery");
@@ -129,7 +128,7 @@
         int to_write = gw->pkt_ring[gw->pkt_ring_tail].size;
         int nbytes = evbuffer_write_atmost(gw->write_buf, gw->socket, to_write);
         if (nbytes == -1 && errno != EAGAIN) {
-            lgtd_warn("can't write to [%s]:%hu", gw->ip_addr, gw->port);
+            lgtd_warn("can't write to %s", gw->peeraddr);
             lgtd_lifx_gateway_close(gw);
             if (!lgtd_lifx_broadcast_discovery()) {
                 lgtd_err(1, "can't start auto discovery");
@@ -270,8 +269,8 @@
             SLIST_INSERT_HEAD(&gw->bulbs, bulb, link_by_gw);
             char addr[LGTD_LIFX_ADDR_STRLEN];
             lgtd_info(
-                "bulb %s on [%s]:%hu",
-                LGTD_IEEE8023MACTOA(bulb->addr, addr), gw->ip_addr, gw->port
+                "bulb %s on %s",
+                LGTD_IEEE8023MACTOA(bulb->addr, addr), gw->peeraddr
             );
         }
     }
@@ -279,7 +278,7 @@
 }
 
 struct lgtd_lifx_gateway *
-lgtd_lifx_gateway_open(const struct sockaddr_storage *peer,
+lgtd_lifx_gateway_open(const struct sockaddr *peer,
                        ev_socklen_t addrlen,
                        const uint8_t *site,
                        lgtd_time_mono_t received_at)
@@ -292,12 +291,12 @@
         lgtd_warn("can't allocate a new gateway bulb");
         return false;
     }
-    gw->socket = socket(peer->ss_family, SOCK_DGRAM, IPPROTO_UDP);
+    gw->socket = socket(peer->sa_family, SOCK_DGRAM, IPPROTO_UDP);
     if (gw->socket == -1) {
         lgtd_warn("can't open a new socket");
         goto error_socket;
     }
-    if (connect(gw->socket, (const struct sockaddr *)peer, addrlen) == -1
+    if (connect(gw->socket, peer, addrlen) == -1
         || evutil_make_socket_nonblocking(gw->socket) == -1) {
         lgtd_warn("can't open a new socket");
         goto error_connect;
@@ -312,13 +311,16 @@
     );
     gw->write_buf = evbuffer_new();
     if (!gw->write_ev || !gw->write_buf) {
-        lgtd_warn("can't allocate a new gateway bulb");
+        goto error_allocate;
+    }
+    gw->peer = malloc(addrlen);
+    if (!gw->peer) {
         goto error_allocate;
     }
 
-    memcpy(&gw->peer, peer, sizeof(gw->peer));
-    lgtd_sockaddrtoa(peer, gw->ip_addr, sizeof(gw->ip_addr));
-    gw->port = lgtd_sockaddrport(peer);
+    memcpy(gw->peer, peer, addrlen);
+    gw->peerlen = addrlen;
+    LGTD_SOCKADDRTOA(gw->peer, gw->peeraddr);
     memcpy(gw->site.as_array, site, sizeof(gw->site.as_array));
     gw->last_req_at = received_at;
     gw->next_req_at = received_at;
@@ -338,9 +340,8 @@
 
     char site_addr[LGTD_LIFX_ADDR_STRLEN];
     lgtd_info(
-        "gateway for site %s at [%s]:%hu",
-        LGTD_IEEE8023MACTOA(gw->site.as_array, site_addr),
-        gw->ip_addr, gw->port
+        "gateway for site %s at %s",
+        LGTD_IEEE8023MACTOA(gw->site.as_array, site_addr), gw->peeraddr
     );
     LIST_INSERT_HEAD(&lgtd_lifx_gateways, gw, link);
 
@@ -353,6 +354,7 @@
     return gw;
 
 error_allocate:
+    lgtd_warn("can't allocate a new gateway bulb");
     if (gw->write_ev) {
         event_free(gw->write_ev);
     }
@@ -362,19 +364,21 @@
 error_connect:
     evutil_closesocket(gw->socket);
 error_socket:
+    free(gw->peer);
     free(gw);
     return NULL;
 }
 
 struct lgtd_lifx_gateway *
-lgtd_lifx_gateway_get(const struct sockaddr_storage *peer)
+lgtd_lifx_gateway_get(const struct sockaddr *peer, ev_socklen_t peerlen)
 {
     assert(peer);
 
     struct lgtd_lifx_gateway *gw, *next_gw;
     LIST_FOREACH_SAFE(gw, &lgtd_lifx_gateways, link, next_gw) {
-        if (peer->ss_family == gw->peer.ss_family
-            && !memcmp(&gw->peer, peer, sizeof(*peer))) {
+        if (peer->sa_family == gw->peer->sa_family
+            && peerlen == gw->peerlen
+            && !memcmp(gw->peer, peer, peerlen)) {
             return gw;
         }
     }
@@ -406,8 +410,8 @@
 
     if (gw->pkt_ring_full) {
         lgtd_warnx(
-            "dropping packet type %s: packet queue on [%s]:%hu is full",
-            pkt_info->name, gw->ip_addr, gw->port
+            "dropping packet type %s: packet queue on %s is full",
+            pkt_info->name, gw->peeraddr
         );
         return;
     }
@@ -441,9 +445,9 @@
             gw->tag_refcounts[tag_id]++;
         } else {
             lgtd_warnx(
-                "reached refcount limit (%u) for tag [%s] (%d) on gw [%s]:%hu",
+                "reached refcount limit (%u) for tag [%s] (%d) on gw %s",
                 UINT8_MAX, gw->tags[tag_id] ? gw->tags[tag_id]->label : NULL,
-                tag_id, gw->ip_addr, gw->port
+                tag_id, gw->peeraddr
             );
         }
     }
@@ -453,9 +457,9 @@
         if (--gw->tag_refcounts[tag_id] == 0) {
             char site[LGTD_LIFX_ADDR_STRLEN];
             lgtd_info(
-                "deleting unused tag [%s] (%d) from gw [%s]:%hu (site %s)",
+                "deleting unused tag [%s] (%d) from gw %s (site %s)",
                 gw->tags[tag_id] ? gw->tags[tag_id]->label : NULL,
-                tag_id, gw->ip_addr, gw->port,
+                tag_id, gw->peeraddr,
                 LGTD_IEEE8023MACTOA(gw->site.as_array, site)
             );
             struct lgtd_lifx_packet_tag_labels pkt = {
@@ -487,8 +491,8 @@
 
     char addr[LGTD_LIFX_ADDR_STRLEN], site[LGTD_LIFX_ADDR_STRLEN];
     lgtd_debug(
-        "SET_PAN_GATEWAY <-- [%s]:%hu - %s site=%s, service_type=%d",
-        gw->ip_addr, gw->port,
+        "SET_PAN_GATEWAY <-- %s - %s site=%s, service_type=%d",
+        gw->peeraddr,
         LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         LGTD_IEEE8023MACTOA(hdr->site, site), pkt->service_type
     );
@@ -503,11 +507,10 @@
 
     char addr[LGTD_LIFX_ADDR_STRLEN];
     lgtd_debug(
-        "SET_LIGHT_STATE <-- [%s]:%hu - %s "
+        "SET_LIGHT_STATE <-- %s - %s "
         "hue=%#hx, saturation=%#hx, brightness=%#hx, "
         "kelvin=%d, dim=%#hx, power=%#hx, label=%.*s, tags=%#jx",
-        gw->ip_addr, gw->port,
-        LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
+        gw->peeraddr, LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         pkt->hue, pkt->saturation, pkt->brightness, pkt->kelvin,
         pkt->dim, pkt->power, LGTD_LIFX_LABEL_SIZE, pkt->label,
         (uintmax_t)pkt->tags
@@ -546,8 +549,8 @@
             struct timeval tv = LGTD_MSECS_TO_TIMEVAL(timeout);
             lgtd_timer_reschedule(gw->refresh_timer, &tv);
             lgtd_debug(
-                "[%s]:%hu latency is %jums, scheduling next GET_LIGHT_STATE in %dms",
-                gw->ip_addr, gw->port, (uintmax_t)latency, timeout
+                "%s latency is %jums, scheduling next GET_LIGHT_STATE in %dms",
+                gw->peeraddr, (uintmax_t)latency, timeout
             );
         }
         return;
@@ -555,14 +558,14 @@
 
     if (!gw->pending_refresh_req) {
         lgtd_debug(
-            "[%s]:%hu latency is %jums, sending GET_LIGHT_STATE now",
-            gw->ip_addr, gw->port, (uintmax_t)latency
+            "%s latency is %jums, sending GET_LIGHT_STATE now",
+            gw->peeraddr, (uintmax_t)latency
         );
         lgtd_lifx_gateway_send_get_all_light_state(gw);
     } else {
         lgtd_debug(
-            "[%s]:%hu GET_LIGHT_STATE for all bulbs on this gw has already "
-            "been enqueued", gw->ip_addr, gw->port
+            "%s GET_LIGHT_STATE for all bulbs on this gw has already "
+            "been enqueued", gw->peeraddr
         );
     }
 }
@@ -576,8 +579,7 @@
 
     char addr[LGTD_LIFX_ADDR_STRLEN];
     lgtd_debug(
-        "SET_POWER_STATE <-- [%s]:%hu - %s power=%#hx",
-        gw->ip_addr, gw->port,
+        "SET_POWER_STATE <-- %s - %s power=%#hx", gw->peeraddr,
         LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr), pkt->power
     );
 
@@ -620,8 +622,8 @@
         tag_id = lgtd_lifx_wire_bitscan64_forward(~gw->tag_ids);
         if (tag_id == -1) {
             lgtd_warnx(
-                "no tag_id left for new tag [%s] on gw [%s]:%hu (site %s)",
-                tag_label, gw->ip_addr, gw->port, site
+                "no tag_id left for new tag [%s] on gw %s (site %s)",
+                tag_label, gw->peeraddr, site
             );
             return -1;
         }
@@ -638,8 +640,8 @@
             return -1;
         }
         lgtd_debug(
-            "tag_id %d allocated for tag [%s] on gw [%s]:%hu (site %s)",
-            tag_id, tag_label, gw->ip_addr, gw->port, site
+            "tag_id %d allocated for tag [%s] on gw %s (site %s)",
+            tag_id, tag_label, gw->peeraddr, site
         );
         gw->tag_ids |= LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
         gw->tags[tag_id] = tag;
@@ -658,10 +660,9 @@
     if (gw->tag_ids & LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id)) {
         char site[LGTD_LIFX_ADDR_STRLEN];
         lgtd_debug(
-            "tag_id %d deallocated for tag [%s] on gw [%s]:%hu (site %s)",
+            "tag_id %d deallocated for tag [%s] on gw %s (site %s)",
             tag_id, gw->tags[tag_id]->label,
-            gw->ip_addr, gw->port,
-            LGTD_IEEE8023MACTOA(gw->site.as_array, site)
+            gw->peeraddr, LGTD_IEEE8023MACTOA(gw->site.as_array, site)
         );
         lgtd_lifx_tagging_decref(gw->tags[tag_id], gw);
         gw->tag_ids &= ~LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
@@ -678,9 +679,8 @@
 
     char addr[LGTD_LIFX_ADDR_STRLEN];
     lgtd_debug(
-        "SET_TAG_LABELS <-- [%s]:%hu - %s label=%.*s, tags=%jx",
-        gw->ip_addr, gw->port,
-        LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
+        "SET_TAG_LABELS <-- %s - %s label=%.*s, tags=%jx",
+        gw->peeraddr, LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         LGTD_LIFX_LABEL_SIZE, pkt->label, (uintmax_t)pkt->tags
     );
 
@@ -703,9 +703,8 @@
 
     char addr[LGTD_LIFX_ADDR_STRLEN];
     lgtd_debug(
-        "SET_TAGS <-- [%s]:%hu - %s tags=%#jx",
-        gw->ip_addr, gw->port,
-        LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
+        "SET_TAGS <-- %s - %s tags=%#jx",
+        gw->peeraddr, LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         (uintmax_t)pkt->tags
     );
 
@@ -718,10 +717,10 @@
         if (!(gw->tag_ids & LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id))) {
             lgtd_warnx(
                 "trying to set unknown tag_id %d (%#jx) "
-                "on bulb %s (%.*s), gw [%s]:%hu (site %s)",
+                "on bulb %s (%.*s), gw %s (site %s)",
                 tag_id, LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id),
                 LGTD_IEEE8023MACTOA(b->addr, bulb_addr),
-                LGTD_LIFX_LABEL_SIZE, b->state.label, gw->ip_addr, gw->port,
+                LGTD_LIFX_LABEL_SIZE, b->state.label, gw->peeraddr,
                 LGTD_IEEE8023MACTOA(gw->site.as_array, site_addr)
             );
         }
@@ -758,10 +757,9 @@
 
     char addr[LGTD_LIFX_ADDR_STRLEN];
     lgtd_debug(
-        "%s <-- [%s]:%hu - %s "
+        "%s <-- %s - %s "
         "signal_strength=%f, rx_bytes=%u, tx_bytes=%u, temperature=%hu",
-        type, gw->ip_addr, gw->port,
-        LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
+        type, gw->peeraddr, LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         pkt->signal_strength, pkt->rx_bytes, pkt->tx_bytes, pkt->temperature
     );
 
@@ -799,10 +797,9 @@
 
     char built_at[64], installed_at[64], addr[LGTD_LIFX_ADDR_STRLEN];
     lgtd_debug(
-        "%s <-- [%s]:%hu - %s "
+        "%s <-- %s - %s "
         "built_at=%s, installed_at=%s, version=%u",
-        type, gw->ip_addr, gw->port,
-        LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
+        type, gw->peeraddr, LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         LGTD_LIFX_WIRE_PRINT_NSEC_TIMESTAMP(pkt->built_at, built_at),
         LGTD_LIFX_WIRE_PRINT_NSEC_TIMESTAMP(pkt->installed_at, installed_at),
         pkt->version
@@ -823,10 +820,9 @@
 
     char addr[LGTD_LIFX_ADDR_STRLEN];
     lgtd_debug(
-        "PRODUCT_INFO <-- [%s]:%hu - %s "
+        "PRODUCT_INFO <-- %s - %s "
         "vendor_id=%#x, product_id=%#x, version=%u",
-        gw->ip_addr, gw->port,
-        LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
+        gw->peeraddr, LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         pkt->vendor_id, pkt->product_id, pkt->version
     );
 
@@ -845,9 +841,8 @@
 
     char device_time[64], uptime[64], downtime[64], addr[LGTD_LIFX_ADDR_STRLEN];
     lgtd_debug(
-        "PRODUCT_INFO <-- [%s]:%hu - %s time=%s, uptime=%s, downtime=%s",
-        gw->ip_addr, gw->port,
-        LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
+        "PRODUCT_INFO <-- %s - %s time=%s, uptime=%s, downtime=%s",
+        gw->peeraddr, LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         LGTD_LIFX_WIRE_PRINT_NSEC_TIMESTAMP(pkt->time, device_time),
         LGTD_PRINT_DURATION(LGTD_NSECS_TO_SECS(pkt->uptime), uptime),
         LGTD_PRINT_DURATION(LGTD_NSECS_TO_SECS(pkt->downtime), downtime)
@@ -868,9 +863,8 @@
 
     char addr[LGTD_LIFX_ADDR_STRLEN];
     lgtd_debug(
-        "BULB_LABEL <-- [%s]:%hu - %s label=%.*s",
-        gw->ip_addr, gw->port,
-        LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
+        "BULB_LABEL <-- %s - %s label=%.*s",
+        gw->peeraddr, LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         (int)sizeof(pkt->label), pkt->label
     );
 
@@ -888,9 +882,8 @@
 
     char addr[LGTD_LIFX_ADDR_STRLEN];
     lgtd_debug(
-        "AMBIENT_LIGHT <-- [%s]:%hu - %s ambient_light=%flx",
-        gw->ip_addr, gw->port,
-        LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
+        "AMBIENT_LIGHT <-- %s - %s ambient_light=%flx",
+        gw->peeraddr, LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         pkt->illuminance
     );
 
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -47,10 +47,10 @@
     // packet doesn't include the device address in the header (i.e: site and
     // device_addr have the same value) so we have no choice but to use the
     // remote ip address to identify a gateway:
-    struct sockaddr_storage         peer;
-    uint8_t                         addr[LGTD_LIFX_ADDR_LENGTH];
-    char                            ip_addr[INET6_ADDRSTRLEN];
-    uint16_t                        port;
+    struct sockaddr                 *peer;
+    ev_socklen_t                    peerlen;
+    // XXX consider having a constants.h file:
+    char                            peeraddr[128];
     // TODO: just use an integer and rename it to site_id:
     union {
         uint8_t                     as_array[LGTD_LIFX_ADDR_LENGTH];
@@ -90,8 +90,8 @@
     (bulb_fn)(b, __VA_ARGS__);                                              \
 } while (0)
 
-struct lgtd_lifx_gateway *lgtd_lifx_gateway_get(const struct sockaddr_storage *);
-struct lgtd_lifx_gateway *lgtd_lifx_gateway_open(const struct sockaddr_storage *,
+struct lgtd_lifx_gateway *lgtd_lifx_gateway_get(const struct sockaddr *, ev_socklen_t);
+struct lgtd_lifx_gateway *lgtd_lifx_gateway_open(const struct sockaddr *,
                                                  ev_socklen_t,
                                                  const uint8_t *,
                                                  lgtd_time_mono_t);
diff --git a/lifx/tagging.c b/lifx/tagging.c
--- a/lifx/tagging.c
+++ b/lifx/tagging.c
@@ -125,8 +125,8 @@
         }
         char site_addr[LGTD_LIFX_ADDR_STRLEN];
         lgtd_info(
-            "tag [%s] added to gw [%s]:%hu (site %s) with tag_id %d",
-            tag_label, gw->ip_addr, gw->port,
+            "tag [%s] added to gw %s (site %s) with tag_id %d",
+            tag_label, gw->peeraddr,
             LGTD_IEEE8023MACTOA(gw->site.as_array, site_addr), tag_id
         );
         site->gw = gw;
@@ -150,8 +150,8 @@
     if (site) {
         char site_addr[LGTD_LIFX_ADDR_STRLEN];
         lgtd_debug(
-            "tag [%s] removed from gw [%s]:%hu (site %s)",
-            tag->label, gw->ip_addr, gw->port,
+            "tag [%s] removed from gw %s (site %s)",
+            tag->label, gw->peeraddr,
             LGTD_IEEE8023MACTOA(gw->site.as_array, site_addr)
         );
         LIST_REMOVE(site, link);
diff --git a/lifx/watchdog.c b/lifx/watchdog.c
--- a/lifx/watchdog.c
+++ b/lifx/watchdog.c
@@ -110,17 +110,15 @@
         int gw_lag = lgtd_lifx_gateway_latency(gw);
         if (gw_lag >= LGTD_LIFX_WATCHDOG_DEVICE_TIMEOUT_MSECS) {
             lgtd_info(
-                "closing bulb gateway [%s]:%hu that "
-                "hasn't received traffic for %dms",
-                gw->ip_addr, gw->port,
-                gw_lag
+                "closing bulb gateway %s that hasn't received traffic for %dms",
+                gw->peeraddr, gw_lag
             );
             lgtd_lifx_gateway_close(gw);
             start_discovery = true;
         } else if (gw_lag >= LGTD_LIFX_WATCHDOG_DEVICE_FORCE_REFRESH_MSECS) {
             lgtd_info(
-                "no update on bulb gateway [%s]:%hu for %dms, forcing refresh",
-                gw->ip_addr, gw->port, gw_lag
+                "no update on bulb gateway %s for %dms, forcing refresh",
+                gw->peeraddr, gw_lag
             );
             lgtd_lifx_gateway_force_refresh(gw);
         }
diff --git a/lifx/wire_proto.c b/lifx/wire_proto.c
--- a/lifx/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -89,10 +89,9 @@
     bool tagged = hdr->protocol & LGTD_LIFX_PROTOCOL_TAGGED;
     unsigned int protocol = hdr->protocol & LGTD_LIFX_PROTOCOL_VERSION_MASK;
     lgtd_info(
-        "%s <-- [%s]:%hu - (Unimplemented, header info: "
+        "%s <-- %s - (Unimplemented, header info: "
         "addressable=%d, tagged=%d, protocol=%d)",
-        pkt_info->name, gw->ip_addr, gw->port,
-        addressable, tagged, protocol
+        pkt_info->name, gw->peeraddr, addressable, tagged, protocol
     );
 }
 
diff --git a/tests/core/client/CMakeLists.txt b/tests/core/client/CMakeLists.txt
--- a/tests/core/client/CMakeLists.txt
+++ b/tests/core/client/CMakeLists.txt
@@ -3,17 +3,18 @@
     ${CMAKE_CURRENT_BINARY_DIR}
 )
 
-ADD_LIBRARY(
+ADD_CORE_LIBRARY(
     test_core_client STATIC
     ${LIGHTSD_SOURCE_DIR}/core/jsmn.c
     ${LIGHTSD_SOURCE_DIR}/core/log.c
     ${LIGHTSD_SOURCE_DIR}/core/stats.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/bulb.c
+    ${LIGHTSD_SOURCE_DIR}/lifx/tagging.c
     ${LIGHTSD_SOURCE_DIR}/lifx/wire_proto.c
     ${CMAKE_CURRENT_SOURCE_DIR}/../tests_shims.c
+    ${CMAKE_CURRENT_SOURCE_DIR}/../tests_utils.c
 )
 
-TARGET_LINK_LIBRARIES(test_core_client ${TIME_MONOTONIC_LIBRARY})
-
 FUNCTION(ADD_CLIENT_TEST TEST_SOURCE)
     ADD_TEST_FROM_C_SOURCES(${TEST_SOURCE} test_core_client)
 ENDFUNCTION()
diff --git a/tests/core/client/test_client_read_callback.c b/tests/core/client/test_client_read_callback.c
--- a/tests/core/client/test_client_read_callback.c
+++ b/tests/core/client/test_client_read_callback.c
@@ -144,9 +144,10 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
-    lgtd_client_read_callback(FAKE_BUFFEREVENT, &client);
+    lgtd_client_read_callback(FAKE_BUFFEREVENT, client);
 
     if (!evbuffer_get_contiguous_space_call_count) {
         errx(1, "evbuffer_get_contiguous_space not called");
diff --git a/tests/core/client/test_client_read_callback_extra_data.c b/tests/core/client/test_client_read_callback_extra_data.c
--- a/tests/core/client/test_client_read_callback_extra_data.c
+++ b/tests/core/client/test_client_read_callback_extra_data.c
@@ -204,9 +204,10 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
-    lgtd_client_read_callback(FAKE_BUFFEREVENT, &client);
+    lgtd_client_read_callback(FAKE_BUFFEREVENT, client);
 
     if (!evbuffer_get_contiguous_space_call_count) {
         errx(1, "evbuffer_get_contiguous_space not called");
diff --git a/tests/core/client/test_client_read_callback_multiple_requests.c b/tests/core/client/test_client_read_callback_multiple_requests.c
--- a/tests/core/client/test_client_read_callback_multiple_requests.c
+++ b/tests/core/client/test_client_read_callback_multiple_requests.c
@@ -189,9 +189,10 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
-    lgtd_client_read_callback(FAKE_BUFFEREVENT, &client);
+    lgtd_client_read_callback(FAKE_BUFFEREVENT, client);
 
     if (!evbuffer_get_contiguous_space_call_count) {
         errx(1, "evbuffer_get_contiguous_space not called");
diff --git a/tests/core/client/test_client_read_callback_part_too_large.c b/tests/core/client/test_client_read_callback_part_too_large.c
--- a/tests/core/client/test_client_read_callback_part_too_large.c
+++ b/tests/core/client/test_client_read_callback_part_too_large.c
@@ -184,9 +184,10 @@
         );
     }
 
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
-    lgtd_client_read_callback(FAKE_BUFFEREVENT, &client);
+    lgtd_client_read_callback(FAKE_BUFFEREVENT, client);
 
     if (!evbuffer_get_contiguous_space_call_count) {
         errx(1, "evbuffer_get_contiguous_space not called");
diff --git a/tests/core/client/test_client_read_callback_yield_on_eagain.c b/tests/core/client/test_client_read_callback_yield_on_eagain.c
--- a/tests/core/client/test_client_read_callback_yield_on_eagain.c
+++ b/tests/core/client/test_client_read_callback_yield_on_eagain.c
@@ -185,10 +185,11 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
-    lgtd_client_read_callback(FAKE_BUFFEREVENT, &client);
-    lgtd_client_read_callback(FAKE_BUFFEREVENT, &client);
+    lgtd_client_read_callback(FAKE_BUFFEREVENT, client);
+    lgtd_client_read_callback(FAKE_BUFFEREVENT, client);
 
     if (!evbuffer_get_contiguous_space_call_count) {
         errx(1, "evbuffer_get_contiguous_space not called");
diff --git a/tests/core/daemon/test_daemon_update_proctitle.c b/tests/core/daemon/test_daemon_update_proctitle.c
--- a/tests/core/daemon/test_daemon_update_proctitle.c
+++ b/tests/core/daemon/test_daemon_update_proctitle.c
@@ -76,19 +76,19 @@
     }
 
     expected = (
-        "listening_on(foobar.com:[1234]); "
+        "listening_on([::ffff:127.0.0.1]:1234); "
         "lifx_gateways(found=1); "
         "bulbs(found=2, on=0); "
         "clients(connected=0)"
     );
-    lgtd_tests_insert_mock_listener("foobar.com", "1234");
+    lgtd_tests_insert_mock_listener("127.0.0.1", 1234);
     lgtd_daemon_update_proctitle();
     if (setproctitle_call_count != 5) {
         errx(1, "setproctitle should have been called");
     }
 
     expected = (
-        "listening_on(foobar.com:[1234]); "
+        "listening_on([::ffff:127.0.0.1]:1234); "
         "lifx_gateways(found=1); "
         "bulbs(found=2, on=1); "
         "clients(connected=0)"
@@ -99,7 +99,7 @@
     }
 
     expected = (
-        "listening_on(foobar.com:[1234]); "
+        "listening_on([::ffff:127.0.0.1]:1234); "
         "lifx_gateways(found=1); "
         "bulbs(found=2, on=1); "
         "clients(connected=1)"
diff --git a/tests/core/proto/test_proto_get_light_state.c b/tests/core/proto/test_proto_get_light_state.c
--- a/tests/core/proto/test_proto_get_light_state.c
+++ b/tests/core/proto/test_proto_get_light_state.c
@@ -37,7 +37,8 @@
     }
 
     static struct lgtd_lifx_gateway gw_bulb_1 = {
-        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_1.bulbs)
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_1.bulbs),
+        .peeraddr = "[::ffff:127.0.0.1]:1"
     };
     static struct lgtd_lifx_bulb bulb_1 = {
         .addr = { 1, 2, 3, 4, 5 },
@@ -69,7 +70,8 @@
     struct lgtd_lifx_tag *gw_2_tag_3 = lgtd_tests_insert_mock_tag("wave~");
     static struct lgtd_lifx_gateway gw_bulb_2 = {
         .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_2.bulbs),
-        .tag_ids = 0x7
+        .tag_ids = 0x7,
+        .peeraddr = "[::ffff:127.0.0.1]:2"
     };
     lgtd_tests_add_tag_to_gw(gw_2_tag_1, &gw_bulb_2, 0);
     lgtd_tests_add_tag_to_gw(gw_2_tag_2, &gw_bulb_2, 1);
@@ -104,10 +106,11 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
     struct lgtd_proto_target_list *targets = (void *)0x2a;
 
-    lgtd_proto_get_light_state(&client, targets);
+    lgtd_proto_get_light_state(client, targets);
 
     const char expected[] = ("["
         "{"
@@ -115,7 +118,7 @@
                 "\"addr\":\"05:04:03:02:01:00\","
                 "\"gateway\":{"
                     "\"site\":\"00:00:00:00:00:00\","
-                    "\"url\":\"tcp://[]:0\","
+                    "\"url\":\"tcp://[::ffff:127.0.0.1]:2\","
                     "\"latency\":0"
                 "},"
                 "\"mcu\":{"
@@ -158,7 +161,7 @@
                 "\"addr\":\"01:02:03:04:05:00\","
                 "\"gateway\":{"
                     "\"site\":\"00:00:00:00:00:00\","
-                    "\"url\":\"tcp://[]:0\","
+                    "\"url\":\"tcp://[::ffff:127.0.0.1]:1\","
                     "\"latency\":0"
                 "},"
                 "\"mcu\":{"
@@ -228,7 +231,7 @@
                 "\"addr\":\"05:04:03:02:01:00\","
                 "\"gateway\":{"
                     "\"site\":\"00:00:00:00:00:00\","
-                    "\"url\":\"tcp://[]:0\","
+                    "\"url\":\"tcp://[::ffff:127.0.0.1]:2\","
                     "\"latency\":0"
                 "},"
                 "\"mcu\":{\"firmware_version\":\"2.1\"},"
@@ -246,7 +249,7 @@
                 "\"addr\":\"01:02:03:04:05:00\","
                 "\"gateway\":{"
                     "\"site\":\"00:00:00:00:00:00\","
-                    "\"url\":\"tcp://[]:0\","
+                    "\"url\":\"tcp://[::ffff:127.0.0.1]:1\","
                     "\"latency\":0"
                 "},"
                 "\"mcu\":{\"firmware_version\":\"0.0\"},"
@@ -263,7 +266,7 @@
 
     reset_client_write_buf();
 
-    lgtd_proto_get_light_state(&client, targets);
+    lgtd_proto_get_light_state(client, targets);
 
     if (client_write_buf_idx != sizeof(expected_info) - 1) {
         lgtd_errx(
diff --git a/tests/core/proto/test_proto_get_light_state_empty_device_list.c b/tests/core/proto/test_proto_get_light_state_empty_device_list.c
--- a/tests/core/proto/test_proto_get_light_state_empty_device_list.c
+++ b/tests/core/proto/test_proto_get_light_state_empty_device_list.c
@@ -38,10 +38,11 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
     struct lgtd_proto_target_list *targets = (void *)0x2a;
 
-    lgtd_proto_get_light_state(&client, targets);
+    lgtd_proto_get_light_state(client, targets);
 
     const char expected[] = "[]";
 
diff --git a/tests/core/proto/test_proto_get_light_state_label_overflow.c b/tests/core/proto/test_proto_get_light_state_label_overflow.c
--- a/tests/core/proto/test_proto_get_light_state_label_overflow.c
+++ b/tests/core/proto/test_proto_get_light_state_label_overflow.c
@@ -37,7 +37,8 @@
     }
 
     static struct lgtd_lifx_gateway gw_bulb_1 = {
-        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_1.bulbs)
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_1.bulbs),
+        .peeraddr = "[::ffff:127.0.0.1]:1"
     };
     static struct lgtd_lifx_bulb bulb_1 = {
         .addr = { 1, 2, 3, 4, 5 },
@@ -70,7 +71,8 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
     struct lgtd_proto_target_list *targets = (void *)0x2a;
 
     lgtd_opts.verbosity = LGTD_INFO;
@@ -81,7 +83,7 @@
                 "\"addr\":\"01:02:03:04:05:00\","
                 "\"gateway\":{"
                     "\"site\":\"00:00:00:00:00:00\","
-                    "\"url\":\"tcp://[]:0\","
+                    "\"url\":\"tcp://[::ffff:127.0.0.1]:1\","
                     "\"latency\":0"
                 "},"
                 "\"mcu\":{\"firmware_version\":\"0.0\"},"
@@ -98,7 +100,7 @@
 
     reset_client_write_buf();
 
-    lgtd_proto_get_light_state(&client, targets);
+    lgtd_proto_get_light_state(client, targets);
 
     if (client_write_buf_idx != sizeof(expected_info) - 1) {
         lgtd_errx(
diff --git a/tests/core/proto/test_proto_get_light_state_null_device_list.c b/tests/core/proto/test_proto_get_light_state_null_device_list.c
--- a/tests/core/proto/test_proto_get_light_state_null_device_list.c
+++ b/tests/core/proto/test_proto_get_light_state_null_device_list.c
@@ -48,10 +48,11 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
     struct lgtd_proto_target_list *targets = (void *)0x2a;
 
-    lgtd_proto_get_light_state(&client, targets);
+    lgtd_proto_get_light_state(client, targets);
 
     if (!send_error_called) {
         lgtd_errx(1, "lgtd_client_send_error hasn't been called");
diff --git a/tests/core/proto/test_proto_get_light_state_unknown_tag_id.c b/tests/core/proto/test_proto_get_light_state_unknown_tag_id.c
--- a/tests/core/proto/test_proto_get_light_state_unknown_tag_id.c
+++ b/tests/core/proto/test_proto_get_light_state_unknown_tag_id.c
@@ -34,7 +34,8 @@
         SLIST_HEAD_INITIALIZER(&devices);
 
     static struct lgtd_lifx_gateway gw_bulb_1 = {
-        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_1.bulbs)
+        .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_1.bulbs),
+        .peeraddr = "[::ffff:127.0.0.1]:1"
     };
     static struct lgtd_lifx_bulb bulb_1 = {
         .addr = { 1, 2, 3, 4, 5 },
@@ -57,7 +58,8 @@
     struct lgtd_lifx_tag *gw_2_tag_3 = lgtd_tests_insert_mock_tag("wave~");
     static struct lgtd_lifx_gateway gw_bulb_2 = {
         .bulbs = LIST_HEAD_INITIALIZER(&gw_bulb_2.bulbs),
-        .tag_ids = 0x7
+        .tag_ids = 0x7,
+        .peeraddr = "[::ffff:127.0.0.1]:2"
     };
     lgtd_tests_add_tag_to_gw(gw_2_tag_1, &gw_bulb_2, 0);
     lgtd_tests_add_tag_to_gw(gw_2_tag_2, &gw_bulb_2, 1);
@@ -84,12 +86,13 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
     struct lgtd_proto_target_list *targets = (void *)0x2a;
 
     lgtd_opts.verbosity = LGTD_INFO;
 
-    lgtd_proto_get_light_state(&client, targets);
+    lgtd_proto_get_light_state(client, targets);
 
     const char expected[] = ("["
         "{"
@@ -97,7 +100,7 @@
                 "\"addr\":\"05:04:03:02:01:00\","
                 "\"gateway\":{"
                     "\"site\":\"00:00:00:00:00:00\","
-                    "\"url\":\"tcp://[]:0\","
+                    "\"url\":\"tcp://[::ffff:127.0.0.1]:2\","
                     "\"latency\":0"
                 "},"
                 "\"mcu\":{\"firmware_version\":\"0.0\"},"
@@ -115,7 +118,7 @@
                 "\"addr\":\"01:02:03:04:05:00\","
                 "\"gateway\":{"
                     "\"site\":\"00:00:00:00:00:00\","
-                    "\"url\":\"tcp://[]:0\","
+                    "\"url\":\"tcp://[::ffff:127.0.0.1]:1\","
                     "\"latency\":0"
                 "},"
                 "\"mcu\":{\"firmware_version\":\"0.0\"},"
diff --git a/tests/core/proto/test_proto_power_off.c b/tests/core/proto/test_proto_power_off.c
--- a/tests/core/proto/test_proto_power_off.c
+++ b/tests/core/proto/test_proto_power_off.c
@@ -55,9 +55,10 @@
     struct lgtd_proto_target_list *targets;
     targets = lgtd_tests_build_target_list("*", NULL);
 
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
-    lgtd_proto_power_off(&client, targets);
+    lgtd_proto_power_off(client, targets);
 
     return 0;
 }
diff --git a/tests/core/proto/test_proto_power_off_routing_error.c b/tests/core/proto/test_proto_power_off_routing_error.c
--- a/tests/core/proto/test_proto_power_off_routing_error.c
+++ b/tests/core/proto/test_proto_power_off_routing_error.c
@@ -55,9 +55,10 @@
     struct lgtd_proto_target_list *targets;
     targets = lgtd_tests_build_target_list("*", NULL);
 
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
-    lgtd_proto_power_off(&client, targets);
+    lgtd_proto_power_off(client, targets);
 
     return 0;
 }
diff --git a/tests/core/proto/test_proto_power_on.c b/tests/core/proto/test_proto_power_on.c
--- a/tests/core/proto/test_proto_power_on.c
+++ b/tests/core/proto/test_proto_power_on.c
@@ -55,9 +55,10 @@
     struct lgtd_proto_target_list *targets;
     targets = lgtd_tests_build_target_list("*", NULL);
 
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
-    lgtd_proto_power_on(&client, targets);
+    lgtd_proto_power_on(client, targets);
 
     return 0;
 }
diff --git a/tests/core/proto/test_proto_power_on_routing_error.c b/tests/core/proto/test_proto_power_on_routing_error.c
--- a/tests/core/proto/test_proto_power_on_routing_error.c
+++ b/tests/core/proto/test_proto_power_on_routing_error.c
@@ -55,9 +55,10 @@
     struct lgtd_proto_target_list *targets;
     targets = lgtd_tests_build_target_list("*", NULL);
 
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
-    lgtd_proto_power_on(&client, targets);
+    lgtd_proto_power_on(client, targets);
 
     return 0;
 }
diff --git a/tests/core/proto/test_proto_power_toggle.c b/tests/core/proto/test_proto_power_toggle.c
--- a/tests/core/proto/test_proto_power_toggle.c
+++ b/tests/core/proto/test_proto_power_toggle.c
@@ -127,10 +127,11 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
     struct lgtd_proto_target_list *targets = (void *)0x2a;
 
-    lgtd_proto_power_toggle(&client, targets);
+    lgtd_proto_power_toggle(client, targets);
 
     const char expected[] = "true";
 
diff --git a/tests/core/proto/test_proto_power_toggle_targets_to_device_fails.c b/tests/core/proto/test_proto_power_toggle_targets_to_device_fails.c
--- a/tests/core/proto/test_proto_power_toggle_targets_to_device_fails.c
+++ b/tests/core/proto/test_proto_power_toggle_targets_to_device_fails.c
@@ -66,10 +66,11 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
     struct lgtd_proto_target_list *targets = (void *)0x2a;
 
-    lgtd_proto_power_toggle(&client, targets);
+    lgtd_proto_power_toggle(client, targets);
 
     if (client_send_error_call_count != 1) {
         errx(1, "lgtd_client_send_error called %d times (expected 1)",
diff --git a/tests/core/proto/test_proto_set_label.c b/tests/core/proto/test_proto_set_label.c
--- a/tests/core/proto/test_proto_set_label.c
+++ b/tests/core/proto/test_proto_set_label.c
@@ -69,9 +69,10 @@
     struct lgtd_proto_target_list *targets;
     targets = lgtd_tests_build_target_list("*", NULL);
 
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
-    lgtd_proto_set_label(&client, targets, "test");
+    lgtd_proto_set_label(client, targets, "test");
 
     if (!router_send_call_count) {
         errx(1, "lgtd_router_send wasn't called");
diff --git a/tests/core/proto/test_proto_set_label_too_long.c b/tests/core/proto/test_proto_set_label_too_long.c
--- a/tests/core/proto/test_proto_set_label_too_long.c
+++ b/tests/core/proto/test_proto_set_label_too_long.c
@@ -71,9 +71,10 @@
     struct lgtd_proto_target_list *targets;
     targets = lgtd_tests_build_target_list("*", NULL);
 
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
-    lgtd_proto_set_label(&client, targets, test_label);
+    lgtd_proto_set_label(client, targets, test_label);
 
     if (!router_send_call_count) {
         errx(1, "lgtd_router_send wasn't called");
diff --git a/tests/core/proto/test_proto_tag_create.c b/tests/core/proto/test_proto_tag_create.c
--- a/tests/core/proto/test_proto_tag_create.c
+++ b/tests/core/proto/test_proto_tag_create.c
@@ -220,11 +220,12 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
     setup_devices();
 
-    lgtd_proto_tag(&client, FAKE_TARGET_LIST, "dub");
+    lgtd_proto_tag(client, FAKE_TARGET_LIST, "dub");
 
     const char expected[] = "true";
     if (client_write_buf_idx != sizeof(expected) - 1) {
diff --git a/tests/core/proto/test_proto_tag_create_lifx_gw_tag_ids_full.c b/tests/core/proto/test_proto_tag_create_lifx_gw_tag_ids_full.c
--- a/tests/core/proto/test_proto_tag_create_lifx_gw_tag_ids_full.c
+++ b/tests/core/proto/test_proto_tag_create_lifx_gw_tag_ids_full.c
@@ -187,12 +187,12 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
     setup_devices();
 
-    lgtd_proto_tag(&client, FAKE_TARGET_LIST, "dub");
-
+    lgtd_proto_tag(client, FAKE_TARGET_LIST, "dub");
 
     if (gateway_send_to_site_called) {
         lgtd_errx(1, "SET_TAG_LABELS shouldn't have been sent");
diff --git a/tests/core/proto/test_proto_tag_update.c b/tests/core/proto/test_proto_tag_update.c
--- a/tests/core/proto/test_proto_tag_update.c
+++ b/tests/core/proto/test_proto_tag_update.c
@@ -247,11 +247,12 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
     setup_devices();
 
-    lgtd_proto_tag(&client, FAKE_TARGET_LIST, "dub");
+    lgtd_proto_tag(client, FAKE_TARGET_LIST, "dub");
 
     const char expected[] = "true";
     if (client_write_buf_idx != sizeof(expected) - 1) {
diff --git a/tests/core/proto/test_proto_untag.c b/tests/core/proto/test_proto_untag.c
--- a/tests/core/proto/test_proto_untag.c
+++ b/tests/core/proto/test_proto_untag.c
@@ -136,13 +136,14 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
     struct lgtd_proto_target_list *targets = (void *)0x2a;
 
     tag_vapor = lgtd_tests_insert_mock_tag("vapor");
 
-    lgtd_proto_untag(&client, targets, "vapor");
+    lgtd_proto_untag(client, targets, "vapor");
 
     const char expected[] = "true";
 
diff --git a/tests/core/proto/test_proto_untag_tag_does_not_exist.c b/tests/core/proto/test_proto_untag_tag_does_not_exist.c
--- a/tests/core/proto/test_proto_untag_tag_does_not_exist.c
+++ b/tests/core/proto/test_proto_untag_tag_does_not_exist.c
@@ -53,12 +53,13 @@
 int
 main(void)
 {
-    struct lgtd_client client = { .io = FAKE_BUFFEREVENT };
+    struct lgtd_client *client;
+    client = lgtd_tests_insert_mock_client(FAKE_BUFFEREVENT);
 
     struct lgtd_proto_target_list *targets;
     targets = lgtd_tests_build_target_list("*", NULL);
 
-    lgtd_proto_untag(&client, targets, "vapor");
+    lgtd_proto_untag(client, targets, "vapor");
 
     const char expected[] = "true";
 
diff --git a/tests/core/tests_utils.c b/tests/core/tests_utils.c
--- a/tests/core/tests_utils.c
+++ b/tests/core/tests_utils.c
@@ -1,6 +1,7 @@
 #include <sys/queue.h>
 #include <sys/tree.h>
 #include <sys/socket.h>
+#include <arpa/inet.h>
 #include <assert.h>
 #include <dirent.h>
 #include <endian.h>
@@ -30,6 +31,7 @@
 #include "lifx/bulb.h"
 #include "lifx/gateway.h"
 #include "tests_utils.h"
+#include "core/lightsd.h"
 
 struct lgtd_listen_list lgtd_listeners =
     SLIST_HEAD_INITIALIZER(&lgtd_listeners);
@@ -42,6 +44,17 @@
     gw->socket = id;
     gw->site.as_array[0] = id;
 
+#if 0
+    struct sockaddr_in in_addr = {
+        .sin_family = AF_INET,
+        .sin_addr.s_addr = inet_addr("127.0.0.1"),
+        .sin_port = htons(id)
+    };
+    gw->peer = calloc(1, sizeof(in_addr));
+    memcpy(gw->peeraddr, &in_addr, sizeof(in_addr));
+    gw->peerlen = sizeof(in_addr);
+#endif
+
     LIST_INSERT_HEAD(&lgtd_lifx_gateways, gw, link);
 
     LGTD_STATS_ADD_AND_UPDATE_PROCTITLE(gateways, 1);
@@ -124,16 +137,44 @@
 }
 
 struct lgtd_listen *
-lgtd_tests_insert_mock_listener(const char *addr, const char *port)
+lgtd_tests_insert_mock_listener(const char *ipv4, uint16_t port)
 {
     struct lgtd_listen *listener = calloc(1, sizeof(*listener));
-    listener->addr = addr;
-    listener->port = port;
+    struct sockaddr_in in_addr = {
+        .sin_family = AF_INET,
+        .sin_addr.s_addr = inet_addr(ipv4),
+        .sin_port = htons(port)
+    };
+    listener->sockaddr = calloc(1, sizeof(in_addr));
+    memcpy(listener->sockaddr, &in_addr, sizeof(in_addr));
+    listener->addrlen = sizeof(in_addr);
     SLIST_INSERT_HEAD(&lgtd_listeners, listener, link);
 
     return listener;
 }
 
+static struct sockaddr *
+lgtd_tests_make_sockaddr(int family, const char *addr, size_t addrlen)
+{
+    struct sockaddr *sa = calloc(1, sizeof(struct sockaddr_storage));
+    sa->sa_family = family;
+    memcpy(sa->sa_data, addr, LGTD_MIN(
+        sizeof(*sa) - offsetof(struct sockaddr, sa_data), addrlen
+    ));
+    return sa;
+}
+
+struct lgtd_client *
+lgtd_tests_insert_mock_client(struct bufferevent *io)
+{
+    struct lgtd_client *client = calloc(1, sizeof(*client));
+    client->io = io;
+    client->addr = lgtd_tests_make_sockaddr(
+        AF_UNIX, "/toto.sock", sizeof("/toto.sock")
+    );
+    return client;
+}
+
 char *
 lgtd_tests_make_temp_dir(void)
 {
diff --git a/tests/core/tests_utils.h b/tests/core/tests_utils.h
--- a/tests/core/tests_utils.h
+++ b/tests/core/tests_utils.h
@@ -1,5 +1,7 @@
 #pragma once
 
+struct bufferevent;
+
 static inline bool
 lgtd_tests_lifx_header_has_flags(const struct lgtd_lifx_packet_header *hdr,
                                  int flags)
@@ -40,4 +42,5 @@
 struct lgtd_lifx_site *lgtd_tests_add_tag_to_gw(struct lgtd_lifx_tag *,
                                                 struct lgtd_lifx_gateway *,
                                                 int);
-struct lgtd_listen *lgtd_tests_insert_mock_listener(const char *addr, const char *port);
+struct lgtd_listen *lgtd_tests_insert_mock_listener(const char *, uint16_t);
+struct lgtd_client *lgtd_tests_insert_mock_client(struct bufferevent *);
