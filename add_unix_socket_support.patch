# HG changeset patch
# Parent  4e63aff2211f55dc8b5c773910a3cd5b3bd69e5f
Add support for unix sockets with the -s option (--socket)

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,10 +1,11 @@
-CMAKE_MINIMUM_REQUIRED(VERSION 2.8.11)  # first version TARGET_INCLUDE_DIRECTORIES
+# first version with TARGET_INCLUDE_DIRECTORIES:
+CMAKE_MINIMUM_REQUIRED(VERSION 2.8.11)
 
 PROJECT(LIGHTSD C)
 
 SET(CPACK_PACKAGE_VERSION_MAJOR "0")
 SET(CPACK_PACKAGE_VERSION_MINOR "9")
-SET(CPACK_PACKAGE_VERSION_PATCH "1")
+SET(CPACK_PACKAGE_VERSION_PATCH "2")
 SET(LIGHTSD_VERSION "${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}")
 
 MESSAGE(STATUS "CMake version: ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}")
@@ -14,7 +15,7 @@
 MESSAGE(STATUS "Install prefix: ${CMAKE_INSTALL_PREFIX}")
 MESSAGE(STATUS "Source directory: ${LIGHTSD_SOURCE_DIR}")
 
-SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${LIGHTSD_SOURCE_DIR}/CMakeScripts)
+SET(CMAKE_MODULE_PATH "${CMAKE_MODULE_PATH}" "${LIGHTSD_SOURCE_DIR}/CMakeScripts")
 
 ENABLE_TESTING()
 
@@ -38,9 +39,11 @@
 
 SET(CMAKE_EXPORT_COMPILE_COMMANDS TRUE)
 
-SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE}} -pipe")
-SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wextra -Wall -Wstrict-prototypes -std=c99")
+SET(CMAKE_C_FLAGS "-pipe ${CMAKE_C_FLAGS}")
 STRING(STRIP "${CMAKE_C_FLAGS}" CMAKE_C_FLAGS)
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE}}")
+STRING(STRIP "${CMAKE_C_FLAGS}" CMAKE_C_FLAGS)
+SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wextra -Wall -Wstrict-prototypes -std=c11")
 SET(CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE} "")
 
 ADD_DEFINITIONS(
diff --git a/README.rst b/README.rst
--- a/README.rst
+++ b/README.rst
@@ -33,8 +33,8 @@
 - set_label;
 - tag/untag (group/ungroup bulbs together).
 
-The JSON-RPC interface works on top of TCP/IPv4/v6 or over a command pipe (named
-pipe, see mkfifo(1)).
+The JSON-RPC interface works on top of TCP/IPv4/v6, Unix sockets, or over a
+command pipe (named pipe, see mkfifo(1)).
 
 lightsd can target single or multiple bulbs at once:
 
diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -69,6 +69,9 @@
 
     struct lgtd_client *client = ctx;
 
+    char addr[LGTD_SOCKADDR_STRLEN];
+    LGTD_SOCKADDRTOA(client->addr, addr);
+
     struct evbuffer *input = bufferevent_get_input(bev);
     size_t nbytes = evbuffer_get_contiguous_space(input);
     // Get the actual pointer to the beginning of the evbuf:
@@ -86,10 +89,7 @@
         switch (rv) {
         case JSMN_ERROR_NOMEM:
         case JSMN_ERROR_INVAL:
-            lgtd_warnx(
-                "client [%s]:%hu: request too big or invalid",
-                client->ip_addr, client->port
-            );
+            lgtd_warnx("client %s: request too big or invalid", addr);
             evbuffer_drain(input, nbytes);
             break;
         case JSMN_ERROR_PART:
@@ -100,10 +100,7 @@
             (void)0;
             size_t buflen = evbuffer_get_length(input);
             if (buflen > LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) {
-                lgtd_warnx(
-                    "client [%s]:%hu: request too big or invalid",
-                    client->ip_addr, client->port
-                );
+                lgtd_warnx("client %s: request too big or invalid", addr);
                 evbuffer_drain(input, buflen);
             } else if (nbytes == buflen) {
                 return; // We pulled up everything already, wait for more data
@@ -139,10 +136,10 @@
     struct lgtd_client *client = ctx;
 
     if (events & (BEV_EVENT_ERROR|BEV_EVENT_EOF)) {
-        lgtd_info(
-            "lost connection with client [%s]:%hu",
-            client->ip_addr, client->port
-        );
+        char addr[LGTD_SOCKADDR_STRLEN];
+        lgtd_info("lost connection with client %s", LGTD_SOCKADDRTOA(
+            client->addr, addr
+        ));
         lgtd_client_close(client);
     }
 }
@@ -197,21 +194,29 @@
 }
 
 struct lgtd_client *
-lgtd_client_open(evutil_socket_t peer, const struct sockaddr_storage *peer_addr)
+lgtd_client_open(evutil_socket_t peer, const struct sockaddr *addr, int addrlen)
 {
     assert(peer != -1);
-    assert(peer_addr);
+    assert(addr);
 
     struct lgtd_client *client = calloc(1, sizeof(*client));
     if (!client) {
         return NULL;
     }
+
     client->io = bufferevent_socket_new(
         lgtd_ev_base, peer, BEV_OPT_CLOSE_ON_FREE
     );
     if (!client->io) {
-        return NULL;
+        goto error;
     }
+
+    client->addr = calloc(1, addrlen);
+    if (!client->addr) {
+        goto error;
+    }
+    memcpy(client->addr, addr, addrlen);
+
     bufferevent_setcb(
         client->io,
         lgtd_client_read_callback,
@@ -219,15 +224,23 @@
         lgtd_client_event_callback,
         client
     );
-    lgtd_sockaddrtoa(peer_addr, client->ip_addr, sizeof(client->ip_addr));
-    client->port = lgtd_sockaddrport(peer_addr);
-    bufferevent_enable(client->io, EV_READ|EV_WRITE|EV_TIMEOUT);
+    if (bufferevent_enable(client->io, EV_READ|EV_WRITE|EV_TIMEOUT) == -1) {
+        goto error;
+    }
 
     LIST_INSERT_HEAD(&lgtd_clients, client, link);
 
     LGTD_STATS_ADD_AND_UPDATE_PROCTITLE(clients, 1);
 
     return client;
+
+error:
+    if (client->io) {
+        bufferevent_free(client->io);
+    }
+    free(client->addr);
+    free(client);
+    return NULL;
 }
 
 void
diff --git a/core/client.h b/core/client.h
--- a/core/client.h
+++ b/core/client.h
@@ -33,8 +33,7 @@
 struct lgtd_client {
     LIST_ENTRY(lgtd_client)     link;
     struct bufferevent          *io;
-    char                        ip_addr[INET6_ADDRSTRLEN];
-    uint16_t                    port;
+    struct sockaddr             *addr;
     jsmn_parser                 jsmn_ctx;
     jsmntok_t                   jsmn_tokens[LGTD_CLIENT_JSMN_TOKENS_NUM];
     const char                  *json;
@@ -42,7 +41,7 @@
 };
 LIST_HEAD(lgtd_client_list, lgtd_client);
 
-struct lgtd_client *lgtd_client_open(evutil_socket_t, const struct sockaddr_storage *);
+struct lgtd_client *lgtd_client_open(evutil_socket_t, const struct sockaddr *, int);
 void lgtd_client_open_from_pipe(struct lgtd_client *);
 void lgtd_client_close_all(void);
 
diff --git a/core/daemon.c b/core/daemon.c
--- a/core/daemon.c
+++ b/core/daemon.c
@@ -135,9 +135,10 @@
     }                                                         \
 } while (0)
 
+    char addr[LGTD_SOCKADDR_STRLEN];
     LOOP(
         SLIST, &lgtd_listeners, struct lgtd_listen,
-        "listening_on", "%s:[%s]", it->addr, it->port
+        "listening_on", "%s", LGTD_SOCKADDRTOA(it->sockaddr, addr)
     );
 
     LOOP(
diff --git a/core/lightsd.c b/core/lightsd.c
--- a/core/lightsd.c
+++ b/core/lightsd.c
@@ -76,20 +76,6 @@
 #endif
 }
 
-short
-lgtd_sockaddrport(const struct sockaddr_storage *peer)
-{
-    assert(peer);
-
-    if (peer->ss_family == AF_INET) {
-        const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
-        return ntohs(in_peer->sin_port);
-    } else {
-        const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
-        return ntohs(in6_peer->sin6_port);
-    }
-}
-
 static void
 lgtd_signal_event_callback(int signum, short events, void *ctx)
 {
@@ -143,6 +129,8 @@
 "  [-c,--comand-pipe /command/fifo [+]] Open an unidirectional JSON-RPC \n"
 "                                       command pipe at this location (can \n"
 "                                       be repeated).\n"
+"  [-s,--socket /unix/socket [+]]       Open an Unix socket at this location \n"
+"                                       (can be repeated).\n"
 "  [-f,--foreground]                    Stay in the foreground (default).\n"
 "  [-d,--daemonize]                     Fork in the background.\n"
 "  [-t,--no-timestamps]                 Disable timestamps in logs.\n"
@@ -168,6 +156,7 @@
     static const struct option long_opts[] = {
         {"listen",          required_argument, NULL, 'l'},
         {"command-pipe",    required_argument, NULL, 'c'},
+        {"socket",          required_argument, NULL, 's'},
         {"foreground",      no_argument,       NULL, 'f'},
         {"daemonize",       no_argument,       NULL, 'd'},
         {"no-timestamps",   no_argument,       NULL, 't'},
@@ -177,7 +166,7 @@
         {"prefix",          no_argument,       NULL, 'p'},
         {NULL,              0,                 NULL, 0}
     };
-    const char short_opts[] = "l:c:fdthv:V";
+    const char short_opts[] = "l:c:s:fdthv:V";
 
     if (argc == 1) {
         lgtd_usage(argv[0]);
@@ -203,6 +192,11 @@
                 exit(1);
             }
             break;
+        case 's':
+            if (!lgtd_listen_unix_open(optarg)) {
+                exit(1);
+            }
+            break;
         case 'f':
             lgtd_opts.foreground = true;
             break;
@@ -229,6 +223,7 @@
             break;
         case 'V':
             printf("lightsd %s\n", LGTD_VERSION);
+            lgtd_cleanup();
             return 0;
         case 'p':
             printf(
diff --git a/core/lightsd.h b/core/lightsd.h
--- a/core/lightsd.h
+++ b/core/lightsd.h
@@ -66,6 +66,8 @@
 
 enum { LGTD_ERROR_MSG_BUFSIZE = 2048 };
 
+enum { LGTD_SOCKADDR_STRLEN = 128 };  // should be >= sockaddr_un.sun_path
+
 struct lgtd_opts {
     bool                foreground;
     bool                log_timestamps;
@@ -79,8 +81,9 @@
 char *lgtd_iee8023mactoa(const uint8_t *addr, char *buf, int buflen);
 #define LGTD_IEEE8023MACTOA(addr, buf) \
     lgtd_iee8023mactoa((addr), (buf), sizeof(buf))
-void lgtd_sockaddrtoa(const struct sockaddr_storage *, char *buf, int buflen);
-short lgtd_sockaddrport(const struct sockaddr_storage *);
+char *lgtd_sockaddrtoa(const struct sockaddr *, char *buf, int buflen);
+#define LGTD_SOCKADDRTOA(addr, buf) \
+    lgtd_sockaddrtoa((addr), (buf), sizeof(buf))
 
 char *lgtd_print_duration(uint64_t, char *, int);
 #define LGTD_PRINT_DURATION(secs, arr) \
diff --git a/core/listen.c b/core/listen.c
--- a/core/listen.c
+++ b/core/listen.c
@@ -16,8 +16,12 @@
 // along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <sys/queue.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/un.h>
 #include <assert.h>
 #include <err.h>
+#include <errno.h>
 #include <stdbool.h>
 #include <stdlib.h>
 #include <string.h>
@@ -39,26 +43,38 @@
 static void
 lgtd_listen_accept_new_client(struct evconnlistener *evlistener,
                               evutil_socket_t peer,
-                              struct sockaddr *peer_addr,
+                              struct sockaddr *addr,
                               int addrlen,
                               void *ctx)
 {
     (void)evlistener;
-    (void)addrlen;
+    struct lgtd_listen *listener = ctx;
 
-    struct lgtd_listen *listener = ctx;
-    struct lgtd_client *client = lgtd_client_open(
-        peer, (struct sockaddr_storage *)peer_addr
-    );
-    if (client) {
-        lgtd_info(
-            "accepted new client [%s]:%hu", client->ip_addr, client->port
+    char bufserver[LGTD_SOCKADDR_STRLEN];
+    LGTD_SOCKADDRTOA(listener->sockaddr, bufserver);
+
+    struct lgtd_client *client = NULL;
+    if (addr->sa_family == AF_UNIX) {
+        struct sockaddr_storage sockname;
+        memset(&sockname, 0, sizeof(sockname));
+        ev_socklen_t socklen = sizeof(sockname);
+        getsockname(peer, (struct sockaddr *)&sockname, &socklen);
+        client = lgtd_client_open(peer, (struct sockaddr *)&sockname, socklen);
+    } else {
+        client = lgtd_client_open(peer, addr, addrlen);
+    }
+
+    if (!client) {
+        char bufclient[LGTD_SOCKADDR_STRLEN];
+        lgtd_warn(
+            "can't accept new client %s on %s",
+            LGTD_SOCKADDRTOA(client->addr, bufclient),
+            bufserver
         );
         return;
     }
-    lgtd_warn(
-        "can't accept new client on %s:%s", listener->addr, listener->port
-    );
+
+    lgtd_info("accepted new client %s", bufserver);
 }
 
 void
@@ -67,7 +83,15 @@
     while (!SLIST_EMPTY(&lgtd_listeners)) {
         struct lgtd_listen *listener = SLIST_FIRST(&lgtd_listeners);
         SLIST_REMOVE_HEAD(&lgtd_listeners, link);
+        if (listener->sockaddr->sa_family == AF_UNIX) {
+            struct sockaddr_un *sockpath;
+            sockpath = (struct sockaddr_un *)listener->sockaddr;
+            unlink(sockpath->sun_path);
+        }
         evconnlistener_free(listener->evlistener);
+        char addr[LGTD_SOCKADDR_STRLEN];
+        LGTD_SOCKADDRTOA(listener->sockaddr, addr);
+        lgtd_info("closed socket %s", addr);
         free(listener);
     }
 
@@ -80,13 +104,6 @@
     assert(addr);
     assert(port);
 
-    struct lgtd_listen *listener;
-    SLIST_FOREACH(listener, &lgtd_listeners, link) {
-        if (!strcmp(listener->addr, addr) && listener->port == port) {
-            return true;
-        }
-    }
-
     struct evutil_addrinfo *res = NULL, hints = {
         .ai_family = AF_UNSPEC,
         .ai_socktype = SOCK_STREAM,
@@ -102,13 +119,25 @@
         return false;
     }
 
+    struct lgtd_listen *listener;
     struct evconnlistener *evlistener;
     for (struct evutil_addrinfo *it = res; it; it = it->ai_next) {
+        SLIST_FOREACH(listener, &lgtd_listeners, link) {
+            if (listener->addrlen == it->ai_addrlen
+                && memcmp(listener->sockaddr, it->ai_addr, it->ai_addrlen)) {
+                return true;
+            }
+        }
+
         evlistener = NULL;
         listener = calloc(1, sizeof(*listener));
         if (!listener) {
             goto error;
         }
+        listener->sockaddr = calloc(1, it->ai_addrlen);
+        if (!listener->sockaddr) {
+            goto error;
+        }
         evlistener = evconnlistener_new_bind(
             lgtd_ev_base,
             lgtd_listen_accept_new_client,
@@ -121,9 +150,11 @@
         if (!evlistener) {
             goto error;
         }
+
         listener->evlistener = evlistener;
-        listener->addr = addr;
-        listener->port = port;
+        listener->addrlen = it->ai_addrlen;
+        memcpy(listener->sockaddr, it->ai_addr, it->ai_addrlen);
+
         SLIST_INSERT_HEAD(&lgtd_listeners, listener, link);
         lgtd_info(
             "listening on %s:%s (%s)",
@@ -139,10 +170,110 @@
 
 error:
     lgtd_warn("can't listen on %s:%s", addr, port);
-    if (evlistener) {
-        evconnlistener_free(evlistener);
+    if (listener) {
+        if (listener->evlistener) {
+            evconnlistener_free(evlistener);
+        }
+        free(listener->sockaddr);
+        free(listener);
     }
-    free(listener);
     evutil_freeaddrinfo(res);
     return false;
 }
+
+bool
+lgtd_listen_unix_open(const char *path)
+{
+    assert(path);
+
+    static const int maxpathlen =
+        sizeof(struct sockaddr_un) - offsetof(struct sockaddr_un, sun_path);
+    int pathlen = strlen(path);
+    if (pathlen > maxpathlen) {
+        lgtd_warnx(
+            "%s (%d bytes) is too long, your system only supports paths up to "
+            "%d bytes", path, pathlen, maxpathlen
+        );
+        return false;
+    }
+
+    struct lgtd_listen *listener;
+    SLIST_FOREACH(listener, &lgtd_listeners, link) {
+        if (listener->addrlen == sizeof(struct sockaddr_un)) {
+            struct sockaddr_un *sockaddr;
+            sockaddr = (struct sockaddr_un *)listener->sockaddr;
+            if (!strcmp(sockaddr->sun_path, path)) {
+                return true;
+            }
+        }
+    }
+
+    evutil_socket_t fd = -1;
+
+    listener = calloc(1, sizeof(*listener));
+    if (!listener) {
+        goto error;
+    }
+
+    struct sockaddr_un *sockpath = calloc(1, sizeof(*sockpath));
+    if (!sockpath) {
+        goto error;
+    }
+    sockpath->sun_family = AF_UNIX;
+    memcpy(sockpath->sun_path, path, pathlen);
+    listener->sockaddr = (struct sockaddr *)sockpath;
+    listener->addrlen = sizeof(*sockpath);
+
+    fd = socket(AF_UNIX, SOCK_STREAM, 0);
+    if (fd == -1) {
+        goto error;
+    }
+
+    if (evutil_make_socket_nonblocking(fd) == -1) {
+        goto error;
+    }
+
+    struct stat sb;
+    if (stat(path, &sb) == -1) {
+        if (errno != ENOENT) {
+            goto error;
+        }
+    } else if ((sb.st_mode & S_IFMT) == S_IFSOCK) {
+        lgtd_warnx("removing existing unix socket: %s", path);
+        if (unlink(path) == -1 && errno != ENOENT) {
+            goto error;
+        }
+    } else {
+        errno = EEXIST;
+        goto error;
+    }
+
+    if (bind(fd, (struct sockaddr *)sockpath, sizeof(*sockpath)) == -1) {
+        goto error;
+    }
+
+    listener->evlistener = evconnlistener_new(
+        lgtd_ev_base,
+        lgtd_listen_accept_new_client,
+        listener,
+        LEV_OPT_CLOSE_ON_FREE,
+        -1,
+        fd
+    );
+    if (!listener->evlistener) {
+        goto error;
+    }
+
+    SLIST_INSERT_HEAD(&lgtd_listeners, listener, link);
+    lgtd_info("unix socket ready at %s", path);
+
+    return true;
+
+error:
+    lgtd_warn("can't open unix at %s", path);
+    if (fd != -1) {
+        close(fd);
+    }
+    free(listener);
+    return false;
+}
diff --git a/core/listen.h b/core/listen.h
--- a/core/listen.h
+++ b/core/listen.h
@@ -21,8 +21,8 @@
 
 struct lgtd_listen {
     SLIST_ENTRY(lgtd_listen)    link;
-    const char                  *addr;
-    const char                  *port;
+    ev_socklen_t                addrlen;
+    struct sockaddr             *sockaddr;
     struct evconnlistener       *evlistener;
 };
 SLIST_HEAD(lgtd_listen_list, lgtd_listen);
@@ -30,4 +30,5 @@
 extern struct lgtd_listen_list lgtd_listeners;
 
 bool lgtd_listen_open(const char *, const char *);
+bool lgtd_listen_unix_open(const char *);
 void lgtd_listen_close_all(void);
diff --git a/core/log.c b/core/log.c
--- a/core/log.c
+++ b/core/log.c
@@ -15,8 +15,10 @@
 // You should have received a copy of the GNU General Public License
 // along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
 
+#include <sys/socket.h>
 #include <sys/tree.h>
 #include <sys/time.h>
+#include <sys/un.h>
 #include <arpa/inet.h>
 #include <assert.h>
 #include <endian.h>
@@ -27,6 +29,7 @@
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <time.h>
 
 #if LGTD_HAVE_LIBBSD
@@ -88,23 +91,46 @@
     return buf;
 }
 
-void
-lgtd_sockaddrtoa(const struct sockaddr_storage *peer, char *buf, int buflen)
+char *
+lgtd_sockaddrtoa(const struct sockaddr *peer, char *buf, int buflen)
 {
     assert(peer);
     assert(buf);
-    assert(buflen > 0);
+    assert(buflen > 1);
 
-    const char *printed;
-    if (peer->ss_family == AF_INET) {
+    const char *printed = NULL;
+    int i = 0;
+    switch (peer->sa_family) {
+    case AF_INET:
+        (void)0;
         const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
-        int i = 0;
-        LGTD_SNPRINTF_APPEND(buf, i, buflen, "::ffff:");
+        LGTD_SNPRINTF_APPEND(buf, i, buflen, "[::ffff:");
         printed = inet_ntop(AF_INET, &in_peer->sin_addr, &buf[i], buflen - i);
-    } else {
+        if (printed) {
+            i += strlen(printed);
+            LGTD_SNPRINTF_APPEND(buf, i, buflen, "]:%hu", in_peer->sin_port);
+        }
+        break;
+    case AF_INET6:
+        (void)0;
         const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
-        printed = inet_ntop(AF_INET6, &in6_peer->sin6_addr, buf, buflen);
+        LGTD_SNPRINTF_APPEND(buf, i, buflen, "[");
+        printed = inet_ntop(AF_INET6, &in6_peer->sin6_addr, &buf[i], buflen - i);
+        if (printed) {
+            i += strlen(printed);
+            LGTD_SNPRINTF_APPEND(buf, i, buflen, "]:%hu", in6_peer->sin6_port);
+        }
+        break;
+    case AF_UNIX:
+        (void)0;
+        const struct sockaddr_un *un_path = (const struct sockaddr_un *)peer;
+        LGTD_SNPRINTF_APPEND(buf, i, buflen, "at %s", un_path->sun_path);
+        printed = buf;
+        break;
+    default:
+        break;
     }
+
     if (!printed) {
         buf[0] = 0;
         lgtd_warnx("not enough space to log an ip address");
@@ -112,6 +138,8 @@
         abort();
 #endif
     }
+
+    return buf;
 }
 
 char *
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -195,6 +195,9 @@
         return;
     }
 
+    char client_ip_addr[LGTD_SOCKADDR_STRLEN];
+    LGTD_SOCKADDRTOA(client->addr, client_ip_addr);
+
     lgtd_client_start_send_response(client);
     lgtd_client_write_string(client, "[");
     struct lgtd_router_device *device;
@@ -203,11 +206,13 @@
 
         char buf[2048],
              site_addr[LGTD_LIFX_ADDR_STRLEN],
-             bulb_addr[LGTD_LIFX_ADDR_STRLEN];
+             bulb_addr[LGTD_LIFX_ADDR_STRLEN],
+             gw_ip_addr[LGTD_SOCKADDR_STRLEN];
         int i = 0;
 
         LGTD_IEEE8023MACTOA(bulb->addr, bulb_addr);
         LGTD_IEEE8023MACTOA(bulb->gw->site.as_array, site_addr);
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&bulb->gw->peer, gw_ip_addr);
 
         LGTD_SNPRINTF_APPEND(
             buf, i, (int)sizeof(buf),
@@ -216,11 +221,10 @@
                     "\"addr\":\"%s\","
                     "\"gateway\":{"
                         "\"site\":\"%s\","
-                        "\"url\":\"tcp://[%s]:%hu\","
+                        "\"url\":\"tcp://%s\","
                         "\"latency\":%ju"
                     "}",
-            bulb_addr, site_addr,
-            bulb->gw->ip_addr, bulb->gw->port,
+            bulb_addr, site_addr, gw_ip_addr,
             (uintmax_t)lgtd_lifx_gateway_latency(bulb->gw)
         );
 
@@ -347,8 +351,8 @@
         if (i >= (int)sizeof(buf)) {
             lgtd_warnx(
                 "can't send state of bulb %s (%s) to client "
-                "[%s]:%hu: output buffer to small",
-                bulb->state.label, bulb_addr, client->ip_addr, client->port
+                "%s: output buffer to small",
+                bulb->state.label, bulb_addr, client_ip_addr
             );
             continue;
         }
@@ -365,9 +369,9 @@
             } else {
                 lgtd_warnx(
                     "tag_id %d on bulb %.*s (%s) doesn't "
-                    "exist on gw [%s]:%hu (site %s)",
+                    "exist on gw %s (site %s)",
                     tag_id, (int)sizeof(bulb->state.label), bulb->state.label,
-                    bulb_addr, bulb->gw->ip_addr, bulb->gw->port, site_addr
+                    bulb_addr, gw_ip_addr, site_addr
                 );
             }
         }
@@ -438,9 +442,12 @@
         if (!enqueued) {
             goto error_site_alloc;
         }
+        char site_gw_ip_addr[LGTD_SOCKADDR_STRLEN];
         lgtd_info(
-            "created tag [%s] with id %d on gw [%s]:%hu",
-            tag_label, tag_id, site->gw->ip_addr, site->gw->port
+            "created tag [%s] with id %d on gw %s",
+            tag_label, tag_id, LGTD_SOCKADDRTOA(
+                (const struct sockaddr *)&site->gw->peer, site_gw_ip_addr
+            )
         );
     }
 
diff --git a/examples/lightsc.py b/examples/lightsc.py
--- a/examples/lightsc.py
+++ b/examples/lightsc.py
@@ -33,15 +33,25 @@
 import json
 import socket
 import sys
+import urllib.parse
 import uuid
 
 
 class LightsClient:
 
-    def __init__(self, host, port):
-        self.host = host
-        self.port = port
-        self._socket = socket.create_connection((host, port))
+    def __init__(self, url):
+        self.url = url
+
+        parts = urllib.parse.urlparse(args.url)
+
+        if parts.scheme == "unix":
+            self._socket = socket.socket(socket.AF_UNIX)
+            self._socket.connect(parts.path)
+        elif parts.scheme == "tcp":
+            self._socket = socket.create_connection((parts.hostname, parts.port))
+        else:
+            raise ValueError("Unsupported url {}".format(url))
+
         self._pipeline = []
         self._batch = False
 
@@ -191,8 +201,8 @@
     middle = "d073d502e530"  # noqa
 
     banner = (
-        "Connected to {}:{}, use the variable c to interact with your "
-        "bulbs:\n\n>>> r = c.get_light_state(\"*\")".format(c.host, c.port)
+        "Connected to {}, use the variable c to interact with your "
+        "bulbs:\n\n>>> r = c.get_light_state(\"*\")".format(c.url)
     )
 
     try:
@@ -213,18 +223,19 @@
         description="lightsc.py is an interactive lightsd Python client"
     )
     parser.add_argument(
-        "host", type=str, help="The hostname or ip where lightsd is running"
-    )
-    parser.add_argument(
-        "port", type=int, help="The port on which lightsd is listening on"
+        "url", type=str,
+        help="How to connect to lightsd (e.g: "
+             "unix:///run/lightsd.sock or tcp://[::1]:1234)"
     )
     args = parser.parse_args()
+
     try:
-        _drop_to_shell(LightsClient(args.host, args.port))
-    except socket.error as ex:
+        with LightsClient(args.url) as client:
+            _drop_to_shell(client)
+    except Exception as ex:
         print(
-            "Couldn't connect to lightsd@{}:{}, is it running? "
-            "({})".format(args.host, args.port, ex.strerror),
+            "Couldn't connect to {}, is lightsd running? "
+            "({})".format(args.url, ex),
             file=sys.stderr
         )
         sys.exit(1)
diff --git a/lifx/broadcast.c b/lifx/broadcast.c
--- a/lifx/broadcast.c
+++ b/lifx/broadcast.c
@@ -88,29 +88,23 @@
 
         lgtd_time_mono_t received_at = lgtd_time_monotonic_msecs();
         char peer_addr[INET6_ADDRSTRLEN];
-        lgtd_sockaddrtoa(&peer, peer_addr, sizeof(peer_addr));
-        short peer_port = lgtd_sockaddrport(&peer);
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&peer, peer_addr);
 
         if (nbytes < LGTD_LIFX_PACKET_HEADER_SIZE) {
-            lgtd_warnx(
-                "broadcast packet too short from [%s]:%hu", peer_addr, peer_port
-            );
+            lgtd_warnx("broadcast packet too short from %s", peer_addr);
             return false;
         }
 
         lgtd_lifx_wire_decode_header(&read.hdr);
         if (read.hdr.size != nbytes) {
-            lgtd_warnx(
-                "incomplete broadcast packet from [%s]:%hu",
-                peer_addr, peer_port
-            );
+            lgtd_warnx("incomplete broadcast packet from %s", peer_addr);
             return false;
         }
         int proto_version = read.hdr.protocol & LGTD_LIFX_PROTOCOL_VERSION_MASK;
         if (proto_version != LGTD_LIFX_PROTOCOL_V1) {
             lgtd_warnx(
-                "unsupported protocol %d from [%s]:%hu",
-                read.hdr.protocol & 0x0fff, peer_addr, peer_port
+                "unsupported protocol %d from %s",
+                read.hdr.protocol & 0x0fff, peer_addr
             );
         }
         if (read.hdr.packet_type == LGTD_LIFX_GET_PAN_GATEWAY) {
@@ -121,15 +115,15 @@
             lgtd_lifx_wire_get_packet_info(read.hdr.packet_type);
         if (!pkt_info) {
             lgtd_warnx(
-                "received unknown packet %#x from [%s]:%hu",
-                read.hdr.packet_type, peer_addr, peer_port
+                "received unknown packet %#x from %s",
+                read.hdr.packet_type, peer_addr
             );
             continue;
         }
         if (!(read.hdr.protocol & LGTD_LIFX_PROTOCOL_ADDRESSABLE)) {
             lgtd_warnx(
-                "received non-addressable packet %s from [%s]:%hu",
-                pkt_info->name, peer_addr, peer_port
+                "received non-addressable packet %s from %s",
+                pkt_info->name, peer_addr
             );
             continue;
         }
@@ -148,9 +142,7 @@
             pkt_info->decode(pkt);
             pkt_info->handle(gw, &read.hdr, pkt);
         } else {
-            lgtd_warnx(
-                "got packet from unknown gateway [%s]:%hu", peer_addr, peer_port
-            );
+            lgtd_warnx("got packet from unknown gateway %s", peer_addr);
         }
     }
 }
diff --git a/lifx/bulb.c b/lifx/bulb.c
--- a/lifx/bulb.c
+++ b/lifx/bulb.c
@@ -195,14 +195,13 @@
         LGTD_STATS_ADD_AND_UPDATE_PROCTITLE(bulbs_powered_on, -1);
     }
     RB_REMOVE(lgtd_lifx_bulb_map, &lgtd_lifx_bulbs_table, bulb);
-    char addr[LGTD_LIFX_ADDR_STRLEN];
+    char addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_info(
-        "closed bulb \"%.*s\" (%s) on [%s]:%hu",
+        "closed bulb \"%.*s\" (%s) on %s",
         LGTD_LIFX_LABEL_SIZE,
         bulb->state.label,
         LGTD_IEEE8023MACTOA(bulb->addr, addr),
-        bulb->gw->ip_addr,
-        bulb->gw->port
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&bulb->gw->peer, gw_ip_addr)
     );
     free(bulb);
 }
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -76,10 +76,11 @@
         lgtd_lifx_gateway_remove_and_close_bulb(gw, bulb);
     }
 
-    char site[LGTD_LIFX_ADDR_STRLEN];
+    char site[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_info(
-        "connection with gateway bulb [%s]:%hu (site %s) closed",
-        gw->ip_addr, gw->port, LGTD_IEEE8023MACTOA(gw->site.as_array, site)
+        "connection with gateway bulb %s (site %s) closed",
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
+        LGTD_IEEE8023MACTOA(gw->site.as_array, site)
     );
     free(gw);
 }
@@ -110,11 +111,11 @@
     assert(ctx);
 
     struct lgtd_lifx_gateway *gw = (struct lgtd_lifx_gateway *)ctx;
+    char gw_ip_addr[LGTD_SOCKADDR_STRLEN];
+    LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr);
 
     if (events & EV_TIMEOUT) {  // Not sure how that could happen in UDP but eh.
-        lgtd_warn(
-            "lost connection with gateway bulb [%s]:%hu", gw->ip_addr, gw->port
-        );
+        lgtd_warn("lost connection with gateway bulb %s", gw_ip_addr);
         lgtd_lifx_gateway_close(gw);
         if (!lgtd_lifx_broadcast_discovery()) {
             lgtd_err(1, "can't start auto discovery");
@@ -129,7 +130,7 @@
         int to_write = gw->pkt_ring[gw->pkt_ring_tail].size;
         int nbytes = evbuffer_write_atmost(gw->write_buf, gw->socket, to_write);
         if (nbytes == -1 && errno != EAGAIN) {
-            lgtd_warn("can't write to [%s]:%hu", gw->ip_addr, gw->port);
+            lgtd_warn("can't write to %s", gw_ip_addr);
             lgtd_lifx_gateway_close(gw);
             if (!lgtd_lifx_broadcast_discovery()) {
                 lgtd_err(1, "can't start auto discovery");
@@ -268,10 +269,11 @@
         bulb = lgtd_lifx_bulb_open(gw, bulb_addr);
         if (bulb) {
             SLIST_INSERT_HEAD(&gw->bulbs, bulb, link_by_gw);
-            char addr[LGTD_LIFX_ADDR_STRLEN];
+            char addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
             lgtd_info(
-                "bulb %s on [%s]:%hu",
-                LGTD_IEEE8023MACTOA(bulb->addr, addr), gw->ip_addr, gw->port
+                "bulb %s on %s",
+                LGTD_IEEE8023MACTOA(bulb->addr, addr),
+                LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr)
             );
         }
     }
@@ -317,8 +319,6 @@
     }
 
     memcpy(&gw->peer, peer, sizeof(gw->peer));
-    lgtd_sockaddrtoa(peer, gw->ip_addr, sizeof(gw->ip_addr));
-    gw->port = lgtd_sockaddrport(peer);
     memcpy(gw->site.as_array, site, sizeof(gw->site.as_array));
     gw->last_req_at = received_at;
     gw->next_req_at = received_at;
@@ -336,11 +336,11 @@
         goto error_allocate;
     }
 
-    char site_addr[LGTD_LIFX_ADDR_STRLEN];
+    char site_addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_info(
-        "gateway for site %s at [%s]:%hu",
+        "gateway for site %s at %s",
         LGTD_IEEE8023MACTOA(gw->site.as_array, site_addr),
-        gw->ip_addr, gw->port
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr)
     );
     LIST_INSERT_HEAD(&lgtd_lifx_gateways, gw, link);
 
@@ -405,9 +405,11 @@
     assert(gw->pkt_ring_head < (int)LGTD_ARRAY_SIZE(gw->pkt_ring));
 
     if (gw->pkt_ring_full) {
+        char gw_ip_addr[LGTD_SOCKADDR_STRLEN];
         lgtd_warnx(
-            "dropping packet type %s: packet queue on [%s]:%hu is full",
-            pkt_info->name, gw->ip_addr, gw->port
+            "dropping packet type %s: packet queue on %s is full",
+            pkt_info->name,
+            LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr)
         );
         return;
     }
@@ -436,14 +438,17 @@
     uint64_t removed_tags = changes & bulb_tags;
     int tag_id;
 
+    char gw_ip_addr[LGTD_SOCKADDR_STRLEN];
+    LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr);
+
     LGTD_LIFX_WIRE_FOREACH_TAG_ID(tag_id, added_tags) {
         if (gw->tag_refcounts[tag_id] != UINT8_MAX) {
             gw->tag_refcounts[tag_id]++;
         } else {
             lgtd_warnx(
-                "reached refcount limit (%u) for tag [%s] (%d) on gw [%s]:%hu",
+                "reached refcount limit (%u) for tag [%s] (%d) on gw %s",
                 UINT8_MAX, gw->tags[tag_id] ? gw->tags[tag_id]->label : NULL,
-                tag_id, gw->ip_addr, gw->port
+                tag_id, gw_ip_addr
             );
         }
     }
@@ -453,10 +458,9 @@
         if (--gw->tag_refcounts[tag_id] == 0) {
             char site[LGTD_LIFX_ADDR_STRLEN];
             lgtd_info(
-                "deleting unused tag [%s] (%d) from gw [%s]:%hu (site %s)",
+                "deleting unused tag [%s] (%d) from gw %s (site %s)",
                 gw->tags[tag_id] ? gw->tags[tag_id]->label : NULL,
-                tag_id, gw->ip_addr, gw->port,
-                LGTD_IEEE8023MACTOA(gw->site.as_array, site)
+                tag_id, gw_ip_addr, LGTD_IEEE8023MACTOA(gw->site.as_array, site)
             );
             struct lgtd_lifx_packet_tag_labels pkt = {
                 .tags = ~(gw->tag_ids & ~LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id))
@@ -485,10 +489,12 @@
 {
     assert(gw && hdr && pkt);
 
-    char addr[LGTD_LIFX_ADDR_STRLEN], site[LGTD_LIFX_ADDR_STRLEN];
+    char addr[LGTD_LIFX_ADDR_STRLEN],
+         site[LGTD_LIFX_ADDR_STRLEN],
+         gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_debug(
-        "SET_PAN_GATEWAY <-- [%s]:%hu - %s site=%s, service_type=%d",
-        gw->ip_addr, gw->port,
+        "SET_PAN_GATEWAY <-- %s - %s site=%s, service_type=%d",
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
         LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         LGTD_IEEE8023MACTOA(hdr->site, site), pkt->service_type
     );
@@ -501,13 +507,13 @@
 {
     assert(gw && hdr && pkt);
 
-    char addr[LGTD_LIFX_ADDR_STRLEN];
+    char addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
+    LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr);
     lgtd_debug(
-        "SET_LIGHT_STATE <-- [%s]:%hu - %s "
+        "SET_LIGHT_STATE <-- %s - %s "
         "hue=%#hx, saturation=%#hx, brightness=%#hx, "
         "kelvin=%d, dim=%#hx, power=%#hx, label=%.*s, tags=%#jx",
-        gw->ip_addr, gw->port,
-        LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
+        gw_ip_addr, LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         pkt->hue, pkt->saturation, pkt->brightness, pkt->kelvin,
         pkt->dim, pkt->power, LGTD_LIFX_LABEL_SIZE, pkt->label,
         (uintmax_t)pkt->tags
@@ -546,8 +552,8 @@
             struct timeval tv = LGTD_MSECS_TO_TIMEVAL(timeout);
             lgtd_timer_reschedule(gw->refresh_timer, &tv);
             lgtd_debug(
-                "[%s]:%hu latency is %jums, scheduling next GET_LIGHT_STATE in %dms",
-                gw->ip_addr, gw->port, (uintmax_t)latency, timeout
+                "%s latency is %jums, scheduling next GET_LIGHT_STATE in %dms",
+                gw_ip_addr, (uintmax_t)latency, timeout
             );
         }
         return;
@@ -555,14 +561,14 @@
 
     if (!gw->pending_refresh_req) {
         lgtd_debug(
-            "[%s]:%hu latency is %jums, sending GET_LIGHT_STATE now",
-            gw->ip_addr, gw->port, (uintmax_t)latency
+            "%s latency is %jums, sending GET_LIGHT_STATE now",
+            gw_ip_addr, (uintmax_t)latency
         );
         lgtd_lifx_gateway_send_get_all_light_state(gw);
     } else {
         lgtd_debug(
-            "[%s]:%hu GET_LIGHT_STATE for all bulbs on this gw has already "
-            "been enqueued", gw->ip_addr, gw->port
+            "%s GET_LIGHT_STATE for all bulbs on this gw has already "
+            "been enqueued", gw_ip_addr
         );
     }
 }
@@ -574,10 +580,10 @@
 {
     assert(gw && hdr && pkt);
 
-    char addr[LGTD_LIFX_ADDR_STRLEN];
+    char addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_debug(
-        "SET_POWER_STATE <-- [%s]:%hu - %s power=%#hx",
-        gw->ip_addr, gw->port,
+        "SET_POWER_STATE <-- %s - %s power=%#hx",
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
         LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr), pkt->power
     );
 
@@ -613,15 +619,16 @@
     assert(tag_id >= -1);
     assert(tag_id < LGTD_LIFX_GATEWAY_MAX_TAGS);
 
-    char site[LGTD_LIFX_ADDR_STRLEN];
+    char site[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     LGTD_IEEE8023MACTOA(gw->site.as_array, site);
+    LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr);
 
     if (tag_id == -1) {
         tag_id = lgtd_lifx_wire_bitscan64_forward(~gw->tag_ids);
         if (tag_id == -1) {
             lgtd_warnx(
-                "no tag_id left for new tag [%s] on gw [%s]:%hu (site %s)",
-                tag_label, gw->ip_addr, gw->port, site
+                "no tag_id left for new tag [%s] on gw %s (site %s)",
+                tag_label, gw_ip_addr, site
             );
             return -1;
         }
@@ -638,8 +645,8 @@
             return -1;
         }
         lgtd_debug(
-            "tag_id %d allocated for tag [%s] on gw [%s]:%hu (site %s)",
-            tag_id, tag_label, gw->ip_addr, gw->port, site
+            "tag_id %d allocated for tag [%s] on gw %s (site %s)",
+            tag_id, tag_label, gw_ip_addr, site
         );
         gw->tag_ids |= LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id);
         gw->tags[tag_id] = tag;
@@ -656,11 +663,11 @@
     assert(tag_id < LGTD_LIFX_GATEWAY_MAX_TAGS);
 
     if (gw->tag_ids & LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id)) {
-        char site[LGTD_LIFX_ADDR_STRLEN];
+        char site[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
         lgtd_debug(
-            "tag_id %d deallocated for tag [%s] on gw [%s]:%hu (site %s)",
+            "tag_id %d deallocated for tag [%s] on gw %s (site %s)",
             tag_id, gw->tags[tag_id]->label,
-            gw->ip_addr, gw->port,
+            LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
             LGTD_IEEE8023MACTOA(gw->site.as_array, site)
         );
         lgtd_lifx_tagging_decref(gw->tags[tag_id], gw);
@@ -676,10 +683,10 @@
 {
     assert(gw && hdr && pkt);
 
-    char addr[LGTD_LIFX_ADDR_STRLEN];
+    char addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_debug(
-        "SET_TAG_LABELS <-- [%s]:%hu - %s label=%.*s, tags=%jx",
-        gw->ip_addr, gw->port,
+        "SET_TAG_LABELS <-- %s - %s label=%.*s, tags=%jx",
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
         LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         LGTD_LIFX_LABEL_SIZE, pkt->label, (uintmax_t)pkt->tags
     );
@@ -701,10 +708,11 @@
 {
     assert(gw && hdr && pkt);
 
-    char addr[LGTD_LIFX_ADDR_STRLEN];
+    char addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
+    LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr);
     lgtd_debug(
-        "SET_TAGS <-- [%s]:%hu - %s tags=%#jx",
-        gw->ip_addr, gw->port,
+        "SET_TAGS <-- %s - %s tags=%#jx",
+        gw_ip_addr,
         LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         (uintmax_t)pkt->tags
     );
@@ -718,10 +726,10 @@
         if (!(gw->tag_ids & LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id))) {
             lgtd_warnx(
                 "trying to set unknown tag_id %d (%#jx) "
-                "on bulb %s (%.*s), gw [%s]:%hu (site %s)",
+                "on bulb %s (%.*s), gw %s (site %s)",
                 tag_id, LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id),
                 LGTD_IEEE8023MACTOA(b->addr, bulb_addr),
-                LGTD_LIFX_LABEL_SIZE, b->state.label, gw->ip_addr, gw->port,
+                LGTD_LIFX_LABEL_SIZE, b->state.label, gw_ip_addr,
                 LGTD_IEEE8023MACTOA(gw->site.as_array, site_addr)
             );
         }
@@ -756,11 +764,11 @@
         return;
     }
 
-    char addr[LGTD_LIFX_ADDR_STRLEN];
+    char addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_debug(
-        "%s <-- [%s]:%hu - %s "
+        "%s <-- %s - %s "
         "signal_strength=%f, rx_bytes=%u, tx_bytes=%u, temperature=%hu",
-        type, gw->ip_addr, gw->port,
+        type, LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
         LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         pkt->signal_strength, pkt->rx_bytes, pkt->tx_bytes, pkt->temperature
     );
@@ -797,11 +805,12 @@
         return;
     }
 
-    char built_at[64], installed_at[64], addr[LGTD_LIFX_ADDR_STRLEN];
+    char built_at[64], installed_at[64],
+         addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_debug(
-        "%s <-- [%s]:%hu - %s "
+        "%s <-- %s - %s "
         "built_at=%s, installed_at=%s, version=%u",
-        type, gw->ip_addr, gw->port,
+        type, LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
         LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         LGTD_LIFX_WIRE_PRINT_NSEC_TIMESTAMP(pkt->built_at, built_at),
         LGTD_LIFX_WIRE_PRINT_NSEC_TIMESTAMP(pkt->installed_at, installed_at),
@@ -821,11 +830,11 @@
 {
     assert(gw && hdr && pkt);
 
-    char addr[LGTD_LIFX_ADDR_STRLEN];
+    char addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_debug(
-        "PRODUCT_INFO <-- [%s]:%hu - %s "
+        "PRODUCT_INFO <-- %s - %s "
         "vendor_id=%#x, product_id=%#x, version=%u",
-        gw->ip_addr, gw->port,
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
         LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         pkt->vendor_id, pkt->product_id, pkt->version
     );
@@ -843,10 +852,11 @@
 {
     assert(gw && hdr && pkt);
 
-    char device_time[64], uptime[64], downtime[64], addr[LGTD_LIFX_ADDR_STRLEN];
+    char device_time[64], uptime[64], downtime[64],
+         addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_debug(
-        "PRODUCT_INFO <-- [%s]:%hu - %s time=%s, uptime=%s, downtime=%s",
-        gw->ip_addr, gw->port,
+        "PRODUCT_INFO <-- %s - %s time=%s, uptime=%s, downtime=%s",
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
         LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         LGTD_LIFX_WIRE_PRINT_NSEC_TIMESTAMP(pkt->time, device_time),
         LGTD_PRINT_DURATION(LGTD_NSECS_TO_SECS(pkt->uptime), uptime),
@@ -866,10 +876,10 @@
 {
     assert(gw && hdr && pkt);
 
-    char addr[LGTD_LIFX_ADDR_STRLEN];
+    char addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_debug(
-        "BULB_LABEL <-- [%s]:%hu - %s label=%.*s",
-        gw->ip_addr, gw->port,
+        "BULB_LABEL <-- %s - %s label=%.*s",
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
         LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         (int)sizeof(pkt->label), pkt->label
     );
@@ -886,10 +896,10 @@
 {
     assert(gw && hdr && pkt);
 
-    char addr[LGTD_LIFX_ADDR_STRLEN];
+    char addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_debug(
-        "AMBIENT_LIGHT <-- [%s]:%hu - %s ambient_light=%flx",
-        gw->ip_addr, gw->port,
+        "AMBIENT_LIGHT <-- %s - %s ambient_light=%flx",
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
         LGTD_IEEE8023MACTOA(hdr->target.device_addr, addr),
         pkt->illuminance
     );
diff --git a/lifx/gateway.h b/lifx/gateway.h
--- a/lifx/gateway.h
+++ b/lifx/gateway.h
@@ -49,8 +49,6 @@
     // remote ip address to identify a gateway:
     struct sockaddr_storage         peer;
     uint8_t                         addr[LGTD_LIFX_ADDR_LENGTH];
-    char                            ip_addr[INET6_ADDRSTRLEN];
-    uint16_t                        port;
     // TODO: just use an integer and rename it to site_id:
     union {
         uint8_t                     as_array[LGTD_LIFX_ADDR_LENGTH];
diff --git a/lifx/tagging.c b/lifx/tagging.c
--- a/lifx/tagging.c
+++ b/lifx/tagging.c
@@ -123,10 +123,11 @@
         if (dealloc_tag) {
             lgtd_info("discovered tag [%s]", tag_label);
         }
-        char site_addr[LGTD_LIFX_ADDR_STRLEN];
+        char site_addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
         lgtd_info(
-            "tag [%s] added to gw [%s]:%hu (site %s) with tag_id %d",
-            tag_label, gw->ip_addr, gw->port,
+            "tag [%s] added to gw %s (site %s) with tag_id %d",
+            tag_label,
+            LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
             LGTD_IEEE8023MACTOA(gw->site.as_array, site_addr), tag_id
         );
         site->gw = gw;
@@ -148,10 +149,11 @@
     struct lgtd_lifx_site *site;
     site = lgtd_lifx_tagging_find_site(&tag->sites, gw);
     if (site) {
-        char site_addr[LGTD_LIFX_ADDR_STRLEN];
+        char site_addr[LGTD_LIFX_ADDR_STRLEN], gw_ip_addr[LGTD_SOCKADDR_STRLEN];
         lgtd_debug(
-            "tag [%s] removed from gw [%s]:%hu (site %s)",
-            tag->label, gw->ip_addr, gw->port,
+            "tag [%s] removed from gw %s (site %s)",
+            tag->label,
+            LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
             LGTD_IEEE8023MACTOA(gw->site.as_array, site_addr)
         );
         LIST_REMOVE(site, link);
diff --git a/lifx/watchdog.c b/lifx/watchdog.c
--- a/lifx/watchdog.c
+++ b/lifx/watchdog.c
@@ -108,19 +108,19 @@
     struct lgtd_lifx_gateway *gw, *next_gw;
     LIST_FOREACH_SAFE(gw, &lgtd_lifx_gateways, link, next_gw) {
         int gw_lag = lgtd_lifx_gateway_latency(gw);
+        char gw_ip_addr[LGTD_SOCKADDR_STRLEN];
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr);
         if (gw_lag >= LGTD_LIFX_WATCHDOG_DEVICE_TIMEOUT_MSECS) {
             lgtd_info(
-                "closing bulb gateway [%s]:%hu that "
-                "hasn't received traffic for %dms",
-                gw->ip_addr, gw->port,
-                gw_lag
+                "closing bulb gateway %s that hasn't received traffic for %dms",
+                gw_ip_addr, gw_lag
             );
             lgtd_lifx_gateway_close(gw);
             start_discovery = true;
         } else if (gw_lag >= LGTD_LIFX_WATCHDOG_DEVICE_FORCE_REFRESH_MSECS) {
             lgtd_info(
-                "no update on bulb gateway [%s]:%hu for %dms, forcing refresh",
-                gw->ip_addr, gw->port, gw_lag
+                "no update on bulb gateway %s for %dms, forcing refresh",
+                gw_ip_addr, gw_lag
             );
             lgtd_lifx_gateway_force_refresh(gw);
         }
diff --git a/lifx/wire_proto.c b/lifx/wire_proto.c
--- a/lifx/wire_proto.c
+++ b/lifx/wire_proto.c
@@ -88,10 +88,12 @@
     bool addressable = hdr->protocol & LGTD_LIFX_PROTOCOL_ADDRESSABLE;
     bool tagged = hdr->protocol & LGTD_LIFX_PROTOCOL_TAGGED;
     unsigned int protocol = hdr->protocol & LGTD_LIFX_PROTOCOL_VERSION_MASK;
+    char gw_ip_addr[LGTD_SOCKADDR_STRLEN];
     lgtd_info(
-        "%s <-- [%s]:%hu - (Unimplemented, header info: "
+        "%s <-- %s - (Unimplemented, header info: "
         "addressable=%d, tagged=%d, protocol=%d)",
-        pkt_info->name, gw->ip_addr, gw->port,
+        pkt_info->name,
+        LGTD_SOCKADDRTOA((const struct sockaddr *)&gw->peer, gw_ip_addr),
         addressable, tagged, protocol
     );
 }
