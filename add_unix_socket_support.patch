# HG changeset patch
# Parent  f3af75bc1046e1f3269659b7b0254922d6092be4
Add support for unix sockets with the -s option (--socket)

diff --git a/README.rst b/README.rst
--- a/README.rst
+++ b/README.rst
@@ -33,8 +33,8 @@
 - set_label;
 - tag/untag (group/ungroup bulbs together).
 
-The JSON-RPC interface works on top of TCP/IPv4/v6 or over a command pipe (named
-pipe, see mkfifo(1)).
+The JSON-RPC interface works on top of TCP/IPv4/v6, Unix sockets, or over a
+command pipe (named pipe, see mkfifo(1)).
 
 lightsd can target single or multiple bulbs at once:
 
diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -69,6 +69,9 @@
 
     struct lgtd_client *client = ctx;
 
+    char addr[LGTD_SOCKADDR_STRLEN];
+    LGTD_SOCKADDRTOA(client->addr, addr);
+
     struct evbuffer *input = bufferevent_get_input(bev);
     size_t nbytes = evbuffer_get_contiguous_space(input);
     // Get the actual pointer to the beginning of the evbuf:
@@ -86,10 +89,7 @@
         switch (rv) {
         case JSMN_ERROR_NOMEM:
         case JSMN_ERROR_INVAL:
-            lgtd_warnx(
-                "client [%s]:%hu: request too big or invalid",
-                client->ip_addr, client->port
-            );
+            lgtd_warnx("client %s: request too big or invalid", addr);
             evbuffer_drain(input, nbytes);
             break;
         case JSMN_ERROR_PART:
@@ -100,10 +100,7 @@
             (void)0;
             size_t buflen = evbuffer_get_length(input);
             if (buflen > LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) {
-                lgtd_warnx(
-                    "client [%s]:%hu: request too big or invalid",
-                    client->ip_addr, client->port
-                );
+                lgtd_warnx("client %s: request too big or invalid", addr);
                 evbuffer_drain(input, buflen);
             } else if (nbytes == buflen) {
                 return; // We pulled up everything already, wait for more data
@@ -139,10 +136,10 @@
     struct lgtd_client *client = ctx;
 
     if (events & (BEV_EVENT_ERROR|BEV_EVENT_EOF)) {
-        lgtd_info(
-            "lost connection with client [%s]:%hu",
-            client->ip_addr, client->port
-        );
+        char addr[LGTD_SOCKADDR_STRLEN];
+        lgtd_info("lost connection with client %s", LGTD_SOCKADDRTOA(
+            client->addr, addr
+        ));
         lgtd_client_close(client);
     }
 }
@@ -197,21 +194,31 @@
 }
 
 struct lgtd_client *
-lgtd_client_open(evutil_socket_t peer, const struct sockaddr_storage *peer_addr)
+lgtd_client_open(evutil_socket_t peer,
+                 const struct sockaddr *addr,
+                 ev_socklen_t addrlen)
 {
     assert(peer != -1);
-    assert(peer_addr);
+    assert(addr);
 
     struct lgtd_client *client = calloc(1, sizeof(*client));
     if (!client) {
         return NULL;
     }
+
     client->io = bufferevent_socket_new(
         lgtd_ev_base, peer, BEV_OPT_CLOSE_ON_FREE
     );
     if (!client->io) {
-        return NULL;
+        goto error;
     }
+
+    client->addr = calloc(1, addrlen);
+    if (!client->addr) {
+        goto error;
+    }
+    memcpy(client->addr, addr, addrlen);
+
     bufferevent_setcb(
         client->io,
         lgtd_client_read_callback,
@@ -219,15 +226,23 @@
         lgtd_client_event_callback,
         client
     );
-    lgtd_sockaddrtoa(peer_addr, client->ip_addr, sizeof(client->ip_addr));
-    client->port = lgtd_sockaddrport(peer_addr);
-    bufferevent_enable(client->io, EV_READ|EV_WRITE|EV_TIMEOUT);
+    if (bufferevent_enable(client->io, EV_READ|EV_WRITE|EV_TIMEOUT) == -1) {
+        goto error;
+    }
 
     LIST_INSERT_HEAD(&lgtd_clients, client, link);
 
     LGTD_STATS_ADD_AND_UPDATE_PROCTITLE(clients, 1);
 
     return client;
+
+error:
+    if (client->io) {
+        bufferevent_free(client->io);
+    }
+    free(client->addr);
+    free(client);
+    return NULL;
 }
 
 void
diff --git a/core/client.h b/core/client.h
--- a/core/client.h
+++ b/core/client.h
@@ -33,8 +33,7 @@
 struct lgtd_client {
     LIST_ENTRY(lgtd_client)     link;
     struct bufferevent          *io;
-    char                        ip_addr[INET6_ADDRSTRLEN];
-    uint16_t                    port;
+    struct sockaddr             *addr;
     jsmn_parser                 jsmn_ctx;
     jsmntok_t                   jsmn_tokens[LGTD_CLIENT_JSMN_TOKENS_NUM];
     const char                  *json;
@@ -42,7 +41,7 @@
 };
 LIST_HEAD(lgtd_client_list, lgtd_client);
 
-struct lgtd_client *lgtd_client_open(evutil_socket_t, const struct sockaddr_storage *);
+struct lgtd_client *lgtd_client_open(evutil_socket_t, const struct sockaddr *, ev_socklen_t);
 void lgtd_client_open_from_pipe(struct lgtd_client *);
 void lgtd_client_close_all(void);
 
diff --git a/core/lightsd.c b/core/lightsd.c
--- a/core/lightsd.c
+++ b/core/lightsd.c
@@ -81,12 +81,17 @@
 {
     assert(peer);
 
-    if (peer->ss_family == AF_INET) {
+    switch (peer->ss_family) {
+    case AF_INET:
+        (void)0;
         const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
         return ntohs(in_peer->sin_port);
-    } else {
+    case AF_INET6:
+        (void)0;
         const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
         return ntohs(in6_peer->sin6_port);
+    default:
+        return 0;
     }
 }
 
@@ -143,6 +148,8 @@
 "  [-c,--comand-pipe /command/fifo [+]] Open an unidirectional JSON-RPC \n"
 "                                       command pipe at this location (can \n"
 "                                       be repeated).\n"
+"  [-s,--socket /unix/socket [+]]       Open an Unix socket at this location \n"
+"                                       (can be repeated).\n"
 "  [-f,--foreground]                    Stay in the foreground (default).\n"
 "  [-d,--daemonize]                     Fork in the background.\n"
 "  [-t,--no-timestamps]                 Disable timestamps in logs.\n"
@@ -168,6 +175,7 @@
     static const struct option long_opts[] = {
         {"listen",          required_argument, NULL, 'l'},
         {"command-pipe",    required_argument, NULL, 'c'},
+        {"socket",          required_argument, NULL, 's'},
         {"foreground",      no_argument,       NULL, 'f'},
         {"daemonize",       no_argument,       NULL, 'd'},
         {"no-timestamps",   no_argument,       NULL, 't'},
@@ -177,7 +185,7 @@
         {"prefix",          no_argument,       NULL, 'p'},
         {NULL,              0,                 NULL, 0}
     };
-    const char short_opts[] = "l:c:fdthv:V";
+    const char short_opts[] = "l:c:s:fdthv:V";
 
     if (argc == 1) {
         lgtd_usage(argv[0]);
@@ -203,6 +211,11 @@
                 exit(1);
             }
             break;
+        case 's':
+            if (!lgtd_listen_unix_open(optarg)) {
+                exit(1);
+            }
+            break;
         case 'f':
             lgtd_opts.foreground = true;
             break;
diff --git a/core/lightsd.h b/core/lightsd.h
--- a/core/lightsd.h
+++ b/core/lightsd.h
@@ -66,6 +66,8 @@
 
 enum { LGTD_ERROR_MSG_BUFSIZE = 2048 };
 
+enum { LGTD_SOCKADDR_STRLEN = 128 };  // should be >= sockaddr_un.sun_path
+
 struct lgtd_opts {
     bool                foreground;
     bool                log_timestamps;
@@ -79,8 +81,9 @@
 char *lgtd_iee8023mactoa(const uint8_t *addr, char *buf, int buflen);
 #define LGTD_IEEE8023MACTOA(addr, buf) \
     lgtd_iee8023mactoa((addr), (buf), sizeof(buf))
-void lgtd_sockaddrtoa(const struct sockaddr_storage *, char *buf, int buflen);
-short lgtd_sockaddrport(const struct sockaddr_storage *);
+char *lgtd_sockaddrtoa(const struct sockaddr *, char *buf, int buflen);
+#define LGTD_SOCKADDRTOA(addr, buf) \
+    lgtd_sockaddrtoa((addr), (buf), sizeof(buf))
 
 char *lgtd_print_duration(uint64_t, char *, int);
 #define LGTD_PRINT_DURATION(secs, arr) \
diff --git a/core/listen.c b/core/listen.c
--- a/core/listen.c
+++ b/core/listen.c
@@ -16,8 +16,12 @@
 // along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
 
 #include <sys/queue.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/un.h>
 #include <assert.h>
 #include <err.h>
+#include <errno.h>
 #include <stdbool.h>
 #include <stdlib.h>
 #include <string.h>
@@ -39,26 +43,25 @@
 static void
 lgtd_listen_accept_new_client(struct evconnlistener *evlistener,
                               evutil_socket_t peer,
-                              struct sockaddr *peer_addr,
-                              int addrlen,
+                              struct sockaddr *addr,
+                              ev_socklen_t addrlen,
                               void *ctx)
 {
     (void)evlistener;
-    (void)addrlen;
 
+    char buf[LGTD_SOCKADDR_STRLEN];
     struct lgtd_listen *listener = ctx;
-    struct lgtd_client *client = lgtd_client_open(
-        peer, (struct sockaddr_storage *)peer_addr
-    );
-    if (client) {
-        lgtd_info(
-            "accepted new client [%s]:%hu", client->ip_addr, client->port
+    struct lgtd_client *client = lgtd_client_open(peer, addr, addrlen);
+    if (!client) {
+        char bufclient[LGTD_SOCKADDR_STRLEN];
+        lgtd_warn(
+            "can't accept new client %s on %s",
+            LGTD_SOCKADDRTOA(addr, bufclient),
+            LGTD_SOCKADDRTOA(listener->sockaddr, buf)
         );
         return;
     }
-    lgtd_warn(
-        "can't accept new client on %s:%s", listener->addr, listener->port
-    );
+    lgtd_info("accepted new client %s", LGTD_SOCKADDRTOA(client->addr, buf));
 }
 
 void
@@ -67,6 +70,11 @@
     while (!SLIST_EMPTY(&lgtd_listeners)) {
         struct lgtd_listen *listener = SLIST_FIRST(&lgtd_listeners);
         SLIST_REMOVE_HEAD(&lgtd_listeners, link);
+        if (listener->sockaddr->sa_family == AF_UNIX) {
+            struct sockaddr_un *sockpath;
+            sockpath = (struct sockaddr_un *)listener->sockaddr;
+            unlink(sockpath->sun_path);
+        }
         evconnlistener_free(listener->evlistener);
         free(listener);
     }
@@ -80,13 +88,6 @@
     assert(addr);
     assert(port);
 
-    struct lgtd_listen *listener;
-    SLIST_FOREACH(listener, &lgtd_listeners, link) {
-        if (!strcmp(listener->addr, addr) && listener->port == port) {
-            return true;
-        }
-    }
-
     struct evutil_addrinfo *res = NULL, hints = {
         .ai_family = AF_UNSPEC,
         .ai_socktype = SOCK_STREAM,
@@ -102,13 +103,25 @@
         return false;
     }
 
+    struct lgtd_listen *listener;
     struct evconnlistener *evlistener;
     for (struct evutil_addrinfo *it = res; it; it = it->ai_next) {
+        SLIST_FOREACH(listener, &lgtd_listeners, link) {
+            if (listener->addrlen == it->ai_addrlen
+                && memcmp(listener->sockaddr, it->ai_addr, it->ai_addrlen)) {
+                return true;
+            }
+        }
+
         evlistener = NULL;
         listener = calloc(1, sizeof(*listener));
         if (!listener) {
             goto error;
         }
+        listener->sockaddr = calloc(1, it->ai_addrlen);
+        if (!listener->sockaddr) {
+            goto error;
+        }
         evlistener = evconnlistener_new_bind(
             lgtd_ev_base,
             lgtd_listen_accept_new_client,
@@ -121,9 +134,11 @@
         if (!evlistener) {
             goto error;
         }
+
         listener->evlistener = evlistener;
-        listener->addr = addr;
-        listener->port = port;
+        listener->addrlen = it->ai_addrlen;
+        memcpy(listener->sockaddr, it->ai_addr, it->ai_addrlen);
+
         SLIST_INSERT_HEAD(&lgtd_listeners, listener, link);
         lgtd_info(
             "listening on %s:%s (%s)",
@@ -139,10 +154,109 @@
 
 error:
     lgtd_warn("can't listen on %s:%s", addr, port);
-    if (evlistener) {
-        evconnlistener_free(evlistener);
+    if (listener) {
+        if (listener->evlistener) {
+            evconnlistener_free(evlistener);
+        }
+        free(listener->sockaddr);
+        free(listener);
     }
-    free(listener);
     evutil_freeaddrinfo(res);
     return false;
 }
+
+bool
+lgtd_listen_unix_open(const char *path)
+{
+    assert(path);
+
+    static const int maxpathlen =
+        sizeof(struct sockaddr_un) - offsetof(struct sockaddr_un, sun_path);
+    int pathlen = strlen(path);
+    if (pathlen > maxpathlen) {
+        lgtd_warnx(
+            "%s (%d bytes) is too long, your system only supports paths up to "
+            "%d bytes", path, pathlen, maxpathlen
+        );
+        return false;
+    }
+
+    struct lgtd_listen *listener;
+    SLIST_FOREACH(listener, &lgtd_listeners, link) {
+        if (listener->addrlen == sizeof(struct sockaddr_un)) {
+            struct sockaddr_un *sockaddr;
+            sockaddr = (struct sockaddr_un *)listener->sockaddr;
+            if (!strcmp(sockaddr->sun_path, path)) {
+                return true;
+            }
+        }
+    }
+
+    evutil_socket_t fd = -1;
+
+    listener = calloc(1, sizeof(*listener));
+    if (!listener) {
+        goto error;
+    }
+
+    struct sockaddr_un *sockpath = calloc(1, sizeof(*sockpath));
+    if (!sockpath) {
+        goto error;
+    }
+    sockpath->sun_family = AF_UNIX;
+    memcpy(sockpath->sun_path, path, pathlen);
+    listener->sockaddr = (struct sockaddr *)sockpath;
+    listener->addrlen = sizeof(*sockpath);
+
+    fd = socket(AF_UNIX, SOCK_STREAM, 0);
+    if (fd == -1) {
+        goto error;
+    }
+
+    if (evutil_make_socket_nonblocking(fd) == -1) {
+        goto error;
+    }
+
+    struct stat sb;
+    if (stat(path, &sb) == -1) {
+        if (errno != ENOENT) {
+            goto error;
+        }
+    } else if ((sb.st_mode & S_IFMT) == S_IFSOCK) {
+        lgtd_warnx("removing existing unix socket: %s", path);
+        if (unlink(path) == -1 && errno != ENOENT) {
+            goto error;
+        }
+    } else {
+        errno = EEXIST;
+        goto error;
+    }
+
+    if (bind(fd, (struct sockaddr *)sockpath, sizeof(*sockpath)) == -1) {
+        goto error;
+    }
+
+    struct evconnlistener *evlistener = evconnlistener_new(
+        lgtd_ev_base,
+        lgtd_listen_accept_new_client,
+        listener,
+        LEV_OPT_CLOSE_ON_FREE,
+        -1,
+        fd
+    );
+    if (!evlistener) {
+        goto error;
+    }
+
+    lgtd_info("unix socket at %s", path);
+
+    return true;
+
+error:
+    lgtd_warn("can't open unix at %s", path);
+    if (fd != -1) {
+        close(fd);
+    }
+    free(listener);
+    return false;
+}
diff --git a/core/listen.h b/core/listen.h
--- a/core/listen.h
+++ b/core/listen.h
@@ -21,8 +21,8 @@
 
 struct lgtd_listen {
     SLIST_ENTRY(lgtd_listen)    link;
-    const char                  *addr;
-    const char                  *port;
+    ev_socklen_t                addrlen;
+    struct sockaddr             *sockaddr;
     struct evconnlistener       *evlistener;
 };
 SLIST_HEAD(lgtd_listen_list, lgtd_listen);
@@ -30,4 +30,5 @@
 extern struct lgtd_listen_list lgtd_listeners;
 
 bool lgtd_listen_open(const char *, const char *);
+bool lgtd_listen_unix_open(const char *);
 void lgtd_listen_close_all(void);
diff --git a/core/log.c b/core/log.c
--- a/core/log.c
+++ b/core/log.c
@@ -15,8 +15,10 @@
 // You should have received a copy of the GNU General Public License
 // along with lighstd.  If not, see <http://www.gnu.org/licenses/>.
 
+#include <sys/socket.h>
 #include <sys/tree.h>
 #include <sys/time.h>
+#include <sys/un.h>
 #include <arpa/inet.h>
 #include <assert.h>
 #include <endian.h>
@@ -27,6 +29,7 @@
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <time.h>
 
 #if LGTD_HAVE_LIBBSD
@@ -88,23 +91,48 @@
     return buf;
 }
 
-void
-lgtd_sockaddrtoa(const struct sockaddr_storage *peer, char *buf, int buflen)
+char *
+lgtd_sockaddrtoa(const struct sockaddr *peer, char *buf, int buflen)
 {
     assert(peer);
     assert(buf);
-    assert(buflen > 0);
+    assert(buflen > 1);
 
-    const char *printed;
-    if (peer->ss_family == AF_INET) {
+    const char *printed = NULL;
+    int i = 0;
+    switch (peer->sa_family) {
+    case AF_INET:
+        (void)0;
         const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
-        int i = 0;
-        LGTD_SNPRINTF_APPEND(buf, i, buflen, "::ffff:");
+        LGTD_SNPRINTF_APPEND(buf, i, buflen, "[::ffff:");
         printed = inet_ntop(AF_INET, &in_peer->sin_addr, &buf[i], buflen - i);
-    } else {
+        if (printed) {
+            i += strlen(printed);
+            LGTD_SNPRINTF_APPEND(buf, i, buflen, "]:%hu", in_peer->sin_port);
+        }
+        break;
+    case AF_INET6:
+        (void)0;
         const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
+        LGTD_SNPRINTF_APPEND(buf, i, buflen, "[");
         printed = inet_ntop(AF_INET6, &in6_peer->sin6_addr, buf, buflen);
+        if (printed) {
+            i += strlen(printed);
+            LGTD_SNPRINTF_APPEND(buf, i, buflen, "]:%hu", in6_peer->sin6_port);
+        }
+        break;
+    case AF_UNIX:
+        (void)0;
+        const struct sockaddr_un *un_path = (const struct sockaddr_un *)peer;
+        int to_copy = LGTD_MIN(strlen(un_path->sun_path), (unsigned)buflen - 1);
+        if (to_copy) {
+            printed = memcpy(buf, un_path->sun_path, to_copy);
+        }
+        break;
+    default:
+        break;
     }
+
     if (!printed) {
         buf[0] = 0;
         lgtd_warnx("not enough space to log an ip address");
@@ -112,6 +140,8 @@
         abort();
 #endif
     }
+
+    return buf;
 }
 
 char *
diff --git a/examples/lightsc.py b/examples/lightsc.py
--- a/examples/lightsc.py
+++ b/examples/lightsc.py
@@ -33,15 +33,25 @@
 import json
 import socket
 import sys
+import urllib.parse
 import uuid
 
 
 class LightsClient:
 
-    def __init__(self, host, port):
-        self.host = host
-        self.port = port
-        self._socket = socket.create_connection((host, port))
+    def __init__(self, url):
+        self.url = url
+
+        parts = urllib.parse.urlparse(args.url)
+
+        if parts.scheme == "unix":
+            self._socket = socket.socket(socket.AF_UNIX)
+            self._socket.connect(parts.path)
+        elif parts.scheme == "tcp":
+            self._socket = socket.create_connection((parts.hostname, parts.port))
+        else:
+            raise ValueError("Unsupported scheme {}".format(parts.scheme))
+
         self._pipeline = []
         self._batch = False
 
@@ -191,8 +201,8 @@
     middle = "d073d502e530"  # noqa
 
     banner = (
-        "Connected to {}:{}, use the variable c to interact with your "
-        "bulbs:\n\n>>> r = c.get_light_state(\"*\")".format(c.host, c.port)
+        "Connected to {}, use the variable c to interact with your "
+        "bulbs:\n\n>>> r = c.get_light_state(\"*\")".format(c.url)
     )
 
     try:
@@ -213,18 +223,17 @@
         description="lightsc.py is an interactive lightsd Python client"
     )
     parser.add_argument(
-        "host", type=str, help="The hostname or ip where lightsd is running"
-    )
-    parser.add_argument(
-        "port", type=int, help="The port on which lightsd is listening on"
+        "url", type=str,
+        help="How to connect to lightsd (e.g: "
+             "unix:///run/lightsd.sock or tcp://[::1]:1234)"
     )
     args = parser.parse_args()
-    try:
-        _drop_to_shell(LightsClient(args.host, args.port))
-    except socket.error as ex:
-        print(
-            "Couldn't connect to lightsd@{}:{}, is it running? "
-            "({})".format(args.host, args.port, ex.strerror),
-            file=sys.stderr
-        )
-        sys.exit(1)
+#   try:
+    _drop_to_shell(LightsClient(args.url))
+#   except Exception as ex:
+#       print(
+#           "Couldn't connect to {}, is it running? "
+#           "({})".format(args.url, ex),
+#           file=sys.stderr
+#       )
+#       sys.exit(1)
