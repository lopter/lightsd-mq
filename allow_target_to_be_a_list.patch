# HG changeset patch
# Parent 6f2644d079c169a459e3f5d23129abbf9c56fc12
Allow the target argument to be a list

We actually need that to support tagging.

diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -1,4 +1,3 @@
-// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
 //
 // This file is part of lighstd.
 //
@@ -155,6 +154,13 @@
 }
 
 static bool
+lgtd_jsonrpc_type_array(const jsmntok_t *t, const char *json)
+{
+    (void)json;
+    return t->type == JSMN_ARRAY;
+}
+
+static bool
 lgtd_jsonrpc_type_object_or_array(const jsmntok_t *t, const char *json)
 {
     (void)json;
@@ -167,7 +173,14 @@
 {
     return lgtd_jsonrpc_type_number(t, json)
         || lgtd_jsonrpc_type_null(t, json)
-        || t->type == JSMN_STRING;
+        || lgtd_jsonrpc_type_string(t, json);
+}
+
+static bool
+lgtd_jsonrpc_type_string_or_array(const jsmntok_t *t, const char *json)
+{
+    return lgtd_jsonrpc_type_string(t, json)
+        || lgtd_jsonrpc_type_array(t, json);
 }
 
 static int
@@ -229,7 +242,8 @@
             return false;
         }
 
-        for (int si = 0;; si++) {
+        int si = 0;
+        for (;; si++) {
             if (si == schema_size) {
                 ti++; // nothing matched, skip the key
                 break;
@@ -272,6 +286,7 @@
 
         // skip the value, if it's an object or an array we need to
         // skip everything in it:
+        int value_ntokens = ti;
         if (tokens[ti].type == JSMN_OBJECT || tokens[ti].type == JSMN_ARRAY) {
             ti = lgtd_jsonrpc_consume_object_or_array(
                 tokens, ti, ntokens, json
@@ -279,6 +294,12 @@
         } else {
             ti++;
         }
+        value_ntokens = ti - value_ntokens;
+        if (si < schema_size && schema[si].ntokens_offset != -1) {
+            LGTD_JSONRPC_SET_NTOKENS(
+                output, schema[si].ntokens_offset, value_ntokens
+            );
+        }
     }
 
     for (int si = 0; si != schema_size; si++) {
@@ -325,6 +346,7 @@
         }
         // skip the value, if it's an object or an array we need to
         // skip everything in it:
+        int value_ntokens = ti;
         if (tokens[ti].type == JSMN_OBJECT || tokens[ti].type == JSMN_ARRAY) {
             ti = lgtd_jsonrpc_consume_object_or_array(
                 tokens, ti, ntokens, json
@@ -332,6 +354,12 @@
         } else {
             ti++;
         }
+        value_ntokens = ti - value_ntokens;
+        if (schema[si].ntokens_offset != -1) {
+            LGTD_JSONRPC_SET_NTOKENS(
+                output, schema[si].ntokens_offset, value_ntokens
+            );
+        }
     }
 
     return si == schema_size;
@@ -419,29 +447,32 @@
 {
     static const struct lgtd_jsonrpc_node request_schema[] = {
         LGTD_JSONRPC_NODE(
-            "jsonrpc", -1, lgtd_jsonrpc_type_string, false
+            "jsonrpc", -1, -1, lgtd_jsonrpc_type_string, false
         ),
         LGTD_JSONRPC_NODE(
             "method",
             offsetof(struct lgtd_jsonrpc_request, method),
+            -1,
             lgtd_jsonrpc_type_string,
             false
         ),
         LGTD_JSONRPC_NODE(
             "params",
             offsetof(struct lgtd_jsonrpc_request, params),
+            offsetof(struct lgtd_jsonrpc_request, params_ntokens),
             lgtd_jsonrpc_type_object_or_array,
             true
         ),
         LGTD_JSONRPC_NODE(
             "id",
             offsetof(struct lgtd_jsonrpc_request, id),
+            -1,
             lgtd_jsonrpc_type_string_number_or_null,
             true
         )
     };
 
-    bool ok = lgtd_jsonrpc_extract_values_from_schema_and_dict(
+    return lgtd_jsonrpc_extract_values_from_schema_and_dict(
         request,
         request_schema,
         LGTD_ARRAY_SIZE(request_schema),
@@ -449,38 +480,20 @@
         ntokens,
         json
     );
-    if (ok) {
-        // XXX We already do that from extract_values_from_schema_and_dict:
-        if (request->params) {
-            const jsmntok_t *params = request->params;
-            int params_ti = params - tokens;
-            while (params[request->params_ntokens].start < params->end
-                   && params_ti + request->params_ntokens < ntokens) {
-                request->params_ntokens++;
-            }
-        }
-        return true;
-    }
-
-    return false;
 }
 
-static char *
-lgtd_jsonrpc_dup_target(struct lgtd_client *client,
-                        const struct lgtd_jsonrpc_request *request,
-                        const char *json,
-                        const jsmntok_t *t)
+static bool
+lgtd_jsonrpc_build_target_list(struct lgtd_proto_target_list *targets,
+                               struct lgtd_client *client,
+                               jsmntok_t *target,
+                               int target_ntokens,
+                               const char *json)
 {
-    char *target = strndup(
-        &json[t->start], LGTD_JSONRPC_TOKEN_LEN(t)
-    );
-    if (!target) {
-        lgtd_jsonrpc_send_error(
-            client, request, json, LGTD_JSONRPC_INTERNAL_ERROR,
-            "Shit's on fire, yo"
-        );
-    }
-    return target;
+    assert(targets);
+    assert(client);
+    assert(target);
+    assert(target_ntokens >= 1);
+    assert(json);
 }
 
 static void
@@ -490,46 +503,53 @@
 {
     struct lgtd_jsonrpc_set_light_from_hsbk_args {
         const jsmntok_t *target;
+        int             target_ntokens;
         const jsmntok_t *h;
         const jsmntok_t *s;
         const jsmntok_t *b;
         const jsmntok_t *k;
         const jsmntok_t *t;
-    } params = { NULL, NULL, NULL, NULL, NULL, NULL };
+    } params = { NULL, 0, NULL, NULL, NULL, NULL, NULL };
     static const struct lgtd_jsonrpc_node schema[] = {
         LGTD_JSONRPC_NODE(
             "target",
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, target),
-            lgtd_jsonrpc_type_string,
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, target_ntokens),
+            lgtd_jsonrpc_type_string_or_array,
             false
         ),
         LGTD_JSONRPC_NODE(
             "hue",
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, h),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_360,
             false
         ),
         LGTD_JSONRPC_NODE(
             "saturation",
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, s),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "brightness",
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, b),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "kelvin",
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, k),
+            -1,
             lgtd_jsonrpc_type_integer,
             false
         ),
         LGTD_JSONRPC_NODE(
             "transition",
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, t),
+            -1,
             lgtd_jsonrpc_type_integer,
             false
         ),
@@ -566,14 +586,16 @@
         goto error_invalid_params;
     }
 
-    char *target;
-    target = lgtd_jsonrpc_dup_target(client, request, json, params.target);
-    if (!target) {
-        return;
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
+    ok = lgtd_jsonrpc_build_target_list(
+        &targets, client, params.target, params.target_ntokens, json
+    );
+    if (!ok) {
+        goto error_invalid_params;
     }
 
-    ok = lgtd_proto_set_light_from_hsbk(target, h, s, b, k, t);
-    free(target);
+    ok = lgtd_proto_set_light_from_hsbk(&targets, h, s, b, k, t);
+    lgtd_proto_target_list_clear(&targets);
     if (ok) {
         lgtd_jsonrpc_send_response(client, request, json, "true");
         return;
@@ -586,28 +608,28 @@
     );
 }
 
-static char *
-lgtd_jsonrpc_extract_target_only(struct lgtd_client *client,
+static bool
+lgtd_jsonrpc_extract_target_list(struct lgtd_proto_target_list *targets,
+                                 struct lgtd_client *client,
                                  const struct lgtd_jsonrpc_request *request,
                                  const char *json)
 {
     const jsmntok_t *target = NULL;
+    int target_ntokens = 0;
     static const struct lgtd_jsonrpc_node schema[] = {
-        LGTD_JSONRPC_NODE("target", 0, lgtd_jsonrpc_type_string, false)
+        LGTD_JSONRPC_NODE("target", 0, sizeof(*target), lgtd_jsonrpc_type_string_or_array, false)
     };
 
     bool ok = lgtd_jsonrpc_extract_and_validate_params_against_schema(
         &target, schema, 1, request->params, request->params_ntokens, json
     );
     if (!ok) {
-        lgtd_jsonrpc_send_error(
-            client, request, json, LGTD_JSONRPC_INVALID_PARAMS,
-            "Invalid parameters"
-        );
-        return NULL;
+        return false;
     }
 
-    return lgtd_jsonrpc_dup_target(client, request, json, target);
+    ok = lgtd_jsonrpc_build_target_list(
+        &targets, client, target, target_ntokens, json
+    );
 }
 
 static void
@@ -616,18 +638,20 @@
                                      const char *json)
 {
 
-    char *target = lgtd_jsonrpc_extract_target_only(client, request, json);
-    if (!target) {
-        return;
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
+    bool ok = lgtd_jsonrpc_extract_target_list(&targets, client, request, json);
+    if (!ok) {
+        goto error;
     }
 
-    bool ok = lgtd_proto_power_on(target);
-    free(target);
+    ok = lgtd_proto_power_on(&targets);
+    lgtd_proto_target_list_clear(&targets);
     if (ok) {
         lgtd_jsonrpc_send_response(client, request, json, "true");
         return;
     }
 
+error:
     lgtd_jsonrpc_send_error(
         client, request, json, LGTD_JSONRPC_INVALID_PARAMS,
         "Invalid parameters"
@@ -641,6 +665,7 @@
 {
     struct lgtd_jsonrpc_set_waveform_args {
         const jsmntok_t *target;
+        int             target_ntokens;
         const jsmntok_t *waveform;
         const jsmntok_t *h;
         const jsmntok_t *s;
@@ -650,65 +675,75 @@
         const jsmntok_t *cycles;
         const jsmntok_t *skew_ratio;
         const jsmntok_t *transient;
-    } params = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
+    } params = { NULL, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
     static const struct lgtd_jsonrpc_node schema[] = {
         LGTD_JSONRPC_NODE(
             "target",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, target),
-            lgtd_jsonrpc_type_string,
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, target_ntokens),
+            lgtd_jsonrpc_type_string_or_array,
             false
         ),
         LGTD_JSONRPC_NODE(
             "waveform",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, waveform),
+            -1,
             lgtd_jsonrpc_type_string,
             false
         ),
         LGTD_JSONRPC_NODE(
             "hue",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, h),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_360,
             false
         ),
         LGTD_JSONRPC_NODE(
             "saturation",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, s),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "brightness",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, b),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "kelvin",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, k),
+            -1,
             lgtd_jsonrpc_type_integer,
             false
         ),
         LGTD_JSONRPC_NODE(
             "period",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, period),
+            -1,
             lgtd_jsonrpc_type_integer,
             false
         ),
         LGTD_JSONRPC_NODE(
             "cycles",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, cycles),
+            -1,
             lgtd_jsonrpc_type_integer,
             false
         ),
         LGTD_JSONRPC_NODE(
             "skew_ratio",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, skew_ratio),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "transient",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, transient),
+            -1,
             lgtd_jsonrpc_type_bool,
             false
         ),
@@ -764,18 +799,18 @@
     skew_ratio -= UINT16_MAX / 2;
     bool transient = json[params.transient->start] == 't';
 
-
-    char *target;
-    target = lgtd_jsonrpc_dup_target(client, request, json, params.target);
-    if (!target) {
-        return;
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
+    ok = lgtd_jsonrpc_build_target_list(
+        &targets, client, params.target, params.target_ntokens, json
+    );
+    if (!ok) {
+        goto error_invalid_params;
     }
 
-    lgtd_proto_set_waveform(
-        target, waveform, h, s, b, k, period, cycles, skew_ratio, transient
+    ok = lgtd_proto_set_waveform(
+        &targets, waveform, h, s, b, k, period, cycles, skew_ratio, transient
     );
-
-    free(target);
+    lgtd_proto_target_list_clear(&targets);
     if (ok) {
         lgtd_jsonrpc_send_response(client, request, json, "true");
         return;
@@ -794,18 +829,20 @@
                                       const char *json)
 {
 
-    char *target = lgtd_jsonrpc_extract_target_only(client, request, json);
-    if (!target) {
-        return;
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
+    bool ok = lgtd_jsonrpc_extract_target_list(&targets, client, request, json);
+    if (!ok) {
+        goto error;
     }
 
-    bool ok = lgtd_proto_power_off(target);
-    free(target);
+    ok = lgtd_proto_power_off(&targets);
+    lgtd_proto_target_list_clear(&targets);
     if (ok) {
         lgtd_jsonrpc_send_response(client, request, json, "true");
         return;
     }
 
+error:
     lgtd_jsonrpc_send_error(
         client, request, json, LGTD_JSONRPC_INVALID_PARAMS,
         "Invalid parameters"
diff --git a/core/jsonrpc.h b/core/jsonrpc.h
--- a/core/jsonrpc.h
+++ b/core/jsonrpc.h
@@ -28,6 +28,7 @@
     const char      *key;
     int             keylen;
     int             value_offset;
+    int             ntokens_offset;
     bool            (*type_cmp)(const jsmntok_t *, const char *);
     bool            optional;
 };
@@ -37,14 +38,19 @@
 } while (0)
 
 #define LGTD_JSONRPC_GET_JSMNTOK(object, value_offset)          \
-    *(const jsmntok_t **)(&((char *)(object))[value_offset]);   \
+    *(const jsmntok_t **)(&((char *)(object))[value_offset]);
 
-#define LGTD_JSONRPC_NODE(key_, value_offset_, fn_type_cmp, optional_)   { \
-    .key = (key_),                                                          \
-    .keylen = sizeof((key_)) - 1,                                           \
-    .value_offset = (value_offset_),                                        \
-    .type_cmp = (fn_type_cmp),                                              \
-    .optional = (optional_)                                                 \
+#define LGTD_JSONRPC_SET_NTOKENS(object, ntokens_offset, ntokens) do {  \
+    *(int *)(&(((char *)(object))[ntokens_offset])) = (ntokens);          \
+} while (0)
+
+#define LGTD_JSONRPC_NODE(key_, value_offset_, ntokens_offset_, fn_type_cmp, optional_)   { \
+    .key = (key_),                                                                          \
+    .keylen = sizeof((key_)) - 1,                                                           \
+    .value_offset = (value_offset_),                                                        \
+    .ntokens_offset = (ntokens_offset_),                                                    \
+    .type_cmp = (fn_type_cmp),                                                              \
+    .optional = (optional_)                                                                 \
 }
 
 #define LGTD_JSONRPC_TOKEN_LEN(t) ((t)->end - (t)->start)
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -31,7 +31,7 @@
 #include "lightsd.h"
 
 bool
-lgtd_proto_power_on(const char *target)
+lgtd_proto_power_on(const struct lgtd_proto_target_list *targets)
 {
     assert(target);
 
@@ -40,16 +40,16 @@
 }
 
 bool
-lgtd_proto_power_off(const char *target)
+lgtd_proto_power_off(const struct lgtd_proto_target_list *targets)
 {
     assert(target);
 
     struct lgtd_lifx_packet_power_state pkt = { .power = LGTD_LIFX_POWER_OFF };
-    return lgtd_router_send(target, LGTD_LIFX_SET_POWER_STATE, &pkt);
+    return lgtd_router_send(targets, LGTD_LIFX_SET_POWER_STATE, &pkt);
 }
 
 bool
-lgtd_proto_set_light_from_hsbk(const char *target,
+lgtd_proto_set_light_from_hsbk(const struct lgtd_proto_target_list *targets,
                                int hue,
                                int saturation,
                                int brightness,
@@ -72,10 +72,10 @@
         .transition = transition_msecs
     };
     lgtd_lifx_wire_encode_light_color(&pkt);
-    return lgtd_router_send(target, LGTD_LIFX_SET_LIGHT_COLOR, &pkt);
+    return lgtd_router_send(targets, LGTD_LIFX_SET_LIGHT_COLOR, &pkt);
 }
 
-bool lgtd_proto_set_waveform(const char *target,
+bool lgtd_proto_set_waveform(const struct lgtd_proto_target_list *targets,
                              enum lgtd_lifx_waveform_type waveform,
                              int hue, int saturation,
                              int brightness, int kelvin,
@@ -106,5 +106,5 @@
     };
 
     lgtd_lifx_wire_encode_waveform(&pkt);
-    return lgtd_router_send(target, LGTD_LIFX_SET_WAVEFORM, &pkt);
+    return lgtd_router_send(targets, LGTD_LIFX_SET_WAVEFORM, &pkt);
 }
diff --git a/core/proto.h b/core/proto.h
--- a/core/proto.h
+++ b/core/proto.h
@@ -17,10 +17,20 @@
 
 #pragma once
 
-bool lgtd_proto_set_light_from_hsbk(const char *, int, int, int, int, int);
-bool lgtd_proto_set_waveform(const char *,
+struct lgtd_proto_target {
+    SLIST_ENTRY(lgtd_proto_target)  link;
+    char                            target[];
+};
+SLIST_HEAD(lgtd_proto_target_list, lgtd_proto_target);
+
+void lgtd_proto_target_list_clear(struct lgtd_proto_target_list *);
+const struct lgtd_proto_target *lgtd_proto_target_list_add(struct lgtd_proto_target_list *,
+                                                           const char *, int);
+
+bool lgtd_proto_set_light_from_hsbk(const struct lgtd_proto_target_list *, int, int, int, int, int);
+bool lgtd_proto_set_waveform(const struct lgtd_proto_target_list *,
                              enum lgtd_lifx_waveform_type,
                              int, int, int, int,
                              int, float, int, bool);
-bool lgtd_proto_power_on(const char *);
-bool lgtd_proto_power_off(const char *);
+bool lgtd_proto_power_on(const struct lgtd_proto_target_list *);
+bool lgtd_proto_power_off(const struct lgtd_proto_target_list *);
diff --git a/core/router.c b/core/router.c
--- a/core/router.c
+++ b/core/router.c
@@ -95,36 +95,37 @@
 }
 
 bool
-lgtd_router_send(const char *target,
+lgtd_router_send(const struct lgtd_proto_target_list *targets,
                  enum lgtd_lifx_packet_type pkt_type,
                  void *pkt)
 {
     assert(target);
 
-    if (!strcmp(target, "*")) {
-        lgtd_router_broadcast(pkt_type, pkt);
-        return true;
+    bool rv = true;
+
+    const struct lgtd_proto_target *target;
+    SLIST_FOREACH(target, targets, link) {
+        if (!strcmp(target->target, "*")) {
+            lgtd_router_broadcast(pkt_type, pkt);
+        } else if (isxdigit(target->target[0])) {
+            const char *endptr = NULL;
+            errno = 0;
+            long long device = strtoll(target->target, (char **)&endptr, 16);
+            if (*endptr || errno == ERANGE) {
+                lgtd_debug("invalid target device %s", target->target);
+                rv = false;
+            }
+            device = htobe64(device);
+            struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_get(
+                (uint8_t *)&device + sizeof(device) - LGTD_LIFX_ADDR_LENGTH
+            );
+            if (!bulb) {
+                lgtd_debug("target device %#llx not found", device);
+                rv = false;
+            }
+            lgtd_router_device(bulb, pkt_type, pkt);
+        }
     }
 
-    if (isxdigit(target[0])) {
-        const char *endptr = NULL;
-        errno = 0;
-        long long device = strtoll(target, (char **)&endptr, 16);
-        if (*endptr || errno == ERANGE) {
-            lgtd_debug("invalid target device %s", target);
-            return false;
-        }
-        device = htobe64(device);
-        struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_get(
-            (uint8_t *)&device + sizeof(device) - LGTD_LIFX_ADDR_LENGTH
-        );
-        if (!bulb) {
-            lgtd_debug("target device %#llx not found", device);
-            return false;
-        }
-        lgtd_router_device(bulb, pkt_type, pkt);
-        return true;
-    }
-
-    return false;
+    return rv;
 }
diff --git a/core/router.h b/core/router.h
--- a/core/router.h
+++ b/core/router.h
@@ -17,4 +17,4 @@
 
 #pragma once
 
-bool lgtd_router_send(const char *, enum lgtd_lifx_packet_type, void *);
+bool lgtd_router_send(const struct lgtd_proto_target_list *, enum lgtd_lifx_packet_type, void *);
