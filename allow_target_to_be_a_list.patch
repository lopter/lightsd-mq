# HG changeset patch
# Parent 6f2644d079c169a459e3f5d23129abbf9c56fc12
# Parent  6f2644d079c169a459e3f5d23129abbf9c56fc12
Allow the target argument to be a list

We actually need that to support tagging.

diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -1,4 +1,3 @@
-// Copyright (c) 2015, Louis Opter <kalessin@kalessin.fr>
 //
 // This file is part of lighstd.
 //
@@ -155,6 +154,13 @@
 }
 
 static bool
+lgtd_jsonrpc_type_array(const jsmntok_t *t, const char *json)
+{
+    (void)json;
+    return t->type == JSMN_ARRAY;
+}
+
+static bool
 lgtd_jsonrpc_type_object_or_array(const jsmntok_t *t, const char *json)
 {
     (void)json;
@@ -167,7 +173,30 @@
 {
     return lgtd_jsonrpc_type_number(t, json)
         || lgtd_jsonrpc_type_null(t, json)
-        || t->type == JSMN_STRING;
+        || lgtd_jsonrpc_type_string(t, json);
+}
+
+static bool
+lgtd_jsonrpc_type_string_or_number(const jsmntok_t *t,
+                                   const char *json)
+{
+    return lgtd_jsonrpc_type_string(t, json)
+        || lgtd_jsonrpc_type_number(t, json);
+}
+
+static bool __attribute__((unused))
+lgtd_jsonrpc_type_string_or_array(const jsmntok_t *t, const char *json)
+{
+    return lgtd_jsonrpc_type_string(t, json)
+        || lgtd_jsonrpc_type_array(t, json);
+}
+
+static bool
+lgtd_jsonrpc_type_string_number_or_array(const jsmntok_t *t, const char *json)
+{
+    return lgtd_jsonrpc_type_string(t, json)
+        || lgtd_jsonrpc_type_number(t, json)
+        || lgtd_jsonrpc_type_array(t, json);
 }
 
 static int
@@ -229,7 +258,8 @@
             return false;
         }
 
-        for (int si = 0;; si++) {
+        int si = 0;
+        for (;; si++) {
             if (si == schema_size) {
                 ti++; // nothing matched, skip the key
                 break;
@@ -272,6 +302,7 @@
 
         // skip the value, if it's an object or an array we need to
         // skip everything in it:
+        int value_ntokens = ti;
         if (tokens[ti].type == JSMN_OBJECT || tokens[ti].type == JSMN_ARRAY) {
             ti = lgtd_jsonrpc_consume_object_or_array(
                 tokens, ti, ntokens, json
@@ -279,6 +310,12 @@
         } else {
             ti++;
         }
+        value_ntokens = ti - value_ntokens;
+        if (si < schema_size && schema[si].ntokens_offset != -1) {
+            LGTD_JSONRPC_SET_NTOKENS(
+                output, schema[si].ntokens_offset, value_ntokens
+            );
+        }
     }
 
     for (int si = 0; si != schema_size; si++) {
@@ -325,6 +362,7 @@
         }
         // skip the value, if it's an object or an array we need to
         // skip everything in it:
+        int value_ntokens = ti;
         if (tokens[ti].type == JSMN_OBJECT || tokens[ti].type == JSMN_ARRAY) {
             ti = lgtd_jsonrpc_consume_object_or_array(
                 tokens, ti, ntokens, json
@@ -332,6 +370,12 @@
         } else {
             ti++;
         }
+        value_ntokens = ti - value_ntokens;
+        if (schema[si].ntokens_offset != -1) {
+            LGTD_JSONRPC_SET_NTOKENS(
+                output, schema[si].ntokens_offset, value_ntokens
+            );
+        }
     }
 
     return si == schema_size;
@@ -419,29 +463,32 @@
 {
     static const struct lgtd_jsonrpc_node request_schema[] = {
         LGTD_JSONRPC_NODE(
-            "jsonrpc", -1, lgtd_jsonrpc_type_string, false
+            "jsonrpc", -1, -1, lgtd_jsonrpc_type_string, false
         ),
         LGTD_JSONRPC_NODE(
             "method",
             offsetof(struct lgtd_jsonrpc_request, method),
+            -1,
             lgtd_jsonrpc_type_string,
             false
         ),
         LGTD_JSONRPC_NODE(
             "params",
             offsetof(struct lgtd_jsonrpc_request, params),
+            offsetof(struct lgtd_jsonrpc_request, params_ntokens),
             lgtd_jsonrpc_type_object_or_array,
             true
         ),
         LGTD_JSONRPC_NODE(
             "id",
             offsetof(struct lgtd_jsonrpc_request, id),
+            -1,
             lgtd_jsonrpc_type_string_number_or_null,
             true
         )
     };
 
-    bool ok = lgtd_jsonrpc_extract_values_from_schema_and_dict(
+    return lgtd_jsonrpc_extract_values_from_schema_and_dict(
         request,
         request_schema,
         LGTD_ARRAY_SIZE(request_schema),
@@ -449,40 +496,62 @@
         ntokens,
         json
     );
-    if (ok) {
-        // XXX We already do that from extract_values_from_schema_and_dict:
-        if (request->params) {
-            const jsmntok_t *params = request->params;
-            int params_ti = params - tokens;
-            while (params[request->params_ntokens].start < params->end
-                   && params_ti + request->params_ntokens < ntokens) {
-                request->params_ntokens++;
-            }
-        }
-        return true;
+}
+
+static bool
+lgtd_jsonrpc_build_target_list(struct lgtd_proto_target_list *targets,
+                               struct lgtd_client *client,
+                               const struct lgtd_jsonrpc_request *request,
+                               const jsmntok_t *target,
+                               int target_ntokens,
+                               const char *json)
+{
+    assert(targets);
+    assert(client);
+    assert(request);
+    assert(target);
+    assert(target_ntokens >= 1);
+    assert(json);
+
+    if (lgtd_jsonrpc_type_array(target, json)) {
+        target_ntokens -= 1;
+        target++;
     }
 
+    for (int ti = target_ntokens; ti--;) {
+        int token_len = LGTD_JSONRPC_TOKEN_LEN(&target[ti]);
+        if (lgtd_jsonrpc_type_string_or_number(&target[ti], json)) {
+            struct lgtd_proto_target *t = malloc(sizeof(*t) + token_len);
+            if (!t) {
+                lgtd_warn("can't allocate a new target");
+                lgtd_jsonrpc_send_error(
+                    client, request, json, LGTD_JSONRPC_INTERNAL_ERROR,
+                    "Can't allocate memory"
+                );
+                goto error;
+            }
+            memcpy(t->target, json + target[ti].start, token_len);
+            t->target[token_len] = '\0';
+            SLIST_INSERT_HEAD(targets, t, link);
+        } else {
+            lgtd_info(
+                "invalid target value %.*s", token_len, json + target[ti].start
+            );
+            lgtd_jsonrpc_send_error(
+                client, request, json, LGTD_JSONRPC_INVALID_PARAMS,
+                "Invalid parameters"
+            );
+            goto error;
+        }
+    }
+
+    return true;
+
+error:
+    lgtd_proto_target_list_clear(targets);
     return false;
 }
 
-static char *
-lgtd_jsonrpc_dup_target(struct lgtd_client *client,
-                        const struct lgtd_jsonrpc_request *request,
-                        const char *json,
-                        const jsmntok_t *t)
-{
-    char *target = strndup(
-        &json[t->start], LGTD_JSONRPC_TOKEN_LEN(t)
-    );
-    if (!target) {
-        lgtd_jsonrpc_send_error(
-            client, request, json, LGTD_JSONRPC_INTERNAL_ERROR,
-            "Shit's on fire, yo"
-        );
-    }
-    return target;
-}
-
 static void
 lgtd_jsonrpc_check_and_call_set_light_from_hsbk(struct lgtd_client *client,
                                                 const struct lgtd_jsonrpc_request *request,
@@ -490,46 +559,53 @@
 {
     struct lgtd_jsonrpc_set_light_from_hsbk_args {
         const jsmntok_t *target;
+        int             target_ntokens;
         const jsmntok_t *h;
         const jsmntok_t *s;
         const jsmntok_t *b;
         const jsmntok_t *k;
         const jsmntok_t *t;
-    } params = { NULL, NULL, NULL, NULL, NULL, NULL };
+    } params = { NULL, 0, NULL, NULL, NULL, NULL, NULL };
     static const struct lgtd_jsonrpc_node schema[] = {
         LGTD_JSONRPC_NODE(
             "target",
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, target),
-            lgtd_jsonrpc_type_string,
+            offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, target_ntokens),
+            lgtd_jsonrpc_type_string_number_or_array,
             false
         ),
         LGTD_JSONRPC_NODE(
             "hue",
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, h),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_360,
             false
         ),
         LGTD_JSONRPC_NODE(
             "saturation",
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, s),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "brightness",
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, b),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "kelvin",
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, k),
+            -1,
             lgtd_jsonrpc_type_integer,
             false
         ),
         LGTD_JSONRPC_NODE(
             "transition",
             offsetof(struct lgtd_jsonrpc_set_light_from_hsbk_args, t),
+            -1,
             lgtd_jsonrpc_type_integer,
             false
         ),
@@ -566,14 +642,16 @@
         goto error_invalid_params;
     }
 
-    char *target;
-    target = lgtd_jsonrpc_dup_target(client, request, json, params.target);
-    if (!target) {
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
+    ok = lgtd_jsonrpc_build_target_list(
+        &targets, client, request, params.target, params.target_ntokens, json
+    );
+    if (!ok) {
         return;
     }
 
-    ok = lgtd_proto_set_light_from_hsbk(target, h, s, b, k, t);
-    free(target);
+    ok = lgtd_proto_set_light_from_hsbk(&targets, h, s, b, k, t);
+    lgtd_proto_target_list_clear(&targets);
     if (ok) {
         lgtd_jsonrpc_send_response(client, request, json, "true");
         return;
@@ -586,28 +664,40 @@
     );
 }
 
-static char *
-lgtd_jsonrpc_extract_target_only(struct lgtd_client *client,
+static bool
+lgtd_jsonrpc_extract_target_list(struct lgtd_proto_target_list *targets,
+                                 struct lgtd_client *client,
                                  const struct lgtd_jsonrpc_request *request,
                                  const char *json)
 {
-    const jsmntok_t *target = NULL;
+    struct lgtd_jsonrpc_target_args {
+        const jsmntok_t *target;
+        int             target_ntokens;
+    } params = { NULL, 0 };
     static const struct lgtd_jsonrpc_node schema[] = {
-        LGTD_JSONRPC_NODE("target", 0, lgtd_jsonrpc_type_string, false)
+        LGTD_JSONRPC_NODE(
+            "target",
+            offsetof(struct lgtd_jsonrpc_target_args, target),
+            offsetof(struct lgtd_jsonrpc_target_args, target_ntokens),
+            lgtd_jsonrpc_type_string_number_or_array,
+            false
+        )
     };
 
     bool ok = lgtd_jsonrpc_extract_and_validate_params_against_schema(
-        &target, schema, 1, request->params, request->params_ntokens, json
+        &params, schema, 1, request->params, request->params_ntokens, json
     );
     if (!ok) {
         lgtd_jsonrpc_send_error(
             client, request, json, LGTD_JSONRPC_INVALID_PARAMS,
             "Invalid parameters"
         );
-        return NULL;
+        return false;
     }
 
-    return lgtd_jsonrpc_dup_target(client, request, json, target);
+    return lgtd_jsonrpc_build_target_list(
+        targets, client, request, params.target, params.target_ntokens, json
+    );
 }
 
 static void
@@ -616,13 +706,14 @@
                                      const char *json)
 {
 
-    char *target = lgtd_jsonrpc_extract_target_only(client, request, json);
-    if (!target) {
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
+    bool ok = lgtd_jsonrpc_extract_target_list(&targets, client, request, json);
+    if (!ok) {
         return;
     }
 
-    bool ok = lgtd_proto_power_on(target);
-    free(target);
+    ok = lgtd_proto_power_on(&targets);
+    lgtd_proto_target_list_clear(&targets);
     if (ok) {
         lgtd_jsonrpc_send_response(client, request, json, "true");
         return;
@@ -641,6 +732,7 @@
 {
     struct lgtd_jsonrpc_set_waveform_args {
         const jsmntok_t *target;
+        int             target_ntokens;
         const jsmntok_t *waveform;
         const jsmntok_t *h;
         const jsmntok_t *s;
@@ -650,65 +742,75 @@
         const jsmntok_t *cycles;
         const jsmntok_t *skew_ratio;
         const jsmntok_t *transient;
-    } params = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
+    } params = { NULL, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
     static const struct lgtd_jsonrpc_node schema[] = {
         LGTD_JSONRPC_NODE(
             "target",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, target),
-            lgtd_jsonrpc_type_string,
+            offsetof(struct lgtd_jsonrpc_set_waveform_args, target_ntokens),
+            lgtd_jsonrpc_type_string_number_or_array,
             false
         ),
         LGTD_JSONRPC_NODE(
             "waveform",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, waveform),
+            -1,
             lgtd_jsonrpc_type_string,
             false
         ),
         LGTD_JSONRPC_NODE(
             "hue",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, h),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_360,
             false
         ),
         LGTD_JSONRPC_NODE(
             "saturation",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, s),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "brightness",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, b),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "kelvin",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, k),
+            -1,
             lgtd_jsonrpc_type_integer,
             false
         ),
         LGTD_JSONRPC_NODE(
             "period",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, period),
+            -1,
             lgtd_jsonrpc_type_integer,
             false
         ),
         LGTD_JSONRPC_NODE(
             "cycles",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, cycles),
+            -1,
             lgtd_jsonrpc_type_integer,
             false
         ),
         LGTD_JSONRPC_NODE(
             "skew_ratio",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, skew_ratio),
+            -1,
             lgtd_jsonrpc_type_float_between_0_and_1,
             false
         ),
         LGTD_JSONRPC_NODE(
             "transient",
             offsetof(struct lgtd_jsonrpc_set_waveform_args, transient),
+            -1,
             lgtd_jsonrpc_type_bool,
             false
         ),
@@ -764,18 +866,18 @@
     skew_ratio -= UINT16_MAX / 2;
     bool transient = json[params.transient->start] == 't';
 
-
-    char *target;
-    target = lgtd_jsonrpc_dup_target(client, request, json, params.target);
-    if (!target) {
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
+    ok = lgtd_jsonrpc_build_target_list(
+        &targets, client, request, params.target, params.target_ntokens, json
+    );
+    if (!ok) {
         return;
     }
 
-    lgtd_proto_set_waveform(
-        target, waveform, h, s, b, k, period, cycles, skew_ratio, transient
+    ok = lgtd_proto_set_waveform(
+        &targets, waveform, h, s, b, k, period, cycles, skew_ratio, transient
     );
-
-    free(target);
+    lgtd_proto_target_list_clear(&targets);
     if (ok) {
         lgtd_jsonrpc_send_response(client, request, json, "true");
         return;
@@ -794,13 +896,14 @@
                                       const char *json)
 {
 
-    char *target = lgtd_jsonrpc_extract_target_only(client, request, json);
-    if (!target) {
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
+    bool ok = lgtd_jsonrpc_extract_target_list(&targets, client, request, json);
+    if (!ok) {
         return;
     }
 
-    bool ok = lgtd_proto_power_off(target);
-    free(target);
+    ok = lgtd_proto_power_off(&targets);
+    lgtd_proto_target_list_clear(&targets);
     if (ok) {
         lgtd_jsonrpc_send_response(client, request, json, "true");
         return;
diff --git a/core/jsonrpc.h b/core/jsonrpc.h
--- a/core/jsonrpc.h
+++ b/core/jsonrpc.h
@@ -28,6 +28,7 @@
     const char      *key;
     int             keylen;
     int             value_offset;
+    int             ntokens_offset;
     bool            (*type_cmp)(const jsmntok_t *, const char *);
     bool            optional;
 };
@@ -37,14 +38,19 @@
 } while (0)
 
 #define LGTD_JSONRPC_GET_JSMNTOK(object, value_offset)          \
-    *(const jsmntok_t **)(&((char *)(object))[value_offset]);   \
+    *(const jsmntok_t **)(&((char *)(object))[value_offset]);
 
-#define LGTD_JSONRPC_NODE(key_, value_offset_, fn_type_cmp, optional_)   { \
-    .key = (key_),                                                          \
-    .keylen = sizeof((key_)) - 1,                                           \
-    .value_offset = (value_offset_),                                        \
-    .type_cmp = (fn_type_cmp),                                              \
-    .optional = (optional_)                                                 \
+#define LGTD_JSONRPC_SET_NTOKENS(object, ntokens_offset, ntokens) do {  \
+    *(int *)(&(((char *)(object))[ntokens_offset])) = (ntokens);          \
+} while (0)
+
+#define LGTD_JSONRPC_NODE(key_, value_offset_, ntokens_offset_, fn_type_cmp, optional_)   { \
+    .key = (key_),                                                                          \
+    .keylen = sizeof((key_)) - 1,                                                           \
+    .value_offset = (value_offset_),                                                        \
+    .ntokens_offset = (ntokens_offset_),                                                    \
+    .type_cmp = (fn_type_cmp),                                                              \
+    .optional = (optional_)                                                                 \
 }
 
 #define LGTD_JSONRPC_TOKEN_LEN(t) ((t)->end - (t)->start)
diff --git a/core/proto.c b/core/proto.c
--- a/core/proto.c
+++ b/core/proto.c
@@ -30,33 +30,44 @@
 #include "router.h"
 #include "lightsd.h"
 
+void lgtd_proto_target_list_clear(struct lgtd_proto_target_list *targets)
+{
+    assert(targets);
+
+    while (!SLIST_EMPTY(targets)) {
+        struct lgtd_proto_target *target = SLIST_FIRST(targets);
+        SLIST_REMOVE_HEAD(targets, link);
+        free(target);
+    }
+}
+
 bool
-lgtd_proto_power_on(const char *target)
+lgtd_proto_power_on(const struct lgtd_proto_target_list *targets)
 {
-    assert(target);
+    assert(targets);
 
     struct lgtd_lifx_packet_power_state pkt = { .power = LGTD_LIFX_POWER_ON };
     return lgtd_router_send(target, LGTD_LIFX_SET_POWER_STATE, &pkt);
 }
 
 bool
-lgtd_proto_power_off(const char *target)
+lgtd_proto_power_off(const struct lgtd_proto_target_list *targets)
 {
-    assert(target);
+    assert(targets);
 
     struct lgtd_lifx_packet_power_state pkt = { .power = LGTD_LIFX_POWER_OFF };
-    return lgtd_router_send(target, LGTD_LIFX_SET_POWER_STATE, &pkt);
+    return lgtd_router_send(targets, LGTD_LIFX_SET_POWER_STATE, &pkt);
 }
 
 bool
-lgtd_proto_set_light_from_hsbk(const char *target,
+lgtd_proto_set_light_from_hsbk(const struct lgtd_proto_target_list *targets,
                                int hue,
                                int saturation,
                                int brightness,
                                int kelvin,
                                int transition_msecs)
 {
-    assert(target);
+    assert(targets);
     assert(hue >= 0 && hue <= UINT16_MAX);
     assert(saturation >= 0 && saturation <= UINT16_MAX);
     assert(brightness >= 0 && brightness <= UINT16_MAX);
@@ -72,17 +83,17 @@
         .transition = transition_msecs
     };
     lgtd_lifx_wire_encode_light_color(&pkt);
-    return lgtd_router_send(target, LGTD_LIFX_SET_LIGHT_COLOR, &pkt);
+    return lgtd_router_send(targets, LGTD_LIFX_SET_LIGHT_COLOR, &pkt);
 }
 
-bool lgtd_proto_set_waveform(const char *target,
+bool lgtd_proto_set_waveform(const struct lgtd_proto_target_list *targets,
                              enum lgtd_lifx_waveform_type waveform,
                              int hue, int saturation,
                              int brightness, int kelvin,
                              int period, float cycles,
                              int skew_ratio, bool transient)
 {
-    assert(target);
+    assert(targets);
     assert(hue >= 0 && hue <= UINT16_MAX);
     assert(saturation >= 0 && saturation <= UINT16_MAX);
     assert(brightness >= 0 && brightness <= UINT16_MAX);
@@ -106,5 +117,5 @@
     };
 
     lgtd_lifx_wire_encode_waveform(&pkt);
-    return lgtd_router_send(target, LGTD_LIFX_SET_WAVEFORM, &pkt);
+    return lgtd_router_send(targets, LGTD_LIFX_SET_WAVEFORM, &pkt);
 }
diff --git a/core/proto.h b/core/proto.h
--- a/core/proto.h
+++ b/core/proto.h
@@ -17,10 +17,20 @@
 
 #pragma once
 
-bool lgtd_proto_set_light_from_hsbk(const char *, int, int, int, int, int);
-bool lgtd_proto_set_waveform(const char *,
+struct lgtd_proto_target {
+    SLIST_ENTRY(lgtd_proto_target)  link;
+    char                            target[];
+};
+SLIST_HEAD(lgtd_proto_target_list, lgtd_proto_target);
+
+void lgtd_proto_target_list_clear(struct lgtd_proto_target_list *);
+const struct lgtd_proto_target *lgtd_proto_target_list_add(struct lgtd_proto_target_list *,
+                                                           const char *, int);
+
+bool lgtd_proto_set_light_from_hsbk(const struct lgtd_proto_target_list *, int, int, int, int, int);
+bool lgtd_proto_set_waveform(const struct lgtd_proto_target_list *,
                              enum lgtd_lifx_waveform_type,
                              int, int, int, int,
                              int, float, int, bool);
-bool lgtd_proto_power_on(const char *);
-bool lgtd_proto_power_off(const char *);
+bool lgtd_proto_power_on(const struct lgtd_proto_target_list *);
+bool lgtd_proto_power_off(const struct lgtd_proto_target_list *);
diff --git a/core/router.c b/core/router.c
--- a/core/router.c
+++ b/core/router.c
@@ -95,36 +95,37 @@
 }
 
 bool
-lgtd_router_send(const char *target,
+lgtd_router_send(const struct lgtd_proto_target_list *targets,
                  enum lgtd_lifx_packet_type pkt_type,
                  void *pkt)
 {
     assert(target);
 
-    if (!strcmp(target, "*")) {
-        lgtd_router_broadcast(pkt_type, pkt);
-        return true;
+    bool rv = true;
+
+    const struct lgtd_proto_target *target;
+    SLIST_FOREACH(target, targets, link) {
+        if (!strcmp(target->target, "*")) {
+            lgtd_router_broadcast(pkt_type, pkt);
+        } else if (isxdigit(target->target[0])) {
+            const char *endptr = NULL;
+            errno = 0;
+            long long device = strtoll(target->target, (char **)&endptr, 16);
+            if (*endptr || errno == ERANGE) {
+                lgtd_debug("invalid target device %s", target->target);
+                rv = false;
+            }
+            device = htobe64(device);
+            struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_get(
+                (uint8_t *)&device + sizeof(device) - LGTD_LIFX_ADDR_LENGTH
+            );
+            if (!bulb) {
+                lgtd_debug("target device %#llx not found", device);
+                rv = false;
+            }
+            lgtd_router_device(bulb, pkt_type, pkt);
+        }
     }
 
-    if (isxdigit(target[0])) {
-        const char *endptr = NULL;
-        errno = 0;
-        long long device = strtoll(target, (char **)&endptr, 16);
-        if (*endptr || errno == ERANGE) {
-            lgtd_debug("invalid target device %s", target);
-            return false;
-        }
-        device = htobe64(device);
-        struct lgtd_lifx_bulb *bulb = lgtd_lifx_bulb_get(
-            (uint8_t *)&device + sizeof(device) - LGTD_LIFX_ADDR_LENGTH
-        );
-        if (!bulb) {
-            lgtd_debug("target device %#llx not found", device);
-            return false;
-        }
-        lgtd_router_device(bulb, pkt_type, pkt);
-        return true;
-    }
-
-    return false;
+    return rv;
 }
diff --git a/core/router.h b/core/router.h
--- a/core/router.h
+++ b/core/router.h
@@ -17,4 +17,4 @@
 
 #pragma once
 
-bool lgtd_router_send(const char *, enum lgtd_lifx_packet_type, void *);
+bool lgtd_router_send(const struct lgtd_proto_target_list *, enum lgtd_lifx_packet_type, void *);
diff --git a/tests/core/jsonrpc/test_jsonrpc_build_target_list.c b/tests/core/jsonrpc/test_jsonrpc_build_target_list.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_build_target_list.c
@@ -0,0 +1,64 @@
+#include "jsonrpc.c"
+
+#include "test_jsonrpc_utils.h"
+
+static void
+test_params(const char *json, const char **expected_targets)
+{
+    struct lgtd_client client = { .io = NULL };
+    struct lgtd_jsonrpc_request request = { .id = NULL };
+
+    jsmntok_t tokens[32];
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, strlen(json)
+    );
+
+    struct lgtd_proto_target_list targets = SLIST_HEAD_INITIALIZER(&targets);
+
+    reset_client_write_buf();
+
+    bool ok = lgtd_jsonrpc_build_target_list(
+        &targets, &client, &request, tokens, parsed, json
+    );
+
+    if (!expected_targets && !SLIST_EMPTY(&targets)) {
+        if (ok) {
+            errx(1, "lgtd_jsonrpc_build_target_list returned true on an error");
+        }
+        return;
+    }
+
+    struct lgtd_proto_target *target;
+    int i = 0;
+    SLIST_FOREACH(target, &targets, link) {
+        if (!expected_targets[i]) {
+            errx(1, "unexpected target %s", target->target);
+        }
+        if (strcmp(target->target, expected_targets[i])) {
+            errx(
+                1, "target mismatch got %s but expected %s",
+                target->target, expected_targets[i]
+            );
+        }
+        i++;
+    }
+}
+
+int
+main(void)
+{
+    const char *expected_1[] = {"on", "12345", "6789", NULL};
+    test_params("[\"on\", 12345, \"6789\"]", expected_1);
+
+    const char *expected_2[] = {"#tower", NULL};
+    test_params("#tower", expected_2);
+
+    test_params("{\"key\": 42}", NULL);
+
+    test_params("null", NULL);
+
+    const char *expected_3[] = {NULL};
+    test_params("[]", expected_3);
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off.c
@@ -6,10 +6,13 @@
 static bool power_off_called = false;
 
 bool
-lgtd_proto_power_off(const char *target)
+lgtd_proto_power_off(const struct lgtd_proto_target_list *targets)
 {
-    if (strcmp(target, "*")) {
-        errx(1, "Invalid target [%s] (expected=[*])", target);
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
     }
     power_off_called = true;
     return true;
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off_missing_target.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off_missing_target.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off_missing_target.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_off_missing_target.c
@@ -6,9 +6,9 @@
 static bool power_off_called = false;
 
 bool
-lgtd_proto_power_off(const char *target)
+lgtd_proto_power_off(const struct lgtd_proto_target_list *targets)
 {
-    (void)target;
+    (void)targets;
     power_off_called = true;
     return true;
 }
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on.c
@@ -6,10 +6,13 @@
 static bool power_on_called = false;
 
 bool
-lgtd_proto_power_on(const char *target)
+lgtd_proto_power_on(const struct lgtd_proto_target_list *targets)
 {
-    if (strcmp(target, "*")) {
-        errx(1, "Invalid target [%s] (expected=[*])", target);
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
     }
     power_on_called = true;
     return true;
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on_missing_target.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on_missing_target.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on_missing_target.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_power_on_missing_target.c
@@ -6,9 +6,9 @@
 static bool power_on_called = false;
 
 bool
-lgtd_proto_power_on(const char *target)
+lgtd_proto_power_on(const struct lgtd_proto_target_list *targets)
 {
-    (void)target;
+    (void)targets;
     power_on_called = true;
     return true;
 }
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk.c
@@ -6,15 +6,18 @@
 static bool set_light_called = false;
 
 bool
-lgtd_proto_set_light_from_hsbk(const char *target,
+lgtd_proto_set_light_from_hsbk(const struct lgtd_proto_target_list *targets,
                                int hue,
                                int saturation,
                                int brightness,
                                int kelvin,
                                int transition_msecs)
 {
-    if (strcmp(target, "*")) {
-        errx(1, "Invalid target [%s] (expected=[*])", target);
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
     }
     int expected_hue = lgtd_jsonrpc_float_range_to_uint16(
         "324.2341", strlen("324.2341"), 0, 360
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_from_array.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_from_array.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_from_array.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_from_array.c
@@ -6,15 +6,18 @@
 static bool set_light_called = false;
 
 bool
-lgtd_proto_set_light_from_hsbk(const char *target,
+lgtd_proto_set_light_from_hsbk(const struct lgtd_proto_target_list *targets,
                                int hue,
                                int saturation,
                                int brightness,
                                int kelvin,
                                int transition_msecs)
 {
-    if (strcmp(target, "*")) {
-        errx(1, "Invalid target [%s] (expected=[*])", target);
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
     }
     int expected_hue = lgtd_jsonrpc_float_range_to_uint16(
         "324.2341", strlen("324.2341"), 0, 360
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_invalid_params.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_invalid_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_invalid_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_light_from_hsbk_invalid_params.c
@@ -6,14 +6,14 @@
 static bool set_light_called = false;
 
 bool
-lgtd_proto_set_light_from_hsbk(const char *target,
+lgtd_proto_set_light_from_hsbk(const struct lgtd_proto_target_list *targets,
                                int hue,
                                int saturation,
                                int brightness,
                                int kelvin,
                                int transition_msecs)
 {
-    (void)target;
+    (void)targets;
     (void)hue;
     (void)saturation;
     (void)brightness;
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform.c
@@ -6,15 +6,18 @@
 static bool set_waveform_called = false;
 
 bool
-lgtd_proto_set_waveform(const char *target,
+lgtd_proto_set_waveform(const struct lgtd_proto_target_list *targets,
                         enum lgtd_lifx_waveform_type waveform,
                         int hue, int saturation,
                         int brightness, int kelvin,
                         int period, float cycles,
                         int skew_ratio, bool transient)
 {
-    if (strcmp(target, "*")) {
-        errx(1, "Invalid target [%s] (expected=[*])", target);
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
     }
     int expected_hue = lgtd_jsonrpc_float_range_to_uint16(
         "324.2341", strlen("324.2341"), 0, 360
diff --git a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform_invalid_params.c b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform_invalid_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform_invalid_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_check_and_call_set_waveform_invalid_params.c
@@ -6,14 +6,14 @@
 static bool set_waveform_called = false;
 
 bool
-lgtd_proto_set_waveform(const char *target,
+lgtd_proto_set_waveform(const struct lgtd_proto_target_list *targets,
                         enum lgtd_lifx_waveform_type waveform,
                         int hue, int saturation,
                         int brightness, int kelvin,
                         int period, float cycles,
                         int skew_ratio, bool transient)
 {
-    (void)target;
+    (void)targets;
     (void)waveform;
     (void)hue;
     (void)saturation;
diff --git a/tests/core/jsonrpc/test_jsonrpc_utils.h b/tests/core/jsonrpc/test_jsonrpc_utils.h
--- a/tests/core/jsonrpc/test_jsonrpc_utils.h
+++ b/tests/core/jsonrpc/test_jsonrpc_utils.h
@@ -30,16 +30,21 @@
     return 0;
 }
 
+void lgtd_proto_target_list_clear(struct lgtd_proto_target_list *targets)
+{
+    assert(targets);
+}
+
 #ifndef LGTD_TESTING_SET_LIGHT_FROM_HSBK
 bool
-lgtd_proto_set_light_from_hsbk(const char *target,
+lgtd_proto_set_light_from_hsbk(const struct lgtd_proto_target_list *targets,
                                int hue,
                                int saturation,
                                int brightness,
                                int kelvin,
                                int transition_msecs)
 {
-    (void)target;
+    (void)targets;
     (void)hue;
     (void)saturation;
     (void)brightness;
@@ -51,31 +56,31 @@
 
 #ifndef LGTD_TESTING_POWER_ON
 bool
-lgtd_proto_power_on(const char *target)
+lgtd_proto_power_on(const struct lgtd_proto_target_list *targets)
 {
-    (void)target;
+    (void)targets;
     return true;
 }
 #endif
 
 #ifndef LGTD_TESTING_POWER_OFF
 bool
-lgtd_proto_power_off(const char *target)
+lgtd_proto_power_off(const struct lgtd_proto_target_list *targets)
 {
-    (void)target;
+    (void)targets;
     return true;
 }
 #endif
 
 #ifndef LGTD_TESTING_SET_WAVEFORM
-bool lgtd_proto_set_waveform(const char *target,
+bool lgtd_proto_set_waveform(const struct lgtd_proto_target_list *targets,
                              enum lgtd_lifx_waveform_type waveform,
                              int hue, int saturation,
                              int brightness, int kelvin,
                              int period, float cycles,
                              int skew_ratio, bool transient)
 {
-    (void)target;
+    (void)targets;
     (void)waveform;
     (void)hue;
     (void)saturation;
