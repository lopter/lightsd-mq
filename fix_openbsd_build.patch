# HG changeset patch
# Parent  37f851b43c05b5b40fb5e34bf8bbadbe67e3a29e
Fix build on OpenBSD 5.7

Yes, someone actually tried and emailed me <3.

Well supporting GCC 4.2 is not really ideal but on the bright side
everything that was done on the system introspection side pretty much
worked out of the box.

diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -80,6 +80,7 @@
 MESSAGE(STATUS "lightsd runtime directory: ${LGTD_RUNTIME_DIRECTORY}")
 
 INCLUDE_DIRECTORIES(
+    ${EVENT2_INCLUDE_DIR}
     ${LIGHTSD_BINARY_DIR}/compat
     ${LIGHTSD_BINARY_DIR}/compat/generic
 )
diff --git a/CMakeScripts/FindEvent2.cmake b/CMakeScripts/FindEvent2.cmake
--- a/CMakeScripts/FindEvent2.cmake
+++ b/CMakeScripts/FindEvent2.cmake
@@ -1,13 +1,20 @@
+FIND_PATH(
+    EVENT2_INCLUDE_DIR
+    event2/event.h
+    # OpenBSD has libevent1 in /usr/lib, always try /usr/local first:
+    HINTS /usr/local/
+)
+
 FOREACH (COMPONENT ${Event2_FIND_COMPONENTS})
     STRING(TOUPPER ${COMPONENT} UPPER_COMPONENT)
-    FIND_LIBRARY(EVENT2_${UPPER_COMPONENT}_LIBRARY event_${COMPONENT})
+    FIND_LIBRARY(
+        EVENT2_${UPPER_COMPONENT}_LIBRARY event_${COMPONENT} HINTS /usr/local/
+    )
     IF (EVENT2_${UPPER_COMPONENT}_LIBRARY)
         SET(Event2_${COMPONENT}_FOUND TRUE)
     ENDIF ()
 ENDFOREACH ()
 
-FIND_PATH(EVENT2_INCLUDE_DIR event2/event.h)
-
 INCLUDE(FindPackageHandleStandardArgs)
 
 FIND_PACKAGE_HANDLE_STANDARD_ARGS(
diff --git a/README.rst b/README.rst
--- a/README.rst
+++ b/README.rst
@@ -68,8 +68,8 @@
 - CMake ≥ 2.8.9 (released August 2012): only if you want to build lightsd from
   its sources.
 
-lightsd is actively developed and tested from Arch Linux, Debian and Mac OS X;
-both for 32/64 bits and little/big endian architectures.
+lightsd is actively developed and tested from Arch Linux, Debian, Mac OS X and
+OpenBSD; both for 32/64 bits and little/big endian architectures.
 
 Developers
 ----------
diff --git a/core/client.c b/core/client.c
--- a/core/client.c
+++ b/core/client.c
@@ -66,6 +66,8 @@
     }
 }
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wswitch"
 static void
 lgtd_client_read_callback(struct bufferevent *bev, void *ctx)
 {
@@ -95,10 +97,7 @@
             evbuffer_drain(input, nbytes);
             break;
         case JSMN_ERROR_PART:
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wswitch"
         case 0:
-#pragma GCC diagnostic pop
             (void)0;
             size_t buflen = evbuffer_get_length(input);
             if (buflen > LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) {
@@ -139,6 +138,7 @@
         nbytes = evbuffer_get_contiguous_space(input);
     } while (nbytes);
 }
+#pragma GCC diagnostic pop
 
 static void
 lgtd_client_event_callback(struct bufferevent *bev, short events, void *ctx)
diff --git a/core/pipe.c b/core/pipe.c
--- a/core/pipe.c
+++ b/core/pipe.c
@@ -68,6 +68,8 @@
 
 static void lgtd_command_pipe_reset(struct lgtd_command_pipe *);
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wswitch"
 static void
 lgtd_command_pipe_read_callback(evutil_socket_t socket, short events, void *ctx)
 {
@@ -113,10 +115,7 @@
                 drain = true;
                 break;
             case JSMN_ERROR_PART:
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wswitch"
             case 0:
-#pragma GCC diagnostic pop
                 if (bufsz >= LGTD_CLIENT_MAX_REQUEST_BUF_SIZE) {
                     lgtd_warnx("pipe %s: request too big", pipe->path);
                     drain = true;
@@ -154,6 +153,7 @@
 
     lgtd_command_pipe_reset(pipe);
 }
+#pragma GCC diagnostic pop
 
 static bool
 _lgtd_command_pipe_open(const char *path)
diff --git a/docs/installation.rst b/docs/installation.rst
--- a/docs/installation.rst
+++ b/docs/installation.rst
@@ -72,8 +72,8 @@
 - libevent ≥ 2.0.19 (released May 2012);
 - CMake ≥ 2.8.9 (released August 2012).
 
-lightsd is developed and tested from Arch Linux, Debian and Mac OS X; both for
-32/64 bits and little/big endian architectures.
+lightsd is developed and tested from Arch Linux, Debian, OpenBSD and Mac OS X;
+both for 32/64 bits and little/big endian architectures.
 
 For Debian and Ubuntu you would need to install the following packages to build
 lightsd:
diff --git a/lifx/gateway.c b/lifx/gateway.c
--- a/lifx/gateway.c
+++ b/lifx/gateway.c
@@ -725,7 +725,7 @@
             lgtd_warnx(
                 "trying to set unknown tag_id %d (%#jx) "
                 "on bulb %s (%.*s), gw %s (site %s)",
-                tag_id, LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id),
+                tag_id, (uintmax_t)LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(tag_id),
                 LGTD_IEEE8023MACTOA(b->addr, bulb_addr),
                 LGTD_LIFX_LABEL_SIZE, b->state.label, gw->peeraddr,
                 LGTD_IEEE8023MACTOA(gw->site.as_array, site_addr)
diff --git a/tests/core/tests_shims.c b/tests/core/tests_shims.c
--- a/tests/core/tests_shims.c
+++ b/tests/core/tests_shims.c
@@ -33,17 +33,3 @@
 lgtd_cleanup(void)
 {
 }
-
-short
-lgtd_sockaddrport(const struct sockaddr_storage *peer)
-{
-    assert(peer);
-
-    if (peer->ss_family == AF_INET) {
-        const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
-        return ntohs(in_peer->sin_port);
-    } else {
-        const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
-        return ntohs(in6_peer->sin6_port);
-    }
-}
diff --git a/tests/lifx/bulb/test_bulb_fetch_hardware_info.c b/tests/lifx/bulb/test_bulb_fetch_hardware_info.c
--- a/tests/lifx/bulb/test_bulb_fetch_hardware_info.c
+++ b/tests/lifx/bulb/test_bulb_fetch_hardware_info.c
@@ -28,6 +28,8 @@
 static int get_mesh_firmware_state_sent = 0;
 static int get_wifi_firmware_state_sent = 0;
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wswitch" // we don't test the whole enum
 void
 lgtd_router_send_to_device(struct lgtd_lifx_bulb *bulb,
                            enum lgtd_lifx_packet_type pkt_type,
@@ -44,8 +46,6 @@
         errx(1, "got unexpected pkt");
     }
 
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wswitch" // we don't test the whole enum
     switch (pkt_type) {
     case LGTD_LIFX_GET_VERSION:
         get_version_sent++;
@@ -57,8 +57,8 @@
         get_wifi_firmware_state_sent++;
         break;
     }
+}
 #pragma GCC diagnostic pop
-}
 
 static void
 test_counters(int get_version, int mcu_fw_info, int wifi_fw_info)
diff --git a/tests/lifx/gateway/test_gateway_handle_tag_labels.c b/tests/lifx/gateway/test_gateway_handle_tag_labels.c
--- a/tests/lifx/gateway/test_gateway_handle_tag_labels.c
+++ b/tests/lifx/gateway/test_gateway_handle_tag_labels.c
@@ -30,7 +30,7 @@
     if (gw.tag_ids != LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(42)) {
         errx(
             1, "expected gw.tag_ids == %jx but got %jx",
-            LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(42), (uintmax_t)gw.tag_ids
+            (uintmax_t)LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(42), (uintmax_t)gw.tag_ids
         );
     }
     if (!gw.tags[42]) {
@@ -55,7 +55,7 @@
     if (gw.tag_ids != expected) {
         errx(
             1, "expected gw.tag_ids == %jx but got %jx",
-            LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(42), (uintmax_t)gw.tag_ids
+            (uintmax_t)LGTD_LIFX_WIRE_TAG_ID_TO_VALUE(42), (uintmax_t)gw.tag_ids
         );
     }
     if (strcmp(gw.tags[2]->label, "toto")) {
diff --git a/tests/lifx/tests_shims.c b/tests/lifx/tests_shims.c
--- a/tests/lifx/tests_shims.c
+++ b/tests/lifx/tests_shims.c
@@ -20,22 +20,6 @@
 {
 }
 
-short
-lgtd_sockaddrport(const struct sockaddr_storage *peer)
-{
-    if (!peer) {
-        return -1;
-    }
-
-    if (peer->ss_family == AF_INET) {
-        const struct sockaddr_in *in_peer = (const struct sockaddr_in *)peer;
-        return ntohs(in_peer->sin_port);
-    } else {
-        const struct sockaddr_in6 *in6_peer = (const struct sockaddr_in6 *)peer;
-        return ntohs(in6_peer->sin6_port);
-    }
-}
-
 void
 lgtd_daemon_update_proctitle(void)
 {
