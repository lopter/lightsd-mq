# HG changeset patch
# Parent  350944f17e69f07bc02fc3655aeaee889d0c4d3c

diff --git a/core/jsonrpc.c b/core/jsonrpc.c
--- a/core/jsonrpc.c
+++ b/core/jsonrpc.c
@@ -1080,11 +1080,26 @@
     );
 }
 
+static void
+lgtd_jsonrpc_batch_prepare_next_part(struct lgtd_client *client,
+                                     const int *batch_sent)
+{
+    assert(client);
+    
+    if (batch_sent) {
+        if (*batch_sent == 1) {
+            lgtd_client_write_string(client, "[");
+        } else if (*batch_sent) {
+            lgtd_client_write_string(client, ",");
+        }
+    }
+}
+
 static int
 lgtd_jsonrpc_dispatch_one(struct lgtd_client *client,
                           const jsmntok_t *tokens,
                           int ntokens,
-                          struct lgtd_jsonrpc_request *request)
+                          int *batch_sent)
 {
     static const struct lgtd_jsonrpc_method methods[] = {
         LGTD_JSONRPC_METHOD(
@@ -1126,44 +1141,48 @@
         )
     };
 
-    memset(request, 0, sizeof(*request));
+    if (batch_sent) {
+        ++*batch_sent;
+    }
+
+    enum lgtd_jsonrpc_error_code error_code;
+    const char *error_msg;
+
+    struct lgtd_jsonrpc_request request;
+    memset(&request, 0, sizeof(request));
     bool ok = lgtd_jsonrpc_check_and_extract_request(
-        request, tokens, ntokens, client->json
+        &request, tokens, ntokens, client->json
     );
-    client->current_request = request;
+    client->current_request = &request;
     if (!ok) {
-        lgtd_jsonrpc_send_error(
-            client, LGTD_JSONRPC_INVALID_REQUEST, "Invalid request"
-        );
-        return lgtd_jsonrpc_consume_object_or_array(
+        error_code = LGTD_JSONRPC_INVALID_REQUEST;
+        error_msg = "Invalid request";
+        request.request_ntokens = lgtd_jsonrpc_consume_object_or_array(
             tokens, 0, ntokens, client->json
         );
+        goto error;
     }
 
-    assert(request->method);
-    assert(request->request_ntokens);
+    assert(request.method);
+    assert(request.request_ntokens);
 
     for (int i = 0; i != LGTD_ARRAY_SIZE(methods); i++) {
-        int parsed_method_namelen = LGTD_JSONRPC_TOKEN_LEN(request->method);
+        int parsed_method_namelen = LGTD_JSONRPC_TOKEN_LEN(request.method);
         if (parsed_method_namelen != methods[i].namelen) {
             continue;
         }
         int diff = memcmp(
-            methods[i].name,
-            &client->json[request->method->start],
-            methods[i].namelen
+            methods[i].name, &client->json[request.method->start], methods[i].namelen
         );
         if (!diff) {
-            int params_count = request->params ? request->params->size : 0;
+            int params_count = request.params ? request.params->size : 0;
             if (params_count != methods[i].params_count) {
-                lgtd_jsonrpc_send_error(
-                    client, LGTD_JSONRPC_INVALID_PARAMS,
-                    "Invalid number of parameters"
-                );
+                error_code = LGTD_JSONRPC_INVALID_PARAMS;
+                error_msg = "Invalid number of parameters";
                 goto error;
             }
             struct bufferevent *client_io = NULL; // keep compilers happy...
-            if (!request->id) {
+            if (!request.id) {
                 // Ugly hack to behave correctly on jsonrpc notifications, it's
                 // not worth it do it properly right now. It is especially ugly
                 // since we can't properly close that client now (but we don't
@@ -1171,22 +1190,29 @@
                 // event loop).
                 client_io = client->io;
                 client->io = NULL;
+                if (batch_sent) {
+                    --*batch_sent;
+                }
+            } else {
+                lgtd_jsonrpc_batch_prepare_next_part(client, batch_sent);
             }
             methods[i].method(client);
-            if (!request->id) {
+            if (!request.id) {
                 client->io = client_io;
             }
             client->current_request = NULL;
-            return request->request_ntokens;
+            return request.request_ntokens;
         }
     }
 
-    lgtd_jsonrpc_send_error(
-        client, LGTD_JSONRPC_METHOD_NOT_FOUND, "Method not found"
-    );
+    error_code = LGTD_JSONRPC_METHOD_NOT_FOUND;
+    error_msg = "Method not found";
+
 error:
+    lgtd_jsonrpc_batch_prepare_next_part(client, batch_sent);
+    lgtd_jsonrpc_send_error(client, error_code, error_msg);
     client->current_request = NULL;
-    return request->request_ntokens;
+    return request.request_ntokens;
 }
 
 void
@@ -1202,29 +1228,22 @@
         return;
     }
 
-    struct lgtd_jsonrpc_request request = { .id = NULL };
-
     if (!lgtd_jsonrpc_type_array(client->jsmn_tokens, client->json)) {
-        lgtd_jsonrpc_dispatch_one(
-            client, client->jsmn_tokens, parsed, &request
-        );
+        lgtd_jsonrpc_dispatch_one(client, client->jsmn_tokens, parsed, NULL);
         return;
     }
 
-    bool comma = false;
+    int batch_sent = 0;
     for (int ti = 1; ti < parsed;) {
         const jsmntok_t *tok = &client->jsmn_tokens[ti];
 
-        if (!comma) {
-            lgtd_client_write_string(client, "[");
-            comma = true;
-        } else if (request.id) {
-            lgtd_client_write_string(client, ",");
-        }
-
         if (lgtd_jsonrpc_type_object(tok, client->json)) {
-            ti += lgtd_jsonrpc_dispatch_one(client, tok, parsed - ti, &request);
+            ti += lgtd_jsonrpc_dispatch_one(
+                client, tok, parsed - ti, &batch_sent
+            );
         } else {
+            batch_sent++;
+            lgtd_jsonrpc_batch_prepare_next_part(client, &batch_sent);
             lgtd_jsonrpc_send_error(
                 client, LGTD_JSONRPC_INVALID_REQUEST, "Invalid request"
             );
@@ -1237,5 +1256,8 @@
             }
         }
     }
-    lgtd_client_write_string(client, "]");
+
+    if (batch_sent) {
+        lgtd_client_write_string(client, "]");
+    }
 }
diff --git a/tests/core/jsonrpc/test_jsonrpc_batch.c b/tests/core/jsonrpc/test_jsonrpc_batch.c
--- a/tests/core/jsonrpc/test_jsonrpc_batch.c
+++ b/tests/core/jsonrpc/test_jsonrpc_batch.c
@@ -53,6 +53,7 @@
 int
 main(void)
 {
+    jsmntok_t tokens[32];
     const char json[] = ("["
         "{"
             "\"method\": \"power_on\","
@@ -67,12 +68,9 @@
             "\"jsonrpc\": \"2.0\""
         "}"
     "]");
-    struct lgtd_client client = { .json = json };
+    struct lgtd_client client = { .json = json, .jsmn_tokens = tokens };
     int parsed = parse_json(
-        client.jsmn_tokens,
-        LGTD_ARRAY_SIZE(client.jsmn_tokens),
-        json,
-        sizeof(json)
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
     );
 
     lgtd_jsonrpc_dispatch_request(&client, parsed);
diff --git a/tests/core/jsonrpc/test_jsonrpc_batch_notifications_only.c b/tests/core/jsonrpc/test_jsonrpc_batch_notifications_only.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_batch_notifications_only.c
@@ -0,0 +1,90 @@
+#include "jsonrpc.c"
+
+#include "mock_client_buf.h"
+#define MOCKED_LGTD_PROTO_GET_LIGHT_STATE
+#define MOCKED_LGTD_PROTO_POWER_ON
+#include "mock_proto.h"
+#include "test_jsonrpc_utils.h"
+
+static int power_on_call_count = 0;
+
+void
+lgtd_proto_power_on(struct lgtd_client *client,
+                    const struct lgtd_proto_target_list *targets)
+{
+    if (!client) {
+        errx(1, "missing client!");
+    }
+
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+
+    if (power_on_call_count++) {
+        errx(1, "proto_power_on should have been called once");
+    }
+}
+
+static int get_light_state_call_count = 0;
+
+void
+lgtd_proto_get_light_state(struct lgtd_client *client,
+                           const struct lgtd_proto_target_list *targets)
+{
+    if (!client) {
+        errx(1, "missing client!");
+    }
+
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+
+    if (get_light_state_call_count++) {
+        errx(1, "proto_power_on should have been called once");
+    }
+}
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("["
+        "{"
+            "\"method\": \"power_on\","
+            "\"params\": [\"*\"],"
+            "\"jsonrpc\": \"2.0\""
+        "},"
+        "{"
+            "\"method\": \"get_light_state\","
+            "\"params\": [\"*\"],"
+            "\"jsonrpc\": \"2.0\""
+        "}"
+    "]");
+    struct lgtd_client client = { .json = json, .jsmn_tokens = tokens };
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    lgtd_jsonrpc_dispatch_request(&client, parsed);
+
+    if (!power_on_call_count) {
+        errx(1, "power_on was never called");
+    }
+
+    if (!get_light_state_call_count) {
+        errx(1, "get_light_state was never called");
+    }
+
+    const char expected[] = "";
+    if (strcmp(expected, client_write_buf)) {
+        errx(1, "got client buf %s (expected %s)", client_write_buf, expected);
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_batch_one_invalid_request.c b/tests/core/jsonrpc/test_jsonrpc_batch_one_invalid_request.c
--- a/tests/core/jsonrpc/test_jsonrpc_batch_one_invalid_request.c
+++ b/tests/core/jsonrpc/test_jsonrpc_batch_one_invalid_request.c
@@ -30,6 +30,7 @@
 int
 main(void)
 {
+    jsmntok_t tokens[32];
     const char json[] = ("["
         "{"
             "\"method\": \"power_on\","
@@ -44,12 +45,9 @@
             "\"jsonrpc\": \"2.0\""
         "}"
     "]");
-    struct lgtd_client client = { .json = json };
+    struct lgtd_client client = { .json = json, .jsmn_tokens = tokens };
     int parsed = parse_json(
-        client.jsmn_tokens,
-        LGTD_ARRAY_SIZE(client.jsmn_tokens),
-        json,
-        sizeof(json)
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
     );
 
     lgtd_jsonrpc_dispatch_request(&client, parsed);
@@ -58,7 +56,8 @@
         errx(1, "power_on was never called");
     }
 
-    const char expected[] = ("[,"
+    const char expected[] = ("["
+        "," // we mocked the first function
         "{"
             "\"jsonrpc\": \"2.0\", "
             "\"id\": \"1f7a32c8-6741-4ee7-bec1-8431c7d514dc\", "
diff --git a/tests/core/jsonrpc/test_jsonrpc_batch_one_notification.c b/tests/core/jsonrpc/test_jsonrpc_batch_one_notification.c
new file mode 100644
--- /dev/null
+++ b/tests/core/jsonrpc/test_jsonrpc_batch_one_notification.c
@@ -0,0 +1,91 @@
+#include "jsonrpc.c"
+
+#include "mock_client_buf.h"
+#define MOCKED_LGTD_PROTO_GET_LIGHT_STATE
+#define MOCKED_LGTD_PROTO_POWER_ON
+#include "mock_proto.h"
+#include "test_jsonrpc_utils.h"
+
+static int power_on_call_count = 0;
+
+void
+lgtd_proto_power_on(struct lgtd_client *client,
+                    const struct lgtd_proto_target_list *targets)
+{
+    if (!client) {
+        errx(1, "missing client!");
+    }
+
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+
+    if (power_on_call_count++) {
+        errx(1, "proto_power_on should have been called once");
+    }
+}
+
+static int get_light_state_call_count = 0;
+
+void
+lgtd_proto_get_light_state(struct lgtd_client *client,
+                           const struct lgtd_proto_target_list *targets)
+{
+    if (!client) {
+        errx(1, "missing client!");
+    }
+
+    if (strcmp(SLIST_FIRST(targets)->target, "*")) {
+        errx(
+            1, "Invalid target [%s] (expected=[*])",
+            SLIST_FIRST(targets)->target
+        );
+    }
+
+    if (get_light_state_call_count++) {
+        errx(1, "proto_power_on should have been called once");
+    }
+}
+
+int
+main(void)
+{
+    jsmntok_t tokens[32];
+    const char json[] = ("["
+        "{"
+            "\"method\": \"power_on\","
+            "\"id\": \"004daf12-0561-4fbc-bfdb-bfe69cfbf4b5\","
+            "\"params\": [\"*\"],"
+            "\"jsonrpc\": \"2.0\""
+        "},"
+        "{"
+            "\"method\": \"get_light_state\","
+            "\"params\": [\"*\"],"
+            "\"jsonrpc\": \"2.0\""
+        "}"
+    "]");
+    struct lgtd_client client = { .json = json, .jsmn_tokens = tokens };
+    int parsed = parse_json(
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
+    );
+
+    lgtd_jsonrpc_dispatch_request(&client, parsed);
+
+    if (!power_on_call_count) {
+        errx(1, "power_on was never called");
+    }
+
+    if (!get_light_state_call_count) {
+        errx(1, "get_light_state was never called");
+    }
+
+    const char expected[] = "[]";  // we mocked the functions
+    if (strcmp(expected, client_write_buf)) {
+        errx(1, "got client buf %s (expected %s)", client_write_buf, expected);
+    }
+
+    return 0;
+}
diff --git a/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c b/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c
--- a/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c
+++ b/tests/core/jsonrpc/test_jsonrpc_dispatch_one_no_params.c
@@ -19,18 +19,18 @@
 int
 main(void)
 {
+    jsmntok_t tokens[32];
     const char json[] = ("{"
         "\"jsonrpc\": \"2.0\","
         "\"method\": \"power_on\","
         "\"id\": \"42\""
     "}");
     struct lgtd_client client = { .json = json };
-    client.jsmn_tokens = calloc(32, sizeof(*client.jsmn_tokens));
     int parsed = parse_json(
-        client.jsmn_tokens, 32, json, sizeof(json)
+        tokens, LGTD_ARRAY_SIZE(tokens), json, sizeof(json)
     );
-    struct lgtd_jsonrpc_request req;
-    lgtd_jsonrpc_dispatch_one(&client, client.jsmn_tokens, parsed, &req);
+
+    lgtd_jsonrpc_dispatch_one(&client, tokens, parsed, NULL);
 
     const char expected[] = ("{"
         "\"jsonrpc\": \"2.0\", "
